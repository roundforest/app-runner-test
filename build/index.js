var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj)), __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
}, __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

// node_modules/source-map-support/node_modules/source-map/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/base64.js"(exports) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports.encode = function(number) {
      if (0 <= number && number < intToCharMap.length)
        return intToCharMap[number];
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports.decode = function(charCode) {
      var bigA = 65, bigZ = 90, littleA = 97, littleZ = 122, zero = 48, nine = 57, plus = 43, slash = 47, littleOffset = 26, numberOffset = 52;
      return bigA <= charCode && charCode <= bigZ ? charCode - bigA : littleA <= charCode && charCode <= littleZ ? charCode - littleA + littleOffset : zero <= charCode && charCode <= nine ? charCode - zero + numberOffset : charCode == plus ? 62 : charCode == slash ? 63 : -1;
    };
  }
});

// node_modules/source-map-support/node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/base64-vlq.js"(exports) {
    var base64 = require_base64(), VLQ_BASE_SHIFT = 5, VLQ_BASE = 1 << VLQ_BASE_SHIFT, VLQ_BASE_MASK = VLQ_BASE - 1, VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1, shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports.encode = function(aValue) {
      var encoded = "", digit, vlq = toVLQSigned(aValue);
      do
        digit = vlq & VLQ_BASE_MASK, vlq >>>= VLQ_BASE_SHIFT, vlq > 0 && (digit |= VLQ_CONTINUATION_BIT), encoded += base64.encode(digit);
      while (vlq > 0);
      return encoded;
    };
    exports.decode = function(aStr, aIndex, aOutParam) {
      var strLen = aStr.length, result = 0, shift = 0, continuation, digit;
      do {
        if (aIndex >= strLen)
          throw new Error("Expected more digits in base 64 VLQ value.");
        if (digit = base64.decode(aStr.charCodeAt(aIndex++)), digit === -1)
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        continuation = !!(digit & VLQ_CONTINUATION_BIT), digit &= VLQ_BASE_MASK, result = result + (digit << shift), shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result), aOutParam.rest = aIndex;
    };
  }
});

// node_modules/source-map-support/node_modules/source-map/lib/util.js
var require_util = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/util.js"(exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs)
        return aArgs[aName];
      if (arguments.length === 3)
        return aDefaultValue;
      throw new Error('"' + aName + '" is a required argument.');
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      return match ? {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      } : null;
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      return aParsedUrl.scheme && (url += aParsedUrl.scheme + ":"), url += "//", aParsedUrl.auth && (url += aParsedUrl.auth + "@"), aParsedUrl.host && (url += aParsedUrl.host), aParsedUrl.port && (url += ":" + aParsedUrl.port), aParsedUrl.path && (url += aParsedUrl.path), url;
    }
    exports.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path = aPath, url = urlParse(aPath);
      if (url) {
        if (!url.path)
          return aPath;
        path = url.path;
      }
      for (var isAbsolute = exports.isAbsolute(path), parts = path.split(/\/+/), part, up = 0, i2 = parts.length - 1; i2 >= 0; i2--)
        part = parts[i2], part === "." ? parts.splice(i2, 1) : part === ".." ? up++ : up > 0 && (part === "" ? (parts.splice(i2 + 1, up), up = 0) : (parts.splice(i2, 2), up--));
      return path = parts.join("/"), path === "" && (path = isAbsolute ? "/" : "."), url ? (url.path = path, urlGenerate(url)) : path;
    }
    exports.normalize = normalize;
    function join(aRoot, aPath) {
      aRoot === "" && (aRoot = "."), aPath === "" && (aPath = ".");
      var aPathUrl = urlParse(aPath), aRootUrl = urlParse(aRoot);
      if (aRootUrl && (aRoot = aRootUrl.path || "/"), aPathUrl && !aPathUrl.scheme)
        return aRootUrl && (aPathUrl.scheme = aRootUrl.scheme), urlGenerate(aPathUrl);
      if (aPathUrl || aPath.match(dataUrlRegexp))
        return aPath;
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path)
        return aRootUrl.host = aPath, urlGenerate(aRootUrl);
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      return aRootUrl ? (aRootUrl.path = joined, urlGenerate(aRootUrl)) : joined;
    }
    exports.join = join;
    exports.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      aRoot === "" && (aRoot = "."), aRoot = aRoot.replace(/\/$/, "");
      for (var level = 0; aPath.indexOf(aRoot + "/") !== 0; ) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0 || (aRoot = aRoot.slice(0, index), aRoot.match(/^([^\/]+:\/)?\/*$/)))
          return aPath;
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s2) {
      return s2;
    }
    function toSetString(aStr) {
      return isProtoString(aStr) ? "$" + aStr : aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      return isProtoString(aStr) ? aStr.slice(1) : aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s2) {
      if (!s2)
        return !1;
      var length = s2.length;
      if (length < 9 || s2.charCodeAt(length - 1) !== 95 || s2.charCodeAt(length - 2) !== 95 || s2.charCodeAt(length - 3) !== 111 || s2.charCodeAt(length - 4) !== 116 || s2.charCodeAt(length - 5) !== 111 || s2.charCodeAt(length - 6) !== 114 || s2.charCodeAt(length - 7) !== 112 || s2.charCodeAt(length - 8) !== 95 || s2.charCodeAt(length - 9) !== 95)
        return !1;
      for (var i2 = length - 10; i2 >= 0; i2--)
        if (s2.charCodeAt(i2) !== 36)
          return !1;
      return !0;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      return cmp !== 0 || (cmp = mappingA.originalLine - mappingB.originalLine, cmp !== 0) || (cmp = mappingA.originalColumn - mappingB.originalColumn, cmp !== 0 || onlyCompareOriginal) || (cmp = mappingA.generatedColumn - mappingB.generatedColumn, cmp !== 0) || (cmp = mappingA.generatedLine - mappingB.generatedLine, cmp !== 0) ? cmp : strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      return cmp !== 0 || (cmp = mappingA.generatedColumn - mappingB.generatedColumn, cmp !== 0 || onlyCompareGenerated) || (cmp = strcmp(mappingA.source, mappingB.source), cmp !== 0) || (cmp = mappingA.originalLine - mappingB.originalLine, cmp !== 0) || (cmp = mappingA.originalColumn - mappingB.originalColumn, cmp !== 0) ? cmp : strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      return aStr1 === aStr2 ? 0 : aStr1 === null ? 1 : aStr2 === null ? -1 : aStr1 > aStr2 ? 1 : -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      return cmp !== 0 || (cmp = mappingA.generatedColumn - mappingB.generatedColumn, cmp !== 0) || (cmp = strcmp(mappingA.source, mappingB.source), cmp !== 0) || (cmp = mappingA.originalLine - mappingB.originalLine, cmp !== 0) || (cmp = mappingA.originalColumn - mappingB.originalColumn, cmp !== 0) ? cmp : strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      if (sourceURL = sourceURL || "", sourceRoot && (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/" && (sourceRoot += "/"), sourceURL = sourceRoot + sourceURL), sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed)
          throw new Error("sourceMapURL could not be parsed");
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          index >= 0 && (parsed.path = parsed.path.substring(0, index + 1));
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports.computeSourceURL = computeSourceURL;
  }
});

// node_modules/source-map-support/node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/array-set.js"(exports) {
    var util = require_util(), has2 = Object.prototype.hasOwnProperty, hasNativeMap = typeof Map < "u";
    function ArraySet() {
      this._array = [], this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function(aArray, aAllowDuplicates) {
      for (var set = new ArraySet(), i2 = 0, len = aArray.length; i2 < len; i2++)
        set.add(aArray[i2], aAllowDuplicates);
      return set;
    };
    ArraySet.prototype.size = function() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr), isDuplicate = hasNativeMap ? this.has(aStr) : has2.call(this._set, sStr), idx = this._array.length;
      (!isDuplicate || aAllowDuplicates) && this._array.push(aStr), isDuplicate || (hasNativeMap ? this._set.set(aStr, idx) : this._set[sStr] = idx);
    };
    ArraySet.prototype.has = function(aStr) {
      if (hasNativeMap)
        return this._set.has(aStr);
      var sStr = util.toSetString(aStr);
      return has2.call(this._set, sStr);
    };
    ArraySet.prototype.indexOf = function(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0)
          return idx;
      } else {
        var sStr = util.toSetString(aStr);
        if (has2.call(this._set, sStr))
          return this._set[sStr];
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length)
        return this._array[aIdx];
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function() {
      return this._array.slice();
    };
    exports.ArraySet = ArraySet;
  }
});

// node_modules/source-map-support/node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/mapping-list.js"(exports) {
    var util = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine, lineB = mappingB.generatedLine, columnA = mappingA.generatedColumn, columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [], this._sorted = !0, this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function(aMapping) {
      generatedPositionAfter(this._last, aMapping) ? (this._last = aMapping, this._array.push(aMapping)) : (this._sorted = !1, this._array.push(aMapping));
    };
    MappingList.prototype.toArray = function() {
      return this._sorted || (this._array.sort(util.compareByGeneratedPositionsInflated), this._sorted = !0), this._array;
    };
    exports.MappingList = MappingList;
  }
});

// node_modules/source-map-support/node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/source-map-generator.js"(exports) {
    var base64VLQ = require_base64_vlq(), util = require_util(), ArraySet = require_array_set().ArraySet, MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      aArgs || (aArgs = {}), this._file = util.getArg(aArgs, "file", null), this._sourceRoot = util.getArg(aArgs, "sourceRoot", null), this._skipValidation = util.getArg(aArgs, "skipValidation", !1), this._sources = new ArraySet(), this._names = new ArraySet(), this._mappings = new MappingList(), this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot, generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      return aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        mapping.source != null && (newMapping.source = mapping.source, sourceRoot != null && (newMapping.source = util.relative(sourceRoot, newMapping.source)), newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        }, mapping.name != null && (newMapping.name = mapping.name)), generator.addMapping(newMapping);
      }), aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        sourceRoot !== null && (sourceRelative = util.relative(sourceRoot, sourceFile)), generator._sources.has(sourceRelative) || generator._sources.add(sourceRelative);
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        content != null && generator.setSourceContent(sourceFile, content);
      }), generator;
    };
    SourceMapGenerator.prototype.addMapping = function(aArgs) {
      var generated = util.getArg(aArgs, "generated"), original = util.getArg(aArgs, "original", null), source = util.getArg(aArgs, "source", null), name = util.getArg(aArgs, "name", null);
      this._skipValidation || this._validateMapping(generated, original, source, name), source != null && (source = String(source), this._sources.has(source) || this._sources.add(source)), name != null && (name = String(name), this._names.has(name) || this._names.add(name)), this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      this._sourceRoot != null && (source = util.relative(this._sourceRoot, source)), aSourceContent != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[util.toSetString(source)] = aSourceContent) : this._sourcesContents && (delete this._sourcesContents[util.toSetString(source)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
    };
    SourceMapGenerator.prototype.applySourceMap = function(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null)
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      sourceRoot != null && (sourceFile = util.relative(sourceRoot, sourceFile));
      var newSources = new ArraySet(), newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          original.source != null && (mapping.source = original.source, aSourceMapPath != null && (mapping.source = util.join(aSourceMapPath, mapping.source)), sourceRoot != null && (mapping.source = util.relative(sourceRoot, mapping.source)), mapping.originalLine = original.line, mapping.originalColumn = original.column, original.name != null && (mapping.name = original.name));
        }
        var source = mapping.source;
        source != null && !newSources.has(source) && newSources.add(source);
        var name = mapping.name;
        name != null && !newNames.has(name) && newNames.add(name);
      }, this), this._sources = newSources, this._names = newNames, aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        content != null && (aSourceMapPath != null && (sourceFile2 = util.join(aSourceMapPath, sourceFile2)), sourceRoot != null && (sourceFile2 = util.relative(sourceRoot, sourceFile2)), this.setSourceContent(sourceFile2, content));
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line != "number" && typeof aOriginal.column != "number")
        throw new Error(
          "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
        );
      if (!(aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName)) {
        if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource)
          return;
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function() {
      for (var previousGeneratedColumn = 0, previousGeneratedLine = 1, previousOriginalColumn = 0, previousOriginalLine = 0, previousName = 0, previousSource = 0, result = "", next, mapping, nameIdx, sourceIdx, mappings = this._mappings.toArray(), i2 = 0, len = mappings.length; i2 < len; i2++) {
        if (mapping = mappings[i2], next = "", mapping.generatedLine !== previousGeneratedLine)
          for (previousGeneratedColumn = 0; mapping.generatedLine !== previousGeneratedLine; )
            next += ";", previousGeneratedLine++;
        else if (i2 > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i2 - 1]))
            continue;
          next += ",";
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn), previousGeneratedColumn = mapping.generatedColumn, mapping.source != null && (sourceIdx = this._sources.indexOf(mapping.source), next += base64VLQ.encode(sourceIdx - previousSource), previousSource = sourceIdx, next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine), previousOriginalLine = mapping.originalLine - 1, next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn), previousOriginalColumn = mapping.originalColumn, mapping.name != null && (nameIdx = this._names.indexOf(mapping.name), next += base64VLQ.encode(nameIdx - previousName), previousName = nameIdx)), result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents)
          return null;
        aSourceRoot != null && (source = util.relative(aSourceRoot, source));
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      return this._file != null && (map.file = this._file), this._sourceRoot != null && (map.sourceRoot = this._sourceRoot), this._sourcesContents && (map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot)), map;
    };
    SourceMapGenerator.prototype.toString = function() {
      return JSON.stringify(this.toJSON());
    };
    exports.SourceMapGenerator = SourceMapGenerator;
  }
});

// node_modules/source-map-support/node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/binary-search.js"(exports) {
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow, cmp = aCompare(aNeedle, aHaystack[mid], !0);
      return cmp === 0 ? mid : cmp > 0 ? aHigh - mid > 1 ? recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias) : aBias == exports.LEAST_UPPER_BOUND ? aHigh < aHaystack.length ? aHigh : -1 : mid : mid - aLow > 1 ? recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias) : aBias == exports.LEAST_UPPER_BOUND ? mid : aLow < 0 ? -1 : aLow;
    }
    exports.search = function(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0)
        return -1;
      var index = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports.GREATEST_LOWER_BOUND
      );
      if (index < 0)
        return -1;
      for (; index - 1 >= 0 && aCompare(aHaystack[index], aHaystack[index - 1], !0) === 0; )
        --index;
      return index;
    };
  }
});

// node_modules/source-map-support/node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/quick-sort.js"(exports) {
    function swap(ary, x2, y) {
      var temp = ary[x2];
      ary[x2] = ary[y], ary[y] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator, p, r2) {
      if (p < r2) {
        var pivotIndex = randomIntInRange(p, r2), i2 = p - 1;
        swap(ary, pivotIndex, r2);
        for (var pivot = ary[r2], j = p; j < r2; j++)
          comparator(ary[j], pivot) <= 0 && (i2 += 1, swap(ary, i2, j));
        swap(ary, i2 + 1, j);
        var q = i2 + 1;
        doQuickSort(ary, comparator, p, q - 1), doQuickSort(ary, comparator, q + 1, r2);
      }
    }
    exports.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
  }
});

// node_modules/source-map-support/node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/source-map-consumer.js"(exports) {
    var util = require_util(), binarySearch = require_binary_search(), ArraySet = require_array_set().ArraySet, base64VLQ = require_base64_vlq(), quickSort = require_quick_sort().quickSort;
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      return typeof aSourceMap == "string" && (sourceMap = util.parseSourceMapInput(aSourceMap)), sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      configurable: !0,
      enumerable: !0,
      get: function() {
        return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      configurable: !0,
      enumerable: !0,
      get: function() {
        return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function(aCallback, aContext, aOrder) {
      var context = aContext || null, order = aOrder || SourceMapConsumer.GENERATED_ORDER, mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        return source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL), {
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function(aArgs) {
      var line = util.getArg(aArgs, "line"), needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0)
      };
      if (needle.source = this._findSourceIndex(needle.source), needle.source < 0)
        return [];
      var mappings = [], index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        binarySearch.LEAST_UPPER_BOUND
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === void 0)
          for (var originalLine = mapping.originalLine; mapping && mapping.originalLine === originalLine; )
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            }), mapping = this._originalMappings[++index];
        else
          for (var originalColumn = mapping.originalColumn; mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn; )
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            }), mapping = this._originalMappings[++index];
      }
      return mappings;
    };
    exports.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      typeof aSourceMap == "string" && (sourceMap = util.parseSourceMapInput(aSourceMap));
      var version = util.getArg(sourceMap, "version"), sources = util.getArg(sourceMap, "sources"), names = util.getArg(sourceMap, "names", []), sourceRoot = util.getArg(sourceMap, "sourceRoot", null), sourcesContent = util.getArg(sourceMap, "sourcesContent", null), mappings = util.getArg(sourceMap, "mappings"), file = util.getArg(sourceMap, "file", null);
      if (version != this._version)
        throw new Error("Unsupported version: " + version);
      sourceRoot && (sourceRoot = util.normalize(sourceRoot)), sources = sources.map(String).map(util.normalize).map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
      }), this._names = ArraySet.fromArray(names.map(String), !0), this._sources = ArraySet.fromArray(sources, !0), this._absoluteSources = this._sources.toArray().map(function(s2) {
        return util.computeSourceURL(sourceRoot, s2, aSourceMapURL);
      }), this.sourceRoot = sourceRoot, this.sourcesContent = sourcesContent, this._mappings = mappings, this._sourceMapURL = aSourceMapURL, this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null && (relativeSource = util.relative(this.sourceRoot, relativeSource)), this._sources.has(relativeSource))
        return this._sources.indexOf(relativeSource);
      var i2;
      for (i2 = 0; i2 < this._absoluteSources.length; ++i2)
        if (this._absoluteSources[i2] == aSource)
          return i2;
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype), names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), !0), sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), !0);
      smc.sourceRoot = aSourceMap._sourceRoot, smc.sourcesContent = aSourceMap._generateSourcesContent(
        smc._sources.toArray(),
        smc.sourceRoot
      ), smc.file = aSourceMap._file, smc._sourceMapURL = aSourceMapURL, smc._absoluteSources = smc._sources.toArray().map(function(s2) {
        return util.computeSourceURL(smc.sourceRoot, s2, aSourceMapURL);
      });
      for (var generatedMappings = aSourceMap._mappings.toArray().slice(), destGeneratedMappings = smc.__generatedMappings = [], destOriginalMappings = smc.__originalMappings = [], i2 = 0, length = generatedMappings.length; i2 < length; i2++) {
        var srcMapping = generatedMappings[i2], destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine, destMapping.generatedColumn = srcMapping.generatedColumn, srcMapping.source && (destMapping.source = sources.indexOf(srcMapping.source), destMapping.originalLine = srcMapping.originalLine, destMapping.originalColumn = srcMapping.originalColumn, srcMapping.name && (destMapping.name = names.indexOf(srcMapping.name)), destOriginalMappings.push(destMapping)), destGeneratedMappings.push(destMapping);
      }
      return quickSort(smc.__originalMappings, util.compareByOriginalPositions), smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping() {
      this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
    }
    BasicSourceMapConsumer.prototype._parseMappings = function(aStr, aSourceRoot) {
      for (var generatedLine = 1, previousGeneratedColumn = 0, previousOriginalLine = 0, previousOriginalColumn = 0, previousSource = 0, previousName = 0, length = aStr.length, index = 0, cachedSegments = {}, temp = {}, originalMappings = [], generatedMappings = [], mapping, str, segment, end, value; index < length; )
        if (aStr.charAt(index) === ";")
          generatedLine++, index++, previousGeneratedColumn = 0;
        else if (aStr.charAt(index) === ",")
          index++;
        else {
          for (mapping = new Mapping(), mapping.generatedLine = generatedLine, end = index; end < length && !this._charIsMappingSeparator(aStr, end); end++)
            ;
          if (str = aStr.slice(index, end), segment = cachedSegments[str], segment)
            index += str.length;
          else {
            for (segment = []; index < end; )
              base64VLQ.decode(aStr, index, temp), value = temp.value, index = temp.rest, segment.push(value);
            if (segment.length === 2)
              throw new Error("Found a source, but no line and column");
            if (segment.length === 3)
              throw new Error("Found a source and line, but no column");
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0], previousGeneratedColumn = mapping.generatedColumn, segment.length > 1 && (mapping.source = previousSource + segment[1], previousSource += segment[1], mapping.originalLine = previousOriginalLine + segment[2], previousOriginalLine = mapping.originalLine, mapping.originalLine += 1, mapping.originalColumn = previousOriginalColumn + segment[3], previousOriginalColumn = mapping.originalColumn, segment.length > 4 && (mapping.name = previousName + segment[4], previousName += segment[4])), generatedMappings.push(mapping), typeof mapping.originalLine == "number" && originalMappings.push(mapping);
        }
      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated), this.__generatedMappings = generatedMappings, quickSort(originalMappings, util.compareByOriginalPositions), this.__originalMappings = originalMappings;
    };
    BasicSourceMapConsumer.prototype._findMapping = function(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0)
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      if (aNeedle[aColumnName] < 0)
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = 1 / 0;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      }, index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, "source", null);
          source !== null && (source = this._sources.at(source), source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL));
          var name = util.getArg(mapping, "name", null);
          return name !== null && (name = this._names.at(name)), {
            source,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function() {
      return this.sourcesContent ? this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      }) : !1;
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function(aSource, nullOnMissing) {
      if (!this.sourcesContent)
        return null;
      var index = this._findSourceIndex(aSource);
      if (index >= 0)
        return this.sourcesContent[index];
      var relativeSource = aSource;
      this.sourceRoot != null && (relativeSource = util.relative(this.sourceRoot, relativeSource));
      var url;
      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath))
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource))
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
      if (nullOnMissing)
        return null;
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function(aArgs) {
      var source = util.getArg(aArgs, "source");
      if (source = this._findSourceIndex(source), source < 0)
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      var needle = {
        source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column")
      }, index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source)
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          };
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      typeof aSourceMap == "string" && (sourceMap = util.parseSourceMapInput(aSourceMap));
      var version = util.getArg(sourceMap, "version"), sections = util.getArg(sourceMap, "sections");
      if (version != this._version)
        throw new Error("Unsupported version: " + version);
      this._sources = new ArraySet(), this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s2) {
        if (s2.url)
          throw new Error("Support for url field in sections not implemented.");
        var offset = util.getArg(s2, "offset"), offsetLine = util.getArg(offset, "line"), offsetColumn = util.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column)
          throw new Error("Section offsets must be ordered and non-overlapping.");
        return lastOffset = offset, {
          generatedOffset: {
            // The offset fields are 0-based, but we use 1-based indices when
            // encoding/decoding from VLQ.
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util.getArg(s2, "map"), aSourceMapURL)
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        for (var sources = [], i2 = 0; i2 < this._sections.length; i2++)
          for (var j = 0; j < this._sections[i2].consumer.sources.length; j++)
            sources.push(this._sections[i2].consumer.sources[j]);
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      }, sectionIndex = binarySearch.search(
        needle,
        this._sections,
        function(needle2, section2) {
          var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
          return cmp || needle2.generatedColumn - section2.generatedOffset.generatedColumn;
        }
      ), section = this._sections[sectionIndex];
      return section ? section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      }) : {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function() {
      return this._sections.every(function(s2) {
        return s2.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function(aSource, nullOnMissing) {
      for (var i2 = 0; i2 < this._sections.length; i2++) {
        var section = this._sections[i2], content = section.consumer.sourceContentFor(aSource, !0);
        if (content)
          return content;
      }
      if (nullOnMissing)
        return null;
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function(aArgs) {
      for (var i2 = 0; i2 < this._sections.length; i2++) {
        var section = this._sections[i2];
        if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) !== -1) {
          var generatedPosition = section.consumer.generatedPositionFor(aArgs);
          if (generatedPosition) {
            var ret = {
              line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
              column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
            };
            return ret;
          }
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function(aStr, aSourceRoot) {
      this.__generatedMappings = [], this.__originalMappings = [];
      for (var i2 = 0; i2 < this._sections.length; i2++)
        for (var section = this._sections[i2], sectionMappings = section.consumer._generatedMappings, j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j], source = section.consumer._sources.at(mapping.source);
          source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL), this._sources.add(source), source = this._sources.indexOf(source);
          var name = null;
          mapping.name && (name = section.consumer._names.at(mapping.name), this._names.add(name), name = this._names.indexOf(name));
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping), typeof adjustedMapping.originalLine == "number" && this.__originalMappings.push(adjustedMapping);
        }
      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated), quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };
    exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// node_modules/source-map-support/node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/source-node.js"(exports) {
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator, util = require_util(), REGEX_NEWLINE = /(\r?\n)/, NEWLINE_CODE = 10, isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [], this.sourceContents = {}, this.line = aLine ?? null, this.column = aColumn ?? null, this.source = aSource ?? null, this.name = aName ?? null, this[isSourceNode] = !0, aChunks != null && this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode(), remainingLines = aGeneratedCode.split(REGEX_NEWLINE), remainingLinesIndex = 0, shiftNextLine = function() {
        var lineContents = getNextLine(), newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      }, lastGeneratedLine = 1, lastGeneratedColumn = 0, lastMapping = null;
      return aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null)
          if (lastGeneratedLine < mapping.generatedLine)
            addMappingWithCode(lastMapping, shiftNextLine()), lastGeneratedLine++, lastGeneratedColumn = 0;
          else {
            var nextLine = remainingLines[remainingLinesIndex] || "", code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn), lastGeneratedColumn = mapping.generatedColumn, addMappingWithCode(lastMapping, code), lastMapping = mapping;
            return;
          }
        for (; lastGeneratedLine < mapping.generatedLine; )
          node.add(shiftNextLine()), lastGeneratedLine++;
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node.add(nextLine.substr(0, mapping.generatedColumn)), remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn), lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this), remainingLinesIndex < remainingLines.length && (lastMapping && addMappingWithCode(lastMapping, shiftNextLine()), node.add(remainingLines.splice(remainingLinesIndex).join(""))), aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        content != null && (aRelativePath != null && (sourceFile = util.join(aRelativePath, sourceFile)), node.setSourceContent(sourceFile, content));
      }), node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0)
          node.add(code);
        else {
          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(
            mapping.originalLine,
            mapping.originalColumn,
            source,
            code,
            mapping.name
          ));
        }
      }
    };
    SourceNode.prototype.add = function(aChunk) {
      if (Array.isArray(aChunk))
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      else if (aChunk[isSourceNode] || typeof aChunk == "string")
        aChunk && this.children.push(aChunk);
      else
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      return this;
    };
    SourceNode.prototype.prepend = function(aChunk) {
      if (Array.isArray(aChunk))
        for (var i2 = aChunk.length - 1; i2 >= 0; i2--)
          this.prepend(aChunk[i2]);
      else if (aChunk[isSourceNode] || typeof aChunk == "string")
        this.children.unshift(aChunk);
      else
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      return this;
    };
    SourceNode.prototype.walk = function(aFn) {
      for (var chunk, i2 = 0, len = this.children.length; i2 < len; i2++)
        chunk = this.children[i2], chunk[isSourceNode] ? chunk.walk(aFn) : chunk !== "" && aFn(chunk, {
          source: this.source,
          line: this.line,
          column: this.column,
          name: this.name
        });
    };
    SourceNode.prototype.join = function(aSep) {
      var newChildren, i2, len = this.children.length;
      if (len > 0) {
        for (newChildren = [], i2 = 0; i2 < len - 1; i2++)
          newChildren.push(this.children[i2]), newChildren.push(aSep);
        newChildren.push(this.children[i2]), this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      return lastChild[isSourceNode] ? lastChild.replaceRight(aPattern, aReplacement) : typeof lastChild == "string" ? this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement) : this.children.push("".replace(aPattern, aReplacement)), this;
    };
    SourceNode.prototype.setSourceContent = function(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function(aFn) {
      for (var i2 = 0, len = this.children.length; i2 < len; i2++)
        this.children[i2][isSourceNode] && this.children[i2].walkSourceContents(aFn);
      for (var sources = Object.keys(this.sourceContents), i2 = 0, len = sources.length; i2 < len; i2++)
        aFn(util.fromSetString(sources[i2]), this.sourceContents[sources[i2]]);
    };
    SourceNode.prototype.toString = function() {
      var str = "";
      return this.walk(function(chunk) {
        str += chunk;
      }), str;
    };
    SourceNode.prototype.toStringWithSourceMap = function(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      }, map = new SourceMapGenerator(aArgs), sourceMappingActive = !1, lastOriginalSource = null, lastOriginalLine = null, lastOriginalColumn = null, lastOriginalName = null;
      return this.walk(function(chunk, original) {
        generated.code += chunk, original.source !== null && original.line !== null && original.column !== null ? ((lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) && map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        }), lastOriginalSource = original.source, lastOriginalLine = original.line, lastOriginalColumn = original.column, lastOriginalName = original.name, sourceMappingActive = !0) : sourceMappingActive && (map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        }), lastOriginalSource = null, sourceMappingActive = !1);
        for (var idx = 0, length = chunk.length; idx < length; idx++)
          chunk.charCodeAt(idx) === NEWLINE_CODE ? (generated.line++, generated.column = 0, idx + 1 === length ? (lastOriginalSource = null, sourceMappingActive = !1) : sourceMappingActive && map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          })) : generated.column++;
      }), this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      }), { code: generated.code, map };
    };
    exports.SourceNode = SourceNode;
  }
});

// node_modules/source-map-support/node_modules/source-map/source-map.js
var require_source_map = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/source-map.js"(exports) {
    exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports.SourceNode = require_source_node().SourceNode;
  }
});

// node_modules/buffer-from/index.js
var require_buffer_from = __commonJS({
  "node_modules/buffer-from/index.js"(exports, module2) {
    var toString = Object.prototype.toString, isModern = typeof Buffer < "u" && typeof Buffer.alloc == "function" && typeof Buffer.allocUnsafe == "function" && typeof Buffer.from == "function";
    function isArrayBuffer(input) {
      return toString.call(input).slice(8, -1) === "ArrayBuffer";
    }
    function fromArrayBuffer(obj, byteOffset, length) {
      byteOffset >>>= 0;
      var maxLength = obj.byteLength - byteOffset;
      if (maxLength < 0)
        throw new RangeError("'offset' is out of bounds");
      if (length === void 0)
        length = maxLength;
      else if (length >>>= 0, length > maxLength)
        throw new RangeError("'length' is out of bounds");
      return isModern ? Buffer.from(obj.slice(byteOffset, byteOffset + length)) : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)));
    }
    function fromString(string, encoding) {
      if ((typeof encoding != "string" || encoding === "") && (encoding = "utf8"), !Buffer.isEncoding(encoding))
        throw new TypeError('"encoding" must be a valid string encoding');
      return isModern ? Buffer.from(string, encoding) : new Buffer(string, encoding);
    }
    function bufferFrom(value, encodingOrOffset, length) {
      if (typeof value == "number")
        throw new TypeError('"value" argument must not be a number');
      return isArrayBuffer(value) ? fromArrayBuffer(value, encodingOrOffset, length) : typeof value == "string" ? fromString(value, encodingOrOffset) : isModern ? Buffer.from(value) : new Buffer(value);
    }
    module2.exports = bufferFrom;
  }
});

// node_modules/source-map-support/source-map-support.js
var require_source_map_support = __commonJS({
  "node_modules/source-map-support/source-map-support.js"(exports, module2) {
    var SourceMapConsumer = require_source_map().SourceMapConsumer, path = require("path"), fs2;
    try {
      fs2 = require("fs"), (!fs2.existsSync || !fs2.readFileSync) && (fs2 = null);
    } catch {
    }
    var bufferFrom = require_buffer_from();
    function dynamicRequire(mod, request) {
      return mod.require(request);
    }
    var errorFormatterInstalled = !1, uncaughtShimInstalled = !1, emptyCacheBetweenOperations = !1, environment = "auto", fileContentsCache = {}, sourceMapCache = {}, reSourceMap = /^data:application\/json[^,]+base64,/, retrieveFileHandlers = [], retrieveMapHandlers = [];
    function isInBrowser() {
      return environment === "browser" ? !0 : environment === "node" ? !1 : typeof window < "u" && typeof XMLHttpRequest == "function" && !(window.require && window.module && window.process && window.process.type === "renderer");
    }
    function hasGlobalProcessEventEmitter() {
      return typeof process == "object" && process !== null && typeof process.on == "function";
    }
    function globalProcessVersion() {
      return typeof process == "object" && process !== null ? process.version : "";
    }
    function globalProcessStderr() {
      if (typeof process == "object" && process !== null)
        return process.stderr;
    }
    function globalProcessExit(code) {
      if (typeof process == "object" && process !== null && typeof process.exit == "function")
        return process.exit(code);
    }
    function handlerExec(list2) {
      return function(arg) {
        for (var i2 = 0; i2 < list2.length; i2++) {
          var ret = list2[i2](arg);
          if (ret)
            return ret;
        }
        return null;
      };
    }
    var retrieveFile = handlerExec(retrieveFileHandlers);
    retrieveFileHandlers.push(function(path2) {
      if (path2 = path2.trim(), /^file:/.test(path2) && (path2 = path2.replace(/file:\/\/\/(\w:)?/, function(protocol, drive) {
        return drive ? "" : (
          // file:///C:/dir/file -> C:/dir/file
          "/"
        );
      })), path2 in fileContentsCache)
        return fileContentsCache[path2];
      var contents = "";
      try {
        if (fs2)
          fs2.existsSync(path2) && (contents = fs2.readFileSync(path2, "utf8"));
        else {
          var xhr = new XMLHttpRequest();
          xhr.open(
            "GET",
            path2,
            /** async */
            !1
          ), xhr.send(null), xhr.readyState === 4 && xhr.status === 200 && (contents = xhr.responseText);
        }
      } catch {
      }
      return fileContentsCache[path2] = contents;
    });
    function supportRelativeURL(file, url) {
      if (!file)
        return url;
      var dir = path.dirname(file), match = /^\w+:\/\/[^\/]*/.exec(dir), protocol = match ? match[0] : "", startPath = dir.slice(protocol.length);
      return protocol && /^\/\w\:/.test(startPath) ? (protocol += "/", protocol + path.resolve(dir.slice(protocol.length), url).replace(/\\/g, "/")) : protocol + path.resolve(dir.slice(protocol.length), url);
    }
    function retrieveSourceMapURL(source) {
      var fileData;
      if (isInBrowser())
        try {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", source, !1), xhr.send(null), fileData = xhr.readyState === 4 ? xhr.responseText : null;
          var sourceMapHeader = xhr.getResponseHeader("SourceMap") || xhr.getResponseHeader("X-SourceMap");
          if (sourceMapHeader)
            return sourceMapHeader;
        } catch {
        }
      fileData = retrieveFile(source);
      for (var re = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/mg, lastMatch, match; match = re.exec(fileData); )
        lastMatch = match;
      return lastMatch ? lastMatch[1] : null;
    }
    var retrieveSourceMap = handlerExec(retrieveMapHandlers);
    retrieveMapHandlers.push(function(source) {
      var sourceMappingURL = retrieveSourceMapURL(source);
      if (!sourceMappingURL)
        return null;
      var sourceMapData;
      if (reSourceMap.test(sourceMappingURL)) {
        var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(",") + 1);
        sourceMapData = bufferFrom(rawData, "base64").toString(), sourceMappingURL = source;
      } else
        sourceMappingURL = supportRelativeURL(source, sourceMappingURL), sourceMapData = retrieveFile(sourceMappingURL);
      return sourceMapData ? {
        url: sourceMappingURL,
        map: sourceMapData
      } : null;
    });
    function mapSourcePosition(position) {
      var sourceMap = sourceMapCache[position.source];
      if (!sourceMap) {
        var urlAndMap = retrieveSourceMap(position.source);
        urlAndMap ? (sourceMap = sourceMapCache[position.source] = {
          url: urlAndMap.url,
          map: new SourceMapConsumer(urlAndMap.map)
        }, sourceMap.map.sourcesContent && sourceMap.map.sources.forEach(function(source, i2) {
          var contents = sourceMap.map.sourcesContent[i2];
          if (contents) {
            var url = supportRelativeURL(sourceMap.url, source);
            fileContentsCache[url] = contents;
          }
        })) : sourceMap = sourceMapCache[position.source] = {
          url: null,
          map: null
        };
      }
      if (sourceMap && sourceMap.map && typeof sourceMap.map.originalPositionFor == "function") {
        var originalPosition = sourceMap.map.originalPositionFor(position);
        if (originalPosition.source !== null)
          return originalPosition.source = supportRelativeURL(
            sourceMap.url,
            originalPosition.source
          ), originalPosition;
      }
      return position;
    }
    function mapEvalOrigin(origin) {
      var match = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
      if (match) {
        var position = mapSourcePosition({
          source: match[2],
          line: +match[3],
          column: match[4] - 1
        });
        return "eval at " + match[1] + " (" + position.source + ":" + position.line + ":" + (position.column + 1) + ")";
      }
      return match = /^eval at ([^(]+) \((.+)\)$/.exec(origin), match ? "eval at " + match[1] + " (" + mapEvalOrigin(match[2]) + ")" : origin;
    }
    function CallSiteToString() {
      var fileName, fileLocation = "";
      if (this.isNative())
        fileLocation = "native";
      else {
        fileName = this.getScriptNameOrSourceURL(), !fileName && this.isEval() && (fileLocation = this.getEvalOrigin(), fileLocation += ", "), fileName ? fileLocation += fileName : fileLocation += "<anonymous>";
        var lineNumber = this.getLineNumber();
        if (lineNumber != null) {
          fileLocation += ":" + lineNumber;
          var columnNumber = this.getColumnNumber();
          columnNumber && (fileLocation += ":" + columnNumber);
        }
      }
      var line = "", functionName = this.getFunctionName(), addSuffix = !0, isConstructor = this.isConstructor(), isMethodCall = !(this.isToplevel() || isConstructor);
      if (isMethodCall) {
        var typeName = this.getTypeName();
        typeName === "[object Object]" && (typeName = "null");
        var methodName = this.getMethodName();
        functionName ? (typeName && functionName.indexOf(typeName) != 0 && (line += typeName + "."), line += functionName, methodName && functionName.indexOf("." + methodName) != functionName.length - methodName.length - 1 && (line += " [as " + methodName + "]")) : line += typeName + "." + (methodName || "<anonymous>");
      } else
        isConstructor ? line += "new " + (functionName || "<anonymous>") : functionName ? line += functionName : (line += fileLocation, addSuffix = !1);
      return addSuffix && (line += " (" + fileLocation + ")"), line;
    }
    function cloneCallSite(frame) {
      var object = {};
      return Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function(name) {
        object[name] = /^(?:is|get)/.test(name) ? function() {
          return frame[name].call(frame);
        } : frame[name];
      }), object.toString = CallSiteToString, object;
    }
    function wrapCallSite(frame, state) {
      if (state === void 0 && (state = { nextPosition: null, curPosition: null }), frame.isNative())
        return state.curPosition = null, frame;
      var source = frame.getFileName() || frame.getScriptNameOrSourceURL();
      if (source) {
        var line = frame.getLineNumber(), column = frame.getColumnNumber() - 1, noHeader = /^v(10\.1[6-9]|10\.[2-9][0-9]|10\.[0-9]{3,}|1[2-9]\d*|[2-9]\d|\d{3,}|11\.11)/, headerLength = noHeader.test(globalProcessVersion()) ? 0 : 62;
        line === 1 && column > headerLength && !isInBrowser() && !frame.isEval() && (column -= headerLength);
        var position = mapSourcePosition({
          source,
          line,
          column
        });
        state.curPosition = position, frame = cloneCallSite(frame);
        var originalFunctionName = frame.getFunctionName;
        return frame.getFunctionName = function() {
          return state.nextPosition == null ? originalFunctionName() : state.nextPosition.name || originalFunctionName();
        }, frame.getFileName = function() {
          return position.source;
        }, frame.getLineNumber = function() {
          return position.line;
        }, frame.getColumnNumber = function() {
          return position.column + 1;
        }, frame.getScriptNameOrSourceURL = function() {
          return position.source;
        }, frame;
      }
      var origin = frame.isEval() && frame.getEvalOrigin();
      return origin && (origin = mapEvalOrigin(origin), frame = cloneCallSite(frame), frame.getEvalOrigin = function() {
        return origin;
      }), frame;
    }
    function prepareStackTrace(error, stack) {
      emptyCacheBetweenOperations && (fileContentsCache = {}, sourceMapCache = {});
      for (var name = error.name || "Error", message = error.message || "", errorString = name + ": " + message, state = { nextPosition: null, curPosition: null }, processedStack = [], i2 = stack.length - 1; i2 >= 0; i2--)
        processedStack.push(`
    at ` + wrapCallSite(stack[i2], state)), state.nextPosition = state.curPosition;
      return state.curPosition = state.nextPosition = null, errorString + processedStack.reverse().join("");
    }
    function getErrorSource(error) {
      var match = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(error.stack);
      if (match) {
        var source = match[1], line = +match[2], column = +match[3], contents = fileContentsCache[source];
        if (!contents && fs2 && fs2.existsSync(source))
          try {
            contents = fs2.readFileSync(source, "utf8");
          } catch {
            contents = "";
          }
        if (contents) {
          var code = contents.split(/(?:\r\n|\r|\n)/)[line - 1];
          if (code)
            return source + ":" + line + `
` + code + `
` + new Array(column).join(" ") + "^";
        }
      }
      return null;
    }
    function printErrorAndExit(error) {
      var source = getErrorSource(error), stderr = globalProcessStderr();
      stderr && stderr._handle && stderr._handle.setBlocking && stderr._handle.setBlocking(!0), source && (console.error(), console.error(source)), console.error(error.stack), globalProcessExit(1);
    }
    function shimEmitUncaughtException() {
      var origEmit = process.emit;
      process.emit = function(type) {
        if (type === "uncaughtException") {
          var hasStack = arguments[1] && arguments[1].stack, hasListeners = this.listeners(type).length > 0;
          if (hasStack && !hasListeners)
            return printErrorAndExit(arguments[1]);
        }
        return origEmit.apply(this, arguments);
      };
    }
    var originalRetrieveFileHandlers = retrieveFileHandlers.slice(0), originalRetrieveMapHandlers = retrieveMapHandlers.slice(0);
    exports.wrapCallSite = wrapCallSite;
    exports.getErrorSource = getErrorSource;
    exports.mapSourcePosition = mapSourcePosition;
    exports.retrieveSourceMap = retrieveSourceMap;
    exports.install = function(options) {
      if (options = options || {}, options.environment && (environment = options.environment, ["node", "browser", "auto"].indexOf(environment) === -1))
        throw new Error("environment " + environment + " was unknown. Available options are {auto, browser, node}");
      if (options.retrieveFile && (options.overrideRetrieveFile && (retrieveFileHandlers.length = 0), retrieveFileHandlers.unshift(options.retrieveFile)), options.retrieveSourceMap && (options.overrideRetrieveSourceMap && (retrieveMapHandlers.length = 0), retrieveMapHandlers.unshift(options.retrieveSourceMap)), options.hookRequire && !isInBrowser()) {
        var Module = dynamicRequire(module2, "module"), $compile = Module.prototype._compile;
        $compile.__sourceMapSupport || (Module.prototype._compile = function(content, filename) {
          return fileContentsCache[filename] = content, sourceMapCache[filename] = void 0, $compile.call(this, content, filename);
        }, Module.prototype._compile.__sourceMapSupport = !0);
      }
      if (emptyCacheBetweenOperations || (emptyCacheBetweenOperations = "emptyCacheBetweenOperations" in options ? options.emptyCacheBetweenOperations : !1), errorFormatterInstalled || (errorFormatterInstalled = !0, Error.prepareStackTrace = prepareStackTrace), !uncaughtShimInstalled) {
        var installHandler = "handleUncaughtExceptions" in options ? options.handleUncaughtExceptions : !0;
        try {
          var worker_threads = dynamicRequire(module2, "worker_threads");
          worker_threads.isMainThread === !1 && (installHandler = !1);
        } catch {
        }
        installHandler && hasGlobalProcessEventEmitter() && (uncaughtShimInstalled = !0, shimEmitUncaughtException());
      }
    };
    exports.resetRetrieveHandlers = function() {
      retrieveFileHandlers.length = 0, retrieveMapHandlers.length = 0, retrieveFileHandlers = originalRetrieveFileHandlers.slice(0), retrieveMapHandlers = originalRetrieveMapHandlers.slice(0), retrieveSourceMap = handlerExec(retrieveMapHandlers), retrieveFile = handlerExec(retrieveFileHandlers);
    };
  }
});

// node_modules/event-target-shim/dist/event-target-shim.js
var require_event_target_shim = __commonJS({
  "node_modules/event-target-shim/dist/event-target-shim.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var privateData = /* @__PURE__ */ new WeakMap(), wrappers = /* @__PURE__ */ new WeakMap();
    function pd(event) {
      let retv = privateData.get(event);
      return console.assert(
        retv != null,
        "'this' is expected an Event object, but got",
        event
      ), retv;
    }
    function setCancelFlag(data) {
      if (data.passiveListener != null) {
        typeof console < "u" && typeof console.error == "function" && console.error(
          "Unable to preventDefault inside passive event listener invocation.",
          data.passiveListener
        );
        return;
      }
      data.event.cancelable && (data.canceled = !0, typeof data.event.preventDefault == "function" && data.event.preventDefault());
    }
    function Event(eventTarget, event) {
      privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: !1,
        stopped: !1,
        immediateStopped: !1,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now()
      }), Object.defineProperty(this, "isTrusted", { value: !1, enumerable: !0 });
      let keys = Object.keys(event);
      for (let i2 = 0; i2 < keys.length; ++i2) {
        let key = keys[i2];
        key in this || Object.defineProperty(this, key, defineRedirectDescriptor(key));
      }
    }
    Event.prototype = {
      /**
       * The type of this event.
       * @type {string}
       */
      get type() {
        return pd(this).event.type;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get target() {
        return pd(this).eventTarget;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get currentTarget() {
        return pd(this).currentTarget;
      },
      /**
       * @returns {EventTarget[]} The composed path of this event.
       */
      composedPath() {
        let currentTarget = pd(this).currentTarget;
        return currentTarget == null ? [] : [currentTarget];
      },
      /**
       * Constant of NONE.
       * @type {number}
       */
      get NONE() {
        return 0;
      },
      /**
       * Constant of CAPTURING_PHASE.
       * @type {number}
       */
      get CAPTURING_PHASE() {
        return 1;
      },
      /**
       * Constant of AT_TARGET.
       * @type {number}
       */
      get AT_TARGET() {
        return 2;
      },
      /**
       * Constant of BUBBLING_PHASE.
       * @type {number}
       */
      get BUBBLING_PHASE() {
        return 3;
      },
      /**
       * The target of this event.
       * @type {number}
       */
      get eventPhase() {
        return pd(this).eventPhase;
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopPropagation() {
        let data = pd(this);
        data.stopped = !0, typeof data.event.stopPropagation == "function" && data.event.stopPropagation();
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopImmediatePropagation() {
        let data = pd(this);
        data.stopped = !0, data.immediateStopped = !0, typeof data.event.stopImmediatePropagation == "function" && data.event.stopImmediatePropagation();
      },
      /**
       * The flag to be bubbling.
       * @type {boolean}
       */
      get bubbles() {
        return Boolean(pd(this).event.bubbles);
      },
      /**
       * The flag to be cancelable.
       * @type {boolean}
       */
      get cancelable() {
        return Boolean(pd(this).event.cancelable);
      },
      /**
       * Cancel this event.
       * @returns {void}
       */
      preventDefault() {
        setCancelFlag(pd(this));
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       */
      get defaultPrevented() {
        return pd(this).canceled;
      },
      /**
       * The flag to be composed.
       * @type {boolean}
       */
      get composed() {
        return Boolean(pd(this).event.composed);
      },
      /**
       * The unix time of this event.
       * @type {number}
       */
      get timeStamp() {
        return pd(this).timeStamp;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       * @deprecated
       */
      get srcElement() {
        return pd(this).eventTarget;
      },
      /**
       * The flag to stop event bubbling.
       * @type {boolean}
       * @deprecated
       */
      get cancelBubble() {
        return pd(this).stopped;
      },
      set cancelBubble(value) {
        if (!value)
          return;
        let data = pd(this);
        data.stopped = !0, typeof data.event.cancelBubble == "boolean" && (data.event.cancelBubble = !0);
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       * @deprecated
       */
      get returnValue() {
        return !pd(this).canceled;
      },
      set returnValue(value) {
        value || setCancelFlag(pd(this));
      },
      /**
       * Initialize this event object. But do nothing under event dispatching.
       * @param {string} type The event type.
       * @param {boolean} [bubbles=false] The flag to be possible to bubble up.
       * @param {boolean} [cancelable=false] The flag to be possible to cancel.
       * @deprecated
       */
      initEvent() {
      }
    };
    Object.defineProperty(Event.prototype, "constructor", {
      value: Event,
      configurable: !0,
      writable: !0
    });
    typeof window < "u" && typeof window.Event < "u" && (Object.setPrototypeOf(Event.prototype, window.Event.prototype), wrappers.set(window.Event.prototype, Event));
    function defineRedirectDescriptor(key) {
      return {
        get() {
          return pd(this).event[key];
        },
        set(value) {
          pd(this).event[key] = value;
        },
        configurable: !0,
        enumerable: !0
      };
    }
    function defineCallDescriptor(key) {
      return {
        value() {
          let event = pd(this).event;
          return event[key].apply(event, arguments);
        },
        configurable: !0,
        enumerable: !0
      };
    }
    function defineWrapper(BaseEvent, proto) {
      let keys = Object.keys(proto);
      if (keys.length === 0)
        return BaseEvent;
      function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
      }
      CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: !0, writable: !0 }
      });
      for (let i2 = 0; i2 < keys.length; ++i2) {
        let key = keys[i2];
        if (!(key in BaseEvent.prototype)) {
          let isFunc = typeof Object.getOwnPropertyDescriptor(proto, key).value == "function";
          Object.defineProperty(
            CustomEvent.prototype,
            key,
            isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key)
          );
        }
      }
      return CustomEvent;
    }
    function getWrapper(proto) {
      if (proto == null || proto === Object.prototype)
        return Event;
      let wrapper = wrappers.get(proto);
      return wrapper == null && (wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto), wrappers.set(proto, wrapper)), wrapper;
    }
    function wrapEvent(eventTarget, event) {
      let Wrapper = getWrapper(Object.getPrototypeOf(event));
      return new Wrapper(eventTarget, event);
    }
    function isStopped(event) {
      return pd(event).immediateStopped;
    }
    function setEventPhase(event, eventPhase) {
      pd(event).eventPhase = eventPhase;
    }
    function setCurrentTarget(event, currentTarget) {
      pd(event).currentTarget = currentTarget;
    }
    function setPassiveListener(event, passiveListener) {
      pd(event).passiveListener = passiveListener;
    }
    var listenersMap = /* @__PURE__ */ new WeakMap(), CAPTURE = 1, BUBBLE = 2, ATTRIBUTE = 3;
    function isObject2(x2) {
      return x2 !== null && typeof x2 == "object";
    }
    function getListeners(eventTarget) {
      let listeners = listenersMap.get(eventTarget);
      if (listeners == null)
        throw new TypeError(
          "'this' is expected an EventTarget object, but got another value."
        );
      return listeners;
    }
    function defineEventAttributeDescriptor(eventName) {
      return {
        get() {
          let node = getListeners(this).get(eventName);
          for (; node != null; ) {
            if (node.listenerType === ATTRIBUTE)
              return node.listener;
            node = node.next;
          }
          return null;
        },
        set(listener) {
          typeof listener != "function" && !isObject2(listener) && (listener = null);
          let listeners = getListeners(this), prev = null, node = listeners.get(eventName);
          for (; node != null; )
            node.listenerType === ATTRIBUTE ? prev !== null ? prev.next = node.next : node.next !== null ? listeners.set(eventName, node.next) : listeners.delete(eventName) : prev = node, node = node.next;
          if (listener !== null) {
            let newNode = {
              listener,
              listenerType: ATTRIBUTE,
              passive: !1,
              once: !1,
              next: null
            };
            prev === null ? listeners.set(eventName, newNode) : prev.next = newNode;
          }
        },
        configurable: !0,
        enumerable: !0
      };
    }
    function defineEventAttribute(eventTargetPrototype, eventName) {
      Object.defineProperty(
        eventTargetPrototype,
        `on${eventName}`,
        defineEventAttributeDescriptor(eventName)
      );
    }
    function defineCustomEventTarget(eventNames) {
      function CustomEventTarget() {
        EventTarget.call(this);
      }
      CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: {
          value: CustomEventTarget,
          configurable: !0,
          writable: !0
        }
      });
      for (let i2 = 0; i2 < eventNames.length; ++i2)
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i2]);
      return CustomEventTarget;
    }
    function EventTarget() {
      if (this instanceof EventTarget) {
        listenersMap.set(this, /* @__PURE__ */ new Map());
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0]))
        return defineCustomEventTarget(arguments[0]);
      if (arguments.length > 0) {
        let types3 = new Array(arguments.length);
        for (let i2 = 0; i2 < arguments.length; ++i2)
          types3[i2] = arguments[i2];
        return defineCustomEventTarget(types3);
      }
      throw new TypeError("Cannot call a class as a function");
    }
    EventTarget.prototype = {
      /**
       * Add a given listener to this event target.
       * @param {string} eventName The event name to add.
       * @param {Function} listener The listener to add.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      addEventListener(eventName, listener, options) {
        if (listener == null)
          return;
        if (typeof listener != "function" && !isObject2(listener))
          throw new TypeError("'listener' should be a function or an object.");
        let listeners = getListeners(this), optionsIsObj = isObject2(options), listenerType = Boolean(optionsIsObj ? options.capture : options) ? CAPTURE : BUBBLE, newNode = {
          listener,
          listenerType,
          passive: optionsIsObj && Boolean(options.passive),
          once: optionsIsObj && Boolean(options.once),
          next: null
        }, node = listeners.get(eventName);
        if (node === void 0) {
          listeners.set(eventName, newNode);
          return;
        }
        let prev = null;
        for (; node != null; ) {
          if (node.listener === listener && node.listenerType === listenerType)
            return;
          prev = node, node = node.next;
        }
        prev.next = newNode;
      },
      /**
       * Remove a given listener from this event target.
       * @param {string} eventName The event name to remove.
       * @param {Function} listener The listener to remove.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      removeEventListener(eventName, listener, options) {
        if (listener == null)
          return;
        let listeners = getListeners(this), listenerType = (isObject2(options) ? Boolean(options.capture) : Boolean(options)) ? CAPTURE : BUBBLE, prev = null, node = listeners.get(eventName);
        for (; node != null; ) {
          if (node.listener === listener && node.listenerType === listenerType) {
            prev !== null ? prev.next = node.next : node.next !== null ? listeners.set(eventName, node.next) : listeners.delete(eventName);
            return;
          }
          prev = node, node = node.next;
        }
      },
      /**
       * Dispatch a given event.
       * @param {Event|{type:string}} event The event to dispatch.
       * @returns {boolean} `false` if canceled.
       */
      dispatchEvent(event) {
        if (event == null || typeof event.type != "string")
          throw new TypeError('"event.type" should be a string.');
        let listeners = getListeners(this), eventName = event.type, node = listeners.get(eventName);
        if (node == null)
          return !0;
        let wrappedEvent = wrapEvent(this, event), prev = null;
        for (; node != null; ) {
          if (node.once ? prev !== null ? prev.next = node.next : node.next !== null ? listeners.set(eventName, node.next) : listeners.delete(eventName) : prev = node, setPassiveListener(
            wrappedEvent,
            node.passive ? node.listener : null
          ), typeof node.listener == "function")
            try {
              node.listener.call(this, wrappedEvent);
            } catch (err) {
              typeof console < "u" && typeof console.error == "function" && console.error(err);
            }
          else
            node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent == "function" && node.listener.handleEvent(wrappedEvent);
          if (isStopped(wrappedEvent))
            break;
          node = node.next;
        }
        return setPassiveListener(wrappedEvent, null), setEventPhase(wrappedEvent, 0), setCurrentTarget(wrappedEvent, null), !wrappedEvent.defaultPrevented;
      }
    };
    Object.defineProperty(EventTarget.prototype, "constructor", {
      value: EventTarget,
      configurable: !0,
      writable: !0
    });
    typeof window < "u" && typeof window.EventTarget < "u" && Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
    exports.defineEventAttribute = defineEventAttribute;
    exports.EventTarget = EventTarget;
    exports.default = EventTarget;
    module2.exports = EventTarget;
    module2.exports.EventTarget = module2.exports.default = EventTarget;
    module2.exports.defineEventAttribute = defineEventAttribute;
  }
});

// node_modules/abort-controller/dist/abort-controller.js
var require_abort_controller = __commonJS({
  "node_modules/abort-controller/dist/abort-controller.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var eventTargetShim = require_event_target_shim(), AbortSignal = class extends eventTargetShim.EventTarget {
      /**
       * AbortSignal cannot be constructed directly.
       */
      constructor() {
        throw super(), new TypeError("AbortSignal cannot be constructed directly");
      }
      /**
       * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.
       */
      get aborted() {
        let aborted = abortedFlags.get(this);
        if (typeof aborted != "boolean")
          throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        return aborted;
      }
    };
    eventTargetShim.defineEventAttribute(AbortSignal.prototype, "abort");
    function createAbortSignal() {
      let signal = Object.create(AbortSignal.prototype);
      return eventTargetShim.EventTarget.call(signal), abortedFlags.set(signal, !1), signal;
    }
    function abortSignal(signal) {
      abortedFlags.get(signal) === !1 && (abortedFlags.set(signal, !0), signal.dispatchEvent({ type: "abort" }));
    }
    var abortedFlags = /* @__PURE__ */ new WeakMap();
    Object.defineProperties(AbortSignal.prototype, {
      aborted: { enumerable: !0 }
    });
    typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol" && Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {
      configurable: !0,
      value: "AbortSignal"
    });
    var AbortController2 = class {
      /**
       * Initialize this controller.
       */
      constructor() {
        signals.set(this, createAbortSignal());
      }
      /**
       * Returns the `AbortSignal` object associated with this object.
       */
      get signal() {
        return getSignal(this);
      }
      /**
       * Abort and signal to any observers that the associated activity is to be aborted.
       */
      abort() {
        abortSignal(getSignal(this));
      }
    }, signals = /* @__PURE__ */ new WeakMap();
    function getSignal(controller) {
      let signal = signals.get(controller);
      if (signal == null)
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
      return signal;
    }
    Object.defineProperties(AbortController2.prototype, {
      signal: { enumerable: !0 },
      abort: { enumerable: !0 }
    });
    typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol" && Object.defineProperty(AbortController2.prototype, Symbol.toStringTag, {
      configurable: !0,
      value: "AbortController"
    });
    exports.AbortController = AbortController2;
    exports.AbortSignal = AbortSignal;
    exports.default = AbortController2;
    module2.exports = AbortController2;
    module2.exports.AbortController = module2.exports.default = AbortController2;
    module2.exports.AbortSignal = AbortSignal;
  }
});

// node_modules/mrmime/index.js
var require_mrmime = __commonJS({
  "node_modules/mrmime/index.js"(exports) {
    var mimes = {
      ez: "application/andrew-inset",
      aw: "application/applixware",
      atom: "application/atom+xml",
      atomcat: "application/atomcat+xml",
      atomdeleted: "application/atomdeleted+xml",
      atomsvc: "application/atomsvc+xml",
      dwd: "application/atsc-dwd+xml",
      held: "application/atsc-held+xml",
      rsat: "application/atsc-rsat+xml",
      bdoc: "application/bdoc",
      xcs: "application/calendar+xml",
      ccxml: "application/ccxml+xml",
      cdfx: "application/cdfx+xml",
      cdmia: "application/cdmi-capability",
      cdmic: "application/cdmi-container",
      cdmid: "application/cdmi-domain",
      cdmio: "application/cdmi-object",
      cdmiq: "application/cdmi-queue",
      cu: "application/cu-seeme",
      mpd: "application/dash+xml",
      davmount: "application/davmount+xml",
      dbk: "application/docbook+xml",
      dssc: "application/dssc+der",
      xdssc: "application/dssc+xml",
      es: "application/ecmascript",
      ecma: "application/ecmascript",
      emma: "application/emma+xml",
      emotionml: "application/emotionml+xml",
      epub: "application/epub+zip",
      exi: "application/exi",
      fdt: "application/fdt+xml",
      pfr: "application/font-tdpfr",
      geojson: "application/geo+json",
      gml: "application/gml+xml",
      gpx: "application/gpx+xml",
      gxf: "application/gxf",
      gz: "application/gzip",
      hjson: "application/hjson",
      stk: "application/hyperstudio",
      ink: "application/inkml+xml",
      inkml: "application/inkml+xml",
      ipfix: "application/ipfix",
      its: "application/its+xml",
      jar: "application/java-archive",
      war: "application/java-archive",
      ear: "application/java-archive",
      ser: "application/java-serialized-object",
      class: "application/java-vm",
      js: "application/javascript",
      mjs: "application/javascript",
      json: "application/json",
      map: "application/json",
      json5: "application/json5",
      jsonml: "application/jsonml+json",
      jsonld: "application/ld+json",
      lgr: "application/lgr+xml",
      lostxml: "application/lost+xml",
      hqx: "application/mac-binhex40",
      cpt: "application/mac-compactpro",
      mads: "application/mads+xml",
      webmanifest: "application/manifest+json",
      mrc: "application/marc",
      mrcx: "application/marcxml+xml",
      ma: "application/mathematica",
      nb: "application/mathematica",
      mb: "application/mathematica",
      mathml: "application/mathml+xml",
      mbox: "application/mbox",
      mscml: "application/mediaservercontrol+xml",
      metalink: "application/metalink+xml",
      meta4: "application/metalink4+xml",
      mets: "application/mets+xml",
      maei: "application/mmt-aei+xml",
      musd: "application/mmt-usd+xml",
      mods: "application/mods+xml",
      m21: "application/mp21",
      mp21: "application/mp21",
      mp4s: "application/mp4",
      m4p: "application/mp4",
      doc: "application/msword",
      dot: "application/msword",
      mxf: "application/mxf",
      nq: "application/n-quads",
      nt: "application/n-triples",
      cjs: "application/node",
      bin: "application/octet-stream",
      dms: "application/octet-stream",
      lrf: "application/octet-stream",
      mar: "application/octet-stream",
      so: "application/octet-stream",
      dist: "application/octet-stream",
      distz: "application/octet-stream",
      pkg: "application/octet-stream",
      bpk: "application/octet-stream",
      dump: "application/octet-stream",
      elc: "application/octet-stream",
      deploy: "application/octet-stream",
      exe: "application/octet-stream",
      dll: "application/octet-stream",
      deb: "application/octet-stream",
      dmg: "application/octet-stream",
      iso: "application/octet-stream",
      img: "application/octet-stream",
      msi: "application/octet-stream",
      msp: "application/octet-stream",
      msm: "application/octet-stream",
      buffer: "application/octet-stream",
      oda: "application/oda",
      opf: "application/oebps-package+xml",
      ogx: "application/ogg",
      omdoc: "application/omdoc+xml",
      onetoc: "application/onenote",
      onetoc2: "application/onenote",
      onetmp: "application/onenote",
      onepkg: "application/onenote",
      oxps: "application/oxps",
      relo: "application/p2p-overlay+xml",
      xer: "application/patch-ops-error+xml",
      pdf: "application/pdf",
      pgp: "application/pgp-encrypted",
      asc: "application/pgp-signature",
      sig: "application/pgp-signature",
      prf: "application/pics-rules",
      p10: "application/pkcs10",
      p7m: "application/pkcs7-mime",
      p7c: "application/pkcs7-mime",
      p7s: "application/pkcs7-signature",
      p8: "application/pkcs8",
      ac: "application/pkix-attr-cert",
      cer: "application/pkix-cert",
      crl: "application/pkix-crl",
      pkipath: "application/pkix-pkipath",
      pki: "application/pkixcmp",
      pls: "application/pls+xml",
      ai: "application/postscript",
      eps: "application/postscript",
      ps: "application/postscript",
      provx: "application/provenance+xml",
      cww: "application/prs.cww",
      pskcxml: "application/pskc+xml",
      raml: "application/raml+yaml",
      rdf: "application/rdf+xml",
      owl: "application/rdf+xml",
      rif: "application/reginfo+xml",
      rnc: "application/relax-ng-compact-syntax",
      rl: "application/resource-lists+xml",
      rld: "application/resource-lists-diff+xml",
      rs: "application/rls-services+xml",
      rapd: "application/route-apd+xml",
      sls: "application/route-s-tsid+xml",
      rusd: "application/route-usd+xml",
      gbr: "application/rpki-ghostbusters",
      mft: "application/rpki-manifest",
      roa: "application/rpki-roa",
      rsd: "application/rsd+xml",
      rss: "application/rss+xml",
      rtf: "application/rtf",
      sbml: "application/sbml+xml",
      scq: "application/scvp-cv-request",
      scs: "application/scvp-cv-response",
      spq: "application/scvp-vp-request",
      spp: "application/scvp-vp-response",
      sdp: "application/sdp",
      senmlx: "application/senml+xml",
      sensmlx: "application/sensml+xml",
      setpay: "application/set-payment-initiation",
      setreg: "application/set-registration-initiation",
      shf: "application/shf+xml",
      siv: "application/sieve",
      sieve: "application/sieve",
      smi: "application/smil+xml",
      smil: "application/smil+xml",
      rq: "application/sparql-query",
      srx: "application/sparql-results+xml",
      gram: "application/srgs",
      grxml: "application/srgs+xml",
      sru: "application/sru+xml",
      ssdl: "application/ssdl+xml",
      ssml: "application/ssml+xml",
      swidtag: "application/swid+xml",
      tei: "application/tei+xml",
      teicorpus: "application/tei+xml",
      tfi: "application/thraud+xml",
      tsd: "application/timestamped-data",
      toml: "application/toml",
      trig: "application/trig",
      ttml: "application/ttml+xml",
      ubj: "application/ubjson",
      rsheet: "application/urc-ressheet+xml",
      td: "application/urc-targetdesc+xml",
      vxml: "application/voicexml+xml",
      wasm: "application/wasm",
      wgt: "application/widget",
      hlp: "application/winhlp",
      wsdl: "application/wsdl+xml",
      wspolicy: "application/wspolicy+xml",
      xaml: "application/xaml+xml",
      xav: "application/xcap-att+xml",
      xca: "application/xcap-caps+xml",
      xdf: "application/xcap-diff+xml",
      xel: "application/xcap-el+xml",
      xns: "application/xcap-ns+xml",
      xenc: "application/xenc+xml",
      xhtml: "application/xhtml+xml",
      xht: "application/xhtml+xml",
      xlf: "application/xliff+xml",
      xml: "application/xml",
      xsl: "application/xml",
      xsd: "application/xml",
      rng: "application/xml",
      dtd: "application/xml-dtd",
      xop: "application/xop+xml",
      xpl: "application/xproc+xml",
      xslt: "application/xml",
      xspf: "application/xspf+xml",
      mxml: "application/xv+xml",
      xhvml: "application/xv+xml",
      xvml: "application/xv+xml",
      xvm: "application/xv+xml",
      yang: "application/yang",
      yin: "application/yin+xml",
      zip: "application/zip",
      "3gpp": "video/3gpp",
      adp: "audio/adpcm",
      amr: "audio/amr",
      au: "audio/basic",
      snd: "audio/basic",
      mid: "audio/midi",
      midi: "audio/midi",
      kar: "audio/midi",
      rmi: "audio/midi",
      mxmf: "audio/mobile-xmf",
      mp3: "audio/mpeg",
      m4a: "audio/mp4",
      mp4a: "audio/mp4",
      mpga: "audio/mpeg",
      mp2: "audio/mpeg",
      mp2a: "audio/mpeg",
      m2a: "audio/mpeg",
      m3a: "audio/mpeg",
      oga: "audio/ogg",
      ogg: "audio/ogg",
      spx: "audio/ogg",
      opus: "audio/ogg",
      s3m: "audio/s3m",
      sil: "audio/silk",
      wav: "audio/wav",
      weba: "audio/webm",
      xm: "audio/xm",
      ttc: "font/collection",
      otf: "font/otf",
      ttf: "font/ttf",
      woff: "font/woff",
      woff2: "font/woff2",
      exr: "image/aces",
      apng: "image/apng",
      avif: "image/avif",
      bmp: "image/bmp",
      cgm: "image/cgm",
      drle: "image/dicom-rle",
      emf: "image/emf",
      fits: "image/fits",
      g3: "image/g3fax",
      gif: "image/gif",
      heic: "image/heic",
      heics: "image/heic-sequence",
      heif: "image/heif",
      heifs: "image/heif-sequence",
      hej2: "image/hej2k",
      hsj2: "image/hsj2",
      ief: "image/ief",
      jls: "image/jls",
      jp2: "image/jp2",
      jpg2: "image/jp2",
      jpeg: "image/jpeg",
      jpg: "image/jpeg",
      jpe: "image/jpeg",
      jph: "image/jph",
      jhc: "image/jphc",
      jpm: "image/jpm",
      jpx: "image/jpx",
      jpf: "image/jpx",
      jxr: "image/jxr",
      jxra: "image/jxra",
      jxrs: "image/jxrs",
      jxs: "image/jxs",
      jxsc: "image/jxsc",
      jxsi: "image/jxsi",
      jxss: "image/jxss",
      ktx: "image/ktx",
      ktx2: "image/ktx2",
      png: "image/png",
      btif: "image/prs.btif",
      pti: "image/prs.pti",
      sgi: "image/sgi",
      svg: "image/svg+xml",
      svgz: "image/svg+xml",
      t38: "image/t38",
      tif: "image/tiff",
      tiff: "image/tiff",
      tfx: "image/tiff-fx",
      webp: "image/webp",
      wmf: "image/wmf",
      "disposition-notification": "message/disposition-notification",
      u8msg: "message/global",
      u8dsn: "message/global-delivery-status",
      u8mdn: "message/global-disposition-notification",
      u8hdr: "message/global-headers",
      eml: "message/rfc822",
      mime: "message/rfc822",
      "3mf": "model/3mf",
      gltf: "model/gltf+json",
      glb: "model/gltf-binary",
      igs: "model/iges",
      iges: "model/iges",
      msh: "model/mesh",
      mesh: "model/mesh",
      silo: "model/mesh",
      mtl: "model/mtl",
      obj: "model/obj",
      stpz: "model/step+zip",
      stpxz: "model/step-xml+zip",
      stl: "model/stl",
      wrl: "model/vrml",
      vrml: "model/vrml",
      x3db: "model/x3d+fastinfoset",
      x3dbz: "model/x3d+binary",
      x3dv: "model/x3d-vrml",
      x3dvz: "model/x3d+vrml",
      x3d: "model/x3d+xml",
      x3dz: "model/x3d+xml",
      appcache: "text/cache-manifest",
      manifest: "text/cache-manifest",
      ics: "text/calendar",
      ifb: "text/calendar",
      coffee: "text/coffeescript",
      litcoffee: "text/coffeescript",
      css: "text/css",
      csv: "text/csv",
      html: "text/html",
      htm: "text/html",
      shtml: "text/html",
      jade: "text/jade",
      jsx: "text/jsx",
      less: "text/less",
      markdown: "text/markdown",
      md: "text/markdown",
      mml: "text/mathml",
      mdx: "text/mdx",
      n3: "text/n3",
      txt: "text/plain",
      text: "text/plain",
      conf: "text/plain",
      def: "text/plain",
      list: "text/plain",
      log: "text/plain",
      in: "text/plain",
      ini: "text/plain",
      dsc: "text/prs.lines.tag",
      rtx: "text/richtext",
      sgml: "text/sgml",
      sgm: "text/sgml",
      shex: "text/shex",
      slim: "text/slim",
      slm: "text/slim",
      spdx: "text/spdx",
      stylus: "text/stylus",
      styl: "text/stylus",
      tsv: "text/tab-separated-values",
      t: "text/troff",
      tr: "text/troff",
      roff: "text/troff",
      man: "text/troff",
      me: "text/troff",
      ms: "text/troff",
      ttl: "text/turtle",
      uri: "text/uri-list",
      uris: "text/uri-list",
      urls: "text/uri-list",
      vcard: "text/vcard",
      vtt: "text/vtt",
      yaml: "text/yaml",
      yml: "text/yaml",
      "3gp": "video/3gpp",
      "3g2": "video/3gpp2",
      h261: "video/h261",
      h263: "video/h263",
      h264: "video/h264",
      m4s: "video/iso.segment",
      jpgv: "video/jpeg",
      jpgm: "image/jpm",
      mj2: "video/mj2",
      mjp2: "video/mj2",
      ts: "video/mp2t",
      mp4: "video/mp4",
      mp4v: "video/mp4",
      mpg4: "video/mp4",
      mpeg: "video/mpeg",
      mpg: "video/mpeg",
      mpe: "video/mpeg",
      m1v: "video/mpeg",
      m2v: "video/mpeg",
      ogv: "video/ogg",
      qt: "video/quicktime",
      mov: "video/quicktime",
      webm: "video/webm"
    };
    function lookup(extn) {
      let tmp = ("" + extn).trim().toLowerCase(), idx = tmp.lastIndexOf(".");
      return mimes[~idx ? tmp.substring(++idx) : tmp];
    }
    exports.lookup = lookup;
    exports.mimes = mimes;
  }
});

// node_modules/data-uri-to-buffer/dist/src/index.js
var require_src = __commonJS({
  "node_modules/data-uri-to-buffer/dist/src/index.js"(exports, module2) {
    "use strict";
    function dataUriToBuffer2(uri) {
      if (!/^data:/i.test(uri))
        throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
      uri = uri.replace(/\r?\n/g, "");
      let firstComma = uri.indexOf(",");
      if (firstComma === -1 || firstComma <= 4)
        throw new TypeError("malformed data: URI");
      let meta = uri.substring(5, firstComma).split(";"), charset = "", base64 = !1, type = meta[0] || "text/plain", typeFull = type;
      for (let i2 = 1; i2 < meta.length; i2++)
        meta[i2] === "base64" ? base64 = !0 : (typeFull += `;${meta[i2]}`, meta[i2].indexOf("charset=") === 0 && (charset = meta[i2].substring(8)));
      !meta[0] && !charset.length && (typeFull += ";charset=US-ASCII", charset = "US-ASCII");
      let encoding = base64 ? "base64" : "ascii", data = unescape(uri.substring(firstComma + 1)), buffer = Buffer.from(data, encoding);
      return buffer.type = type, buffer.typeFull = typeFull, buffer.charset = charset, buffer;
    }
    module2.exports = dataUriToBuffer2;
  }
});

// node_modules/web-encoding/src/lib.js
var require_lib = __commonJS({
  "node_modules/web-encoding/src/lib.js"(exports) {
    "use strict";
    exports.TextEncoder = typeof TextEncoder < "u" ? TextEncoder : require("util").TextEncoder;
    exports.TextDecoder = typeof TextDecoder < "u" ? TextDecoder : require("util").TextDecoder;
  }
});

// node_modules/web-streams-polyfill/dist/ponyfill.js
var require_ponyfill = __commonJS({
  "node_modules/web-streams-polyfill/dist/ponyfill.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports == "object" && typeof module2 < "u" ? factory(exports) : typeof define == "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis < "u" ? globalThis : global2 || self, factory(global2.WebStreamsPolyfill = {}));
    })(exports, function(exports2) {
      "use strict";
      var SymbolPolyfill = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol : function(description) {
        return "Symbol(" + description + ")";
      };
      function noop2() {
      }
      function getGlobals() {
        if (typeof self < "u")
          return self;
        if (typeof window < "u")
          return window;
        if (typeof global < "u")
          return global;
      }
      var globals = getGlobals();
      function typeIsObject(x2) {
        return typeof x2 == "object" && x2 !== null || typeof x2 == "function";
      }
      var rethrowAssertionErrorRejection = noop2, originalPromise = Promise, originalPromiseThen = Promise.prototype.then, originalPromiseResolve = Promise.resolve.bind(originalPromise), originalPromiseReject = Promise.reject.bind(originalPromise);
      function newPromise(executor) {
        return new originalPromise(executor);
      }
      function promiseResolvedWith(value) {
        return originalPromiseResolve(value);
      }
      function promiseRejectedWith(reason) {
        return originalPromiseReject(reason);
      }
      function PerformPromiseThen(promise, onFulfilled, onRejected) {
        return originalPromiseThen.call(promise, onFulfilled, onRejected);
      }
      function uponPromise(promise, onFulfilled, onRejected) {
        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
      }
      function uponFulfillment(promise, onFulfilled) {
        uponPromise(promise, onFulfilled);
      }
      function uponRejection(promise, onRejected) {
        uponPromise(promise, void 0, onRejected);
      }
      function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
      }
      function setPromiseIsHandledToTrue(promise) {
        PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
      }
      var queueMicrotask = function() {
        var globalQueueMicrotask = globals && globals.queueMicrotask;
        if (typeof globalQueueMicrotask == "function")
          return globalQueueMicrotask;
        var resolvedPromise = promiseResolvedWith(void 0);
        return function(fn) {
          return PerformPromiseThen(resolvedPromise, fn);
        };
      }();
      function reflectCall(F2, V, args) {
        if (typeof F2 != "function")
          throw new TypeError("Argument is not a function");
        return Function.prototype.apply.call(F2, V, args);
      }
      function promiseCall(F2, V, args) {
        try {
          return promiseResolvedWith(reflectCall(F2, V, args));
        } catch (value) {
          return promiseRejectedWith(value);
        }
      }
      var QUEUE_MAX_ARRAY_SIZE = 16384, SimpleQueue = (
        /** @class */
        function() {
          function SimpleQueue2() {
            this._cursor = 0, this._size = 0, this._front = {
              _elements: [],
              _next: void 0
            }, this._back = this._front, this._cursor = 0, this._size = 0;
          }
          return Object.defineProperty(SimpleQueue2.prototype, "length", {
            get: function() {
              return this._size;
            },
            enumerable: !1,
            configurable: !0
          }), SimpleQueue2.prototype.push = function(element) {
            var oldBack = this._back, newBack = oldBack;
            oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1 && (newBack = {
              _elements: [],
              _next: void 0
            }), oldBack._elements.push(element), newBack !== oldBack && (this._back = newBack, oldBack._next = newBack), ++this._size;
          }, SimpleQueue2.prototype.shift = function() {
            var oldFront = this._front, newFront = oldFront, oldCursor = this._cursor, newCursor = oldCursor + 1, elements = oldFront._elements, element = elements[oldCursor];
            return newCursor === QUEUE_MAX_ARRAY_SIZE && (newFront = oldFront._next, newCursor = 0), --this._size, this._cursor = newCursor, oldFront !== newFront && (this._front = newFront), elements[oldCursor] = void 0, element;
          }, SimpleQueue2.prototype.forEach = function(callback) {
            for (var i2 = this._cursor, node = this._front, elements = node._elements; (i2 !== elements.length || node._next !== void 0) && !(i2 === elements.length && (node = node._next, elements = node._elements, i2 = 0, elements.length === 0)); )
              callback(elements[i2]), ++i2;
          }, SimpleQueue2.prototype.peek = function() {
            var front = this._front, cursor = this._cursor;
            return front._elements[cursor];
          }, SimpleQueue2;
        }()
      );
      function ReadableStreamReaderGenericInitialize(reader, stream) {
        reader._ownerReadableStream = stream, stream._reader = reader, stream._state === "readable" ? defaultReaderClosedPromiseInitialize(reader) : stream._state === "closed" ? defaultReaderClosedPromiseInitializeAsResolved(reader) : defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
      }
      function ReadableStreamReaderGenericCancel(reader, reason) {
        var stream = reader._ownerReadableStream;
        return ReadableStreamCancel(stream, reason);
      }
      function ReadableStreamReaderGenericRelease(reader) {
        reader._ownerReadableStream._state === "readable" ? defaultReaderClosedPromiseReject(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : defaultReaderClosedPromiseResetToRejected(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), reader._ownerReadableStream._reader = void 0, reader._ownerReadableStream = void 0;
      }
      function readerLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released reader");
      }
      function defaultReaderClosedPromiseInitialize(reader) {
        reader._closedPromise = newPromise(function(resolve, reject) {
          reader._closedPromise_resolve = resolve, reader._closedPromise_reject = reject;
        });
      }
      function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
        defaultReaderClosedPromiseInitialize(reader), defaultReaderClosedPromiseReject(reader, reason);
      }
      function defaultReaderClosedPromiseInitializeAsResolved(reader) {
        defaultReaderClosedPromiseInitialize(reader), defaultReaderClosedPromiseResolve(reader);
      }
      function defaultReaderClosedPromiseReject(reader, reason) {
        reader._closedPromise_reject !== void 0 && (setPromiseIsHandledToTrue(reader._closedPromise), reader._closedPromise_reject(reason), reader._closedPromise_resolve = void 0, reader._closedPromise_reject = void 0);
      }
      function defaultReaderClosedPromiseResetToRejected(reader, reason) {
        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
      }
      function defaultReaderClosedPromiseResolve(reader) {
        reader._closedPromise_resolve !== void 0 && (reader._closedPromise_resolve(void 0), reader._closedPromise_resolve = void 0, reader._closedPromise_reject = void 0);
      }
      var AbortSteps = SymbolPolyfill("[[AbortSteps]]"), ErrorSteps = SymbolPolyfill("[[ErrorSteps]]"), CancelSteps = SymbolPolyfill("[[CancelSteps]]"), PullSteps = SymbolPolyfill("[[PullSteps]]"), NumberIsFinite = Number.isFinite || function(x2) {
        return typeof x2 == "number" && isFinite(x2);
      }, MathTrunc = Math.trunc || function(v) {
        return v < 0 ? Math.ceil(v) : Math.floor(v);
      };
      function isDictionary(x2) {
        return typeof x2 == "object" || typeof x2 == "function";
      }
      function assertDictionary(obj, context) {
        if (obj !== void 0 && !isDictionary(obj))
          throw new TypeError(context + " is not an object.");
      }
      function assertFunction(x2, context) {
        if (typeof x2 != "function")
          throw new TypeError(context + " is not a function.");
      }
      function isObject2(x2) {
        return typeof x2 == "object" && x2 !== null || typeof x2 == "function";
      }
      function assertObject(x2, context) {
        if (!isObject2(x2))
          throw new TypeError(context + " is not an object.");
      }
      function assertRequiredArgument(x2, position, context) {
        if (x2 === void 0)
          throw new TypeError("Parameter " + position + " is required in '" + context + "'.");
      }
      function assertRequiredField(x2, field, context) {
        if (x2 === void 0)
          throw new TypeError(field + " is required in '" + context + "'.");
      }
      function convertUnrestrictedDouble(value) {
        return Number(value);
      }
      function censorNegativeZero(x2) {
        return x2 === 0 ? 0 : x2;
      }
      function integerPart(x2) {
        return censorNegativeZero(MathTrunc(x2));
      }
      function convertUnsignedLongLongWithEnforceRange(value, context) {
        var lowerBound = 0, upperBound = Number.MAX_SAFE_INTEGER, x2 = Number(value);
        if (x2 = censorNegativeZero(x2), !NumberIsFinite(x2))
          throw new TypeError(context + " is not a finite number");
        if (x2 = integerPart(x2), x2 < lowerBound || x2 > upperBound)
          throw new TypeError(context + " is outside the accepted range of " + lowerBound + " to " + upperBound + ", inclusive");
        return !NumberIsFinite(x2) || x2 === 0 ? 0 : x2;
      }
      function assertReadableStream(x2, context) {
        if (!IsReadableStream(x2))
          throw new TypeError(context + " is not a ReadableStream.");
      }
      function AcquireReadableStreamDefaultReader(stream) {
        return new ReadableStreamDefaultReader(stream);
      }
      function ReadableStreamAddReadRequest(stream, readRequest) {
        stream._reader._readRequests.push(readRequest);
      }
      function ReadableStreamFulfillReadRequest(stream, chunk, done) {
        var reader = stream._reader, readRequest = reader._readRequests.shift();
        done ? readRequest._closeSteps() : readRequest._chunkSteps(chunk);
      }
      function ReadableStreamGetNumReadRequests(stream) {
        return stream._reader._readRequests.length;
      }
      function ReadableStreamHasDefaultReader(stream) {
        var reader = stream._reader;
        return !(reader === void 0 || !IsReadableStreamDefaultReader(reader));
      }
      var ReadableStreamDefaultReader = (
        /** @class */
        function() {
          function ReadableStreamDefaultReader2(stream) {
            if (assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader"), assertReadableStream(stream, "First parameter"), IsReadableStreamLocked(stream))
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            ReadableStreamReaderGenericInitialize(this, stream), this._readRequests = new SimpleQueue();
          }
          return Object.defineProperty(ReadableStreamDefaultReader2.prototype, "closed", {
            /**
             * Returns a promise that will be fulfilled when the stream becomes closed,
             * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
             */
            get: function() {
              return IsReadableStreamDefaultReader(this) ? this._closedPromise : promiseRejectedWith(defaultReaderBrandCheckException("closed"));
            },
            enumerable: !1,
            configurable: !0
          }), ReadableStreamDefaultReader2.prototype.cancel = function(reason) {
            return reason === void 0 && (reason = void 0), IsReadableStreamDefaultReader(this) ? this._ownerReadableStream === void 0 ? promiseRejectedWith(readerLockException("cancel")) : ReadableStreamReaderGenericCancel(this, reason) : promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
          }, ReadableStreamDefaultReader2.prototype.read = function() {
            if (!IsReadableStreamDefaultReader(this))
              return promiseRejectedWith(defaultReaderBrandCheckException("read"));
            if (this._ownerReadableStream === void 0)
              return promiseRejectedWith(readerLockException("read from"));
            var resolvePromise, rejectPromise, promise = newPromise(function(resolve, reject) {
              resolvePromise = resolve, rejectPromise = reject;
            }), readRequest = {
              _chunkSteps: function(chunk) {
                return resolvePromise({ value: chunk, done: !1 });
              },
              _closeSteps: function() {
                return resolvePromise({ value: void 0, done: !0 });
              },
              _errorSteps: function(e2) {
                return rejectPromise(e2);
              }
            };
            return ReadableStreamDefaultReaderRead(this, readRequest), promise;
          }, ReadableStreamDefaultReader2.prototype.releaseLock = function() {
            if (!IsReadableStreamDefaultReader(this))
              throw defaultReaderBrandCheckException("releaseLock");
            if (this._ownerReadableStream !== void 0) {
              if (this._readRequests.length > 0)
                throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
              ReadableStreamReaderGenericRelease(this);
            }
          }, ReadableStreamDefaultReader2;
        }()
      );
      Object.defineProperties(ReadableStreamDefaultReader.prototype, {
        cancel: { enumerable: !0 },
        read: { enumerable: !0 },
        releaseLock: { enumerable: !0 },
        closed: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamDefaultReader",
        configurable: !0
      });
      function IsReadableStreamDefaultReader(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_readRequests") ? !1 : x2 instanceof ReadableStreamDefaultReader;
      }
      function ReadableStreamDefaultReaderRead(reader, readRequest) {
        var stream = reader._ownerReadableStream;
        stream._disturbed = !0, stream._state === "closed" ? readRequest._closeSteps() : stream._state === "errored" ? readRequest._errorSteps(stream._storedError) : stream._readableStreamController[PullSteps](readRequest);
      }
      function defaultReaderBrandCheckException(name) {
        return new TypeError("ReadableStreamDefaultReader.prototype." + name + " can only be used on a ReadableStreamDefaultReader");
      }
      var _a4, AsyncIteratorPrototype;
      typeof SymbolPolyfill.asyncIterator == "symbol" && (AsyncIteratorPrototype = (_a4 = {}, // 25.1.3.1 %AsyncIteratorPrototype% [ @@asyncIterator ] ( )
      // https://tc39.github.io/ecma262/#sec-asynciteratorprototype-asynciterator
      _a4[SymbolPolyfill.asyncIterator] = function() {
        return this;
      }, _a4), Object.defineProperty(AsyncIteratorPrototype, SymbolPolyfill.asyncIterator, { enumerable: !1 }));
      var ReadableStreamAsyncIteratorImpl = (
        /** @class */
        function() {
          function ReadableStreamAsyncIteratorImpl2(reader, preventCancel) {
            this._ongoingPromise = void 0, this._isFinished = !1, this._reader = reader, this._preventCancel = preventCancel;
          }
          return ReadableStreamAsyncIteratorImpl2.prototype.next = function() {
            var _this = this, nextSteps = function() {
              return _this._nextSteps();
            };
            return this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps(), this._ongoingPromise;
          }, ReadableStreamAsyncIteratorImpl2.prototype.return = function(value) {
            var _this = this, returnSteps = function() {
              return _this._returnSteps(value);
            };
            return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
          }, ReadableStreamAsyncIteratorImpl2.prototype._nextSteps = function() {
            var _this = this;
            if (this._isFinished)
              return Promise.resolve({ value: void 0, done: !0 });
            var reader = this._reader;
            if (reader._ownerReadableStream === void 0)
              return promiseRejectedWith(readerLockException("iterate"));
            var resolvePromise, rejectPromise, promise = newPromise(function(resolve, reject) {
              resolvePromise = resolve, rejectPromise = reject;
            }), readRequest = {
              _chunkSteps: function(chunk) {
                _this._ongoingPromise = void 0, queueMicrotask(function() {
                  return resolvePromise({ value: chunk, done: !1 });
                });
              },
              _closeSteps: function() {
                _this._ongoingPromise = void 0, _this._isFinished = !0, ReadableStreamReaderGenericRelease(reader), resolvePromise({ value: void 0, done: !0 });
              },
              _errorSteps: function(reason) {
                _this._ongoingPromise = void 0, _this._isFinished = !0, ReadableStreamReaderGenericRelease(reader), rejectPromise(reason);
              }
            };
            return ReadableStreamDefaultReaderRead(reader, readRequest), promise;
          }, ReadableStreamAsyncIteratorImpl2.prototype._returnSteps = function(value) {
            if (this._isFinished)
              return Promise.resolve({ value, done: !0 });
            this._isFinished = !0;
            var reader = this._reader;
            if (reader._ownerReadableStream === void 0)
              return promiseRejectedWith(readerLockException("finish iterating"));
            if (!this._preventCancel) {
              var result = ReadableStreamReaderGenericCancel(reader, value);
              return ReadableStreamReaderGenericRelease(reader), transformPromiseWith(result, function() {
                return { value, done: !0 };
              });
            }
            return ReadableStreamReaderGenericRelease(reader), promiseResolvedWith({ value, done: !0 });
          }, ReadableStreamAsyncIteratorImpl2;
        }()
      ), ReadableStreamAsyncIteratorPrototype = {
        next: function() {
          return IsReadableStreamAsyncIterator(this) ? this._asyncIteratorImpl.next() : promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
        },
        return: function(value) {
          return IsReadableStreamAsyncIterator(this) ? this._asyncIteratorImpl.return(value) : promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
        }
      };
      AsyncIteratorPrototype !== void 0 && Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
      function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
        var reader = AcquireReadableStreamDefaultReader(stream), impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel), iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
        return iterator._asyncIteratorImpl = impl, iterator;
      }
      function IsReadableStreamAsyncIterator(x2) {
        if (!typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_asyncIteratorImpl"))
          return !1;
        try {
          return x2._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
        } catch {
          return !1;
        }
      }
      function streamAsyncIteratorBrandCheckException(name) {
        return new TypeError("ReadableStreamAsyncIterator." + name + " can only be used on a ReadableSteamAsyncIterator");
      }
      var NumberIsNaN = Number.isNaN || function(x2) {
        return x2 !== x2;
      };
      function CreateArrayFromList(elements) {
        return elements.slice();
      }
      function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
      }
      function TransferArrayBuffer(O) {
        return O;
      }
      function IsDetachedBuffer(O) {
        return !1;
      }
      function ArrayBufferSlice(buffer, begin, end) {
        if (buffer.slice)
          return buffer.slice(begin, end);
        var length = end - begin, slice = new ArrayBuffer(length);
        return CopyDataBlockBytes(slice, 0, buffer, begin, length), slice;
      }
      function IsNonNegativeNumber(v) {
        return !(typeof v != "number" || NumberIsNaN(v) || v < 0);
      }
      function CloneAsUint8Array(O) {
        var buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
        return new Uint8Array(buffer);
      }
      function DequeueValue(container) {
        var pair = container._queue.shift();
        return container._queueTotalSize -= pair.size, container._queueTotalSize < 0 && (container._queueTotalSize = 0), pair.value;
      }
      function EnqueueValueWithSize(container, value, size) {
        if (!IsNonNegativeNumber(size) || size === 1 / 0)
          throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
        container._queue.push({ value, size }), container._queueTotalSize += size;
      }
      function PeekQueueValue(container) {
        var pair = container._queue.peek();
        return pair.value;
      }
      function ResetQueue(container) {
        container._queue = new SimpleQueue(), container._queueTotalSize = 0;
      }
      var ReadableStreamBYOBRequest = (
        /** @class */
        function() {
          function ReadableStreamBYOBRequest2() {
            throw new TypeError("Illegal constructor");
          }
          return Object.defineProperty(ReadableStreamBYOBRequest2.prototype, "view", {
            /**
             * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
             */
            get: function() {
              if (!IsReadableStreamBYOBRequest(this))
                throw byobRequestBrandCheckException("view");
              return this._view;
            },
            enumerable: !1,
            configurable: !0
          }), ReadableStreamBYOBRequest2.prototype.respond = function(bytesWritten) {
            if (!IsReadableStreamBYOBRequest(this))
              throw byobRequestBrandCheckException("respond");
            if (assertRequiredArgument(bytesWritten, 1, "respond"), bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter"), this._associatedReadableByteStreamController === void 0)
              throw new TypeError("This BYOB request has been invalidated");
            IsDetachedBuffer(this._view.buffer), ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
          }, ReadableStreamBYOBRequest2.prototype.respondWithNewView = function(view) {
            if (!IsReadableStreamBYOBRequest(this))
              throw byobRequestBrandCheckException("respondWithNewView");
            if (assertRequiredArgument(view, 1, "respondWithNewView"), !ArrayBuffer.isView(view))
              throw new TypeError("You can only respond with array buffer views");
            if (this._associatedReadableByteStreamController === void 0)
              throw new TypeError("This BYOB request has been invalidated");
            IsDetachedBuffer(view.buffer), ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
          }, ReadableStreamBYOBRequest2;
        }()
      );
      Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
        respond: { enumerable: !0 },
        respondWithNewView: { enumerable: !0 },
        view: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamBYOBRequest",
        configurable: !0
      });
      var ReadableByteStreamController = (
        /** @class */
        function() {
          function ReadableByteStreamController2() {
            throw new TypeError("Illegal constructor");
          }
          return Object.defineProperty(ReadableByteStreamController2.prototype, "byobRequest", {
            /**
             * Returns the current BYOB pull request, or `null` if there isn't one.
             */
            get: function() {
              if (!IsReadableByteStreamController(this))
                throw byteStreamControllerBrandCheckException("byobRequest");
              return ReadableByteStreamControllerGetBYOBRequest(this);
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(ReadableByteStreamController2.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
             * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
             */
            get: function() {
              if (!IsReadableByteStreamController(this))
                throw byteStreamControllerBrandCheckException("desiredSize");
              return ReadableByteStreamControllerGetDesiredSize(this);
            },
            enumerable: !1,
            configurable: !0
          }), ReadableByteStreamController2.prototype.close = function() {
            if (!IsReadableByteStreamController(this))
              throw byteStreamControllerBrandCheckException("close");
            if (this._closeRequested)
              throw new TypeError("The stream has already been closed; do not close it again!");
            var state = this._controlledReadableByteStream._state;
            if (state !== "readable")
              throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be closed");
            ReadableByteStreamControllerClose(this);
          }, ReadableByteStreamController2.prototype.enqueue = function(chunk) {
            if (!IsReadableByteStreamController(this))
              throw byteStreamControllerBrandCheckException("enqueue");
            if (assertRequiredArgument(chunk, 1, "enqueue"), !ArrayBuffer.isView(chunk))
              throw new TypeError("chunk must be an array buffer view");
            if (chunk.byteLength === 0)
              throw new TypeError("chunk must have non-zero byteLength");
            if (chunk.buffer.byteLength === 0)
              throw new TypeError("chunk's buffer must have non-zero byteLength");
            if (this._closeRequested)
              throw new TypeError("stream is closed or draining");
            var state = this._controlledReadableByteStream._state;
            if (state !== "readable")
              throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be enqueued to");
            ReadableByteStreamControllerEnqueue(this, chunk);
          }, ReadableByteStreamController2.prototype.error = function(e2) {
            if (e2 === void 0 && (e2 = void 0), !IsReadableByteStreamController(this))
              throw byteStreamControllerBrandCheckException("error");
            ReadableByteStreamControllerError(this, e2);
          }, ReadableByteStreamController2.prototype[CancelSteps] = function(reason) {
            ReadableByteStreamControllerClearPendingPullIntos(this), ResetQueue(this);
            var result = this._cancelAlgorithm(reason);
            return ReadableByteStreamControllerClearAlgorithms(this), result;
          }, ReadableByteStreamController2.prototype[PullSteps] = function(readRequest) {
            var stream = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) {
              var entry2 = this._queue.shift();
              this._queueTotalSize -= entry2.byteLength, ReadableByteStreamControllerHandleQueueDrain(this);
              var view = new Uint8Array(entry2.buffer, entry2.byteOffset, entry2.byteLength);
              readRequest._chunkSteps(view);
              return;
            }
            var autoAllocateChunkSize = this._autoAllocateChunkSize;
            if (autoAllocateChunkSize !== void 0) {
              var buffer = void 0;
              try {
                buffer = new ArrayBuffer(autoAllocateChunkSize);
              } catch (bufferE) {
                readRequest._errorSteps(bufferE);
                return;
              }
              var pullIntoDescriptor = {
                buffer,
                bufferByteLength: autoAllocateChunkSize,
                byteOffset: 0,
                byteLength: autoAllocateChunkSize,
                bytesFilled: 0,
                elementSize: 1,
                viewConstructor: Uint8Array,
                readerType: "default"
              };
              this._pendingPullIntos.push(pullIntoDescriptor);
            }
            ReadableStreamAddReadRequest(stream, readRequest), ReadableByteStreamControllerCallPullIfNeeded(this);
          }, ReadableByteStreamController2;
        }()
      );
      Object.defineProperties(ReadableByteStreamController.prototype, {
        close: { enumerable: !0 },
        enqueue: { enumerable: !0 },
        error: { enumerable: !0 },
        byobRequest: { enumerable: !0 },
        desiredSize: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableByteStreamController",
        configurable: !0
      });
      function IsReadableByteStreamController(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_controlledReadableByteStream") ? !1 : x2 instanceof ReadableByteStreamController;
      }
      function IsReadableStreamBYOBRequest(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_associatedReadableByteStreamController") ? !1 : x2 instanceof ReadableStreamBYOBRequest;
      }
      function ReadableByteStreamControllerCallPullIfNeeded(controller) {
        var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
        if (shouldPull) {
          if (controller._pulling) {
            controller._pullAgain = !0;
            return;
          }
          controller._pulling = !0;
          var pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, function() {
            controller._pulling = !1, controller._pullAgain && (controller._pullAgain = !1, ReadableByteStreamControllerCallPullIfNeeded(controller));
          }, function(e2) {
            ReadableByteStreamControllerError(controller, e2);
          });
        }
      }
      function ReadableByteStreamControllerClearPendingPullIntos(controller) {
        ReadableByteStreamControllerInvalidateBYOBRequest(controller), controller._pendingPullIntos = new SimpleQueue();
      }
      function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
        var done = !1;
        stream._state === "closed" && (done = !0);
        var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        pullIntoDescriptor.readerType === "default" ? ReadableStreamFulfillReadRequest(stream, filledView, done) : ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
      }
      function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
        var bytesFilled = pullIntoDescriptor.bytesFilled, elementSize = pullIntoDescriptor.elementSize;
        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
      }
      function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
        controller._queue.push({ buffer, byteOffset, byteLength }), controller._queueTotalSize += byteLength;
      }
      function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
        var elementSize = pullIntoDescriptor.elementSize, currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize, maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled), maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy, maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize, totalBytesToCopyRemaining = maxBytesToCopy, ready = !1;
        maxAlignedBytes > currentAlignedBytes && (totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled, ready = !0);
        for (var queue = controller._queue; totalBytesToCopyRemaining > 0; ) {
          var headOfQueue = queue.peek(), bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength), destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy), headOfQueue.byteLength === bytesToCopy ? queue.shift() : (headOfQueue.byteOffset += bytesToCopy, headOfQueue.byteLength -= bytesToCopy), controller._queueTotalSize -= bytesToCopy, ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor), totalBytesToCopyRemaining -= bytesToCopy;
        }
        return ready;
      }
      function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
        pullIntoDescriptor.bytesFilled += size;
      }
      function ReadableByteStreamControllerHandleQueueDrain(controller) {
        controller._queueTotalSize === 0 && controller._closeRequested ? (ReadableByteStreamControllerClearAlgorithms(controller), ReadableStreamClose(controller._controlledReadableByteStream)) : ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
        controller._byobRequest !== null && (controller._byobRequest._associatedReadableByteStreamController = void 0, controller._byobRequest._view = null, controller._byobRequest = null);
      }
      function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
        for (; controller._pendingPullIntos.length > 0; ) {
          if (controller._queueTotalSize === 0)
            return;
          var pullIntoDescriptor = controller._pendingPullIntos.peek();
          ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) && (ReadableByteStreamControllerShiftPendingPullInto(controller), ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor));
        }
      }
      function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
        var stream = controller._controlledReadableByteStream, elementSize = 1;
        view.constructor !== DataView && (elementSize = view.constructor.BYTES_PER_ELEMENT);
        var ctor = view.constructor, buffer = view.buffer, pullIntoDescriptor = {
          buffer,
          bufferByteLength: buffer.byteLength,
          byteOffset: view.byteOffset,
          byteLength: view.byteLength,
          bytesFilled: 0,
          elementSize,
          viewConstructor: ctor,
          readerType: "byob"
        };
        if (controller._pendingPullIntos.length > 0) {
          controller._pendingPullIntos.push(pullIntoDescriptor), ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          return;
        }
        if (stream._state === "closed") {
          var emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
          readIntoRequest._closeSteps(emptyView);
          return;
        }
        if (controller._queueTotalSize > 0) {
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
            ReadableByteStreamControllerHandleQueueDrain(controller), readIntoRequest._chunkSteps(filledView);
            return;
          }
          if (controller._closeRequested) {
            var e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e2), readIntoRequest._errorSteps(e2);
            return;
          }
        }
        controller._pendingPullIntos.push(pullIntoDescriptor), ReadableStreamAddReadIntoRequest(stream, readIntoRequest), ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
        var stream = controller._controlledReadableByteStream;
        if (ReadableStreamHasBYOBReader(stream))
          for (; ReadableStreamGetNumReadIntoRequests(stream) > 0; ) {
            var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
          }
      }
      function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
        if (ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor), !(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize)) {
          ReadableByteStreamControllerShiftPendingPullInto(controller);
          var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
          if (remainderSize > 0) {
            var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled, remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
          }
          pullIntoDescriptor.bytesFilled -= remainderSize, ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor), ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        }
      }
      function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
        var firstDescriptor = controller._pendingPullIntos.peek();
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        var state = controller._controlledReadableByteStream._state;
        state === "closed" ? ReadableByteStreamControllerRespondInClosedState(controller) : ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor), ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerShiftPendingPullInto(controller) {
        var descriptor = controller._pendingPullIntos.shift();
        return descriptor;
      }
      function ReadableByteStreamControllerShouldCallPull(controller) {
        var stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable" || controller._closeRequested || !controller._started)
          return !1;
        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0 || ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0)
          return !0;
        var desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
        return desiredSize > 0;
      }
      function ReadableByteStreamControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0, controller._cancelAlgorithm = void 0;
      }
      function ReadableByteStreamControllerClose(controller) {
        var stream = controller._controlledReadableByteStream;
        if (!(controller._closeRequested || stream._state !== "readable")) {
          if (controller._queueTotalSize > 0) {
            controller._closeRequested = !0;
            return;
          }
          if (controller._pendingPullIntos.length > 0) {
            var firstPendingPullInto = controller._pendingPullIntos.peek();
            if (firstPendingPullInto.bytesFilled > 0) {
              var e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              throw ReadableByteStreamControllerError(controller, e2), e2;
            }
          }
          ReadableByteStreamControllerClearAlgorithms(controller), ReadableStreamClose(stream);
        }
      }
      function ReadableByteStreamControllerEnqueue(controller, chunk) {
        var stream = controller._controlledReadableByteStream;
        if (!(controller._closeRequested || stream._state !== "readable")) {
          var buffer = chunk.buffer, byteOffset = chunk.byteOffset, byteLength = chunk.byteLength, transferredBuffer = buffer;
          if (controller._pendingPullIntos.length > 0) {
            var firstPendingPullInto = controller._pendingPullIntos.peek();
            IsDetachedBuffer(firstPendingPullInto.buffer), firstPendingPullInto.buffer = firstPendingPullInto.buffer;
          }
          if (ReadableByteStreamControllerInvalidateBYOBRequest(controller), ReadableStreamHasDefaultReader(stream))
            if (ReadableStreamGetNumReadRequests(stream) === 0)
              ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            else {
              controller._pendingPullIntos.length > 0 && ReadableByteStreamControllerShiftPendingPullInto(controller);
              var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
              ReadableStreamFulfillReadRequest(stream, transferredView, !1);
            }
          else
            ReadableStreamHasBYOBReader(stream) ? (ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength), ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller)) : ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
      }
      function ReadableByteStreamControllerError(controller, e2) {
        var stream = controller._controlledReadableByteStream;
        stream._state === "readable" && (ReadableByteStreamControllerClearPendingPullIntos(controller), ResetQueue(controller), ReadableByteStreamControllerClearAlgorithms(controller), ReadableStreamError(stream, e2));
      }
      function ReadableByteStreamControllerGetBYOBRequest(controller) {
        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
          var firstDescriptor = controller._pendingPullIntos.peek(), view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled), byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
          SetUpReadableStreamBYOBRequest(byobRequest, controller, view), controller._byobRequest = byobRequest;
        }
        return controller._byobRequest;
      }
      function ReadableByteStreamControllerGetDesiredSize(controller) {
        var state = controller._controlledReadableByteStream._state;
        return state === "errored" ? null : state === "closed" ? 0 : controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableByteStreamControllerRespond(controller, bytesWritten) {
        var firstDescriptor = controller._pendingPullIntos.peek(), state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (bytesWritten !== 0)
            throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
        } else {
          if (bytesWritten === 0)
            throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
          if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength)
            throw new RangeError("bytesWritten out of range");
        }
        firstDescriptor.buffer = firstDescriptor.buffer, ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
      }
      function ReadableByteStreamControllerRespondWithNewView(controller, view) {
        var firstDescriptor = controller._pendingPullIntos.peek(), state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (view.byteLength !== 0)
            throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
        } else if (view.byteLength === 0)
          throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset)
          throw new RangeError("The region specified by view does not match byobRequest");
        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength)
          throw new RangeError("The buffer of view has different capacity than byobRequest");
        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength)
          throw new RangeError("The region specified by view is larger than byobRequest");
        var viewByteLength = view.byteLength;
        firstDescriptor.buffer = view.buffer, ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
      }
      function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
        controller._controlledReadableByteStream = stream, controller._pullAgain = !1, controller._pulling = !1, controller._byobRequest = null, controller._queue = controller._queueTotalSize = void 0, ResetQueue(controller), controller._closeRequested = !1, controller._started = !1, controller._strategyHWM = highWaterMark, controller._pullAlgorithm = pullAlgorithm, controller._cancelAlgorithm = cancelAlgorithm, controller._autoAllocateChunkSize = autoAllocateChunkSize, controller._pendingPullIntos = new SimpleQueue(), stream._readableStreamController = controller;
        var startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), function() {
          controller._started = !0, ReadableByteStreamControllerCallPullIfNeeded(controller);
        }, function(r2) {
          ReadableByteStreamControllerError(controller, r2);
        });
      }
      function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
        var controller = Object.create(ReadableByteStreamController.prototype), startAlgorithm = function() {
        }, pullAlgorithm = function() {
          return promiseResolvedWith(void 0);
        }, cancelAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        underlyingByteSource.start !== void 0 && (startAlgorithm = function() {
          return underlyingByteSource.start(controller);
        }), underlyingByteSource.pull !== void 0 && (pullAlgorithm = function() {
          return underlyingByteSource.pull(controller);
        }), underlyingByteSource.cancel !== void 0 && (cancelAlgorithm = function(reason) {
          return underlyingByteSource.cancel(reason);
        });
        var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
        if (autoAllocateChunkSize === 0)
          throw new TypeError("autoAllocateChunkSize must be greater than 0");
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
      }
      function SetUpReadableStreamBYOBRequest(request, controller, view) {
        request._associatedReadableByteStreamController = controller, request._view = view;
      }
      function byobRequestBrandCheckException(name) {
        return new TypeError("ReadableStreamBYOBRequest.prototype." + name + " can only be used on a ReadableStreamBYOBRequest");
      }
      function byteStreamControllerBrandCheckException(name) {
        return new TypeError("ReadableByteStreamController.prototype." + name + " can only be used on a ReadableByteStreamController");
      }
      function AcquireReadableStreamBYOBReader(stream) {
        return new ReadableStreamBYOBReader(stream);
      }
      function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
        stream._reader._readIntoRequests.push(readIntoRequest);
      }
      function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
        var reader = stream._reader, readIntoRequest = reader._readIntoRequests.shift();
        done ? readIntoRequest._closeSteps(chunk) : readIntoRequest._chunkSteps(chunk);
      }
      function ReadableStreamGetNumReadIntoRequests(stream) {
        return stream._reader._readIntoRequests.length;
      }
      function ReadableStreamHasBYOBReader(stream) {
        var reader = stream._reader;
        return !(reader === void 0 || !IsReadableStreamBYOBReader(reader));
      }
      var ReadableStreamBYOBReader = (
        /** @class */
        function() {
          function ReadableStreamBYOBReader2(stream) {
            if (assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader"), assertReadableStream(stream, "First parameter"), IsReadableStreamLocked(stream))
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            if (!IsReadableByteStreamController(stream._readableStreamController))
              throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
            ReadableStreamReaderGenericInitialize(this, stream), this._readIntoRequests = new SimpleQueue();
          }
          return Object.defineProperty(ReadableStreamBYOBReader2.prototype, "closed", {
            /**
             * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
             * the reader's lock is released before the stream finishes closing.
             */
            get: function() {
              return IsReadableStreamBYOBReader(this) ? this._closedPromise : promiseRejectedWith(byobReaderBrandCheckException("closed"));
            },
            enumerable: !1,
            configurable: !0
          }), ReadableStreamBYOBReader2.prototype.cancel = function(reason) {
            return reason === void 0 && (reason = void 0), IsReadableStreamBYOBReader(this) ? this._ownerReadableStream === void 0 ? promiseRejectedWith(readerLockException("cancel")) : ReadableStreamReaderGenericCancel(this, reason) : promiseRejectedWith(byobReaderBrandCheckException("cancel"));
          }, ReadableStreamBYOBReader2.prototype.read = function(view) {
            if (!IsReadableStreamBYOBReader(this))
              return promiseRejectedWith(byobReaderBrandCheckException("read"));
            if (!ArrayBuffer.isView(view))
              return promiseRejectedWith(new TypeError("view must be an array buffer view"));
            if (view.byteLength === 0)
              return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
            if (view.buffer.byteLength === 0)
              return promiseRejectedWith(new TypeError("view's buffer must have non-zero byteLength"));
            if (IsDetachedBuffer(view.buffer), this._ownerReadableStream === void 0)
              return promiseRejectedWith(readerLockException("read from"));
            var resolvePromise, rejectPromise, promise = newPromise(function(resolve, reject) {
              resolvePromise = resolve, rejectPromise = reject;
            }), readIntoRequest = {
              _chunkSteps: function(chunk) {
                return resolvePromise({ value: chunk, done: !1 });
              },
              _closeSteps: function(chunk) {
                return resolvePromise({ value: chunk, done: !0 });
              },
              _errorSteps: function(e2) {
                return rejectPromise(e2);
              }
            };
            return ReadableStreamBYOBReaderRead(this, view, readIntoRequest), promise;
          }, ReadableStreamBYOBReader2.prototype.releaseLock = function() {
            if (!IsReadableStreamBYOBReader(this))
              throw byobReaderBrandCheckException("releaseLock");
            if (this._ownerReadableStream !== void 0) {
              if (this._readIntoRequests.length > 0)
                throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
              ReadableStreamReaderGenericRelease(this);
            }
          }, ReadableStreamBYOBReader2;
        }()
      );
      Object.defineProperties(ReadableStreamBYOBReader.prototype, {
        cancel: { enumerable: !0 },
        read: { enumerable: !0 },
        releaseLock: { enumerable: !0 },
        closed: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamBYOBReader",
        configurable: !0
      });
      function IsReadableStreamBYOBReader(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_readIntoRequests") ? !1 : x2 instanceof ReadableStreamBYOBReader;
      }
      function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
        var stream = reader._ownerReadableStream;
        stream._disturbed = !0, stream._state === "errored" ? readIntoRequest._errorSteps(stream._storedError) : ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
      }
      function byobReaderBrandCheckException(name) {
        return new TypeError("ReadableStreamBYOBReader.prototype." + name + " can only be used on a ReadableStreamBYOBReader");
      }
      function ExtractHighWaterMark(strategy, defaultHWM) {
        var highWaterMark = strategy.highWaterMark;
        if (highWaterMark === void 0)
          return defaultHWM;
        if (NumberIsNaN(highWaterMark) || highWaterMark < 0)
          throw new RangeError("Invalid highWaterMark");
        return highWaterMark;
      }
      function ExtractSizeAlgorithm(strategy) {
        var size = strategy.size;
        return size || function() {
          return 1;
        };
      }
      function convertQueuingStrategy(init, context) {
        assertDictionary(init, context);
        var highWaterMark = init == null ? void 0 : init.highWaterMark, size = init == null ? void 0 : init.size;
        return {
          highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
          size: size === void 0 ? void 0 : convertQueuingStrategySize(size, context + " has member 'size' that")
        };
      }
      function convertQueuingStrategySize(fn, context) {
        return assertFunction(fn, context), function(chunk) {
          return convertUnrestrictedDouble(fn(chunk));
        };
      }
      function convertUnderlyingSink(original, context) {
        assertDictionary(original, context);
        var abort = original == null ? void 0 : original.abort, close = original == null ? void 0 : original.close, start = original == null ? void 0 : original.start, type = original == null ? void 0 : original.type, write = original == null ? void 0 : original.write;
        return {
          abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, context + " has member 'abort' that"),
          close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, context + " has member 'close' that"),
          start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, context + " has member 'start' that"),
          write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, context + " has member 'write' that"),
          type
        };
      }
      function convertUnderlyingSinkAbortCallback(fn, original, context) {
        return assertFunction(fn, context), function(reason) {
          return promiseCall(fn, original, [reason]);
        };
      }
      function convertUnderlyingSinkCloseCallback(fn, original, context) {
        return assertFunction(fn, context), function() {
          return promiseCall(fn, original, []);
        };
      }
      function convertUnderlyingSinkStartCallback(fn, original, context) {
        return assertFunction(fn, context), function(controller) {
          return reflectCall(fn, original, [controller]);
        };
      }
      function convertUnderlyingSinkWriteCallback(fn, original, context) {
        return assertFunction(fn, context), function(chunk, controller) {
          return promiseCall(fn, original, [chunk, controller]);
        };
      }
      function assertWritableStream(x2, context) {
        if (!IsWritableStream(x2))
          throw new TypeError(context + " is not a WritableStream.");
      }
      function isAbortSignal2(value) {
        if (typeof value != "object" || value === null)
          return !1;
        try {
          return typeof value.aborted == "boolean";
        } catch {
          return !1;
        }
      }
      var supportsAbortController = typeof AbortController == "function";
      function createAbortController() {
        if (supportsAbortController)
          return new AbortController();
      }
      var WritableStream = (
        /** @class */
        function() {
          function WritableStream2(rawUnderlyingSink, rawStrategy) {
            rawUnderlyingSink === void 0 && (rawUnderlyingSink = {}), rawStrategy === void 0 && (rawStrategy = {}), rawUnderlyingSink === void 0 ? rawUnderlyingSink = null : assertObject(rawUnderlyingSink, "First parameter");
            var strategy = convertQueuingStrategy(rawStrategy, "Second parameter"), underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
            InitializeWritableStream(this);
            var type = underlyingSink.type;
            if (type !== void 0)
              throw new RangeError("Invalid type is specified");
            var sizeAlgorithm = ExtractSizeAlgorithm(strategy), highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
          }
          return Object.defineProperty(WritableStream2.prototype, "locked", {
            /**
             * Returns whether or not the writable stream is locked to a writer.
             */
            get: function() {
              if (!IsWritableStream(this))
                throw streamBrandCheckException$2("locked");
              return IsWritableStreamLocked(this);
            },
            enumerable: !1,
            configurable: !0
          }), WritableStream2.prototype.abort = function(reason) {
            return reason === void 0 && (reason = void 0), IsWritableStream(this) ? IsWritableStreamLocked(this) ? promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer")) : WritableStreamAbort(this, reason) : promiseRejectedWith(streamBrandCheckException$2("abort"));
          }, WritableStream2.prototype.close = function() {
            return IsWritableStream(this) ? IsWritableStreamLocked(this) ? promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer")) : WritableStreamCloseQueuedOrInFlight(this) ? promiseRejectedWith(new TypeError("Cannot close an already-closing stream")) : WritableStreamClose(this) : promiseRejectedWith(streamBrandCheckException$2("close"));
          }, WritableStream2.prototype.getWriter = function() {
            if (!IsWritableStream(this))
              throw streamBrandCheckException$2("getWriter");
            return AcquireWritableStreamDefaultWriter(this);
          }, WritableStream2;
        }()
      );
      Object.defineProperties(WritableStream.prototype, {
        abort: { enumerable: !0 },
        close: { enumerable: !0 },
        getWriter: { enumerable: !0 },
        locked: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
        value: "WritableStream",
        configurable: !0
      });
      function AcquireWritableStreamDefaultWriter(stream) {
        return new WritableStreamDefaultWriter(stream);
      }
      function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        highWaterMark === void 0 && (highWaterMark = 1), sizeAlgorithm === void 0 && (sizeAlgorithm = function() {
          return 1;
        });
        var stream = Object.create(WritableStream.prototype);
        InitializeWritableStream(stream);
        var controller = Object.create(WritableStreamDefaultController.prototype);
        return SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm), stream;
      }
      function InitializeWritableStream(stream) {
        stream._state = "writable", stream._storedError = void 0, stream._writer = void 0, stream._writableStreamController = void 0, stream._writeRequests = new SimpleQueue(), stream._inFlightWriteRequest = void 0, stream._closeRequest = void 0, stream._inFlightCloseRequest = void 0, stream._pendingAbortRequest = void 0, stream._backpressure = !1;
      }
      function IsWritableStream(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_writableStreamController") ? !1 : x2 instanceof WritableStream;
      }
      function IsWritableStreamLocked(stream) {
        return stream._writer !== void 0;
      }
      function WritableStreamAbort(stream, reason) {
        var _a5;
        if (stream._state === "closed" || stream._state === "errored")
          return promiseResolvedWith(void 0);
        stream._writableStreamController._abortReason = reason, (_a5 = stream._writableStreamController._abortController) === null || _a5 === void 0 || _a5.abort();
        var state = stream._state;
        if (state === "closed" || state === "errored")
          return promiseResolvedWith(void 0);
        if (stream._pendingAbortRequest !== void 0)
          return stream._pendingAbortRequest._promise;
        var wasAlreadyErroring = !1;
        state === "erroring" && (wasAlreadyErroring = !0, reason = void 0);
        var promise = newPromise(function(resolve, reject) {
          stream._pendingAbortRequest = {
            _promise: void 0,
            _resolve: resolve,
            _reject: reject,
            _reason: reason,
            _wasAlreadyErroring: wasAlreadyErroring
          };
        });
        return stream._pendingAbortRequest._promise = promise, wasAlreadyErroring || WritableStreamStartErroring(stream, reason), promise;
      }
      function WritableStreamClose(stream) {
        var state = stream._state;
        if (state === "closed" || state === "errored")
          return promiseRejectedWith(new TypeError("The stream (in " + state + " state) is not in the writable state and cannot be closed"));
        var promise = newPromise(function(resolve, reject) {
          var closeRequest = {
            _resolve: resolve,
            _reject: reject
          };
          stream._closeRequest = closeRequest;
        }), writer = stream._writer;
        return writer !== void 0 && stream._backpressure && state === "writable" && defaultWriterReadyPromiseResolve(writer), WritableStreamDefaultControllerClose(stream._writableStreamController), promise;
      }
      function WritableStreamAddWriteRequest(stream) {
        var promise = newPromise(function(resolve, reject) {
          var writeRequest = {
            _resolve: resolve,
            _reject: reject
          };
          stream._writeRequests.push(writeRequest);
        });
        return promise;
      }
      function WritableStreamDealWithRejection(stream, error) {
        var state = stream._state;
        if (state === "writable") {
          WritableStreamStartErroring(stream, error);
          return;
        }
        WritableStreamFinishErroring(stream);
      }
      function WritableStreamStartErroring(stream, reason) {
        var controller = stream._writableStreamController;
        stream._state = "erroring", stream._storedError = reason;
        var writer = stream._writer;
        writer !== void 0 && WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason), !WritableStreamHasOperationMarkedInFlight(stream) && controller._started && WritableStreamFinishErroring(stream);
      }
      function WritableStreamFinishErroring(stream) {
        stream._state = "errored", stream._writableStreamController[ErrorSteps]();
        var storedError = stream._storedError;
        if (stream._writeRequests.forEach(function(writeRequest) {
          writeRequest._reject(storedError);
        }), stream._writeRequests = new SimpleQueue(), stream._pendingAbortRequest === void 0) {
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        var abortRequest = stream._pendingAbortRequest;
        if (stream._pendingAbortRequest = void 0, abortRequest._wasAlreadyErroring) {
          abortRequest._reject(storedError), WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        var promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
        uponPromise(promise, function() {
          abortRequest._resolve(), WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        }, function(reason) {
          abortRequest._reject(reason), WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        });
      }
      function WritableStreamFinishInFlightWrite(stream) {
        stream._inFlightWriteRequest._resolve(void 0), stream._inFlightWriteRequest = void 0;
      }
      function WritableStreamFinishInFlightWriteWithError(stream, error) {
        stream._inFlightWriteRequest._reject(error), stream._inFlightWriteRequest = void 0, WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamFinishInFlightClose(stream) {
        stream._inFlightCloseRequest._resolve(void 0), stream._inFlightCloseRequest = void 0;
        var state = stream._state;
        state === "erroring" && (stream._storedError = void 0, stream._pendingAbortRequest !== void 0 && (stream._pendingAbortRequest._resolve(), stream._pendingAbortRequest = void 0)), stream._state = "closed";
        var writer = stream._writer;
        writer !== void 0 && defaultWriterClosedPromiseResolve(writer);
      }
      function WritableStreamFinishInFlightCloseWithError(stream, error) {
        stream._inFlightCloseRequest._reject(error), stream._inFlightCloseRequest = void 0, stream._pendingAbortRequest !== void 0 && (stream._pendingAbortRequest._reject(error), stream._pendingAbortRequest = void 0), WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamCloseQueuedOrInFlight(stream) {
        return !(stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0);
      }
      function WritableStreamHasOperationMarkedInFlight(stream) {
        return !(stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0);
      }
      function WritableStreamMarkCloseRequestInFlight(stream) {
        stream._inFlightCloseRequest = stream._closeRequest, stream._closeRequest = void 0;
      }
      function WritableStreamMarkFirstWriteRequestInFlight(stream) {
        stream._inFlightWriteRequest = stream._writeRequests.shift();
      }
      function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
        stream._closeRequest !== void 0 && (stream._closeRequest._reject(stream._storedError), stream._closeRequest = void 0);
        var writer = stream._writer;
        writer !== void 0 && defaultWriterClosedPromiseReject(writer, stream._storedError);
      }
      function WritableStreamUpdateBackpressure(stream, backpressure) {
        var writer = stream._writer;
        writer !== void 0 && backpressure !== stream._backpressure && (backpressure ? defaultWriterReadyPromiseReset(writer) : defaultWriterReadyPromiseResolve(writer)), stream._backpressure = backpressure;
      }
      var WritableStreamDefaultWriter = (
        /** @class */
        function() {
          function WritableStreamDefaultWriter2(stream) {
            if (assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter"), assertWritableStream(stream, "First parameter"), IsWritableStreamLocked(stream))
              throw new TypeError("This stream has already been locked for exclusive writing by another writer");
            this._ownerWritableStream = stream, stream._writer = this;
            var state = stream._state;
            if (state === "writable")
              !WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure ? defaultWriterReadyPromiseInitialize(this) : defaultWriterReadyPromiseInitializeAsResolved(this), defaultWriterClosedPromiseInitialize(this);
            else if (state === "erroring")
              defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError), defaultWriterClosedPromiseInitialize(this);
            else if (state === "closed")
              defaultWriterReadyPromiseInitializeAsResolved(this), defaultWriterClosedPromiseInitializeAsResolved(this);
            else {
              var storedError = stream._storedError;
              defaultWriterReadyPromiseInitializeAsRejected(this, storedError), defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
            }
          }
          return Object.defineProperty(WritableStreamDefaultWriter2.prototype, "closed", {
            /**
             * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
             * the writers lock is released before the stream finishes closing.
             */
            get: function() {
              return IsWritableStreamDefaultWriter(this) ? this._closedPromise : promiseRejectedWith(defaultWriterBrandCheckException("closed"));
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(WritableStreamDefaultWriter2.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the streams internal queue. It can be negative, if the queue is over-full.
             * A producer can use this information to determine the right amount of data to write.
             *
             * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
             * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
             * the writers lock is released.
             */
            get: function() {
              if (!IsWritableStreamDefaultWriter(this))
                throw defaultWriterBrandCheckException("desiredSize");
              if (this._ownerWritableStream === void 0)
                throw defaultWriterLockException("desiredSize");
              return WritableStreamDefaultWriterGetDesiredSize(this);
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(WritableStreamDefaultWriter2.prototype, "ready", {
            /**
             * Returns a promise that will be fulfilled when the desired size to fill the streams internal queue transitions
             * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
             * back to zero or below, the getter will return a new promise that stays pending until the next transition.
             *
             * If the stream becomes errored or aborted, or the writers lock is released, the returned promise will become
             * rejected.
             */
            get: function() {
              return IsWritableStreamDefaultWriter(this) ? this._readyPromise : promiseRejectedWith(defaultWriterBrandCheckException("ready"));
            },
            enumerable: !1,
            configurable: !0
          }), WritableStreamDefaultWriter2.prototype.abort = function(reason) {
            return reason === void 0 && (reason = void 0), IsWritableStreamDefaultWriter(this) ? this._ownerWritableStream === void 0 ? promiseRejectedWith(defaultWriterLockException("abort")) : WritableStreamDefaultWriterAbort(this, reason) : promiseRejectedWith(defaultWriterBrandCheckException("abort"));
          }, WritableStreamDefaultWriter2.prototype.close = function() {
            if (!IsWritableStreamDefaultWriter(this))
              return promiseRejectedWith(defaultWriterBrandCheckException("close"));
            var stream = this._ownerWritableStream;
            return stream === void 0 ? promiseRejectedWith(defaultWriterLockException("close")) : WritableStreamCloseQueuedOrInFlight(stream) ? promiseRejectedWith(new TypeError("Cannot close an already-closing stream")) : WritableStreamDefaultWriterClose(this);
          }, WritableStreamDefaultWriter2.prototype.releaseLock = function() {
            if (!IsWritableStreamDefaultWriter(this))
              throw defaultWriterBrandCheckException("releaseLock");
            var stream = this._ownerWritableStream;
            stream !== void 0 && WritableStreamDefaultWriterRelease(this);
          }, WritableStreamDefaultWriter2.prototype.write = function(chunk) {
            return chunk === void 0 && (chunk = void 0), IsWritableStreamDefaultWriter(this) ? this._ownerWritableStream === void 0 ? promiseRejectedWith(defaultWriterLockException("write to")) : WritableStreamDefaultWriterWrite(this, chunk) : promiseRejectedWith(defaultWriterBrandCheckException("write"));
          }, WritableStreamDefaultWriter2;
        }()
      );
      Object.defineProperties(WritableStreamDefaultWriter.prototype, {
        abort: { enumerable: !0 },
        close: { enumerable: !0 },
        releaseLock: { enumerable: !0 },
        write: { enumerable: !0 },
        closed: { enumerable: !0 },
        desiredSize: { enumerable: !0 },
        ready: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
        value: "WritableStreamDefaultWriter",
        configurable: !0
      });
      function IsWritableStreamDefaultWriter(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_ownerWritableStream") ? !1 : x2 instanceof WritableStreamDefaultWriter;
      }
      function WritableStreamDefaultWriterAbort(writer, reason) {
        var stream = writer._ownerWritableStream;
        return WritableStreamAbort(stream, reason);
      }
      function WritableStreamDefaultWriterClose(writer) {
        var stream = writer._ownerWritableStream;
        return WritableStreamClose(stream);
      }
      function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
        var stream = writer._ownerWritableStream, state = stream._state;
        return WritableStreamCloseQueuedOrInFlight(stream) || state === "closed" ? promiseResolvedWith(void 0) : state === "errored" ? promiseRejectedWith(stream._storedError) : WritableStreamDefaultWriterClose(writer);
      }
      function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
        writer._closedPromiseState === "pending" ? defaultWriterClosedPromiseReject(writer, error) : defaultWriterClosedPromiseResetToRejected(writer, error);
      }
      function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
        writer._readyPromiseState === "pending" ? defaultWriterReadyPromiseReject(writer, error) : defaultWriterReadyPromiseResetToRejected(writer, error);
      }
      function WritableStreamDefaultWriterGetDesiredSize(writer) {
        var stream = writer._ownerWritableStream, state = stream._state;
        return state === "errored" || state === "erroring" ? null : state === "closed" ? 0 : WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
      }
      function WritableStreamDefaultWriterRelease(writer) {
        var stream = writer._ownerWritableStream, releasedError = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError), WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError), stream._writer = void 0, writer._ownerWritableStream = void 0;
      }
      function WritableStreamDefaultWriterWrite(writer, chunk) {
        var stream = writer._ownerWritableStream, controller = stream._writableStreamController, chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
        if (stream !== writer._ownerWritableStream)
          return promiseRejectedWith(defaultWriterLockException("write to"));
        var state = stream._state;
        if (state === "errored")
          return promiseRejectedWith(stream._storedError);
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed")
          return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
        if (state === "erroring")
          return promiseRejectedWith(stream._storedError);
        var promise = WritableStreamAddWriteRequest(stream);
        return WritableStreamDefaultControllerWrite(controller, chunk, chunkSize), promise;
      }
      var closeSentinel = {}, WritableStreamDefaultController = (
        /** @class */
        function() {
          function WritableStreamDefaultController2() {
            throw new TypeError("Illegal constructor");
          }
          return Object.defineProperty(WritableStreamDefaultController2.prototype, "abortReason", {
            /**
             * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
             *
             * @deprecated
             *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
             *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
             */
            get: function() {
              if (!IsWritableStreamDefaultController(this))
                throw defaultControllerBrandCheckException$2("abortReason");
              return this._abortReason;
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(WritableStreamDefaultController2.prototype, "signal", {
            /**
             * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
             */
            get: function() {
              if (!IsWritableStreamDefaultController(this))
                throw defaultControllerBrandCheckException$2("signal");
              if (this._abortController === void 0)
                throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
              return this._abortController.signal;
            },
            enumerable: !1,
            configurable: !0
          }), WritableStreamDefaultController2.prototype.error = function(e2) {
            if (e2 === void 0 && (e2 = void 0), !IsWritableStreamDefaultController(this))
              throw defaultControllerBrandCheckException$2("error");
            var state = this._controlledWritableStream._state;
            state === "writable" && WritableStreamDefaultControllerError(this, e2);
          }, WritableStreamDefaultController2.prototype[AbortSteps] = function(reason) {
            var result = this._abortAlgorithm(reason);
            return WritableStreamDefaultControllerClearAlgorithms(this), result;
          }, WritableStreamDefaultController2.prototype[ErrorSteps] = function() {
            ResetQueue(this);
          }, WritableStreamDefaultController2;
        }()
      );
      Object.defineProperties(WritableStreamDefaultController.prototype, {
        abortReason: { enumerable: !0 },
        signal: { enumerable: !0 },
        error: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
        value: "WritableStreamDefaultController",
        configurable: !0
      });
      function IsWritableStreamDefaultController(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_controlledWritableStream") ? !1 : x2 instanceof WritableStreamDefaultController;
      }
      function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledWritableStream = stream, stream._writableStreamController = controller, controller._queue = void 0, controller._queueTotalSize = void 0, ResetQueue(controller), controller._abortReason = void 0, controller._abortController = createAbortController(), controller._started = !1, controller._strategySizeAlgorithm = sizeAlgorithm, controller._strategyHWM = highWaterMark, controller._writeAlgorithm = writeAlgorithm, controller._closeAlgorithm = closeAlgorithm, controller._abortAlgorithm = abortAlgorithm;
        var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
        var startResult = startAlgorithm(), startPromise = promiseResolvedWith(startResult);
        uponPromise(startPromise, function() {
          controller._started = !0, WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, function(r2) {
          controller._started = !0, WritableStreamDealWithRejection(stream, r2);
        });
      }
      function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
        var controller = Object.create(WritableStreamDefaultController.prototype), startAlgorithm = function() {
        }, writeAlgorithm = function() {
          return promiseResolvedWith(void 0);
        }, closeAlgorithm = function() {
          return promiseResolvedWith(void 0);
        }, abortAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        underlyingSink.start !== void 0 && (startAlgorithm = function() {
          return underlyingSink.start(controller);
        }), underlyingSink.write !== void 0 && (writeAlgorithm = function(chunk) {
          return underlyingSink.write(chunk, controller);
        }), underlyingSink.close !== void 0 && (closeAlgorithm = function() {
          return underlyingSink.close();
        }), underlyingSink.abort !== void 0 && (abortAlgorithm = function(reason) {
          return underlyingSink.abort(reason);
        }), SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function WritableStreamDefaultControllerClearAlgorithms(controller) {
        controller._writeAlgorithm = void 0, controller._closeAlgorithm = void 0, controller._abortAlgorithm = void 0, controller._strategySizeAlgorithm = void 0;
      }
      function WritableStreamDefaultControllerClose(controller) {
        EnqueueValueWithSize(controller, closeSentinel, 0), WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
        try {
          return controller._strategySizeAlgorithm(chunk);
        } catch (chunkSizeE) {
          return WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE), 1;
        }
      }
      function WritableStreamDefaultControllerGetDesiredSize(controller) {
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
        try {
          EnqueueValueWithSize(controller, chunk, chunkSize);
        } catch (enqueueE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
          return;
        }
        var stream = controller._controlledWritableStream;
        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
          var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
        var stream = controller._controlledWritableStream;
        if (controller._started && stream._inFlightWriteRequest === void 0) {
          var state = stream._state;
          if (state === "erroring") {
            WritableStreamFinishErroring(stream);
            return;
          }
          if (controller._queue.length !== 0) {
            var value = PeekQueueValue(controller);
            value === closeSentinel ? WritableStreamDefaultControllerProcessClose(controller) : WritableStreamDefaultControllerProcessWrite(controller, value);
          }
        }
      }
      function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
        controller._controlledWritableStream._state === "writable" && WritableStreamDefaultControllerError(controller, error);
      }
      function WritableStreamDefaultControllerProcessClose(controller) {
        var stream = controller._controlledWritableStream;
        WritableStreamMarkCloseRequestInFlight(stream), DequeueValue(controller);
        var sinkClosePromise = controller._closeAlgorithm();
        WritableStreamDefaultControllerClearAlgorithms(controller), uponPromise(sinkClosePromise, function() {
          WritableStreamFinishInFlightClose(stream);
        }, function(reason) {
          WritableStreamFinishInFlightCloseWithError(stream, reason);
        });
      }
      function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
        var stream = controller._controlledWritableStream;
        WritableStreamMarkFirstWriteRequestInFlight(stream);
        var sinkWritePromise = controller._writeAlgorithm(chunk);
        uponPromise(sinkWritePromise, function() {
          WritableStreamFinishInFlightWrite(stream);
          var state = stream._state;
          if (DequeueValue(controller), !WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
            var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, function(reason) {
          stream._state === "writable" && WritableStreamDefaultControllerClearAlgorithms(controller), WritableStreamFinishInFlightWriteWithError(stream, reason);
        });
      }
      function WritableStreamDefaultControllerGetBackpressure(controller) {
        var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
        return desiredSize <= 0;
      }
      function WritableStreamDefaultControllerError(controller, error) {
        var stream = controller._controlledWritableStream;
        WritableStreamDefaultControllerClearAlgorithms(controller), WritableStreamStartErroring(stream, error);
      }
      function streamBrandCheckException$2(name) {
        return new TypeError("WritableStream.prototype." + name + " can only be used on a WritableStream");
      }
      function defaultControllerBrandCheckException$2(name) {
        return new TypeError("WritableStreamDefaultController.prototype." + name + " can only be used on a WritableStreamDefaultController");
      }
      function defaultWriterBrandCheckException(name) {
        return new TypeError("WritableStreamDefaultWriter.prototype." + name + " can only be used on a WritableStreamDefaultWriter");
      }
      function defaultWriterLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released writer");
      }
      function defaultWriterClosedPromiseInitialize(writer) {
        writer._closedPromise = newPromise(function(resolve, reject) {
          writer._closedPromise_resolve = resolve, writer._closedPromise_reject = reject, writer._closedPromiseState = "pending";
        });
      }
      function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
        defaultWriterClosedPromiseInitialize(writer), defaultWriterClosedPromiseReject(writer, reason);
      }
      function defaultWriterClosedPromiseInitializeAsResolved(writer) {
        defaultWriterClosedPromiseInitialize(writer), defaultWriterClosedPromiseResolve(writer);
      }
      function defaultWriterClosedPromiseReject(writer, reason) {
        writer._closedPromise_reject !== void 0 && (setPromiseIsHandledToTrue(writer._closedPromise), writer._closedPromise_reject(reason), writer._closedPromise_resolve = void 0, writer._closedPromise_reject = void 0, writer._closedPromiseState = "rejected");
      }
      function defaultWriterClosedPromiseResetToRejected(writer, reason) {
        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterClosedPromiseResolve(writer) {
        writer._closedPromise_resolve !== void 0 && (writer._closedPromise_resolve(void 0), writer._closedPromise_resolve = void 0, writer._closedPromise_reject = void 0, writer._closedPromiseState = "resolved");
      }
      function defaultWriterReadyPromiseInitialize(writer) {
        writer._readyPromise = newPromise(function(resolve, reject) {
          writer._readyPromise_resolve = resolve, writer._readyPromise_reject = reject;
        }), writer._readyPromiseState = "pending";
      }
      function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
        defaultWriterReadyPromiseInitialize(writer), defaultWriterReadyPromiseReject(writer, reason);
      }
      function defaultWriterReadyPromiseInitializeAsResolved(writer) {
        defaultWriterReadyPromiseInitialize(writer), defaultWriterReadyPromiseResolve(writer);
      }
      function defaultWriterReadyPromiseReject(writer, reason) {
        writer._readyPromise_reject !== void 0 && (setPromiseIsHandledToTrue(writer._readyPromise), writer._readyPromise_reject(reason), writer._readyPromise_resolve = void 0, writer._readyPromise_reject = void 0, writer._readyPromiseState = "rejected");
      }
      function defaultWriterReadyPromiseReset(writer) {
        defaultWriterReadyPromiseInitialize(writer);
      }
      function defaultWriterReadyPromiseResetToRejected(writer, reason) {
        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterReadyPromiseResolve(writer) {
        writer._readyPromise_resolve !== void 0 && (writer._readyPromise_resolve(void 0), writer._readyPromise_resolve = void 0, writer._readyPromise_reject = void 0, writer._readyPromiseState = "fulfilled");
      }
      var NativeDOMException = typeof DOMException < "u" ? DOMException : void 0;
      function isDOMExceptionConstructor(ctor) {
        if (!(typeof ctor == "function" || typeof ctor == "object"))
          return !1;
        try {
          return new ctor(), !0;
        } catch {
          return !1;
        }
      }
      function createDOMExceptionPolyfill() {
        var ctor = function(message, name) {
          this.message = message || "", this.name = name || "Error", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
        };
        return ctor.prototype = Object.create(Error.prototype), Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: !0, configurable: !0 }), ctor;
      }
      var DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
      function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
        var reader = AcquireReadableStreamDefaultReader(source), writer = AcquireWritableStreamDefaultWriter(dest);
        source._disturbed = !0;
        var shuttingDown = !1, currentWrite = promiseResolvedWith(void 0);
        return newPromise(function(resolve, reject) {
          var abortAlgorithm;
          if (signal !== void 0) {
            if (abortAlgorithm = function() {
              var error = new DOMException$1("Aborted", "AbortError"), actions = [];
              preventAbort || actions.push(function() {
                return dest._state === "writable" ? WritableStreamAbort(dest, error) : promiseResolvedWith(void 0);
              }), preventCancel || actions.push(function() {
                return source._state === "readable" ? ReadableStreamCancel(source, error) : promiseResolvedWith(void 0);
              }), shutdownWithAction(function() {
                return Promise.all(actions.map(function(action3) {
                  return action3();
                }));
              }, !0, error);
            }, signal.aborted) {
              abortAlgorithm();
              return;
            }
            signal.addEventListener("abort", abortAlgorithm);
          }
          function pipeLoop() {
            return newPromise(function(resolveLoop, rejectLoop) {
              function next(done) {
                done ? resolveLoop() : PerformPromiseThen(pipeStep(), next, rejectLoop);
              }
              next(!1);
            });
          }
          function pipeStep() {
            return shuttingDown ? promiseResolvedWith(!0) : PerformPromiseThen(writer._readyPromise, function() {
              return newPromise(function(resolveRead, rejectRead) {
                ReadableStreamDefaultReaderRead(reader, {
                  _chunkSteps: function(chunk) {
                    currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop2), resolveRead(!1);
                  },
                  _closeSteps: function() {
                    return resolveRead(!0);
                  },
                  _errorSteps: rejectRead
                });
              });
            });
          }
          if (isOrBecomesErrored(source, reader._closedPromise, function(storedError) {
            preventAbort ? shutdown(!0, storedError) : shutdownWithAction(function() {
              return WritableStreamAbort(dest, storedError);
            }, !0, storedError);
          }), isOrBecomesErrored(dest, writer._closedPromise, function(storedError) {
            preventCancel ? shutdown(!0, storedError) : shutdownWithAction(function() {
              return ReadableStreamCancel(source, storedError);
            }, !0, storedError);
          }), isOrBecomesClosed(source, reader._closedPromise, function() {
            preventClose ? shutdown() : shutdownWithAction(function() {
              return WritableStreamDefaultWriterCloseWithErrorPropagation(writer);
            });
          }), WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
            var destClosed_1 = new TypeError("the destination writable stream closed before all data could be piped to it");
            preventCancel ? shutdown(!0, destClosed_1) : shutdownWithAction(function() {
              return ReadableStreamCancel(source, destClosed_1);
            }, !0, destClosed_1);
          }
          setPromiseIsHandledToTrue(pipeLoop());
          function waitForWritesToFinish() {
            var oldCurrentWrite = currentWrite;
            return PerformPromiseThen(currentWrite, function() {
              return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0;
            });
          }
          function isOrBecomesErrored(stream, promise, action3) {
            stream._state === "errored" ? action3(stream._storedError) : uponRejection(promise, action3);
          }
          function isOrBecomesClosed(stream, promise, action3) {
            stream._state === "closed" ? action3() : uponFulfillment(promise, action3);
          }
          function shutdownWithAction(action3, originalIsError, originalError) {
            if (shuttingDown)
              return;
            shuttingDown = !0, dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest) ? uponFulfillment(waitForWritesToFinish(), doTheRest) : doTheRest();
            function doTheRest() {
              uponPromise(action3(), function() {
                return finalize(originalIsError, originalError);
              }, function(newError) {
                return finalize(!0, newError);
              });
            }
          }
          function shutdown(isError, error) {
            shuttingDown || (shuttingDown = !0, dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest) ? uponFulfillment(waitForWritesToFinish(), function() {
              return finalize(isError, error);
            }) : finalize(isError, error));
          }
          function finalize(isError, error) {
            WritableStreamDefaultWriterRelease(writer), ReadableStreamReaderGenericRelease(reader), signal !== void 0 && signal.removeEventListener("abort", abortAlgorithm), isError ? reject(error) : resolve(void 0);
          }
        });
      }
      var ReadableStreamDefaultController = (
        /** @class */
        function() {
          function ReadableStreamDefaultController2() {
            throw new TypeError("Illegal constructor");
          }
          return Object.defineProperty(ReadableStreamDefaultController2.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
             * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
             */
            get: function() {
              if (!IsReadableStreamDefaultController(this))
                throw defaultControllerBrandCheckException$1("desiredSize");
              return ReadableStreamDefaultControllerGetDesiredSize(this);
            },
            enumerable: !1,
            configurable: !0
          }), ReadableStreamDefaultController2.prototype.close = function() {
            if (!IsReadableStreamDefaultController(this))
              throw defaultControllerBrandCheckException$1("close");
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this))
              throw new TypeError("The stream is not in a state that permits close");
            ReadableStreamDefaultControllerClose(this);
          }, ReadableStreamDefaultController2.prototype.enqueue = function(chunk) {
            if (chunk === void 0 && (chunk = void 0), !IsReadableStreamDefaultController(this))
              throw defaultControllerBrandCheckException$1("enqueue");
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this))
              throw new TypeError("The stream is not in a state that permits enqueue");
            return ReadableStreamDefaultControllerEnqueue(this, chunk);
          }, ReadableStreamDefaultController2.prototype.error = function(e2) {
            if (e2 === void 0 && (e2 = void 0), !IsReadableStreamDefaultController(this))
              throw defaultControllerBrandCheckException$1("error");
            ReadableStreamDefaultControllerError(this, e2);
          }, ReadableStreamDefaultController2.prototype[CancelSteps] = function(reason) {
            ResetQueue(this);
            var result = this._cancelAlgorithm(reason);
            return ReadableStreamDefaultControllerClearAlgorithms(this), result;
          }, ReadableStreamDefaultController2.prototype[PullSteps] = function(readRequest) {
            var stream = this._controlledReadableStream;
            if (this._queue.length > 0) {
              var chunk = DequeueValue(this);
              this._closeRequested && this._queue.length === 0 ? (ReadableStreamDefaultControllerClearAlgorithms(this), ReadableStreamClose(stream)) : ReadableStreamDefaultControllerCallPullIfNeeded(this), readRequest._chunkSteps(chunk);
            } else
              ReadableStreamAddReadRequest(stream, readRequest), ReadableStreamDefaultControllerCallPullIfNeeded(this);
          }, ReadableStreamDefaultController2;
        }()
      );
      Object.defineProperties(ReadableStreamDefaultController.prototype, {
        close: { enumerable: !0 },
        enqueue: { enumerable: !0 },
        error: { enumerable: !0 },
        desiredSize: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamDefaultController",
        configurable: !0
      });
      function IsReadableStreamDefaultController(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_controlledReadableStream") ? !1 : x2 instanceof ReadableStreamDefaultController;
      }
      function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
        var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
        if (shouldPull) {
          if (controller._pulling) {
            controller._pullAgain = !0;
            return;
          }
          controller._pulling = !0;
          var pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, function() {
            controller._pulling = !1, controller._pullAgain && (controller._pullAgain = !1, ReadableStreamDefaultControllerCallPullIfNeeded(controller));
          }, function(e2) {
            ReadableStreamDefaultControllerError(controller, e2);
          });
        }
      }
      function ReadableStreamDefaultControllerShouldCallPull(controller) {
        var stream = controller._controlledReadableStream;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) || !controller._started)
          return !1;
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0)
          return !0;
        var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
        return desiredSize > 0;
      }
      function ReadableStreamDefaultControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0, controller._cancelAlgorithm = void 0, controller._strategySizeAlgorithm = void 0;
      }
      function ReadableStreamDefaultControllerClose(controller) {
        if (ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          var stream = controller._controlledReadableStream;
          controller._closeRequested = !0, controller._queue.length === 0 && (ReadableStreamDefaultControllerClearAlgorithms(controller), ReadableStreamClose(stream));
        }
      }
      function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
        if (ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          var stream = controller._controlledReadableStream;
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0)
            ReadableStreamFulfillReadRequest(stream, chunk, !1);
          else {
            var chunkSize = void 0;
            try {
              chunkSize = controller._strategySizeAlgorithm(chunk);
            } catch (chunkSizeE) {
              throw ReadableStreamDefaultControllerError(controller, chunkSizeE), chunkSizeE;
            }
            try {
              EnqueueValueWithSize(controller, chunk, chunkSize);
            } catch (enqueueE) {
              throw ReadableStreamDefaultControllerError(controller, enqueueE), enqueueE;
            }
          }
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }
      }
      function ReadableStreamDefaultControllerError(controller, e2) {
        var stream = controller._controlledReadableStream;
        stream._state === "readable" && (ResetQueue(controller), ReadableStreamDefaultControllerClearAlgorithms(controller), ReadableStreamError(stream, e2));
      }
      function ReadableStreamDefaultControllerGetDesiredSize(controller) {
        var state = controller._controlledReadableStream._state;
        return state === "errored" ? null : state === "closed" ? 0 : controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableStreamDefaultControllerHasBackpressure(controller) {
        return !ReadableStreamDefaultControllerShouldCallPull(controller);
      }
      function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
        var state = controller._controlledReadableStream._state;
        return !controller._closeRequested && state === "readable";
      }
      function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledReadableStream = stream, controller._queue = void 0, controller._queueTotalSize = void 0, ResetQueue(controller), controller._started = !1, controller._closeRequested = !1, controller._pullAgain = !1, controller._pulling = !1, controller._strategySizeAlgorithm = sizeAlgorithm, controller._strategyHWM = highWaterMark, controller._pullAlgorithm = pullAlgorithm, controller._cancelAlgorithm = cancelAlgorithm, stream._readableStreamController = controller;
        var startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), function() {
          controller._started = !0, ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }, function(r2) {
          ReadableStreamDefaultControllerError(controller, r2);
        });
      }
      function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
        var controller = Object.create(ReadableStreamDefaultController.prototype), startAlgorithm = function() {
        }, pullAlgorithm = function() {
          return promiseResolvedWith(void 0);
        }, cancelAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        underlyingSource.start !== void 0 && (startAlgorithm = function() {
          return underlyingSource.start(controller);
        }), underlyingSource.pull !== void 0 && (pullAlgorithm = function() {
          return underlyingSource.pull(controller);
        }), underlyingSource.cancel !== void 0 && (cancelAlgorithm = function(reason) {
          return underlyingSource.cancel(reason);
        }), SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function defaultControllerBrandCheckException$1(name) {
        return new TypeError("ReadableStreamDefaultController.prototype." + name + " can only be used on a ReadableStreamDefaultController");
      }
      function ReadableStreamTee(stream, cloneForBranch2) {
        return IsReadableByteStreamController(stream._readableStreamController) ? ReadableByteStreamTee(stream) : ReadableStreamDefaultTee(stream);
      }
      function ReadableStreamDefaultTee(stream, cloneForBranch2) {
        var reader = AcquireReadableStreamDefaultReader(stream), reading = !1, readAgain = !1, canceled1 = !1, canceled2 = !1, reason1, reason2, branch1, branch2, resolveCancelPromise, cancelPromise = newPromise(function(resolve) {
          resolveCancelPromise = resolve;
        });
        function pullAlgorithm() {
          if (reading)
            return readAgain = !0, promiseResolvedWith(void 0);
          reading = !0;
          var readRequest = {
            _chunkSteps: function(chunk) {
              queueMicrotask(function() {
                readAgain = !1;
                var chunk1 = chunk, chunk2 = chunk;
                canceled1 || ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1), canceled2 || ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2), reading = !1, readAgain && pullAlgorithm();
              });
            },
            _closeSteps: function() {
              reading = !1, canceled1 || ReadableStreamDefaultControllerClose(branch1._readableStreamController), canceled2 || ReadableStreamDefaultControllerClose(branch2._readableStreamController), (!canceled1 || !canceled2) && resolveCancelPromise(void 0);
            },
            _errorSteps: function() {
              reading = !1;
            }
          };
          return ReadableStreamDefaultReaderRead(reader, readRequest), promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          if (canceled1 = !0, reason1 = reason, canceled2) {
            var compositeReason = CreateArrayFromList([reason1, reason2]), cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          if (canceled2 = !0, reason2 = reason, canceled1) {
            var compositeReason = CreateArrayFromList([reason1, reason2]), cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
        }
        return branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm), branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm), uponRejection(reader._closedPromise, function(r2) {
          ReadableStreamDefaultControllerError(branch1._readableStreamController, r2), ReadableStreamDefaultControllerError(branch2._readableStreamController, r2), (!canceled1 || !canceled2) && resolveCancelPromise(void 0);
        }), [branch1, branch2];
      }
      function ReadableByteStreamTee(stream) {
        var reader = AcquireReadableStreamDefaultReader(stream), reading = !1, readAgainForBranch1 = !1, readAgainForBranch2 = !1, canceled1 = !1, canceled2 = !1, reason1, reason2, branch1, branch2, resolveCancelPromise, cancelPromise = newPromise(function(resolve) {
          resolveCancelPromise = resolve;
        });
        function forwardReaderError(thisReader) {
          uponRejection(thisReader._closedPromise, function(r2) {
            thisReader === reader && (ReadableByteStreamControllerError(branch1._readableStreamController, r2), ReadableByteStreamControllerError(branch2._readableStreamController, r2), (!canceled1 || !canceled2) && resolveCancelPromise(void 0));
          });
        }
        function pullWithDefaultReader() {
          IsReadableStreamBYOBReader(reader) && (ReadableStreamReaderGenericRelease(reader), reader = AcquireReadableStreamDefaultReader(stream), forwardReaderError(reader));
          var readRequest = {
            _chunkSteps: function(chunk) {
              queueMicrotask(function() {
                readAgainForBranch1 = !1, readAgainForBranch2 = !1;
                var chunk1 = chunk, chunk2 = chunk;
                if (!canceled1 && !canceled2)
                  try {
                    chunk2 = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(branch1._readableStreamController, cloneE), ReadableByteStreamControllerError(branch2._readableStreamController, cloneE), resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                canceled1 || ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1), canceled2 || ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2), reading = !1, readAgainForBranch1 ? pull1Algorithm() : readAgainForBranch2 && pull2Algorithm();
              });
            },
            _closeSteps: function() {
              reading = !1, canceled1 || ReadableByteStreamControllerClose(branch1._readableStreamController), canceled2 || ReadableByteStreamControllerClose(branch2._readableStreamController), branch1._readableStreamController._pendingPullIntos.length > 0 && ReadableByteStreamControllerRespond(branch1._readableStreamController, 0), branch2._readableStreamController._pendingPullIntos.length > 0 && ReadableByteStreamControllerRespond(branch2._readableStreamController, 0), (!canceled1 || !canceled2) && resolveCancelPromise(void 0);
            },
            _errorSteps: function() {
              reading = !1;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
        }
        function pullWithBYOBReader(view, forBranch2) {
          IsReadableStreamDefaultReader(reader) && (ReadableStreamReaderGenericRelease(reader), reader = AcquireReadableStreamBYOBReader(stream), forwardReaderError(reader));
          var byobBranch = forBranch2 ? branch2 : branch1, otherBranch = forBranch2 ? branch1 : branch2, readIntoRequest = {
            _chunkSteps: function(chunk) {
              queueMicrotask(function() {
                readAgainForBranch1 = !1, readAgainForBranch2 = !1;
                var byobCanceled = forBranch2 ? canceled2 : canceled1, otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (otherCanceled)
                  byobCanceled || ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                else {
                  var clonedChunk = void 0;
                  try {
                    clonedChunk = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE), ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE), resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                  byobCanceled || ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk), ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                }
                reading = !1, readAgainForBranch1 ? pull1Algorithm() : readAgainForBranch2 && pull2Algorithm();
              });
            },
            _closeSteps: function(chunk) {
              reading = !1;
              var byobCanceled = forBranch2 ? canceled2 : canceled1, otherCanceled = forBranch2 ? canceled1 : canceled2;
              byobCanceled || ReadableByteStreamControllerClose(byobBranch._readableStreamController), otherCanceled || ReadableByteStreamControllerClose(otherBranch._readableStreamController), chunk !== void 0 && (byobCanceled || ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk), !otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0 && ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0)), (!byobCanceled || !otherCanceled) && resolveCancelPromise(void 0);
            },
            _errorSteps: function() {
              reading = !1;
            }
          };
          ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
        }
        function pull1Algorithm() {
          if (reading)
            return readAgainForBranch1 = !0, promiseResolvedWith(void 0);
          reading = !0;
          var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
          return byobRequest === null ? pullWithDefaultReader() : pullWithBYOBReader(byobRequest._view, !1), promiseResolvedWith(void 0);
        }
        function pull2Algorithm() {
          if (reading)
            return readAgainForBranch2 = !0, promiseResolvedWith(void 0);
          reading = !0;
          var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
          return byobRequest === null ? pullWithDefaultReader() : pullWithBYOBReader(byobRequest._view, !0), promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          if (canceled1 = !0, reason1 = reason, canceled2) {
            var compositeReason = CreateArrayFromList([reason1, reason2]), cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          if (canceled2 = !0, reason2 = reason, canceled1) {
            var compositeReason = CreateArrayFromList([reason1, reason2]), cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
        }
        return branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm), branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm), forwardReaderError(reader), [branch1, branch2];
      }
      function convertUnderlyingDefaultOrByteSource(source, context) {
        assertDictionary(source, context);
        var original = source, autoAllocateChunkSize = original == null ? void 0 : original.autoAllocateChunkSize, cancel = original == null ? void 0 : original.cancel, pull = original == null ? void 0 : original.pull, start = original == null ? void 0 : original.start, type = original == null ? void 0 : original.type;
        return {
          autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, context + " has member 'autoAllocateChunkSize' that"),
          cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, context + " has member 'cancel' that"),
          pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, context + " has member 'pull' that"),
          start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, context + " has member 'start' that"),
          type: type === void 0 ? void 0 : convertReadableStreamType(type, context + " has member 'type' that")
        };
      }
      function convertUnderlyingSourceCancelCallback(fn, original, context) {
        return assertFunction(fn, context), function(reason) {
          return promiseCall(fn, original, [reason]);
        };
      }
      function convertUnderlyingSourcePullCallback(fn, original, context) {
        return assertFunction(fn, context), function(controller) {
          return promiseCall(fn, original, [controller]);
        };
      }
      function convertUnderlyingSourceStartCallback(fn, original, context) {
        return assertFunction(fn, context), function(controller) {
          return reflectCall(fn, original, [controller]);
        };
      }
      function convertReadableStreamType(type, context) {
        if (type = "" + type, type !== "bytes")
          throw new TypeError(context + " '" + type + "' is not a valid enumeration value for ReadableStreamType");
        return type;
      }
      function convertReaderOptions(options, context) {
        assertDictionary(options, context);
        var mode = options == null ? void 0 : options.mode;
        return {
          mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, context + " has member 'mode' that")
        };
      }
      function convertReadableStreamReaderMode(mode, context) {
        if (mode = "" + mode, mode !== "byob")
          throw new TypeError(context + " '" + mode + "' is not a valid enumeration value for ReadableStreamReaderMode");
        return mode;
      }
      function convertIteratorOptions(options, context) {
        assertDictionary(options, context);
        var preventCancel = options == null ? void 0 : options.preventCancel;
        return { preventCancel: Boolean(preventCancel) };
      }
      function convertPipeOptions(options, context) {
        assertDictionary(options, context);
        var preventAbort = options == null ? void 0 : options.preventAbort, preventCancel = options == null ? void 0 : options.preventCancel, preventClose = options == null ? void 0 : options.preventClose, signal = options == null ? void 0 : options.signal;
        return signal !== void 0 && assertAbortSignal(signal, context + " has member 'signal' that"), {
          preventAbort: Boolean(preventAbort),
          preventCancel: Boolean(preventCancel),
          preventClose: Boolean(preventClose),
          signal
        };
      }
      function assertAbortSignal(signal, context) {
        if (!isAbortSignal2(signal))
          throw new TypeError(context + " is not an AbortSignal.");
      }
      function convertReadableWritablePair(pair, context) {
        assertDictionary(pair, context);
        var readable = pair == null ? void 0 : pair.readable;
        assertRequiredField(readable, "readable", "ReadableWritablePair"), assertReadableStream(readable, context + " has member 'readable' that");
        var writable = pair == null ? void 0 : pair.writable;
        return assertRequiredField(writable, "writable", "ReadableWritablePair"), assertWritableStream(writable, context + " has member 'writable' that"), { readable, writable };
      }
      var ReadableStream2 = (
        /** @class */
        function() {
          function ReadableStream3(rawUnderlyingSource, rawStrategy) {
            rawUnderlyingSource === void 0 && (rawUnderlyingSource = {}), rawStrategy === void 0 && (rawStrategy = {}), rawUnderlyingSource === void 0 ? rawUnderlyingSource = null : assertObject(rawUnderlyingSource, "First parameter");
            var strategy = convertQueuingStrategy(rawStrategy, "Second parameter"), underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
            if (InitializeReadableStream(this), underlyingSource.type === "bytes") {
              if (strategy.size !== void 0)
                throw new RangeError("The strategy for a byte stream cannot have a size function");
              var highWaterMark = ExtractHighWaterMark(strategy, 0);
              SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
            } else {
              var sizeAlgorithm = ExtractSizeAlgorithm(strategy), highWaterMark = ExtractHighWaterMark(strategy, 1);
              SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
            }
          }
          return Object.defineProperty(ReadableStream3.prototype, "locked", {
            /**
             * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
             */
            get: function() {
              if (!IsReadableStream(this))
                throw streamBrandCheckException$1("locked");
              return IsReadableStreamLocked(this);
            },
            enumerable: !1,
            configurable: !0
          }), ReadableStream3.prototype.cancel = function(reason) {
            return reason === void 0 && (reason = void 0), IsReadableStream(this) ? IsReadableStreamLocked(this) ? promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader")) : ReadableStreamCancel(this, reason) : promiseRejectedWith(streamBrandCheckException$1("cancel"));
          }, ReadableStream3.prototype.getReader = function(rawOptions) {
            if (rawOptions === void 0 && (rawOptions = void 0), !IsReadableStream(this))
              throw streamBrandCheckException$1("getReader");
            var options = convertReaderOptions(rawOptions, "First parameter");
            return options.mode === void 0 ? AcquireReadableStreamDefaultReader(this) : AcquireReadableStreamBYOBReader(this);
          }, ReadableStream3.prototype.pipeThrough = function(rawTransform, rawOptions) {
            if (rawOptions === void 0 && (rawOptions = {}), !IsReadableStream(this))
              throw streamBrandCheckException$1("pipeThrough");
            assertRequiredArgument(rawTransform, 1, "pipeThrough");
            var transform = convertReadableWritablePair(rawTransform, "First parameter"), options = convertPipeOptions(rawOptions, "Second parameter");
            if (IsReadableStreamLocked(this))
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
            if (IsWritableStreamLocked(transform.writable))
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
            var promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
            return setPromiseIsHandledToTrue(promise), transform.readable;
          }, ReadableStream3.prototype.pipeTo = function(destination, rawOptions) {
            if (rawOptions === void 0 && (rawOptions = {}), !IsReadableStream(this))
              return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
            if (destination === void 0)
              return promiseRejectedWith("Parameter 1 is required in 'pipeTo'.");
            if (!IsWritableStream(destination))
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
            var options;
            try {
              options = convertPipeOptions(rawOptions, "Second parameter");
            } catch (e2) {
              return promiseRejectedWith(e2);
            }
            return IsReadableStreamLocked(this) ? promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")) : IsWritableStreamLocked(destination) ? promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")) : ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
          }, ReadableStream3.prototype.tee = function() {
            if (!IsReadableStream(this))
              throw streamBrandCheckException$1("tee");
            var branches = ReadableStreamTee(this);
            return CreateArrayFromList(branches);
          }, ReadableStream3.prototype.values = function(rawOptions) {
            if (rawOptions === void 0 && (rawOptions = void 0), !IsReadableStream(this))
              throw streamBrandCheckException$1("values");
            var options = convertIteratorOptions(rawOptions, "First parameter");
            return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
          }, ReadableStream3;
        }()
      );
      Object.defineProperties(ReadableStream2.prototype, {
        cancel: { enumerable: !0 },
        getReader: { enumerable: !0 },
        pipeThrough: { enumerable: !0 },
        pipeTo: { enumerable: !0 },
        tee: { enumerable: !0 },
        values: { enumerable: !0 },
        locked: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStream",
        configurable: !0
      }), typeof SymbolPolyfill.asyncIterator == "symbol" && Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
        value: ReadableStream2.prototype.values,
        writable: !0,
        configurable: !0
      });
      function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        highWaterMark === void 0 && (highWaterMark = 1), sizeAlgorithm === void 0 && (sizeAlgorithm = function() {
          return 1;
        });
        var stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        var controller = Object.create(ReadableStreamDefaultController.prototype);
        return SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm), stream;
      }
      function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
        var stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        var controller = Object.create(ReadableByteStreamController.prototype);
        return SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0), stream;
      }
      function InitializeReadableStream(stream) {
        stream._state = "readable", stream._reader = void 0, stream._storedError = void 0, stream._disturbed = !1;
      }
      function IsReadableStream(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_readableStreamController") ? !1 : x2 instanceof ReadableStream2;
      }
      function IsReadableStreamLocked(stream) {
        return stream._reader !== void 0;
      }
      function ReadableStreamCancel(stream, reason) {
        if (stream._disturbed = !0, stream._state === "closed")
          return promiseResolvedWith(void 0);
        if (stream._state === "errored")
          return promiseRejectedWith(stream._storedError);
        ReadableStreamClose(stream);
        var reader = stream._reader;
        reader !== void 0 && IsReadableStreamBYOBReader(reader) && (reader._readIntoRequests.forEach(function(readIntoRequest) {
          readIntoRequest._closeSteps(void 0);
        }), reader._readIntoRequests = new SimpleQueue());
        var sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
        return transformPromiseWith(sourceCancelPromise, noop2);
      }
      function ReadableStreamClose(stream) {
        stream._state = "closed";
        var reader = stream._reader;
        reader !== void 0 && (defaultReaderClosedPromiseResolve(reader), IsReadableStreamDefaultReader(reader) && (reader._readRequests.forEach(function(readRequest) {
          readRequest._closeSteps();
        }), reader._readRequests = new SimpleQueue()));
      }
      function ReadableStreamError(stream, e2) {
        stream._state = "errored", stream._storedError = e2;
        var reader = stream._reader;
        reader !== void 0 && (defaultReaderClosedPromiseReject(reader, e2), IsReadableStreamDefaultReader(reader) ? (reader._readRequests.forEach(function(readRequest) {
          readRequest._errorSteps(e2);
        }), reader._readRequests = new SimpleQueue()) : (reader._readIntoRequests.forEach(function(readIntoRequest) {
          readIntoRequest._errorSteps(e2);
        }), reader._readIntoRequests = new SimpleQueue()));
      }
      function streamBrandCheckException$1(name) {
        return new TypeError("ReadableStream.prototype." + name + " can only be used on a ReadableStream");
      }
      function convertQueuingStrategyInit(init, context) {
        assertDictionary(init, context);
        var highWaterMark = init == null ? void 0 : init.highWaterMark;
        return assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit"), {
          highWaterMark: convertUnrestrictedDouble(highWaterMark)
        };
      }
      var byteLengthSizeFunction = function(chunk) {
        return chunk.byteLength;
      };
      try {
        Object.defineProperty(byteLengthSizeFunction, "name", {
          value: "size",
          configurable: !0
        });
      } catch {
      }
      var ByteLengthQueuingStrategy = (
        /** @class */
        function() {
          function ByteLengthQueuingStrategy2(options) {
            assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy"), options = convertQueuingStrategyInit(options, "First parameter"), this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
          }
          return Object.defineProperty(ByteLengthQueuingStrategy2.prototype, "highWaterMark", {
            /**
             * Returns the high water mark provided to the constructor.
             */
            get: function() {
              if (!IsByteLengthQueuingStrategy(this))
                throw byteLengthBrandCheckException("highWaterMark");
              return this._byteLengthQueuingStrategyHighWaterMark;
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(ByteLengthQueuingStrategy2.prototype, "size", {
            /**
             * Measures the size of `chunk` by returning the value of its `byteLength` property.
             */
            get: function() {
              if (!IsByteLengthQueuingStrategy(this))
                throw byteLengthBrandCheckException("size");
              return byteLengthSizeFunction;
            },
            enumerable: !1,
            configurable: !0
          }), ByteLengthQueuingStrategy2;
        }()
      );
      Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
        highWaterMark: { enumerable: !0 },
        size: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
        value: "ByteLengthQueuingStrategy",
        configurable: !0
      });
      function byteLengthBrandCheckException(name) {
        return new TypeError("ByteLengthQueuingStrategy.prototype." + name + " can only be used on a ByteLengthQueuingStrategy");
      }
      function IsByteLengthQueuingStrategy(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_byteLengthQueuingStrategyHighWaterMark") ? !1 : x2 instanceof ByteLengthQueuingStrategy;
      }
      var countSizeFunction = function() {
        return 1;
      };
      try {
        Object.defineProperty(countSizeFunction, "name", {
          value: "size",
          configurable: !0
        });
      } catch {
      }
      var CountQueuingStrategy = (
        /** @class */
        function() {
          function CountQueuingStrategy2(options) {
            assertRequiredArgument(options, 1, "CountQueuingStrategy"), options = convertQueuingStrategyInit(options, "First parameter"), this._countQueuingStrategyHighWaterMark = options.highWaterMark;
          }
          return Object.defineProperty(CountQueuingStrategy2.prototype, "highWaterMark", {
            /**
             * Returns the high water mark provided to the constructor.
             */
            get: function() {
              if (!IsCountQueuingStrategy(this))
                throw countBrandCheckException("highWaterMark");
              return this._countQueuingStrategyHighWaterMark;
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(CountQueuingStrategy2.prototype, "size", {
            /**
             * Measures the size of `chunk` by always returning 1.
             * This ensures that the total queue size is a count of the number of chunks in the queue.
             */
            get: function() {
              if (!IsCountQueuingStrategy(this))
                throw countBrandCheckException("size");
              return countSizeFunction;
            },
            enumerable: !1,
            configurable: !0
          }), CountQueuingStrategy2;
        }()
      );
      Object.defineProperties(CountQueuingStrategy.prototype, {
        highWaterMark: { enumerable: !0 },
        size: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
        value: "CountQueuingStrategy",
        configurable: !0
      });
      function countBrandCheckException(name) {
        return new TypeError("CountQueuingStrategy.prototype." + name + " can only be used on a CountQueuingStrategy");
      }
      function IsCountQueuingStrategy(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_countQueuingStrategyHighWaterMark") ? !1 : x2 instanceof CountQueuingStrategy;
      }
      function convertTransformer(original, context) {
        assertDictionary(original, context);
        var flush = original == null ? void 0 : original.flush, readableType = original == null ? void 0 : original.readableType, start = original == null ? void 0 : original.start, transform = original == null ? void 0 : original.transform, writableType = original == null ? void 0 : original.writableType;
        return {
          flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, context + " has member 'flush' that"),
          readableType,
          start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, context + " has member 'start' that"),
          transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, context + " has member 'transform' that"),
          writableType
        };
      }
      function convertTransformerFlushCallback(fn, original, context) {
        return assertFunction(fn, context), function(controller) {
          return promiseCall(fn, original, [controller]);
        };
      }
      function convertTransformerStartCallback(fn, original, context) {
        return assertFunction(fn, context), function(controller) {
          return reflectCall(fn, original, [controller]);
        };
      }
      function convertTransformerTransformCallback(fn, original, context) {
        return assertFunction(fn, context), function(chunk, controller) {
          return promiseCall(fn, original, [chunk, controller]);
        };
      }
      var TransformStream = (
        /** @class */
        function() {
          function TransformStream2(rawTransformer, rawWritableStrategy, rawReadableStrategy) {
            rawTransformer === void 0 && (rawTransformer = {}), rawWritableStrategy === void 0 && (rawWritableStrategy = {}), rawReadableStrategy === void 0 && (rawReadableStrategy = {}), rawTransformer === void 0 && (rawTransformer = null);
            var writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter"), readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter"), transformer = convertTransformer(rawTransformer, "First parameter");
            if (transformer.readableType !== void 0)
              throw new RangeError("Invalid readableType specified");
            if (transformer.writableType !== void 0)
              throw new RangeError("Invalid writableType specified");
            var readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0), readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy), writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1), writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy), startPromise_resolve, startPromise = newPromise(function(resolve) {
              startPromise_resolve = resolve;
            });
            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm), SetUpTransformStreamDefaultControllerFromTransformer(this, transformer), transformer.start !== void 0 ? startPromise_resolve(transformer.start(this._transformStreamController)) : startPromise_resolve(void 0);
          }
          return Object.defineProperty(TransformStream2.prototype, "readable", {
            /**
             * The readable side of the transform stream.
             */
            get: function() {
              if (!IsTransformStream(this))
                throw streamBrandCheckException("readable");
              return this._readable;
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(TransformStream2.prototype, "writable", {
            /**
             * The writable side of the transform stream.
             */
            get: function() {
              if (!IsTransformStream(this))
                throw streamBrandCheckException("writable");
              return this._writable;
            },
            enumerable: !1,
            configurable: !0
          }), TransformStream2;
        }()
      );
      Object.defineProperties(TransformStream.prototype, {
        readable: { enumerable: !0 },
        writable: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
        value: "TransformStream",
        configurable: !0
      });
      function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
        function startAlgorithm() {
          return startPromise;
        }
        function writeAlgorithm(chunk) {
          return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
        }
        function abortAlgorithm(reason) {
          return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
        }
        function closeAlgorithm() {
          return TransformStreamDefaultSinkCloseAlgorithm(stream);
        }
        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
        function pullAlgorithm() {
          return TransformStreamDefaultSourcePullAlgorithm(stream);
        }
        function cancelAlgorithm(reason) {
          return TransformStreamErrorWritableAndUnblockWrite(stream, reason), promiseResolvedWith(void 0);
        }
        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm), stream._backpressure = void 0, stream._backpressureChangePromise = void 0, stream._backpressureChangePromise_resolve = void 0, TransformStreamSetBackpressure(stream, !0), stream._transformStreamController = void 0;
      }
      function IsTransformStream(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_transformStreamController") ? !1 : x2 instanceof TransformStream;
      }
      function TransformStreamError(stream, e2) {
        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e2), TransformStreamErrorWritableAndUnblockWrite(stream, e2);
      }
      function TransformStreamErrorWritableAndUnblockWrite(stream, e2) {
        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController), WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e2), stream._backpressure && TransformStreamSetBackpressure(stream, !1);
      }
      function TransformStreamSetBackpressure(stream, backpressure) {
        stream._backpressureChangePromise !== void 0 && stream._backpressureChangePromise_resolve(), stream._backpressureChangePromise = newPromise(function(resolve) {
          stream._backpressureChangePromise_resolve = resolve;
        }), stream._backpressure = backpressure;
      }
      var TransformStreamDefaultController = (
        /** @class */
        function() {
          function TransformStreamDefaultController2() {
            throw new TypeError("Illegal constructor");
          }
          return Object.defineProperty(TransformStreamDefaultController2.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the readable sides internal queue. It can be negative, if the queue is over-full.
             */
            get: function() {
              if (!IsTransformStreamDefaultController(this))
                throw defaultControllerBrandCheckException("desiredSize");
              var readableController = this._controlledTransformStream._readable._readableStreamController;
              return ReadableStreamDefaultControllerGetDesiredSize(readableController);
            },
            enumerable: !1,
            configurable: !0
          }), TransformStreamDefaultController2.prototype.enqueue = function(chunk) {
            if (chunk === void 0 && (chunk = void 0), !IsTransformStreamDefaultController(this))
              throw defaultControllerBrandCheckException("enqueue");
            TransformStreamDefaultControllerEnqueue(this, chunk);
          }, TransformStreamDefaultController2.prototype.error = function(reason) {
            if (reason === void 0 && (reason = void 0), !IsTransformStreamDefaultController(this))
              throw defaultControllerBrandCheckException("error");
            TransformStreamDefaultControllerError(this, reason);
          }, TransformStreamDefaultController2.prototype.terminate = function() {
            if (!IsTransformStreamDefaultController(this))
              throw defaultControllerBrandCheckException("terminate");
            TransformStreamDefaultControllerTerminate(this);
          }, TransformStreamDefaultController2;
        }()
      );
      Object.defineProperties(TransformStreamDefaultController.prototype, {
        enqueue: { enumerable: !0 },
        error: { enumerable: !0 },
        terminate: { enumerable: !0 },
        desiredSize: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
        value: "TransformStreamDefaultController",
        configurable: !0
      });
      function IsTransformStreamDefaultController(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_controlledTransformStream") ? !1 : x2 instanceof TransformStreamDefaultController;
      }
      function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
        controller._controlledTransformStream = stream, stream._transformStreamController = controller, controller._transformAlgorithm = transformAlgorithm, controller._flushAlgorithm = flushAlgorithm;
      }
      function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
        var controller = Object.create(TransformStreamDefaultController.prototype), transformAlgorithm = function(chunk) {
          try {
            return TransformStreamDefaultControllerEnqueue(controller, chunk), promiseResolvedWith(void 0);
          } catch (transformResultE) {
            return promiseRejectedWith(transformResultE);
          }
        }, flushAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        transformer.transform !== void 0 && (transformAlgorithm = function(chunk) {
          return transformer.transform(chunk, controller);
        }), transformer.flush !== void 0 && (flushAlgorithm = function() {
          return transformer.flush(controller);
        }), SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
      }
      function TransformStreamDefaultControllerClearAlgorithms(controller) {
        controller._transformAlgorithm = void 0, controller._flushAlgorithm = void 0;
      }
      function TransformStreamDefaultControllerEnqueue(controller, chunk) {
        var stream = controller._controlledTransformStream, readableController = stream._readable._readableStreamController;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController))
          throw new TypeError("Readable side is not in a state that permits enqueue");
        try {
          ReadableStreamDefaultControllerEnqueue(readableController, chunk);
        } catch (e2) {
          throw TransformStreamErrorWritableAndUnblockWrite(stream, e2), stream._readable._storedError;
        }
        var backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
        backpressure !== stream._backpressure && TransformStreamSetBackpressure(stream, !0);
      }
      function TransformStreamDefaultControllerError(controller, e2) {
        TransformStreamError(controller._controlledTransformStream, e2);
      }
      function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
        var transformPromise = controller._transformAlgorithm(chunk);
        return transformPromiseWith(transformPromise, void 0, function(r2) {
          throw TransformStreamError(controller._controlledTransformStream, r2), r2;
        });
      }
      function TransformStreamDefaultControllerTerminate(controller) {
        var stream = controller._controlledTransformStream, readableController = stream._readable._readableStreamController;
        ReadableStreamDefaultControllerClose(readableController);
        var error = new TypeError("TransformStream terminated");
        TransformStreamErrorWritableAndUnblockWrite(stream, error);
      }
      function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
        var controller = stream._transformStreamController;
        if (stream._backpressure) {
          var backpressureChangePromise = stream._backpressureChangePromise;
          return transformPromiseWith(backpressureChangePromise, function() {
            var writable = stream._writable, state = writable._state;
            if (state === "erroring")
              throw writable._storedError;
            return TransformStreamDefaultControllerPerformTransform(controller, chunk);
          });
        }
        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
      }
      function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
        return TransformStreamError(stream, reason), promiseResolvedWith(void 0);
      }
      function TransformStreamDefaultSinkCloseAlgorithm(stream) {
        var readable = stream._readable, controller = stream._transformStreamController, flushPromise = controller._flushAlgorithm();
        return TransformStreamDefaultControllerClearAlgorithms(controller), transformPromiseWith(flushPromise, function() {
          if (readable._state === "errored")
            throw readable._storedError;
          ReadableStreamDefaultControllerClose(readable._readableStreamController);
        }, function(r2) {
          throw TransformStreamError(stream, r2), readable._storedError;
        });
      }
      function TransformStreamDefaultSourcePullAlgorithm(stream) {
        return TransformStreamSetBackpressure(stream, !1), stream._backpressureChangePromise;
      }
      function defaultControllerBrandCheckException(name) {
        return new TypeError("TransformStreamDefaultController.prototype." + name + " can only be used on a TransformStreamDefaultController");
      }
      function streamBrandCheckException(name) {
        return new TypeError("TransformStream.prototype." + name + " can only be used on a TransformStream");
      }
      exports2.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy, exports2.CountQueuingStrategy = CountQueuingStrategy, exports2.ReadableByteStreamController = ReadableByteStreamController, exports2.ReadableStream = ReadableStream2, exports2.ReadableStreamBYOBReader = ReadableStreamBYOBReader, exports2.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest, exports2.ReadableStreamDefaultController = ReadableStreamDefaultController, exports2.ReadableStreamDefaultReader = ReadableStreamDefaultReader, exports2.TransformStream = TransformStream, exports2.TransformStreamDefaultController = TransformStreamDefaultController, exports2.WritableStream = WritableStream, exports2.WritableStreamDefaultController = WritableStreamDefaultController, exports2.WritableStreamDefaultWriter = WritableStreamDefaultWriter, Object.defineProperty(exports2, "__esModule", { value: !0 });
    });
  }
});

// node_modules/@remix-run/web-stream/src/stream.cjs
var require_stream = __commonJS({
  "node_modules/@remix-run/web-stream/src/stream.cjs"(exports, module2) {
    module2.exports = require_ponyfill();
  }
});

// node_modules/@remix-run/web-blob/dist/src/blob.cjs
var require_blob = __commonJS({
  "node_modules/@remix-run/web-blob/dist/src/blob.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var webEncoding = require_lib(), webStream = require_stream(), WebBlob = class Blob4 {
      /**
       * @param {BlobPart[]} [init]
       * @param {BlobPropertyBag} [options]
       */
      constructor(init = [], options = {}) {
        let parts = [], size = 0;
        for (let part of init)
          if (typeof part == "string") {
            let bytes = new webEncoding.TextEncoder().encode(part);
            parts.push(bytes), size += bytes.byteLength;
          } else if (part instanceof WebBlob)
            size += part.size, parts.push(...part._parts);
          else if (part instanceof ArrayBuffer)
            parts.push(new Uint8Array(part)), size += part.byteLength;
          else if (part instanceof Uint8Array)
            parts.push(part), size += part.byteLength;
          else if (ArrayBuffer.isView(part)) {
            let { buffer, byteOffset, byteLength } = part;
            parts.push(new Uint8Array(buffer, byteOffset, byteLength)), size += byteLength;
          } else {
            let bytes = new webEncoding.TextEncoder().encode(String(part));
            parts.push(bytes), size += bytes.byteLength;
          }
        this._size = size, this._type = readType(options.type), this._parts = parts, Object.defineProperties(this, {
          _size: { enumerable: !1 },
          _type: { enumerable: !1 },
          _parts: { enumerable: !1 }
        });
      }
      /**
       * A string indicating the MIME type of the data contained in the Blob.
       * If the type is unknown, this string is empty.
       * @type {string}
       */
      get type() {
        return this._type;
      }
      /**
       * The size, in bytes, of the data contained in the Blob object.
       * @type {number}
       */
      get size() {
        return this._size;
      }
      /**
       * Returns a new Blob object containing the data in the specified range of
       * bytes of the blob on which it's called.
       * @param {number} [start=0] - An index into the Blob indicating the first
       * byte to include in the new Blob. If you specify a negative value, it's
       * treated as an offset from the end of the Blob toward the beginning. For
       * example, `-10` would be the 10th from last byte in the Blob. The default
       * value is `0`. If you specify a value for start that is larger than the
       * size of the source Blob, the returned Blob has size 0 and contains no
       * data.
       * @param {number} [end] - An index into the `Blob` indicating the first byte
       *  that will *not* be included in the new `Blob` (i.e. the byte exactly at
       * this index is not included). If you specify a negative value, it's treated
       * as an offset from the end of the Blob toward the beginning. For example,
       * `-10` would be the 10th from last byte in the `Blob`. The default value is
       * size.
       * @param {string} [type] - The content type to assign to the new Blob;
       * this will be the value of its type property. The default value is an empty
       * string.
       * @returns {Blob}
       */
      slice(start = 0, end = this.size, type = "") {
        let { size, _parts: _parts2 } = this, offset = start < 0 ? Math.max(size + start, 0) : Math.min(start, size), limit = end < 0 ? Math.max(size + end, 0) : Math.min(end, size), span = Math.max(limit - offset, 0), blob = new Blob4([], { type });
        if (span === 0)
          return blob;
        let blobSize = 0, blobParts = [];
        for (let part of _parts2) {
          let { byteLength } = part;
          if (offset > 0 && byteLength <= offset)
            offset -= byteLength, limit -= byteLength;
          else {
            let chunk = part.subarray(offset, Math.min(byteLength, limit));
            if (blobParts.push(chunk), blobSize += chunk.byteLength, offset = 0, blobSize >= span)
              break;
          }
        }
        return blob._parts = blobParts, blob._size = blobSize, blob;
      }
      /**
       * Returns a promise that resolves with an ArrayBuffer containing the entire
       * contents of the Blob as binary data.
       * @returns {Promise<ArrayBuffer>}
       */
      // eslint-disable-next-line require-await
      async arrayBuffer() {
        let buffer = new ArrayBuffer(this.size), bytes = new Uint8Array(buffer), offset = 0;
        for (let part of this._parts)
          bytes.set(part, offset), offset += part.byteLength;
        return buffer;
      }
      /**
       * Returns a promise that resolves with a USVString containing the entire
       * contents of the Blob interpreted as UTF-8 text.
       * @returns {Promise<string>}
       */
      // eslint-disable-next-line require-await
      async text() {
        let decoder = new webEncoding.TextDecoder(), text = "";
        for (let part of this._parts)
          text += decoder.decode(part);
        return text;
      }
      /**
       * @returns {BlobStream}
       */
      stream() {
        return new BlobStream(this._parts);
      }
      /**
       * @returns {string}
       */
      toString() {
        return "[object Blob]";
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
    }, Blob3 = WebBlob, BlobStream = class extends webStream.ReadableStream {
      /**
       * @param {Uint8Array[]} chunks
       */
      constructor(chunks) {
        super(new BlobStreamController(chunks.values()), { type: "bytes" }), this._chunks = chunks;
      }
      /**
       * @param {Object} [_options]
       * @property {boolean} [_options.preventCancel]
       * @returns {AsyncIterator<Uint8Array>}
       */
      async *[Symbol.asyncIterator](_options) {
        let reader = this.getReader();
        yield* this._chunks, reader.releaseLock();
      }
    }, BlobStreamController = class {
      /**
       * @param {Iterator<Uint8Array>} chunks
       */
      constructor(chunks) {
        this.chunks = chunks;
      }
      /**
       * @param {ReadableStreamDefaultController} controller
       */
      start(controller) {
        this.work(controller), this.isWorking = !1, this.isCancelled = !1;
      }
      /**
       *
       * @param {ReadableStreamDefaultController} controller
       */
      async work(controller) {
        let { chunks } = this;
        for (this.isWorking = !0; !this.isCancelled && (controller.desiredSize || 0) > 0; ) {
          let next = null;
          try {
            next = chunks.next();
          } catch (error) {
            controller.error(error);
            break;
          }
          next && (!next.done && !this.isCancelled ? controller.enqueue(next.value) : controller.close());
        }
        this.isWorking = !1;
      }
      /**
       * @param {ReadableStreamDefaultController} controller
       */
      pull(controller) {
        this.isWorking || this.work(controller);
      }
      cancel() {
        this.isCancelled = !0;
      }
    }, readType = (input = "") => {
      let type = String(input).toLowerCase();
      return /[^\u0020-\u007E]/.test(type) ? "" : type;
    };
    Object.defineProperty(exports, "TextDecoder", {
      enumerable: !0,
      get: function() {
        return webEncoding.TextDecoder;
      }
    });
    Object.defineProperty(exports, "TextEncoder", {
      enumerable: !0,
      get: function() {
        return webEncoding.TextEncoder;
      }
    });
    Object.defineProperty(exports, "ReadableStream", {
      enumerable: !0,
      get: function() {
        return webStream.ReadableStream;
      }
    });
    exports.Blob = Blob3;
  }
});

// node_modules/@remix-run/web-blob/dist/src/lib.node.cjs
var require_lib_node = __commonJS({
  "node_modules/@remix-run/web-blob/dist/src/lib.node.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var webEncoding = require_lib(), webStream = require_stream(), blob = require_blob(), Blob3 = globalThis.Blob || // Disable node native blob until impractical perf issue is fixed
    // @see https://github.com/nodejs/node/issues/42108
    // NodeBlob ||
    blob.Blob;
    Object.defineProperty(exports, "TextDecoder", {
      enumerable: !0,
      get: function() {
        return webEncoding.TextDecoder;
      }
    });
    Object.defineProperty(exports, "TextEncoder", {
      enumerable: !0,
      get: function() {
        return webEncoding.TextEncoder;
      }
    });
    Object.defineProperty(exports, "ReadableStream", {
      enumerable: !0,
      get: function() {
        return webStream.ReadableStream;
      }
    });
    exports.Blob = Blob3;
  }
});

// node_modules/@remix-run/web-form-data/dist/src/form-data.cjs
var require_form_data = __commonJS({
  "node_modules/@remix-run/web-form-data/dist/src/form-data.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var FormData4 = class {
      /**
       * @param {HTMLFormElement} [form]
       */
      constructor(form) {
        if (this._entries = [], Object.defineProperty(this, "_entries", { enumerable: !1 }), isHTMLFormElement(form))
          for (let element of form.elements)
            if (isSelectElement(element))
              for (let option of element.options)
                option.selected && this.append(element.name, option.value);
            else
              isInputElement(element) && (element.checked || !["radio", "checkbox"].includes(element.type)) && element.name && this.append(element.name, element.value);
      }
      get [Symbol.toStringTag]() {
        return "FormData";
      }
      /**
       * Appends a new value onto an existing key inside a FormData object, or adds
       * the key if it does not already exist.
       *
       * The difference between `set` and `append` is that if the specified key
       * already exists, `set` will overwrite all existing values with the new one,
       * whereas `append` will append the new value onto the end of the existing
       * set of values.
       *
       * @param {string} name
       * @param {string|Blob|File} value - The name of the field whose data is
       * contained in value.
       * @param {string} [filename] - The filename reported to the server, when a
       * value is a `Blob` or a `File`. The default filename for a `Blob` objects is
       * `"blob"`. The default filename for a `File` is the it's name.
       */
      append(name, value = panic(
        new TypeError("FormData.append: requires at least 2 arguments")
      ), filename) {
        this._entries.push([name, toEntryValue(value, filename)]);
      }
      /**
       * Deletes a key and all its values from a FormData object.
       *
       * @param {string} name
       */
      delete(name = panic(new TypeError("FormData.delete: requires string argument"))) {
        let entries = this._entries, index = 0;
        for (; index < entries.length; ) {
          let [entryName] = (
            /** @type {[string, FormDataEntryValue]}*/
            entries[index]
          );
          entryName === name ? entries.splice(index, 1) : index++;
        }
      }
      /**
       * Returns the first value associated with a given key from within a
       * FormData object.
       *
       * @param {string} name
       * @returns {FormDataEntryValue|null}
       */
      get(name = panic(new TypeError("FormData.get: requires string argument"))) {
        for (let [entryName, value] of this._entries)
          if (entryName === name)
            return value;
        return null;
      }
      /**
       * Returns an array of all the values associated with a given key from within
       * a FormData.
       *
       * @param {string} name
       * @returns {FormDataEntryValue[]}
       */
      getAll(name = panic(new TypeError("FormData.getAll: requires string argument"))) {
        let values = [];
        for (let [entryName, value] of this._entries)
          entryName === name && values.push(value);
        return values;
      }
      /**
       * Returns a boolean stating whether a FormData object contains a certain key.
       *
       * @param {string} name
       */
      has(name = panic(new TypeError("FormData.has: requires string argument"))) {
        for (let [entryName] of this._entries)
          if (entryName === name)
            return !0;
        return !1;
      }
      /**
       * Sets a new value for an existing key inside a FormData object, or adds the
       * key/value if it does not already exist.
       *
       * @param {string} name
       * @param {string|Blob|File} value
       * @param {string} [filename]
       */
      set(name, value = panic(new TypeError("FormData.set: requires at least 2 arguments")), filename) {
        let index = 0, { _entries: entries } = this, entryValue = toEntryValue(value, filename), wasSet = !1;
        for (; index < entries.length; ) {
          let entry2 = (
            /** @type {[string, FormDataEntryValue]}*/
            entries[index]
          );
          entry2[0] === name ? wasSet ? entries.splice(index, 1) : (wasSet = !0, entry2[1] = entryValue, index++) : index++;
        }
        wasSet || entries.push([name, entryValue]);
      }
      /**
       * Method returns an iterator allowing to go through all key/value pairs
       * contained in this object.
       */
      entries() {
        return this._entries.values();
      }
      /**
       * Returns an iterator allowing to go through all keys of the key/value pairs
       * contained in this object.
       *
       * @returns {IterableIterator<string>}
       */
      *keys() {
        for (let [name] of this._entries)
          yield name;
      }
      /**
       * Returns an iterator allowing to go through all values contained in this
       * object.
       *
       * @returns {IterableIterator<FormDataEntryValue>}
       */
      *values() {
        for (let [_, value] of this._entries)
          yield value;
      }
      [Symbol.iterator]() {
        return this._entries.values();
      }
      /**
       * @param {(value: FormDataEntryValue, key: string, parent: globalThis.FormData) => void} fn
       * @param {any} [thisArg]
       * @returns {void}
       */
      forEach(fn, thisArg) {
        for (let [key, value] of this._entries)
          fn.call(thisArg, value, key, this);
      }
    }, isHTMLFormElement = (value) => Object.prototype.toString.call(value) === "[object HTMLFormElement]", toEntryValue = (value, filename) => {
      if (isFile(value))
        return filename != null ? new BlobFile([value], filename, value) : value;
      if (isBlob2(value))
        return new BlobFile([value], filename ?? "blob");
      if (filename != null && filename != "")
        throw new TypeError(
          "filename is only supported when value is Blob or File"
        );
      return `${value}`;
    }, isFile = (value) => Object.prototype.toString.call(value) === "[object File]" && typeof value.name == "string", isBlob2 = (value) => Object.prototype.toString.call(value) === "[object Blob]", BlobFile = class {
      /**
       * @param {[Blob]} parts
       * @param {string} name
       * @param {FilePropertyBag} [options]
       */
      constructor([blob], name, { lastModified = Date.now() } = {}) {
        this.blob = blob, this.name = name, this.lastModified = lastModified;
      }
      get webkitRelativePath() {
        return "";
      }
      get size() {
        return this.blob.size;
      }
      get type() {
        return this.blob.type;
      }
      /**
       *
       * @param {number} [start]
       * @param {number} [end]
       * @param {string} [contentType]
       */
      slice(start, end, contentType) {
        return this.blob.slice(start, end, contentType);
      }
      stream() {
        return this.blob.stream();
      }
      text() {
        return this.blob.text();
      }
      arrayBuffer() {
        return this.blob.arrayBuffer();
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    }, panic = (error) => {
      throw error;
    };
    function isSelectElement(element) {
      return element.tagName === "SELECT";
    }
    function isInputElement(element) {
      return element.tagName === "INPUT" || element.tagName === "TEXTAREA";
    }
    exports.FormData = FormData4;
  }
});

// node_modules/@remix-run/web-form-data/dist/src/lib.node.cjs
var require_lib_node2 = __commonJS({
  "node_modules/@remix-run/web-form-data/dist/src/lib.node.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var formData = require_form_data(), FormData4 = formData.FormData;
    exports.FormData = FormData4;
  }
});

// node_modules/@web3-storage/multipart-parser/cjs/src/utils.js
var require_utils = __commonJS({
  "node_modules/@web3-storage/multipart-parser/cjs/src/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function stringToArray(s2) {
      let utf8 = unescape(encodeURIComponent(s2));
      return Uint8Array.from(utf8, (_, i2) => utf8.charCodeAt(i2));
    }
    function arrayToString(a) {
      let utf8 = String.fromCharCode.apply(null, a);
      return decodeURIComponent(escape(utf8));
    }
    function mergeArrays(...arrays) {
      let out = new Uint8Array(arrays.reduce((total, arr) => total + arr.length, 0)), offset = 0;
      for (let arr of arrays)
        out.set(arr, offset), offset += arr.length;
      return out;
    }
    function arraysEqual(a, b) {
      if (a.length !== b.length)
        return !1;
      for (let i2 = 0; i2 < a.length; i2++)
        if (a[i2] !== b[i2])
          return !1;
      return !0;
    }
    exports.arrayToString = arrayToString;
    exports.arraysEqual = arraysEqual;
    exports.mergeArrays = mergeArrays;
    exports.stringToArray = stringToArray;
  }
});

// node_modules/@web3-storage/multipart-parser/cjs/src/search.js
var require_search = __commonJS({
  "node_modules/@web3-storage/multipart-parser/cjs/src/search.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var utils = require_utils();
    function coerce(a) {
      return a instanceof Uint8Array ? (index) => a[index] : a;
    }
    function jsmemcmp(buf1, pos1, buf2, pos2, len) {
      let fn1 = coerce(buf1), fn2 = coerce(buf2);
      for (let i2 = 0; i2 < len; ++i2)
        if (fn1(pos1 + i2) !== fn2(pos2 + i2))
          return !1;
      return !0;
    }
    function createOccurenceTable(s2) {
      let table = new Array(256).fill(s2.length);
      if (s2.length > 1)
        for (let i2 = 0; i2 < s2.length - 1; i2++)
          table[s2[i2]] = s2.length - 1 - i2;
      return table;
    }
    var MATCH = Symbol("Match"), StreamSearch = class {
      constructor(needle) {
        this._lookbehind = new Uint8Array(), typeof needle == "string" ? this._needle = needle = utils.stringToArray(needle) : this._needle = needle, this._lastChar = needle[needle.length - 1], this._occ = createOccurenceTable(needle);
      }
      feed(chunk) {
        let pos = 0, tokens, allTokens = [];
        for (; pos !== chunk.length; )
          [pos, ...tokens] = this._feed(chunk, pos), allTokens.push(...tokens);
        return allTokens;
      }
      end() {
        let tail = this._lookbehind;
        return this._lookbehind = new Uint8Array(), tail;
      }
      _feed(data, bufPos) {
        let tokens = [], pos = -this._lookbehind.length;
        if (pos < 0) {
          for (; pos < 0 && pos <= data.length - this._needle.length; ) {
            let ch = this._charAt(data, pos + this._needle.length - 1);
            if (ch === this._lastChar && this._memcmp(data, pos, this._needle.length - 1))
              return pos > -this._lookbehind.length && tokens.push(this._lookbehind.slice(0, this._lookbehind.length + pos)), tokens.push(MATCH), this._lookbehind = new Uint8Array(), [
                pos + this._needle.length,
                ...tokens
              ];
            pos += this._occ[ch];
          }
          if (pos < 0)
            for (; pos < 0 && !this._memcmp(data, pos, data.length - pos); )
              pos++;
          if (pos >= 0)
            tokens.push(this._lookbehind), this._lookbehind = new Uint8Array();
          else {
            let bytesToCutOff = this._lookbehind.length + pos;
            return bytesToCutOff > 0 && (tokens.push(this._lookbehind.slice(0, bytesToCutOff)), this._lookbehind = this._lookbehind.slice(bytesToCutOff)), this._lookbehind = Uint8Array.from(new Array(this._lookbehind.length + data.length), (_, i2) => this._charAt(data, i2 - this._lookbehind.length)), [
              data.length,
              ...tokens
            ];
          }
        }
        for (pos += bufPos; pos <= data.length - this._needle.length; ) {
          let ch = data[pos + this._needle.length - 1];
          if (ch === this._lastChar && data[pos] === this._needle[0] && jsmemcmp(this._needle, 0, data, pos, this._needle.length - 1))
            return pos > bufPos && tokens.push(data.slice(bufPos, pos)), tokens.push(MATCH), [
              pos + this._needle.length,
              ...tokens
            ];
          pos += this._occ[ch];
        }
        if (pos < data.length) {
          for (; pos < data.length && (data[pos] !== this._needle[0] || !jsmemcmp(data, pos, this._needle, 0, data.length - pos)); )
            ++pos;
          pos < data.length && (this._lookbehind = data.slice(pos));
        }
        return pos > 0 && tokens.push(data.slice(bufPos, pos < data.length ? pos : data.length)), [
          data.length,
          ...tokens
        ];
      }
      _charAt(data, pos) {
        return pos < 0 ? this._lookbehind[this._lookbehind.length + pos] : data[pos];
      }
      _memcmp(data, pos, len) {
        return jsmemcmp(this._charAt.bind(this, data), pos, this._needle, 0, len);
      }
    }, ReadableStreamSearch = class {
      constructor(needle, _readableStream) {
        this._readableStream = _readableStream, this._search = new StreamSearch(needle);
      }
      async *[Symbol.asyncIterator]() {
        let reader = this._readableStream.getReader();
        try {
          for (; ; ) {
            let result = await reader.read();
            if (result.done)
              break;
            yield* this._search.feed(result.value);
          }
          let tail = this._search.end();
          tail.length && (yield tail);
        } finally {
          reader.releaseLock();
        }
      }
    }, EOQ = Symbol("End of Queue"), QueueableStreamSearch = class {
      constructor(needle) {
        this._chunksQueue = [], this._closed = !1, this._search = new StreamSearch(needle);
      }
      push(...chunks) {
        if (this._closed)
          throw new Error("cannot call push after close");
        this._chunksQueue.push(...chunks), this._notify && this._notify();
      }
      close() {
        if (this._closed)
          throw new Error("close was already called");
        this._closed = !0, this._chunksQueue.push(EOQ), this._notify && this._notify();
      }
      async *[Symbol.asyncIterator]() {
        for (; ; ) {
          let chunk;
          for (; !(chunk = this._chunksQueue.shift()); )
            await new Promise((resolve) => this._notify = resolve), this._notify = void 0;
          if (chunk === EOQ)
            break;
          yield* this._search.feed(chunk);
        }
        let tail = this._search.end();
        tail.length && (yield tail);
      }
    };
    function splitChunks(chunks, needle) {
      let search = new StreamSearch(needle), outchunks = [[]];
      for (let chunk of chunks)
        for (let token of search.feed(chunk))
          token === MATCH ? outchunks.push([]) : outchunks[outchunks.length - 1].push(token);
      let end = search.end();
      return outchunks[outchunks.length - 1].push(end), outchunks.map((chunks2) => utils.mergeArrays(...chunks2));
    }
    function split(buf, needle) {
      return splitChunks([buf], needle);
    }
    async function* chunksIterator(iter) {
      let chunks = [];
      for await (let value of iter)
        value === MATCH ? (yield chunks, chunks = []) : chunks.push(value);
      yield chunks;
    }
    async function* stringIterator(iter) {
      for await (let chunk of chunksIterator(iter))
        yield chunk.map(utils.arrayToString).join("");
    }
    async function allStrings(iter) {
      let segments = [];
      for await (let value of stringIterator(iter))
        segments.push(value);
      return segments;
    }
    async function* arrayIterator(iter) {
      for await (let chunk of chunksIterator(iter))
        yield utils.mergeArrays(...chunk);
    }
    exports.MATCH = MATCH;
    exports.QueueableStreamSearch = QueueableStreamSearch;
    exports.ReadableStreamSearch = ReadableStreamSearch;
    exports.StreamSearch = StreamSearch;
    exports.allStrings = allStrings;
    exports.arrayIterator = arrayIterator;
    exports.chunksIterator = chunksIterator;
    exports.split = split;
    exports.splitChunks = splitChunks;
    exports.stringIterator = stringIterator;
  }
});

// node_modules/@web3-storage/multipart-parser/cjs/src/index.js
var require_src2 = __commonJS({
  "node_modules/@web3-storage/multipart-parser/cjs/src/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var search = require_search(), utils = require_utils(), mergeArrays2 = Function.prototype.apply.bind(utils.mergeArrays, void 0), dash = utils.stringToArray("--"), CRLF = utils.stringToArray(`\r
`);
    function parseContentDisposition(header) {
      let parts = header.split(";").map((part) => part.trim());
      if (parts.shift() !== "form-data")
        throw new Error('malformed content-disposition header: missing "form-data" in `' + JSON.stringify(parts) + "`");
      let out = {};
      for (let part of parts) {
        let kv = part.split("=", 2);
        if (kv.length !== 2)
          throw new Error("malformed content-disposition header: key-value pair not found - " + part + " in `" + header + "`");
        let [name, value] = kv;
        if (value[0] === '"' && value[value.length - 1] === '"')
          out[name] = value.slice(1, -1).replace(/\\"/g, '"');
        else if (value[0] !== '"' && value[value.length - 1] !== '"')
          out[name] = value;
        else if (value[0] === '"' && value[value.length - 1] !== '"' || value[0] !== '"' && value[value.length - 1] === '"')
          throw new Error("malformed content-disposition header: mismatched quotations in `" + header + "`");
      }
      if (!out.name)
        throw new Error("malformed content-disposition header: missing field name in `" + header + "`");
      return out;
    }
    function parsePartHeaders(lines) {
      let entries = [], disposition = !1, line;
      for (; typeof (line = lines.shift()) < "u"; ) {
        let colon = line.indexOf(":");
        if (colon === -1)
          throw new Error("malformed multipart-form header: missing colon");
        let header = line.slice(0, colon).trim().toLowerCase(), value = line.slice(colon + 1).trim();
        switch (header) {
          case "content-disposition":
            disposition = !0, entries.push(...Object.entries(parseContentDisposition(value)));
            break;
          case "content-type":
            entries.push([
              "contentType",
              value
            ]);
        }
      }
      if (!disposition)
        throw new Error("malformed multipart-form header: missing content-disposition");
      return Object.fromEntries(entries);
    }
    async function readHeaderLines(it, needle) {
      let firstChunk = !0, lastTokenWasMatch = !1, headerLines = [[]], crlfSearch = new search.StreamSearch(CRLF);
      for (; ; ) {
        let result = await it.next();
        if (result.done)
          throw new Error("malformed multipart-form data: unexpected end of stream");
        if (firstChunk && result.value !== search.MATCH && utils.arraysEqual(result.value.slice(0, 2), dash))
          return [
            void 0,
            new Uint8Array()
          ];
        let chunk;
        if (result.value !== search.MATCH)
          chunk = result.value;
        else if (!lastTokenWasMatch)
          chunk = needle;
        else
          throw new Error("malformed multipart-form data: unexpected boundary");
        if (!chunk.length)
          continue;
        firstChunk && (firstChunk = !1);
        let tokens = crlfSearch.feed(chunk);
        for (let [i2, token] of tokens.entries()) {
          let isMatch = token === search.MATCH;
          if (!(!isMatch && !token.length)) {
            if (lastTokenWasMatch && isMatch)
              return tokens.push(crlfSearch.end()), [
                headerLines.filter((chunks) => chunks.length).map(mergeArrays2).map(utils.arrayToString),
                utils.mergeArrays(...tokens.slice(i2 + 1).map((token2) => token2 === search.MATCH ? CRLF : token2))
              ];
            (lastTokenWasMatch = isMatch) ? headerLines.push([]) : headerLines[headerLines.length - 1].push(token);
          }
        }
      }
    }
    async function* streamMultipart(body, boundary) {
      let needle = utils.mergeArrays(dash, utils.stringToArray(boundary)), it = new search.ReadableStreamSearch(needle, body)[Symbol.asyncIterator]();
      for (; ; ) {
        let result = await it.next();
        if (result.done)
          return;
        if (result.value === search.MATCH)
          break;
      }
      let crlfSearch = new search.StreamSearch(CRLF);
      for (; ; ) {
        let feedChunk = function(chunk) {
          let chunks = [];
          for (let token of crlfSearch.feed(chunk))
            trailingCRLF && chunks.push(CRLF), (trailingCRLF = token === search.MATCH) || chunks.push(token);
          return utils.mergeArrays(...chunks);
        }, [headerLines, tail] = await readHeaderLines(it, needle);
        if (!headerLines)
          return;
        async function nextToken() {
          let result = await it.next();
          if (result.done)
            throw new Error("malformed multipart-form data: unexpected end of stream");
          return result;
        }
        let trailingCRLF = !1, done = !1;
        async function nextChunk() {
          let result = await nextToken(), chunk;
          if (result.value !== search.MATCH)
            chunk = result.value;
          else if (!trailingCRLF)
            chunk = CRLF;
          else
            return done = !0, { value: crlfSearch.end() };
          return { value: feedChunk(chunk) };
        }
        let bufferedChunks = [{ value: feedChunk(tail) }];
        for (yield {
          ...parsePartHeaders(headerLines),
          data: {
            [Symbol.asyncIterator]() {
              return this;
            },
            async next() {
              for (; ; ) {
                let result = bufferedChunks.shift();
                if (!result)
                  break;
                if (result.value.length > 0)
                  return result;
              }
              for (; ; ) {
                if (done)
                  return {
                    done,
                    value: void 0
                  };
                let result = await nextChunk();
                if (result.value.length > 0)
                  return result;
              }
            }
          }
        }; !done; )
          bufferedChunks.push(await nextChunk());
      }
    }
    async function* iterateMultipart(body, boundary) {
      for await (let part of streamMultipart(body, boundary)) {
        let chunks = [];
        for await (let chunk of part.data)
          chunks.push(chunk);
        yield {
          ...part,
          data: utils.mergeArrays(...chunks)
        };
      }
    }
    exports.iterateMultipart = iterateMultipart;
    exports.streamMultipart = streamMultipart;
  }
});

// node_modules/@remix-run/web-fetch/dist/lib.node.cjs
var require_lib_node3 = __commonJS({
  "node_modules/@remix-run/web-fetch/dist/lib.node.cjs"(exports, module2) {
    "use strict";
    var http3 = require("http"), https2 = require("https"), zlib2 = require("zlib"), fs2 = require("fs"), mime = require_mrmime(), dataUriToBuffer2 = require_src(), Stream3 = require("stream"), util = require("util"), webBlob = require_lib_node(), webFormData = require_lib_node2(), crypto = require("crypto"), multipartParser = require_src2(), url = require("url"), abortController = require_abort_controller(), FetchBaseError2 = class extends Error {
      /**
       * @param {string} message 
       * @param {string} type 
       */
      constructor(message, type) {
        super(message), Error.captureStackTrace(this, this.constructor), this.type = type;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    }, FetchError2 = class extends FetchBaseError2 {
      /**
       * @param  {string} message -      Error message for human
       * @param  {string} type -        Error type for machine
       * @param  {SystemError} [systemError] - For Node.js system error
       */
      constructor(message, type, systemError) {
        super(message, type), systemError && (this.code = this.errno = systemError.code, this.erroredSysCall = systemError.syscall);
      }
    }, NAME2 = Symbol.toStringTag, isURLSearchParameters2 = (object) => typeof object == "object" && typeof object.append == "function" && typeof object.delete == "function" && typeof object.get == "function" && typeof object.getAll == "function" && typeof object.has == "function" && typeof object.set == "function" && typeof object.sort == "function" && object[NAME2] === "URLSearchParams", isBlob2 = (object) => typeof object == "object" && typeof object.arrayBuffer == "function" && typeof object.type == "string" && typeof object.stream == "function" && typeof object.constructor == "function" && /^(Blob|File)$/.test(object[NAME2]);
    function isFormData(object) {
      return typeof object == "object" && typeof object.append == "function" && typeof object.set == "function" && typeof object.get == "function" && typeof object.getAll == "function" && typeof object.delete == "function" && typeof object.keys == "function" && typeof object.values == "function" && typeof object.entries == "function" && typeof object.constructor == "function" && object[NAME2] === "FormData";
    }
    var isMultipartFormDataStream = (value) => value instanceof Stream3 && typeof value.getBoundary == "function" && typeof value.hasKnownLength == "function" && typeof value.getLengthSync == "function", isAbortSignal2 = (object) => typeof object == "object" && (object[NAME2] === "AbortSignal" || object[NAME2] === "EventTarget"), isReadableStream = (value) => typeof value == "object" && typeof value.getReader == "function" && typeof value.cancel == "function" && typeof value.tee == "function", isIterable = (value) => value && Symbol.iterator in value, carriage = `\r
`, dashes = "-".repeat(2), carriageLength = Buffer.byteLength(carriage), getFooter = (boundary) => `${dashes}${boundary}${dashes}${carriage.repeat(2)}`;
    function getHeader(boundary, name, field) {
      let header = "";
      if (header += `${dashes}${boundary}${carriage}`, header += `Content-Disposition: form-data; name="${name}"`, isBlob2(field)) {
        let { name: name2 = "blob", type } = (
          /** @type {Blob & {name?:string}} */
          field
        );
        header += `; filename="${name2}"${carriage}`, header += `Content-Type: ${type || "application/octet-stream"}`;
      }
      return `${header}${carriage.repeat(2)}`;
    }
    var getBoundary = () => crypto.randomBytes(8).toString("hex");
    async function* formDataIterator(form, boundary) {
      let encoder2 = new TextEncoder();
      for (let [name, value] of form)
        yield encoder2.encode(getHeader(boundary, name, value)), isBlob2(value) ? yield* value.stream() : yield encoder2.encode(value), yield encoder2.encode(carriage);
      yield encoder2.encode(getFooter(boundary));
    }
    function getFormDataLength(form, boundary) {
      let length = 0;
      for (let [name, value] of form)
        length += Buffer.byteLength(getHeader(boundary, name, value)), isBlob2(value) ? length += value.size : length += Buffer.byteLength(String(value)), length += carriageLength;
      return length += Buffer.byteLength(getFooter(boundary)), length;
    }
    var toFormData2 = async (source) => {
      let { body, headers } = source, contentType = (headers == null ? void 0 : headers.get("Content-Type")) || "";
      if (contentType.startsWith("application/x-www-form-urlencoded") && body != null) {
        let form = new webFormData.FormData(), bodyText = await source.text();
        return new URLSearchParams(bodyText).forEach((v, k) => form.append(k, v)), form;
      }
      let [type, boundary] = contentType.split(/\s*;\s*boundary=/);
      if (type === "multipart/form-data" && boundary != null && body != null) {
        let form = new webFormData.FormData(), parts = multipartParser.iterateMultipart(body, boundary);
        for await (let { name, data, filename, contentType: contentType2 } of parts)
          filename ? form.append(name, new File([data], filename, { type: contentType2 })) : form.append(name, new TextDecoder().decode(data), filename);
        return form;
      } else
        throw new TypeError("Could not parse content as FormData.");
    }, encoder = new util.TextEncoder(), decoder = new util.TextDecoder(), encode = (text) => encoder.encode(text), decode = (bytes) => decoder.decode(bytes), { readableHighWaterMark } = new Stream3.Readable(), INTERNALS$2 = Symbol("Body internals"), Body2 = class {
      /**
       * @param {BodyInit|Stream|null} body
       * @param {{size?:number}} options
       */
      constructor(body, {
        size = 0
      } = {}) {
        let state = {
          /** @type {null|ReadableStream<Uint8Array>} */
          body: null,
          /** @type {string|null} */
          type: null,
          /** @type {number|null} */
          size: null,
          /** @type {null|string} */
          boundary: null,
          disturbed: !1,
          /** @type {null|Error} */
          error: null
        };
        if (this[INTERNALS$2] = state, body === null)
          state.body = null, state.size = 0;
        else if (isURLSearchParameters2(body)) {
          let bytes = encode(body.toString());
          state.body = fromBytes(bytes), state.size = bytes.byteLength, state.type = "application/x-www-form-urlencoded;charset=UTF-8";
        } else if (isBlob2(body))
          state.size = body.size, state.type = body.type || null, state.body = body.stream();
        else if (body instanceof Uint8Array)
          state.body = fromBytes(body), state.size = body.byteLength;
        else if (util.types.isAnyArrayBuffer(body)) {
          let bytes = new Uint8Array(body);
          state.body = fromBytes(bytes), state.size = bytes.byteLength;
        } else if (ArrayBuffer.isView(body)) {
          let bytes = new Uint8Array(body.buffer, body.byteOffset, body.byteLength);
          state.body = fromBytes(bytes), state.size = bytes.byteLength;
        } else if (isReadableStream(body))
          state.body = body;
        else if (isFormData(body)) {
          let boundary = `NodeFetchFormDataBoundary${getBoundary()}`;
          state.type = `multipart/form-data; boundary=${boundary}`, state.size = getFormDataLength(body, boundary), state.body = fromAsyncIterable(formDataIterator(body, boundary));
        } else if (isMultipartFormDataStream(body))
          state.type = `multipart/form-data; boundary=${body.getBoundary()}`, state.size = body.hasKnownLength() ? body.getLengthSync() : null, state.body = fromStream(body);
        else if (body instanceof Stream3)
          state.body = fromStream(body);
        else {
          let bytes = encode(String(body));
          state.type = "text/plain;charset=UTF-8", state.size = bytes.byteLength, state.body = fromBytes(bytes);
        }
        this.size = size;
      }
      /** @type {Headers} */
      /* c8 ignore next 3 */
      get headers() {
        throw new TypeError("'get headers' called on an object that does not implements interface.");
      }
      get body() {
        return this[INTERNALS$2].body;
      }
      get bodyUsed() {
        return this[INTERNALS$2].disturbed;
      }
      /**
       * Decode response as ArrayBuffer
       *
       * @return {Promise<ArrayBuffer>}
       */
      async arrayBuffer() {
        let { buffer, byteOffset, byteLength } = await consumeBody2(this);
        return buffer.slice(byteOffset, byteOffset + byteLength);
      }
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      async blob() {
        let ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].type || "", buf = await consumeBody2(this);
        return new webBlob.Blob([buf], {
          type: ct
        });
      }
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      async json() {
        return JSON.parse(await this.text());
      }
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      async text() {
        let buffer = await consumeBody2(this);
        return decode(buffer);
      }
      /**
       * @returns {Promise<FormData>}
       */
      async formData() {
        return toFormData2(this);
      }
    };
    Object.defineProperties(Body2.prototype, {
      body: { enumerable: !0 },
      bodyUsed: { enumerable: !0 },
      arrayBuffer: { enumerable: !0 },
      blob: { enumerable: !0 },
      json: { enumerable: !0 },
      text: { enumerable: !0 },
      formData: { enumerable: !0 }
    });
    async function consumeBody2(data) {
      let state = data[INTERNALS$2];
      if (state.disturbed)
        throw new TypeError(`body used already for: ${data.url}`);
      if (state.disturbed = !0, state.error)
        throw state.error;
      let { body } = state;
      if (body === null)
        return new Uint8Array(0);
      let [buffer, chunks, limit] = data.size > 0 ? [new Uint8Array(data.size), [], data.size] : [null, [], 1 / 0], offset = 0, source = streamIterator(body);
      try {
        for await (let chunk of source) {
          let bytes = chunk instanceof Uint8Array ? chunk : Buffer.from(chunk);
          if (offset + bytes.byteLength > limit) {
            let error = new FetchError2(`content size at ${data.url} over limit: ${limit}`, "max-size");
            throw source.throw(error), error;
          } else
            buffer ? buffer.set(bytes, offset) : chunks.push(bytes);
          offset += bytes.byteLength;
        }
        if (buffer) {
          if (offset < buffer.byteLength)
            throw new FetchError2(`Premature close of server response while trying to fetch ${data.url}`, "premature-close");
          return buffer;
        } else
          return writeBytes(new Uint8Array(offset), chunks);
      } catch (error) {
        if (error instanceof FetchBaseError2)
          throw error;
        if (error && error.name === "AbortError")
          throw error;
        {
          let e2 = (
            /** @type {import('./errors/fetch-error').SystemError} */
            error
          );
          throw new FetchError2(`Invalid response body while trying to fetch ${data.url}: ${e2.message}`, "system", e2);
        }
      }
    }
    var clone2 = (instance) => {
      let { body } = instance;
      if (instance.bodyUsed)
        throw new Error("cannot clone body after it is used");
      if (!body)
        return null;
      let [left, right] = body.tee();
      return instance[INTERNALS$2].body = left, right;
    }, extractContentType2 = (source) => source[INTERNALS$2].type, getTotalBytes2 = (source) => source[INTERNALS$2].size, writeToStream2 = (dest, { body }) => {
      body === null ? dest.end() : Stream3.Readable.from(streamIterator(body)).pipe(dest);
    }, StreamIterableIterator = class {
      /**
       * @param {ReadableStream<T>} stream
       */
      constructor(stream) {
        this.stream = stream, this.reader = null;
      }
      /**
       * @returns {AsyncGenerator<T, void, void>}
       */
      [Symbol.asyncIterator]() {
        return this;
      }
      getReader() {
        if (this.reader)
          return this.reader;
        let reader = this.stream.getReader();
        return this.reader = reader, reader;
      }
      /**
       * @returns {Promise<IteratorResult<T, void>>}
       */
      next() {
        return (
          /** @type {Promise<IteratorResult<T, void>>} */
          this.getReader().read()
        );
      }
      /**
       * @returns {Promise<IteratorResult<T, void>>}
       */
      async return() {
        return this.reader && await this.reader.cancel(), { done: !0, value: void 0 };
      }
      /**
       * 
       * @param {any} error 
       * @returns {Promise<IteratorResult<T, void>>}
       */
      async throw(error) {
        return await this.getReader().cancel(error), { done: !0, value: void 0 };
      }
    }, streamIterator = (stream) => new StreamIterableIterator(stream), writeBytes = (buffer, chunks) => {
      let offset = 0;
      for (let chunk of chunks)
        buffer.set(chunk, offset), offset += chunk.byteLength;
      return buffer;
    }, fromBytes = (bytes) => new webBlob.ReadableStream({
      start(controller) {
        controller.enqueue(bytes), controller.close();
      }
    }), fromAsyncIterable = (content) => new webBlob.ReadableStream(new AsyncIterablePump(content)), AsyncIterablePump = class {
      /**
       * @param {AsyncIterable<Uint8Array>} source
       */
      constructor(source) {
        this.source = source[Symbol.asyncIterator]();
      }
      /**
       * @param {ReadableStreamController<Uint8Array>} controller
       */
      async pull(controller) {
        try {
          for (; controller.desiredSize || 0 > 0; ) {
            let next = await this.source.next();
            if (next.done) {
              controller.close();
              break;
            } else
              controller.enqueue(next.value);
          }
        } catch (error) {
          controller.error(error);
        }
      }
      /**
       * @param {any} [reason]
       */
      cancel(reason) {
        reason ? typeof this.source.throw == "function" ? this.source.throw(reason) : typeof this.source.return == "function" && this.source.return() : typeof this.source.return == "function" && this.source.return();
      }
    }, fromStream = (source) => {
      let pump2 = new StreamPump(source);
      return new webBlob.ReadableStream(pump2, pump2);
    }, StreamPump = class {
      /**
       * @param {Stream & {
       * 	readableHighWaterMark?: number
       * 	readable?:boolean,
       * 	resume?: () => void,
       * 	pause?: () => void
       * 	destroy?: (error?:Error) => void
       * }} stream
       */
      constructor(stream) {
        this.highWaterMark = stream.readableHighWaterMark || readableHighWaterMark, this.accumalatedSize = 0, this.stream = stream, this.enqueue = this.enqueue.bind(this), this.error = this.error.bind(this), this.close = this.close.bind(this);
      }
      /**
       * @param {Uint8Array} [chunk]
       */
      size(chunk) {
        return (chunk == null ? void 0 : chunk.byteLength) || 0;
      }
      /**
       * @param {ReadableStreamController<Uint8Array>} controller
       */
      start(controller) {
        this.controller = controller, this.stream.on("data", this.enqueue), this.stream.once("error", this.error), this.stream.once("end", this.close), this.stream.once("close", this.close);
      }
      pull() {
        this.resume();
      }
      /**
       * @param {any} [reason]
       */
      cancel(reason) {
        this.stream.destroy && this.stream.destroy(reason), this.stream.off("data", this.enqueue), this.stream.off("error", this.error), this.stream.off("end", this.close), this.stream.off("close", this.close);
      }
      /**
       * @param {Uint8Array|string} chunk
       */
      enqueue(chunk) {
        if (this.controller)
          try {
            let bytes = chunk instanceof Uint8Array ? chunk : Buffer.from(chunk), available = (this.controller.desiredSize || 0) - bytes.byteLength;
            this.controller.enqueue(bytes), available <= 0 && this.pause();
          } catch {
            this.controller.error(new Error("Could not create Buffer, chunk must be of type string or an instance of Buffer, ArrayBuffer, or Array or an Array-like Object")), this.cancel();
          }
      }
      pause() {
        this.stream.pause && this.stream.pause();
      }
      resume() {
        this.stream.readable && this.stream.resume && this.stream.resume();
      }
      close() {
        this.controller && (this.controller.close(), delete this.controller);
      }
      /**
       * @param {Error} error 
       */
      error(error) {
        this.controller && (this.controller.error(error), delete this.controller);
      }
    }, validators = (
      /** @type {{validateHeaderName?:(name:string) => any, validateHeaderValue?:(name:string, value:string) => any}} */
      http3
    ), validateHeaderName2 = typeof validators.validateHeaderName == "function" ? validators.validateHeaderName : (
      /**
       * @param {string} name
       */
      (name) => {
        if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
          let err = new TypeError(`Header name must be a valid HTTP token [${name}]`);
          throw Object.defineProperty(err, "code", { value: "ERR_INVALID_HTTP_TOKEN" }), err;
        }
      }
    ), validateHeaderValue2 = typeof validators.validateHeaderValue == "function" ? validators.validateHeaderValue : (
      /**
       * @param {string} name
       * @param {string} value
       */
      (name, value) => {
        if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
          let err = new TypeError(`Invalid character in header content ["${name}"]`);
          throw Object.defineProperty(err, "code", { value: "ERR_INVALID_CHAR" }), err;
        }
      }
    ), Headers3 = class extends URLSearchParams {
      /**
       * Headers class
       *
       * @constructor
       * @param {HeadersInit} [init] - Response headers
       */
      constructor(init) {
        let result = [];
        if (init instanceof Headers3) {
          let raw = init.raw();
          for (let [name, values] of Object.entries(raw))
            result.push(...values.map((value) => [name, value]));
        } else if (init != null)
          if (isIterable(init))
            result = [...init].map((pair) => {
              if (typeof pair != "object" || util.types.isBoxedPrimitive(pair))
                throw new TypeError("Each header pair must be an iterable object");
              return [...pair];
            }).map((pair) => {
              if (pair.length !== 2)
                throw new TypeError("Each header pair must be a name/value tuple");
              return [...pair];
            });
          else if (typeof init == "object" && init !== null)
            result.push(...Object.entries(init));
          else
            throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        return result = result.length > 0 ? result.map(([name, value]) => (validateHeaderName2(name), validateHeaderValue2(name, String(value)), [String(name).toLowerCase(), String(value)])) : [], super(result), new Proxy(this, {
          get(target, p, receiver) {
            switch (p) {
              case "append":
              case "set":
                return (name, value) => (validateHeaderName2(name), validateHeaderValue2(name, String(value)), URLSearchParams.prototype[p].call(
                  target,
                  String(name).toLowerCase(),
                  String(value)
                ));
              case "delete":
              case "has":
              case "getAll":
                return (name) => (validateHeaderName2(name), URLSearchParams.prototype[p].call(
                  target,
                  String(name).toLowerCase()
                ));
              case "keys":
                return () => (target.sort(), new Set(URLSearchParams.prototype.keys.call(target)).keys());
              default:
                return Reflect.get(target, p, receiver);
            }
          }
          /* c8 ignore next */
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      /**
       *
       * @param {string} name
       */
      get(name) {
        let values = this.getAll(name);
        if (values.length === 0)
          return null;
        let value = values.join(", ");
        return /^content-encoding$/i.test(name) && (value = value.toLowerCase()), value;
      }
      /**
       * @param {(value: string, key: string, parent: this) => void} callback
       * @param {any} thisArg
       * @returns {void}
       */
      forEach(callback, thisArg = void 0) {
        for (let name of this.keys())
          Reflect.apply(callback, thisArg, [this.get(name), name, this]);
      }
      /**
       * @returns {IterableIterator<string>}
       */
      *values() {
        for (let name of this.keys())
          yield (
            /** @type {string} */
            this.get(name)
          );
      }
      /**
       * @returns {IterableIterator<[string, string]>}
       */
      *entries() {
        for (let name of this.keys())
          yield [
            name,
            /** @type {string} */
            this.get(name)
          ];
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      /**
       * Node-fetch non-spec method
       * returning all headers and their values as array
       * @returns {Record<string, string[]>}
       */
      raw() {
        return [...this.keys()].reduce(
          (result, key) => (result[key] = this.getAll(key), result),
          /** @type {Record<string, string[]>} */
          {}
        );
      }
      /**
       * For better console.log(headers) and also to convert Headers into Node.js Request compatible format
       */
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce(
          (result, key) => {
            let values = this.getAll(key);
            return key === "host" ? result[key] = values[0] : result[key] = values.length > 1 ? values : values[0], result;
          },
          /** @type {Record<string, string|string[]>} */
          {}
        );
      }
    };
    Object.defineProperties(
      Headers3.prototype,
      ["get", "entries", "forEach", "values"].reduce(
        (result, property) => (result[property] = { enumerable: !0 }, result),
        /** @type {Record<string, {enumerable:true}>} */
        {}
      )
    );
    function fromRawHeaders2(headers = []) {
      return new Headers3(
        headers.reduce(
          (result, value, index, array) => (index % 2 === 0 && result.push(array.slice(index, index + 2)), result),
          /** @type {string[][]} */
          []
        ).filter(([name, value]) => {
          try {
            return validateHeaderName2(name), validateHeaderValue2(name, String(value)), !0;
          } catch {
            return !1;
          }
        })
      );
    }
    var redirectStatus2 = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]), isRedirect2 = (code) => redirectStatus2.has(code), INTERNALS$1 = Symbol("Response internals"), Response4 = class extends Body2 {
      /**
       * @param {BodyInit|import('stream').Stream|null} [body] - Readable stream
       * @param {ResponseInit & Ext} [options] - Response options
       */
      constructor(body = null, options = {}) {
        super(body, options);
        let status = options.status || 200, headers = new Headers3(options.headers);
        if (body !== null && !headers.has("Content-Type")) {
          let contentType = extractContentType2(this);
          contentType && headers.append("Content-Type", contentType);
        }
        this[INTERNALS$1] = {
          url: options.url,
          status,
          statusText: options.statusText || "",
          headers,
          counter: options.counter || 0,
          highWaterMark: options.highWaterMark
        };
      }
      /**
       * @type {ResponseType}
       */
      get type() {
        return "default";
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      /**
       * @type {Headers}
       */
      get headers() {
        return this[INTERNALS$1].headers;
      }
      get highWaterMark() {
        return this[INTERNALS$1].highWaterMark;
      }
      /**
       * Clone this response
       *
       * @returns {Response}
       */
      clone() {
        return new Response4(clone2(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          size: this.size
        });
      }
      /**
       * @param {string} url    The URL that the new response is to originate from.
       * @param {number} status An optional status code for the response (e.g., 302.)
       * @returns {Response}    A Response object.
       */
      static redirect(url2, status = 302) {
        if (!isRedirect2(status))
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        return new Response4(null, {
          headers: {
            location: new URL(url2).toString()
          },
          status
        });
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response4.prototype, {
      url: { enumerable: !0 },
      status: { enumerable: !0 },
      ok: { enumerable: !0 },
      redirected: { enumerable: !0 },
      statusText: { enumerable: !0 },
      headers: { enumerable: !0 },
      clone: { enumerable: !0 }
    });
    var getSearch2 = (parsedURL) => {
      if (parsedURL.search)
        return parsedURL.search;
      let lastOffset = parsedURL.href.length - 1, hash = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
      return parsedURL.href[lastOffset - hash.length] === "?" ? "?" : "";
    }, INTERNALS4 = Symbol("Request internals"), forbiddenMethods = /* @__PURE__ */ new Set(["CONNECT", "TRACE", "TRACK"]), normalizedMethods = /* @__PURE__ */ new Set(["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"]), isRequest2 = (object) => typeof object == "object" && typeof object[INTERNALS4] == "object", Request3 = class extends Body2 {
      /**
       * @param {string|Request|URL} info  Url or Request instance
       * @param {RequestInit & RequestExtraOptions} init   Custom options
       */
      constructor(info, init = {}) {
        let parsedURL, settings;
        isRequest2(info) ? (parsedURL = new URL(info.url), settings = info) : (parsedURL = new URL(info), settings = {});
        let method = init.method || settings.method || "GET";
        if (forbiddenMethods.has(method.toUpperCase()))
          throw new TypeError(`Failed to construct 'Request': '${method}' HTTP method is unsupported.`);
        normalizedMethods.has(method.toUpperCase()) && (method = method.toUpperCase());
        let inputBody = init.body != null ? init.body : isRequest2(info) && info.body !== null ? clone2(info) : null;
        if (inputBody != null && (method === "GET" || method === "HEAD"))
          throw new TypeError("Request with GET/HEAD method cannot have body");
        super(inputBody, {
          size: init.size || settings.size || 0
        });
        let input = settings, headers = (
          /** @type {globalThis.Headers} */
          new Headers3(init.headers || input.headers || {})
        );
        if (inputBody !== null && !headers.has("Content-Type")) {
          let contentType = extractContentType2(this);
          contentType && headers.append("Content-Type", contentType);
        }
        let signal = "signal" in init ? init.signal : isRequest2(input) ? input.signal : null;
        if (signal != null && !isAbortSignal2(signal))
          throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
        if (!signal) {
          let AbortControllerConstructor = typeof AbortController < "u" ? AbortController : abortController.AbortController;
          signal = new AbortControllerConstructor().signal;
        }
        this[INTERNALS4] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          credentials: init.credentials || "same-origin",
          parsedURL,
          signal: signal || null
        }, this.keepalive, this.follow = init.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init.follow, this.compress = init.compress === void 0 ? input.compress === void 0 ? !0 : input.compress : init.compress, this.counter = init.counter || input.counter || 0, this.agent = init.agent || input.agent, this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384, this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || !1;
      }
      /**
       * @type {RequestCache}
       */
      get cache() {
        return "default";
      }
      /**
       * @type {RequestCredentials}
       */
      get credentials() {
        return this[INTERNALS4].credentials;
      }
      /**
       * @type {RequestDestination}
       */
      get destination() {
        return "";
      }
      get integrity() {
        return "";
      }
      /** @type {RequestMode} */
      get mode() {
        return "cors";
      }
      /** @type {string} */
      get referrer() {
        return "";
      }
      /** @type {ReferrerPolicy} */
      get referrerPolicy() {
        return "";
      }
      get method() {
        return this[INTERNALS4].method;
      }
      /**
       * @type {string}
       */
      get url() {
        return url.format(this[INTERNALS4].parsedURL);
      }
      /**
       * @type {globalThis.Headers}
       */
      get headers() {
        return this[INTERNALS4].headers;
      }
      get redirect() {
        return this[INTERNALS4].redirect;
      }
      /**
       * @returns {AbortSignal}
       */
      get signal() {
        return this[INTERNALS4].signal;
      }
      /**
       * Clone this request
       *
       * @return  {globalThis.Request}
       */
      clone() {
        return new Request3(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request3.prototype, {
      method: { enumerable: !0 },
      url: { enumerable: !0 },
      headers: { enumerable: !0 },
      redirect: { enumerable: !0 },
      clone: { enumerable: !0 },
      signal: { enumerable: !0 }
    });
    var getNodeRequestOptions2 = (request) => {
      let { parsedURL } = request[INTERNALS4], headers = new Headers3(request[INTERNALS4].headers);
      headers.has("Accept") || headers.set("Accept", "*/*");
      let contentLengthValue = null;
      if (request.body === null && /^(post|put)$/i.test(request.method) && (contentLengthValue = "0"), request.body !== null) {
        let totalBytes = getTotalBytes2(request);
        typeof totalBytes == "number" && !Number.isNaN(totalBytes) && (contentLengthValue = String(totalBytes));
      }
      contentLengthValue && headers.set("Content-Length", contentLengthValue), headers.has("User-Agent") || headers.set("User-Agent", "node-fetch"), request.compress && !headers.has("Accept-Encoding") && headers.set("Accept-Encoding", "gzip,deflate,br");
      let { agent } = request;
      typeof agent == "function" && (agent = agent(parsedURL)), !headers.has("Connection") && !agent && headers.set("Connection", "close");
      let search = getSearch2(parsedURL);
      return {
        path: parsedURL.pathname + search,
        pathname: parsedURL.pathname,
        hostname: parsedURL.hostname,
        protocol: parsedURL.protocol,
        port: parsedURL.port,
        hash: parsedURL.hash,
        search: parsedURL.search,
        // @ts-ignore - it does not has a query
        query: parsedURL.query,
        href: parsedURL.href,
        method: request.method,
        // @ts-ignore - not sure what this supposed to do
        headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
        insecureHTTPParser: request.insecureHTTPParser,
        agent
      };
    }, AbortError2 = class extends FetchBaseError2 {
      /**
       * @param {string} message 
       * @param {string} [type]
       */
      constructor(message, type = "aborted") {
        super(message, type);
      }
    }, supportedSchemas2 = /* @__PURE__ */ new Set(["data:", "http:", "https:", "file:"]);
    async function fetch4(url2, options_ = {}) {
      return new Promise((resolve, reject) => {
        let request = new Request3(url2, options_), options = getNodeRequestOptions2(request);
        if (!supportedSchemas2.has(options.protocol))
          throw new TypeError(`node-fetch cannot load ${url2}. URL scheme "${options.protocol.replace(/:$/, "")}" is not supported.`);
        if (options.protocol === "data:") {
          let data = dataUriToBuffer2(request.url.toString()), response2 = new Response4(data, { headers: { "Content-Type": data.typeFull } });
          resolve(response2);
          return;
        }
        if (options.protocol === "file:") {
          let stream = fs2.createReadStream(new URL(request.url)), type = mime.lookup(request.url) || "application/octet-stream", response2 = new Response4(stream, { headers: { "Content-Type": type } });
          resolve(response2);
          return;
        }
        let send = (options.protocol === "https:" ? https2 : http3).request, { signal } = request, response = null, response_ = null, abort = () => {
          let error = new AbortError2("The operation was aborted.");
          reject(error), request.body && request.body.cancel(error), response_ && response_.emit("error", error);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        let abortAndFinalize = () => {
          abort(), finalize();
        }, request_ = send(options);
        signal && signal.addEventListener("abort", abortAndFinalize);
        let finalize = () => {
          request_.abort(), signal && signal.removeEventListener("abort", abortAndFinalize);
        };
        request_.on("error", (err) => {
          reject(new FetchError2(`request to ${request.url} failed, reason: ${err.message}`, "system", err)), finalize();
        }), fixResponseChunkedTransferBadEnding2(request_, (err) => {
          signal && signal.aborted || response_ == null || response_.emit("error", err);
        }), parseInt(process.version.substring(1)) < 14 && request_.on("socket", (s2) => {
          s2.prependListener("close", (hadError) => {
            let hasDataListener = s2.listenerCount("data") > 0;
            if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
              let err = Object.assign(new Error("Premature close"), {
                code: "ERR_STREAM_PREMATURE_CLOSE"
              });
              response_ == null || response_.emit("error", err);
            }
          });
        }), request_.on("response", (incoming) => {
          response_ = incoming, request_.setTimeout(0);
          let headers = fromRawHeaders2(response_.rawHeaders);
          if (isRedirect2(Number(response_.statusCode))) {
            let location = headers.get("Location"), locationURL = location === null ? null : new URL(location, request.url);
            switch (request.redirect) {
              case "error":
                reject(new FetchError2(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect")), finalize();
                return;
              case "manual":
                locationURL !== null && headers.set("Location", locationURL.toString());
                break;
              case "follow": {
                if (locationURL === null)
                  break;
                if (request.counter >= request.follow) {
                  reject(new FetchError2(`maximum redirect reached at: ${request.url}`, "max-redirect")), finalize();
                  return;
                }
                let requestOptions = {
                  headers: new Headers3(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  // Note: We can not use `request.body` because send would have
                  // consumed it already.
                  body: options_.body,
                  signal,
                  size: request.size
                }, isStreamBody = requestOptions.body instanceof webBlob.ReadableStream || requestOptions.body instanceof Stream3.Readable;
                if (response_.statusCode !== 303 && isStreamBody) {
                  reject(new FetchError2("Cannot follow redirect with body being a readable stream", "unsupported-redirect")), finalize();
                  return;
                }
                (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") && (requestOptions.method = "GET", requestOptions.body = void 0, requestOptions.headers.delete("content-length")), fetch4(new Request3(locationURL.href, requestOptions)).then(resolve, reject), finalize();
                return;
              }
              default:
                return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
            }
          }
          signal && response_.once("end", () => {
            signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = Stream3.pipeline(response_, new Stream3.PassThrough(), reject);
          process.version < "v12.10" && response_.on("aborted", abortAndFinalize);
          let responseOptions = {
            url: request.url,
            status: response_.statusCode,
            statusText: response_.statusMessage,
            headers,
            size: request.size,
            counter: request.counter,
            highWaterMark: request.highWaterMark
          }, codings = headers.get("Content-Encoding");
          if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
            response = new Response4(body, responseOptions), resolve(response);
            return;
          }
          let zlibOptions = {
            flush: zlib2.Z_SYNC_FLUSH,
            finishFlush: zlib2.Z_SYNC_FLUSH
          };
          if (codings === "gzip" || codings === "x-gzip") {
            body = Stream3.pipeline(body, zlib2.createGunzip(zlibOptions), reject), response = new Response4(fromAsyncIterable(body), responseOptions), resolve(response);
            return;
          }
          if (codings === "deflate" || codings === "x-deflate") {
            Stream3.pipeline(response_, new Stream3.PassThrough(), reject).once("data", (chunk) => {
              (chunk[0] & 15) === 8 ? body = Stream3.pipeline(body, zlib2.createInflate(), reject) : body = Stream3.pipeline(body, zlib2.createInflateRaw(), reject), response = new Response4(fromAsyncIterable(body), responseOptions), resolve(response);
            });
            return;
          }
          if (codings === "br") {
            body = Stream3.pipeline(body, zlib2.createBrotliDecompress(), reject), response = new Response4(fromAsyncIterable(body), responseOptions), resolve(response);
            return;
          }
          response = new Response4(fromAsyncIterable(body), responseOptions), resolve(response);
        }), writeToStream2(request_, request);
      });
    }
    function fixResponseChunkedTransferBadEnding2(request, errorCallback) {
      let LAST_CHUNK = Buffer.from(`0\r
\r
`), isChunkedTransfer = !1, properLastChunkReceived = !1, previousChunk;
      request.on("response", (response) => {
        let { headers } = response;
        isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
      }), request.on("socket", (socket) => {
        let onSocketClose = () => {
          if (isChunkedTransfer && !properLastChunkReceived) {
            let error = Object.assign(new Error("Premature close"), {
              code: "ERR_STREAM_PREMATURE_CLOSE"
            });
            errorCallback(error);
          }
        }, onData = (buf) => {
          properLastChunkReceived = Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0, !properLastChunkReceived && previousChunk && (properLastChunkReceived = Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0), previousChunk = buf;
        };
        socket.prependListener("close", onSocketClose), socket.on("data", onData), request.on("close", () => {
          socket.removeListener("close", onSocketClose), socket.removeListener("data", onData);
        });
      });
    }
    Object.defineProperty(exports, "Blob", {
      enumerable: !0,
      get: function() {
        return webBlob.Blob;
      }
    });
    Object.defineProperty(exports, "ReadableStream", {
      enumerable: !0,
      get: function() {
        return webBlob.ReadableStream;
      }
    });
    Object.defineProperty(exports, "FormData", {
      enumerable: !0,
      get: function() {
        return webFormData.FormData;
      }
    });
    exports.Headers = Headers3;
    exports.Request = Request3;
    exports.Response = Response4;
    exports.default = fetch4;
    exports.fetch = fetch4;
    exports = module2.exports = Object.assign(fetch4, exports);
  }
});

// node_modules/@remix-run/web-file/dist/src/file.cjs
var require_file = __commonJS({
  "node_modules/@remix-run/web-file/dist/src/file.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var webBlob = require_lib_node(), File4 = class extends webBlob.Blob {
      /**
       *
       * @param {BlobPart[]} init
       * @param {string} name - A USVString representing the file name or the path
       * to the file.
       * @param {FilePropertyBag} [options]
       */
      constructor(init, name = panic(new TypeError("File constructor requires name argument")), options = {}) {
        super(init, options), this._name = name, this._lastModified = options.lastModified || Date.now();
      }
      /**
       * The name of the file referenced by the File object.
       * @type {string}
       */
      get name() {
        return this._name;
      }
      /**
       * The path the URL of the File is relative to.
       * @type {string}
       */
      get webkitRelativePath() {
        return "";
      }
      /**
       * Returns the last modified time of the file, in millisecond since the UNIX
       * epoch (January 1st, 1970 at Midnight).
       * @returns {number}
       */
      get lastModified() {
        return this._lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    }, panic = (error) => {
      throw error;
    };
    exports.File = File4;
  }
});

// node_modules/@remix-run/web-file/dist/src/lib.node.cjs
var require_lib_node4 = __commonJS({
  "node_modules/@remix-run/web-file/dist/src/lib.node.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var webBlob = require_lib_node(), file = require_file(), File4 = file.File;
    Object.defineProperty(exports, "Blob", {
      enumerable: !0,
      get: function() {
        return webBlob.Blob;
      }
    });
    exports.File = File4;
  }
});

// node_modules/@remix-run/node/dist/fetch.js
var require_fetch = __commonJS({
  "node_modules/@remix-run/node/dist/fetch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var webFetch = require_lib_node3(), webFile = require_lib_node4(), NodeRequest = class extends webFetch.Request {
      constructor(info, init) {
        super(info, init);
      }
      get headers() {
        return super.headers;
      }
      clone() {
        return new NodeRequest(this);
      }
    }, NodeResponse = class extends webFetch.Response {
      get headers() {
        return super.headers;
      }
      clone() {
        return super.clone();
      }
    }, fetch4 = (info, init) => (init = {
      // Disable compression handling so people can return the result of a fetch
      // directly in the loader without messing with the Content-Encoding header.
      compress: !1,
      ...init
    }, webFetch.fetch(info, init));
    Object.defineProperty(exports, "FormData", {
      enumerable: !0,
      get: function() {
        return webFetch.FormData;
      }
    });
    Object.defineProperty(exports, "Headers", {
      enumerable: !0,
      get: function() {
        return webFetch.Headers;
      }
    });
    Object.defineProperty(exports, "Blob", {
      enumerable: !0,
      get: function() {
        return webFile.Blob;
      }
    });
    Object.defineProperty(exports, "File", {
      enumerable: !0,
      get: function() {
        return webFile.File;
      }
    });
    exports.Request = NodeRequest;
    exports.Response = NodeResponse;
    exports.fetch = fetch4;
  }
});

// node_modules/@remix-run/node/dist/base64.js
var require_base642 = __commonJS({
  "node_modules/@remix-run/node/dist/base64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function atob2(a) {
      return Buffer.from(a, "base64").toString("binary");
    }
    function btoa2(b) {
      return Buffer.from(b, "binary").toString("base64");
    }
    exports.atob = atob2;
    exports.btoa = btoa2;
  }
});

// node_modules/@remix-run/node/dist/globals.js
var require_globals = __commonJS({
  "node_modules/@remix-run/node/dist/globals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var webStream = require_stream(), abortController = require_abort_controller(), base64 = require_base642(), fetch4 = require_fetch(), webFile = require_lib_node4(), webFetch = require_lib_node3();
    function installGlobals() {
      global.atob = base64.atob, global.btoa = base64.btoa, global.Blob = webFile.Blob, global.File = webFile.File, global.Headers = webFetch.Headers, global.Request = fetch4.Request, global.Response = fetch4.Response, global.fetch = fetch4.fetch, global.FormData = webFetch.FormData, global.ReadableStream = webStream.ReadableStream, global.WritableStream = webStream.WritableStream, global.AbortController = global.AbortController || abortController.AbortController;
    }
    exports.installGlobals = installGlobals;
  }
});

// node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/cookie/index.js"(exports) {
    "use strict";
    exports.parse = parse;
    exports.serialize = serialize;
    var decode = decodeURIComponent, encode = encodeURIComponent, fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse(str, options) {
      if (typeof str != "string")
        throw new TypeError("argument str must be a string");
      for (var obj = {}, opt = options || {}, pairs = str.split(";"), dec = opt.decode || decode, i2 = 0; i2 < pairs.length; i2++) {
        var pair = pairs[i2], index = pair.indexOf("=");
        if (!(index < 0)) {
          var key = pair.substring(0, index).trim();
          if (obj[key] == null) {
            var val = pair.substring(index + 1, pair.length).trim();
            val[0] === '"' && (val = val.slice(1, -1)), obj[key] = tryDecode(val, dec);
          }
        }
      }
      return obj;
    }
    function serialize(name, val, options) {
      var opt = options || {}, enc = opt.encode || encode;
      if (typeof enc != "function")
        throw new TypeError("option encode is invalid");
      if (!fieldContentRegExp.test(name))
        throw new TypeError("argument name is invalid");
      var value = enc(val);
      if (value && !fieldContentRegExp.test(value))
        throw new TypeError("argument val is invalid");
      var str = name + "=" + value;
      if (opt.maxAge != null) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge))
          throw new TypeError("option maxAge is invalid");
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain))
          throw new TypeError("option domain is invalid");
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path))
          throw new TypeError("option path is invalid");
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        if (typeof opt.expires.toUTCString != "function")
          throw new TypeError("option expires is invalid");
        str += "; Expires=" + opt.expires.toUTCString();
      }
      if (opt.httpOnly && (str += "; HttpOnly"), opt.secure && (str += "; Secure"), opt.sameSite) {
        var sameSite = typeof opt.sameSite == "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case !0:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function tryDecode(str, decode2) {
      try {
        return decode2(str);
      } catch {
        return str;
      }
    }
  }
});

// node_modules/@remix-run/server-runtime/dist/warnings.js
var require_warnings = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/warnings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var alreadyWarned = {};
    function warnOnce(condition, message) {
      !condition && !alreadyWarned[message] && (alreadyWarned[message] = !0, console.warn(message));
    }
    exports.warnOnce = warnOnce;
  }
});

// node_modules/@remix-run/server-runtime/dist/cookies.js
var require_cookies = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/cookies.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var cookie = require_cookie(), warnings = require_warnings(), createCookieFactory = ({
      sign,
      unsign
    }) => (name, cookieOptions = {}) => {
      let {
        secrets = [],
        ...options
      } = {
        path: "/",
        sameSite: "lax",
        ...cookieOptions
      };
      return warnOnceAboutExpiresCookie(name, options.expires), {
        get name() {
          return name;
        },
        get isSigned() {
          return secrets.length > 0;
        },
        get expires() {
          return typeof options.maxAge < "u" ? new Date(Date.now() + options.maxAge * 1e3) : options.expires;
        },
        async parse(cookieHeader, parseOptions) {
          if (!cookieHeader)
            return null;
          let cookies = cookie.parse(cookieHeader, {
            ...options,
            ...parseOptions
          });
          return name in cookies ? cookies[name] === "" ? "" : await decodeCookieValue(unsign, cookies[name], secrets) : null;
        },
        async serialize(value, serializeOptions) {
          return cookie.serialize(name, value === "" ? "" : await encodeCookieValue(sign, value, secrets), {
            ...options,
            ...serializeOptions
          });
        }
      };
    }, isCookie = (object) => object != null && typeof object.name == "string" && typeof object.isSigned == "boolean" && typeof object.parse == "function" && typeof object.serialize == "function";
    async function encodeCookieValue(sign, value, secrets) {
      let encoded = encodeData(value);
      return secrets.length > 0 && (encoded = await sign(encoded, secrets[0])), encoded;
    }
    async function decodeCookieValue(unsign, value, secrets) {
      if (secrets.length > 0) {
        for (let secret of secrets) {
          let unsignedValue = await unsign(value, secret);
          if (unsignedValue !== !1)
            return decodeData(unsignedValue);
        }
        return null;
      }
      return decodeData(value);
    }
    function encodeData(value) {
      return btoa(myUnescape(encodeURIComponent(JSON.stringify(value))));
    }
    function decodeData(value) {
      try {
        return JSON.parse(decodeURIComponent(myEscape(atob(value))));
      } catch {
        return {};
      }
    }
    function myEscape(value) {
      let str = value.toString(), result = "", index = 0, chr, code;
      for (; index < str.length; )
        chr = str.charAt(index++), /[\w*+\-./@]/.exec(chr) ? result += chr : (code = chr.charCodeAt(0), code < 256 ? result += "%" + hex(code, 2) : result += "%u" + hex(code, 4).toUpperCase());
      return result;
    }
    function hex(code, length) {
      let result = code.toString(16);
      for (; result.length < length; )
        result = "0" + result;
      return result;
    }
    function myUnescape(value) {
      let str = value.toString(), result = "", index = 0, chr, part;
      for (; index < str.length; ) {
        if (chr = str.charAt(index++), chr === "%") {
          if (str.charAt(index) === "u") {
            if (part = str.slice(index + 1, index + 5), /^[\da-f]{4}$/i.exec(part)) {
              result += String.fromCharCode(parseInt(part, 16)), index += 5;
              continue;
            }
          } else if (part = str.slice(index, index + 2), /^[\da-f]{2}$/i.exec(part)) {
            result += String.fromCharCode(parseInt(part, 16)), index += 2;
            continue;
          }
        }
        result += chr;
      }
      return result;
    }
    function warnOnceAboutExpiresCookie(name, expires) {
      warnings.warnOnce(!expires, `The "${name}" cookie has an "expires" property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use \`commitSession(session, { expires })\` if using a session storage object, or \`cookie.serialize("value", { expires })\` if you're using the cookie directly.`);
    }
    exports.createCookieFactory = createCookieFactory;
    exports.isCookie = isCookie;
  }
});

// node_modules/@remix-run/server-runtime/dist/formData.js
var require_formData = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/formData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var multipartParser = require_src2();
    function composeUploadHandlers(...handlers) {
      return async (part) => {
        for (let handler of handlers) {
          let value = await handler(part);
          if (typeof value < "u" && value !== null)
            return value;
        }
      };
    }
    async function parseMultipartFormData(request, uploadHandler) {
      let contentType = request.headers.get("Content-Type") || "", [type, boundary] = contentType.split(/\s*;\s*boundary=/);
      if (!request.body || !boundary || type !== "multipart/form-data")
        throw new TypeError("Could not parse content as FormData.");
      let formData = new FormData(), parts = multipartParser.streamMultipart(request.body, boundary);
      for await (let part of parts) {
        if (part.done)
          break;
        typeof part.filename == "string" && (part.filename = part.filename.split(/[/\\]/).pop());
        let value = await uploadHandler(part);
        typeof value < "u" && value !== null && formData.append(part.name, value);
      }
      return formData;
    }
    exports.composeUploadHandlers = composeUploadHandlers;
    exports.parseMultipartFormData = parseMultipartFormData;
  }
});

// node_modules/@remix-run/router/dist/router.cjs.js
var require_router_cjs = __commonJS({
  "node_modules/@remix-run/router/dist/router.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function _extends() {
      return _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    exports.Action = void 0;
    (function(Action) {
      Action.Pop = "POP", Action.Push = "PUSH", Action.Replace = "REPLACE";
    })(exports.Action || (exports.Action = {}));
    var PopStateEventType = "popstate";
    function createMemoryHistory(options) {
      options === void 0 && (options = {});
      let {
        initialEntries = ["/"],
        initialIndex,
        v5Compat = !1
      } = options, entries;
      entries = initialEntries.map((entry2, index2) => createMemoryLocation(entry2, typeof entry2 == "string" ? null : entry2.state, index2 === 0 ? "default" : void 0));
      let index = clampIndex(initialIndex ?? entries.length - 1), action3 = exports.Action.Pop, listener = null;
      function clampIndex(n) {
        return Math.min(Math.max(n, 0), entries.length - 1);
      }
      function getCurrentLocation() {
        return entries[index];
      }
      function createMemoryLocation(to, state, key) {
        state === void 0 && (state = null);
        let location = createLocation(entries ? getCurrentLocation().pathname : "/", to, state, key);
        return warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in memory history: " + JSON.stringify(to)), location;
      }
      function createHref(to) {
        return typeof to == "string" ? to : createPath(to);
      }
      return {
        get index() {
          return index;
        },
        get action() {
          return action3;
        },
        get location() {
          return getCurrentLocation();
        },
        createHref,
        createURL(to) {
          return new URL(createHref(to), "http://localhost");
        },
        encodeLocation(to) {
          let path = typeof to == "string" ? parsePath(to) : to;
          return {
            pathname: path.pathname || "",
            search: path.search || "",
            hash: path.hash || ""
          };
        },
        push(to, state) {
          action3 = exports.Action.Push;
          let nextLocation = createMemoryLocation(to, state);
          index += 1, entries.splice(index, entries.length, nextLocation), v5Compat && listener && listener({
            action: action3,
            location: nextLocation,
            delta: 1
          });
        },
        replace(to, state) {
          action3 = exports.Action.Replace;
          let nextLocation = createMemoryLocation(to, state);
          entries[index] = nextLocation, v5Compat && listener && listener({
            action: action3,
            location: nextLocation,
            delta: 0
          });
        },
        go(delta) {
          action3 = exports.Action.Pop;
          let nextIndex = clampIndex(index + delta), nextLocation = entries[nextIndex];
          index = nextIndex, listener && listener({
            action: action3,
            location: nextLocation,
            delta
          });
        },
        listen(fn) {
          return listener = fn, () => {
            listener = null;
          };
        }
      };
    }
    function createBrowserHistory(options) {
      options === void 0 && (options = {});
      function createBrowserLocation(window2, globalHistory) {
        let {
          pathname,
          search,
          hash
        } = window2.location;
        return createLocation(
          "",
          {
            pathname,
            search,
            hash
          },
          // state defaults to `null` because `window.history.state` does
          globalHistory.state && globalHistory.state.usr || null,
          globalHistory.state && globalHistory.state.key || "default"
        );
      }
      function createBrowserHref(window2, to) {
        return typeof to == "string" ? to : createPath(to);
      }
      return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
    }
    function createHashHistory(options) {
      options === void 0 && (options = {});
      function createHashLocation(window2, globalHistory) {
        let {
          pathname = "/",
          search = "",
          hash = ""
        } = parsePath(window2.location.hash.substr(1));
        return createLocation(
          "",
          {
            pathname,
            search,
            hash
          },
          // state defaults to `null` because `window.history.state` does
          globalHistory.state && globalHistory.state.usr || null,
          globalHistory.state && globalHistory.state.key || "default"
        );
      }
      function createHashHref(window2, to) {
        let base = window2.document.querySelector("base"), href = "";
        if (base && base.getAttribute("href")) {
          let url = window2.location.href, hashIndex = url.indexOf("#");
          href = hashIndex === -1 ? url : url.slice(0, hashIndex);
        }
        return href + "#" + (typeof to == "string" ? to : createPath(to));
      }
      function validateHashLocation(location, to) {
        warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")");
      }
      return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);
    }
    function invariant(value, message) {
      if (value === !1 || value === null || typeof value > "u")
        throw new Error(message);
    }
    function warning(cond, message) {
      if (!cond) {
        typeof console < "u" && console.warn(message);
        try {
          throw new Error(message);
        } catch {
        }
      }
    }
    function createKey() {
      return Math.random().toString(36).substr(2, 8);
    }
    function getHistoryState(location, index) {
      return {
        usr: location.state,
        key: location.key,
        idx: index
      };
    }
    function createLocation(current, to, state, key) {
      return state === void 0 && (state = null), _extends({
        pathname: typeof current == "string" ? current : current.pathname,
        search: "",
        hash: ""
      }, typeof to == "string" ? parsePath(to) : to, {
        state,
        // TODO: This could be cleaned up.  push/replace should probably just take
        // full Locations now and avoid the need to run through this flow at all
        // But that's a pretty big refactor to the current test suite so going to
        // keep as is for the time being and just let any incoming keys take precedence
        key: to && to.key || key || createKey()
      });
    }
    function createPath(_ref) {
      let {
        pathname = "/",
        search = "",
        hash = ""
      } = _ref;
      return search && search !== "?" && (pathname += search.charAt(0) === "?" ? search : "?" + search), hash && hash !== "#" && (pathname += hash.charAt(0) === "#" ? hash : "#" + hash), pathname;
    }
    function parsePath(path) {
      let parsedPath = {};
      if (path) {
        let hashIndex = path.indexOf("#");
        hashIndex >= 0 && (parsedPath.hash = path.substr(hashIndex), path = path.substr(0, hashIndex));
        let searchIndex = path.indexOf("?");
        searchIndex >= 0 && (parsedPath.search = path.substr(searchIndex), path = path.substr(0, searchIndex)), path && (parsedPath.pathname = path);
      }
      return parsedPath;
    }
    function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
      options === void 0 && (options = {});
      let {
        window: window2 = document.defaultView,
        v5Compat = !1
      } = options, globalHistory = window2.history, action3 = exports.Action.Pop, listener = null, index = getIndex();
      index == null && (index = 0, globalHistory.replaceState(_extends({}, globalHistory.state, {
        idx: index
      }), ""));
      function getIndex() {
        return (globalHistory.state || {
          idx: null
        }).idx;
      }
      function handlePop() {
        action3 = exports.Action.Pop;
        let nextIndex = getIndex(), delta = nextIndex == null ? null : nextIndex - index;
        index = nextIndex, listener && listener({
          action: action3,
          location: history.location,
          delta
        });
      }
      function push(to, state) {
        action3 = exports.Action.Push;
        let location = createLocation(history.location, to, state);
        validateLocation && validateLocation(location, to), index = getIndex() + 1;
        let historyState = getHistoryState(location, index), url = history.createHref(location);
        try {
          globalHistory.pushState(historyState, "", url);
        } catch (error) {
          if (error instanceof DOMException && error.name === "DataCloneError")
            throw error;
          window2.location.assign(url);
        }
        v5Compat && listener && listener({
          action: action3,
          location: history.location,
          delta: 1
        });
      }
      function replace(to, state) {
        action3 = exports.Action.Replace;
        let location = createLocation(history.location, to, state);
        validateLocation && validateLocation(location, to), index = getIndex();
        let historyState = getHistoryState(location, index), url = history.createHref(location);
        globalHistory.replaceState(historyState, "", url), v5Compat && listener && listener({
          action: action3,
          location: history.location,
          delta: 0
        });
      }
      function createURL(to) {
        let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href, href = typeof to == "string" ? to : createPath(to);
        return invariant(base, "No window.location.(origin|href) available to create URL for href: " + href), new URL(href, base);
      }
      let history = {
        get action() {
          return action3;
        },
        get location() {
          return getLocation(window2, globalHistory);
        },
        listen(fn) {
          if (listener)
            throw new Error("A history only accepts one active listener");
          return window2.addEventListener(PopStateEventType, handlePop), listener = fn, () => {
            window2.removeEventListener(PopStateEventType, handlePop), listener = null;
          };
        },
        createHref(to) {
          return createHref(window2, to);
        },
        createURL,
        encodeLocation(to) {
          let url = createURL(to);
          return {
            pathname: url.pathname,
            search: url.search,
            hash: url.hash
          };
        },
        push,
        replace,
        go(n) {
          return globalHistory.go(n);
        }
      };
      return history;
    }
    var ResultType;
    (function(ResultType2) {
      ResultType2.data = "data", ResultType2.deferred = "deferred", ResultType2.redirect = "redirect", ResultType2.error = "error";
    })(ResultType || (ResultType = {}));
    var immutableRouteKeys = /* @__PURE__ */ new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
    function isIndexRoute(route) {
      return route.index === !0;
    }
    function convertRoutesToDataRoutes(routes2, mapRouteProperties, parentPath, manifest) {
      return parentPath === void 0 && (parentPath = []), manifest === void 0 && (manifest = {}), routes2.map((route, index) => {
        let treePath = [...parentPath, index], id = typeof route.id == "string" ? route.id : treePath.join("-");
        if (invariant(route.index !== !0 || !route.children, "Cannot specify children on an index route"), invariant(!manifest[id], 'Found a route id collision on id "' + id + `".  Route id's must be globally unique within Data Router usages`), isIndexRoute(route)) {
          let indexRoute = _extends({}, route, mapRouteProperties(route), {
            id
          });
          return manifest[id] = indexRoute, indexRoute;
        } else {
          let pathOrLayoutRoute = _extends({}, route, mapRouteProperties(route), {
            id,
            children: void 0
          });
          return manifest[id] = pathOrLayoutRoute, route.children && (pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties, treePath, manifest)), pathOrLayoutRoute;
        }
      });
    }
    function matchRoutes(routes2, locationArg, basename) {
      basename === void 0 && (basename = "/");
      let location = typeof locationArg == "string" ? parsePath(locationArg) : locationArg, pathname = stripBasename(location.pathname || "/", basename);
      if (pathname == null)
        return null;
      let branches = flattenRoutes(routes2);
      rankRouteBranches(branches);
      let matches = null;
      for (let i2 = 0; matches == null && i2 < branches.length; ++i2)
        matches = matchRouteBranch(
          branches[i2],
          // Incoming pathnames are generally encoded from either window.location
          // or from router.navigate, but we want to match against the unencoded
          // paths in the route definitions.  Memory router locations won't be
          // encoded here but there also shouldn't be anything to decode so this
          // should be a safe operation.  This avoids needing matchRoutes to be
          // history-aware.
          safelyDecodeURI(pathname)
        );
      return matches;
    }
    function flattenRoutes(routes2, branches, parentsMeta, parentPath) {
      branches === void 0 && (branches = []), parentsMeta === void 0 && (parentsMeta = []), parentPath === void 0 && (parentPath = "");
      let flattenRoute = (route, index, relativePath) => {
        let meta = {
          relativePath: relativePath === void 0 ? route.path || "" : relativePath,
          caseSensitive: route.caseSensitive === !0,
          childrenIndex: index,
          route
        };
        meta.relativePath.startsWith("/") && (invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), meta.relativePath = meta.relativePath.slice(parentPath.length));
        let path = joinPaths([parentPath, meta.relativePath]), routesMeta = parentsMeta.concat(meta);
        route.children && route.children.length > 0 && (invariant(
          // Our types know better, but runtime JS may not!
          // @ts-expect-error
          route.index !== !0,
          "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
        ), flattenRoutes(route.children, branches, routesMeta, path)), !(route.path == null && !route.index) && branches.push({
          path,
          score: computeScore(path, route.index),
          routesMeta
        });
      };
      return routes2.forEach((route, index) => {
        var _route$path;
        if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?")))
          flattenRoute(route, index);
        else
          for (let exploded of explodeOptionalSegments(route.path))
            flattenRoute(route, index, exploded);
      }), branches;
    }
    function explodeOptionalSegments(path) {
      let segments = path.split("/");
      if (segments.length === 0)
        return [];
      let [first, ...rest] = segments, isOptional = first.endsWith("?"), required = first.replace(/\?$/, "");
      if (rest.length === 0)
        return isOptional ? [required, ""] : [required];
      let restExploded = explodeOptionalSegments(rest.join("/")), result = [];
      return result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/"))), isOptional && result.push(...restExploded), result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
    }
    function rankRouteBranches(branches) {
      branches.sort((a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map((meta) => meta.childrenIndex), b.routesMeta.map((meta) => meta.childrenIndex)));
    }
    var paramRe = /^:\w+$/, dynamicSegmentValue = 3, indexRouteValue = 2, emptySegmentValue = 1, staticSegmentValue = 10, splatPenalty = -2, isSplat = (s2) => s2 === "*";
    function computeScore(path, index) {
      let segments = path.split("/"), initialScore = segments.length;
      return segments.some(isSplat) && (initialScore += splatPenalty), index && (initialScore += indexRouteValue), segments.filter((s2) => !isSplat(s2)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
    }
    function compareIndexes(a, b) {
      return a.length === b.length && a.slice(0, -1).every((n, i2) => n === b[i2]) ? (
        // If two routes are siblings, we should try to match the earlier sibling
        // first. This allows people to have fine-grained control over the matching
        // behavior by simply putting routes with identical paths in the order they
        // want them tried.
        a[a.length - 1] - b[b.length - 1]
      ) : (
        // Otherwise, it doesn't really make sense to rank non-siblings by index,
        // so they sort equally.
        0
      );
    }
    function matchRouteBranch(branch, pathname) {
      let {
        routesMeta
      } = branch, matchedParams = {}, matchedPathname = "/", matches = [];
      for (let i2 = 0; i2 < routesMeta.length; ++i2) {
        let meta = routesMeta[i2], end = i2 === routesMeta.length - 1, remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/", match = matchPath({
          path: meta.relativePath,
          caseSensitive: meta.caseSensitive,
          end
        }, remainingPathname);
        if (!match)
          return null;
        Object.assign(matchedParams, match.params);
        let route = meta.route;
        matches.push({
          // TODO: Can this as be avoided?
          params: matchedParams,
          pathname: joinPaths([matchedPathname, match.pathname]),
          pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
          route
        }), match.pathnameBase !== "/" && (matchedPathname = joinPaths([matchedPathname, match.pathnameBase]));
      }
      return matches;
    }
    function generatePath(originalPath, params) {
      params === void 0 && (params = {});
      let path = originalPath;
      path.endsWith("*") && path !== "*" && !path.endsWith("/*") && (warning(!1, 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".')), path = path.replace(/\*$/, "/*"));
      let prefix = path.startsWith("/") ? "/" : "", segments = path.split(/\/+/).map((segment, index, array) => {
        if (index === array.length - 1 && segment === "*")
          return params["*"];
        let keyMatch = segment.match(/^:(\w+)(\??)$/);
        if (keyMatch) {
          let [, key, optional] = keyMatch, param = params[key];
          return optional === "?" ? param ?? "" : (param == null && invariant(!1, 'Missing ":' + key + '" param'), param);
        }
        return segment.replace(/\?$/g, "");
      }).filter((segment) => !!segment);
      return prefix + segments.join("/");
    }
    function matchPath(pattern, pathname) {
      typeof pattern == "string" && (pattern = {
        path: pattern,
        caseSensitive: !1,
        end: !0
      });
      let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end), match = pathname.match(matcher);
      if (!match)
        return null;
      let matchedPathname = match[0], pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1"), captureGroups = match.slice(1);
      return {
        params: paramNames.reduce((memo2, paramName, index) => {
          if (paramName === "*") {
            let splatValue = captureGroups[index] || "";
            pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
          }
          return memo2[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName), memo2;
        }, {}),
        pathname: matchedPathname,
        pathnameBase,
        pattern
      };
    }
    function compilePath(path, caseSensitive, end) {
      caseSensitive === void 0 && (caseSensitive = !1), end === void 0 && (end = !0), warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
      let paramNames = [], regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/\/:(\w+)/g, (_, paramName) => (paramNames.push(paramName), "/([^\\/]+)"));
      return path.endsWith("*") ? (paramNames.push("*"), regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : end ? regexpSource += "\\/*$" : path !== "" && path !== "/" && (regexpSource += "(?:(?=\\/|$))"), [new RegExp(regexpSource, caseSensitive ? void 0 : "i"), paramNames];
    }
    function safelyDecodeURI(value) {
      try {
        return decodeURI(value);
      } catch (error) {
        return warning(!1, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ").")), value;
      }
    }
    function safelyDecodeURIComponent(value, paramName) {
      try {
        return decodeURIComponent(value);
      } catch (error) {
        return warning(!1, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ").")), value;
      }
    }
    function stripBasename(pathname, basename) {
      if (basename === "/")
        return pathname;
      if (!pathname.toLowerCase().startsWith(basename.toLowerCase()))
        return null;
      let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length, nextChar = pathname.charAt(startIndex);
      return nextChar && nextChar !== "/" ? null : pathname.slice(startIndex) || "/";
    }
    function resolvePath(to, fromPathname) {
      fromPathname === void 0 && (fromPathname = "/");
      let {
        pathname: toPathname,
        search = "",
        hash = ""
      } = typeof to == "string" ? parsePath(to) : to;
      return {
        pathname: toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname,
        search: normalizeSearch(search),
        hash: normalizeHash(hash)
      };
    }
    function resolvePathname(relativePath, fromPathname) {
      let segments = fromPathname.replace(/\/+$/, "").split("/");
      return relativePath.split("/").forEach((segment) => {
        segment === ".." ? segments.length > 1 && segments.pop() : segment !== "." && segments.push(segment);
      }), segments.length > 1 ? segments.join("/") : "/";
    }
    function getInvalidPathError(char, field, dest, path) {
      return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
    }
    function getPathContributingMatches(matches) {
      return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);
    }
    function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
      isPathRelative === void 0 && (isPathRelative = !1);
      let to;
      typeof toArg == "string" ? to = parsePath(toArg) : (to = _extends({}, toArg), invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to)), invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to)), invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to)));
      let isEmptyPath = toArg === "" || to.pathname === "", toPathname = isEmptyPath ? "/" : to.pathname, from;
      if (isPathRelative || toPathname == null)
        from = locationPathname;
      else {
        let routePathnameIndex = routePathnames.length - 1;
        if (toPathname.startsWith("..")) {
          let toSegments = toPathname.split("/");
          for (; toSegments[0] === ".."; )
            toSegments.shift(), routePathnameIndex -= 1;
          to.pathname = toSegments.join("/");
        }
        from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
      }
      let path = resolvePath(to, from), hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/"), hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
      return !path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash) && (path.pathname += "/"), path;
    }
    function getToPathname(to) {
      return to === "" || to.pathname === "" ? "/" : typeof to == "string" ? parsePath(to).pathname : to.pathname;
    }
    var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/"), normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/"), normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search, normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash, json3 = function(data, init) {
      init === void 0 && (init = {});
      let responseInit = typeof init == "number" ? {
        status: init
      } : init, headers = new Headers(responseInit.headers);
      return headers.has("Content-Type") || headers.set("Content-Type", "application/json; charset=utf-8"), new Response(JSON.stringify(data), _extends({}, responseInit, {
        headers
      }));
    }, AbortedDeferredError = class extends Error {
    }, DeferredData = class {
      constructor(data, responseInit) {
        this.pendingKeysSet = /* @__PURE__ */ new Set(), this.subscribers = /* @__PURE__ */ new Set(), this.deferredKeys = [], invariant(data && typeof data == "object" && !Array.isArray(data), "defer() only accepts plain objects");
        let reject;
        this.abortPromise = new Promise((_, r2) => reject = r2), this.controller = new AbortController();
        let onAbort = () => reject(new AbortedDeferredError("Deferred data aborted"));
        this.unlistenAbortSignal = () => this.controller.signal.removeEventListener("abort", onAbort), this.controller.signal.addEventListener("abort", onAbort), this.data = Object.entries(data).reduce((acc, _ref) => {
          let [key, value] = _ref;
          return Object.assign(acc, {
            [key]: this.trackPromise(key, value)
          });
        }, {}), this.done && this.unlistenAbortSignal(), this.init = responseInit;
      }
      trackPromise(key, value) {
        if (!(value instanceof Promise))
          return value;
        this.deferredKeys.push(key), this.pendingKeysSet.add(key);
        let promise = Promise.race([value, this.abortPromise]).then((data) => this.onSettle(promise, key, null, data), (error) => this.onSettle(promise, key, error));
        return promise.catch(() => {
        }), Object.defineProperty(promise, "_tracked", {
          get: () => !0
        }), promise;
      }
      onSettle(promise, key, error, data) {
        return this.controller.signal.aborted && error instanceof AbortedDeferredError ? (this.unlistenAbortSignal(), Object.defineProperty(promise, "_error", {
          get: () => error
        }), Promise.reject(error)) : (this.pendingKeysSet.delete(key), this.done && this.unlistenAbortSignal(), error ? (Object.defineProperty(promise, "_error", {
          get: () => error
        }), this.emit(!1, key), Promise.reject(error)) : (Object.defineProperty(promise, "_data", {
          get: () => data
        }), this.emit(!1, key), data));
      }
      emit(aborted, settledKey) {
        this.subscribers.forEach((subscriber) => subscriber(aborted, settledKey));
      }
      subscribe(fn) {
        return this.subscribers.add(fn), () => this.subscribers.delete(fn);
      }
      cancel() {
        this.controller.abort(), this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k)), this.emit(!0);
      }
      async resolveData(signal) {
        let aborted = !1;
        if (!this.done) {
          let onAbort = () => this.cancel();
          signal.addEventListener("abort", onAbort), aborted = await new Promise((resolve) => {
            this.subscribe((aborted2) => {
              signal.removeEventListener("abort", onAbort), (aborted2 || this.done) && resolve(aborted2);
            });
          });
        }
        return aborted;
      }
      get done() {
        return this.pendingKeysSet.size === 0;
      }
      get unwrappedData() {
        return invariant(this.data !== null && this.done, "Can only unwrap data on initialized and settled deferreds"), Object.entries(this.data).reduce((acc, _ref2) => {
          let [key, value] = _ref2;
          return Object.assign(acc, {
            [key]: unwrapTrackedPromise(value)
          });
        }, {});
      }
      get pendingKeys() {
        return Array.from(this.pendingKeysSet);
      }
    };
    function isTrackedPromise(value) {
      return value instanceof Promise && value._tracked === !0;
    }
    function unwrapTrackedPromise(value) {
      if (!isTrackedPromise(value))
        return value;
      if (value._error)
        throw value._error;
      return value._data;
    }
    var defer = function(data, init) {
      init === void 0 && (init = {});
      let responseInit = typeof init == "number" ? {
        status: init
      } : init;
      return new DeferredData(data, responseInit);
    }, redirect3 = function(url, init) {
      init === void 0 && (init = 302);
      let responseInit = init;
      typeof responseInit == "number" ? responseInit = {
        status: responseInit
      } : typeof responseInit.status > "u" && (responseInit.status = 302);
      let headers = new Headers(responseInit.headers);
      return headers.set("Location", url), new Response(null, _extends({}, responseInit, {
        headers
      }));
    }, ErrorResponse = class {
      constructor(status, statusText, data, internal) {
        internal === void 0 && (internal = !1), this.status = status, this.statusText = statusText || "", this.internal = internal, data instanceof Error ? (this.data = data.toString(), this.error = data) : this.data = data;
      }
    };
    function isRouteErrorResponse2(error) {
      return error != null && typeof error.status == "number" && typeof error.statusText == "string" && typeof error.internal == "boolean" && "data" in error;
    }
    var validMutationMethodsArr = ["post", "put", "patch", "delete"], validMutationMethods = new Set(validMutationMethodsArr), validRequestMethodsArr = ["get", ...validMutationMethodsArr], validRequestMethods = new Set(validRequestMethodsArr), redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]), redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]), IDLE_NAVIGATION = {
      state: "idle",
      location: void 0,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0
    }, IDLE_FETCHER = {
      state: "idle",
      data: void 0,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0
    }, IDLE_BLOCKER = {
      state: "unblocked",
      proceed: void 0,
      reset: void 0,
      location: void 0
    }, ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, defaultMapRouteProperties = (route) => ({
      hasErrorBoundary: Boolean(route.hasErrorBoundary)
    });
    function createRouter(init) {
      let routerWindow = init.window ? init.window : typeof window < "u" ? window : void 0, isBrowser = typeof routerWindow < "u" && typeof routerWindow.document < "u" && typeof routerWindow.document.createElement < "u", isServer = !isBrowser;
      invariant(init.routes.length > 0, "You must provide a non-empty routes array to createRouter");
      let mapRouteProperties;
      if (init.mapRouteProperties)
        mapRouteProperties = init.mapRouteProperties;
      else if (init.detectErrorBoundary) {
        let detectErrorBoundary = init.detectErrorBoundary;
        mapRouteProperties = (route) => ({
          hasErrorBoundary: detectErrorBoundary(route)
        });
      } else
        mapRouteProperties = defaultMapRouteProperties;
      let manifest = {}, dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties, void 0, manifest), inFlightDataRoutes, basename = init.basename || "/", future2 = _extends({
        v7_normalizeFormMethod: !1,
        v7_prependBasename: !1
      }, init.future), unlistenHistory = null, subscribers = /* @__PURE__ */ new Set(), savedScrollPositions = null, getScrollRestorationKey = null, getScrollPosition = null, initialScrollRestored = init.hydrationData != null, initialMatches = matchRoutes(dataRoutes, init.history.location, basename), initialErrors = null;
      if (initialMatches == null) {
        let error = getInternalRouterError(404, {
          pathname: init.history.location.pathname
        }), {
          matches,
          route
        } = getShortCircuitMatches(dataRoutes);
        initialMatches = matches, initialErrors = {
          [route.id]: error
        };
      }
      let initialized = (
        // All initialMatches need to be loaded before we're ready.  If we have lazy
        // functions around still then we'll need to run them in initialize()
        !initialMatches.some((m2) => m2.route.lazy) && // And we have to either have no loaders or have been provided hydrationData
        (!initialMatches.some((m2) => m2.route.loader) || init.hydrationData != null)
      ), router, state = {
        historyAction: init.history.action,
        location: init.history.location,
        matches: initialMatches,
        initialized,
        navigation: IDLE_NAVIGATION,
        // Don't restore on initial updateState() if we were SSR'd
        restoreScrollPosition: init.hydrationData != null ? !1 : null,
        preventScrollReset: !1,
        revalidation: "idle",
        loaderData: init.hydrationData && init.hydrationData.loaderData || {},
        actionData: init.hydrationData && init.hydrationData.actionData || null,
        errors: init.hydrationData && init.hydrationData.errors || initialErrors,
        fetchers: /* @__PURE__ */ new Map(),
        blockers: /* @__PURE__ */ new Map()
      }, pendingAction = exports.Action.Pop, pendingPreventScrollReset = !1, pendingNavigationController, isUninterruptedRevalidation = !1, isRevalidationRequired = !1, cancelledDeferredRoutes = [], cancelledFetcherLoads = [], fetchControllers = /* @__PURE__ */ new Map(), incrementingLoadId = 0, pendingNavigationLoadId = -1, fetchReloadIds = /* @__PURE__ */ new Map(), fetchRedirectIds = /* @__PURE__ */ new Set(), fetchLoadMatches = /* @__PURE__ */ new Map(), activeDeferreds = /* @__PURE__ */ new Map(), blockerFunctions = /* @__PURE__ */ new Map(), ignoreNextHistoryUpdate = !1;
      function initialize() {
        return unlistenHistory = init.history.listen((_ref) => {
          let {
            action: historyAction,
            location,
            delta
          } = _ref;
          if (ignoreNextHistoryUpdate) {
            ignoreNextHistoryUpdate = !1;
            return;
          }
          warning(blockerFunctions.size === 0 || delta != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
          let blockerKey = shouldBlockNavigation({
            currentLocation: state.location,
            nextLocation: location,
            historyAction
          });
          if (blockerKey && delta != null) {
            ignoreNextHistoryUpdate = !0, init.history.go(delta * -1), updateBlocker(blockerKey, {
              state: "blocked",
              location,
              proceed() {
                updateBlocker(blockerKey, {
                  state: "proceeding",
                  proceed: void 0,
                  reset: void 0,
                  location
                }), init.history.go(delta);
              },
              reset() {
                deleteBlocker(blockerKey), updateState({
                  blockers: new Map(router.state.blockers)
                });
              }
            });
            return;
          }
          return startNavigation(historyAction, location);
        }), state.initialized || startNavigation(exports.Action.Pop, state.location), router;
      }
      function dispose() {
        unlistenHistory && unlistenHistory(), subscribers.clear(), pendingNavigationController && pendingNavigationController.abort(), state.fetchers.forEach((_, key) => deleteFetcher(key)), state.blockers.forEach((_, key) => deleteBlocker(key));
      }
      function subscribe(fn) {
        return subscribers.add(fn), () => subscribers.delete(fn);
      }
      function updateState(newState) {
        state = _extends({}, state, newState), subscribers.forEach((subscriber) => subscriber(state));
      }
      function completeNavigation(location, newState) {
        var _location$state, _location$state2;
        let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== !0, actionData;
        newState.actionData ? Object.keys(newState.actionData).length > 0 ? actionData = newState.actionData : actionData = null : isActionReload ? actionData = state.actionData : actionData = null;
        let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;
        for (let [key] of blockerFunctions)
          deleteBlocker(key);
        let preventScrollReset = pendingPreventScrollReset === !0 || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== !0;
        inFlightDataRoutes && (dataRoutes = inFlightDataRoutes, inFlightDataRoutes = void 0), updateState(_extends({}, newState, {
          // matches, errors, fetchers go through as-is
          actionData,
          loaderData,
          historyAction: pendingAction,
          location,
          initialized: !0,
          navigation: IDLE_NAVIGATION,
          revalidation: "idle",
          restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),
          preventScrollReset,
          blockers: new Map(state.blockers)
        })), isUninterruptedRevalidation || pendingAction === exports.Action.Pop || (pendingAction === exports.Action.Push ? init.history.push(location, location.state) : pendingAction === exports.Action.Replace && init.history.replace(location, location.state)), pendingAction = exports.Action.Pop, pendingPreventScrollReset = !1, isUninterruptedRevalidation = !1, isRevalidationRequired = !1, cancelledDeferredRoutes = [], cancelledFetcherLoads = [];
      }
      async function navigate(to, opts) {
        if (typeof to == "number") {
          init.history.go(to);
          return;
        }
        let normalizedPath = normalizeTo(state.location, state.matches, basename, future2.v7_prependBasename, to, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative), {
          path,
          submission,
          error
        } = normalizeNavigateOptions(future2.v7_normalizeFormMethod, !1, normalizedPath, opts), currentLocation = state.location, nextLocation = createLocation(state.location, path, opts && opts.state);
        nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));
        let userReplace = opts && opts.replace != null ? opts.replace : void 0, historyAction = exports.Action.Push;
        userReplace === !0 ? historyAction = exports.Action.Replace : userReplace === !1 || submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search && (historyAction = exports.Action.Replace);
        let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === !0 : void 0, blockerKey = shouldBlockNavigation({
          currentLocation,
          nextLocation,
          historyAction
        });
        if (blockerKey) {
          updateBlocker(blockerKey, {
            state: "blocked",
            location: nextLocation,
            proceed() {
              updateBlocker(blockerKey, {
                state: "proceeding",
                proceed: void 0,
                reset: void 0,
                location: nextLocation
              }), navigate(to, opts);
            },
            reset() {
              deleteBlocker(blockerKey), updateState({
                blockers: new Map(state.blockers)
              });
            }
          });
          return;
        }
        return await startNavigation(historyAction, nextLocation, {
          submission,
          // Send through the formData serialization error if we have one so we can
          // render at the right error boundary after we match routes
          pendingError: error,
          preventScrollReset,
          replace: opts && opts.replace
        });
      }
      function revalidate() {
        if (interruptActiveLoads(), updateState({
          revalidation: "loading"
        }), state.navigation.state !== "submitting") {
          if (state.navigation.state === "idle") {
            startNavigation(state.historyAction, state.location, {
              startUninterruptedRevalidation: !0
            });
            return;
          }
          startNavigation(pendingAction || state.historyAction, state.navigation.location, {
            overrideNavigation: state.navigation
          });
        }
      }
      async function startNavigation(historyAction, location, opts) {
        pendingNavigationController && pendingNavigationController.abort(), pendingNavigationController = null, pendingAction = historyAction, isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === !0, saveScrollPosition(state.location, state.matches), pendingPreventScrollReset = (opts && opts.preventScrollReset) === !0;
        let routesToUse = inFlightDataRoutes || dataRoutes, loadingNavigation = opts && opts.overrideNavigation, matches = matchRoutes(routesToUse, location, basename);
        if (!matches) {
          let error = getInternalRouterError(404, {
            pathname: location.pathname
          }), {
            matches: notFoundMatches,
            route
          } = getShortCircuitMatches(routesToUse);
          cancelActiveDeferreds(), completeNavigation(location, {
            matches: notFoundMatches,
            loaderData: {},
            errors: {
              [route.id]: error
            }
          });
          return;
        }
        if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
          completeNavigation(location, {
            matches
          });
          return;
        }
        pendingNavigationController = new AbortController();
        let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission), pendingActionData, pendingError;
        if (opts && opts.pendingError)
          pendingError = {
            [findNearestBoundary(matches).route.id]: opts.pendingError
          };
        else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
          let actionOutput = await handleAction(request, location, opts.submission, matches, {
            replace: opts.replace
          });
          if (actionOutput.shortCircuited)
            return;
          pendingActionData = actionOutput.pendingActionData, pendingError = actionOutput.pendingActionError, loadingNavigation = _extends({
            state: "loading",
            location
          }, opts.submission), request = new Request(request.url, {
            signal: request.signal
          });
        }
        let {
          shortCircuited,
          loaderData,
          errors
        } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, pendingActionData, pendingError);
        shortCircuited || (pendingNavigationController = null, completeNavigation(location, _extends({
          matches
        }, pendingActionData ? {
          actionData: pendingActionData
        } : {}, {
          loaderData,
          errors
        })));
      }
      async function handleAction(request, location, submission, matches, opts) {
        interruptActiveLoads();
        let navigation = _extends({
          state: "submitting",
          location
        }, submission);
        updateState({
          navigation
        });
        let result, actionMatch = getTargetMatch(matches, location);
        if (!actionMatch.route.action && !actionMatch.route.lazy)
          result = {
            type: ResultType.error,
            error: getInternalRouterError(405, {
              method: request.method,
              pathname: location.pathname,
              routeId: actionMatch.route.id
            })
          };
        else if (result = await callLoaderOrAction("action", request, actionMatch, matches, manifest, mapRouteProperties, basename), request.signal.aborted)
          return {
            shortCircuited: !0
          };
        if (isRedirectResult(result)) {
          let replace;
          return opts && opts.replace != null ? replace = opts.replace : replace = result.location === state.location.pathname + state.location.search, await startRedirectNavigation(state, result, {
            submission,
            replace
          }), {
            shortCircuited: !0
          };
        }
        if (isErrorResult(result)) {
          let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
          return (opts && opts.replace) !== !0 && (pendingAction = exports.Action.Push), {
            // Send back an empty object we can use to clear out any prior actionData
            pendingActionData: {},
            pendingActionError: {
              [boundaryMatch.route.id]: result.error
            }
          };
        }
        if (isDeferredResult(result))
          throw getInternalRouterError(400, {
            type: "defer-action"
          });
        return {
          pendingActionData: {
            [actionMatch.route.id]: result.data
          }
        };
      }
      async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, pendingActionData, pendingError) {
        let loadingNavigation = overrideNavigation;
        loadingNavigation || (loadingNavigation = _extends({
          state: "loading",
          location,
          formMethod: void 0,
          formAction: void 0,
          formEncType: void 0,
          formData: void 0
        }, submission));
        let activeSubmission = submission || fetcherSubmission ? submission || fetcherSubmission : loadingNavigation.formMethod && loadingNavigation.formAction && loadingNavigation.formData && loadingNavigation.formEncType ? {
          formMethod: loadingNavigation.formMethod,
          formAction: loadingNavigation.formAction,
          formData: loadingNavigation.formData,
          formEncType: loadingNavigation.formEncType
        } : void 0, routesToUse = inFlightDataRoutes || dataRoutes, [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, routesToUse, basename, pendingActionData, pendingError);
        if (cancelActiveDeferreds((routeId) => !(matches && matches.some((m2) => m2.route.id === routeId)) || matchesToLoad && matchesToLoad.some((m2) => m2.route.id === routeId)), matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {
          let updatedFetchers2 = markFetchRedirectsDone();
          return completeNavigation(location, _extends({
            matches,
            loaderData: {},
            // Commit pending error if we're short circuiting
            errors: pendingError || null
          }, pendingActionData ? {
            actionData: pendingActionData
          } : {}, updatedFetchers2 ? {
            fetchers: new Map(state.fetchers)
          } : {})), {
            shortCircuited: !0
          };
        }
        if (!isUninterruptedRevalidation) {
          revalidatingFetchers.forEach((rf) => {
            let fetcher2 = state.fetchers.get(rf.key), revalidatingFetcher = {
              state: "loading",
              data: fetcher2 && fetcher2.data,
              formMethod: void 0,
              formAction: void 0,
              formEncType: void 0,
              formData: void 0,
              " _hasFetcherDoneAnything ": !0
            };
            state.fetchers.set(rf.key, revalidatingFetcher);
          });
          let actionData = pendingActionData || state.actionData;
          updateState(_extends({
            navigation: loadingNavigation
          }, actionData ? Object.keys(actionData).length === 0 ? {
            actionData: null
          } : {
            actionData
          } : {}, revalidatingFetchers.length > 0 ? {
            fetchers: new Map(state.fetchers)
          } : {}));
        }
        pendingNavigationLoadId = ++incrementingLoadId, revalidatingFetchers.forEach((rf) => {
          rf.controller && fetchControllers.set(rf.key, rf.controller);
        });
        let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((f3) => abortFetcher(f3.key));
        pendingNavigationController && pendingNavigationController.signal.addEventListener("abort", abortPendingFetchRevalidations);
        let {
          results,
          loaderResults,
          fetcherResults
        } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);
        if (request.signal.aborted)
          return {
            shortCircuited: !0
          };
        pendingNavigationController && pendingNavigationController.signal.removeEventListener("abort", abortPendingFetchRevalidations), revalidatingFetchers.forEach((rf) => fetchControllers.delete(rf.key));
        let redirect4 = findRedirect(results);
        if (redirect4)
          return await startRedirectNavigation(state, redirect4, {
            replace
          }), {
            shortCircuited: !0
          };
        let {
          loaderData,
          errors
        } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds);
        activeDeferreds.forEach((deferredData, routeId) => {
          deferredData.subscribe((aborted) => {
            (aborted || deferredData.done) && activeDeferreds.delete(routeId);
          });
        });
        let updatedFetchers = markFetchRedirectsDone(), didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId), shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;
        return _extends({
          loaderData,
          errors
        }, shouldUpdateFetchers ? {
          fetchers: new Map(state.fetchers)
        } : {});
      }
      function getFetcher(key) {
        return state.fetchers.get(key) || IDLE_FETCHER;
      }
      function fetch4(key, routeId, href, opts) {
        if (isServer)
          throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
        fetchControllers.has(key) && abortFetcher(key);
        let routesToUse = inFlightDataRoutes || dataRoutes, normalizedPath = normalizeTo(state.location, state.matches, basename, future2.v7_prependBasename, href, routeId, opts == null ? void 0 : opts.relative), matches = matchRoutes(routesToUse, normalizedPath, basename);
        if (!matches) {
          setFetcherError(key, routeId, getInternalRouterError(404, {
            pathname: normalizedPath
          }));
          return;
        }
        let {
          path,
          submission
        } = normalizeNavigateOptions(future2.v7_normalizeFormMethod, !0, normalizedPath, opts), match = getTargetMatch(matches, path);
        if (pendingPreventScrollReset = (opts && opts.preventScrollReset) === !0, submission && isMutationMethod(submission.formMethod)) {
          handleFetcherAction(key, routeId, path, match, matches, submission);
          return;
        }
        fetchLoadMatches.set(key, {
          routeId,
          path
        }), handleFetcherLoader(key, routeId, path, match, matches, submission);
      }
      async function handleFetcherAction(key, routeId, path, match, requestMatches, submission) {
        if (interruptActiveLoads(), fetchLoadMatches.delete(key), !match.route.action && !match.route.lazy) {
          let error = getInternalRouterError(405, {
            method: submission.formMethod,
            pathname: path,
            routeId
          });
          setFetcherError(key, routeId, error);
          return;
        }
        let existingFetcher = state.fetchers.get(key), fetcher2 = _extends({
          state: "submitting"
        }, submission, {
          data: existingFetcher && existingFetcher.data,
          " _hasFetcherDoneAnything ": !0
        });
        state.fetchers.set(key, fetcher2), updateState({
          fetchers: new Map(state.fetchers)
        });
        let abortController = new AbortController(), fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);
        fetchControllers.set(key, abortController);
        let actionResult = await callLoaderOrAction("action", fetchRequest, match, requestMatches, manifest, mapRouteProperties, basename);
        if (fetchRequest.signal.aborted) {
          fetchControllers.get(key) === abortController && fetchControllers.delete(key);
          return;
        }
        if (isRedirectResult(actionResult)) {
          fetchControllers.delete(key), fetchRedirectIds.add(key);
          let loadingFetcher = _extends({
            state: "loading"
          }, submission, {
            data: void 0,
            " _hasFetcherDoneAnything ": !0
          });
          return state.fetchers.set(key, loadingFetcher), updateState({
            fetchers: new Map(state.fetchers)
          }), startRedirectNavigation(state, actionResult, {
            submission,
            isFetchActionRedirect: !0
          });
        }
        if (isErrorResult(actionResult)) {
          setFetcherError(key, routeId, actionResult.error);
          return;
        }
        if (isDeferredResult(actionResult))
          throw getInternalRouterError(400, {
            type: "defer-action"
          });
        let nextLocation = state.navigation.location || state.location, revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal), routesToUse = inFlightDataRoutes || dataRoutes, matches = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;
        invariant(matches, "Didn't find any matches after fetcher action");
        let loadId = ++incrementingLoadId;
        fetchReloadIds.set(key, loadId);
        let loadFetcher = _extends({
          state: "loading",
          data: actionResult.data
        }, submission, {
          " _hasFetcherDoneAnything ": !0
        });
        state.fetchers.set(key, loadFetcher);
        let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(
          init.history,
          state,
          matches,
          submission,
          nextLocation,
          isRevalidationRequired,
          cancelledDeferredRoutes,
          cancelledFetcherLoads,
          fetchLoadMatches,
          routesToUse,
          basename,
          {
            [match.route.id]: actionResult.data
          },
          void 0
          // No need to send through errors since we short circuit above
        );
        revalidatingFetchers.filter((rf) => rf.key !== key).forEach((rf) => {
          let staleKey = rf.key, existingFetcher2 = state.fetchers.get(staleKey), revalidatingFetcher = {
            state: "loading",
            data: existingFetcher2 && existingFetcher2.data,
            formMethod: void 0,
            formAction: void 0,
            formEncType: void 0,
            formData: void 0,
            " _hasFetcherDoneAnything ": !0
          };
          state.fetchers.set(staleKey, revalidatingFetcher), rf.controller && fetchControllers.set(staleKey, rf.controller);
        }), updateState({
          fetchers: new Map(state.fetchers)
        });
        let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((rf) => abortFetcher(rf.key));
        abortController.signal.addEventListener("abort", abortPendingFetchRevalidations);
        let {
          results,
          loaderResults,
          fetcherResults
        } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);
        if (abortController.signal.aborted)
          return;
        abortController.signal.removeEventListener("abort", abortPendingFetchRevalidations), fetchReloadIds.delete(key), fetchControllers.delete(key), revalidatingFetchers.forEach((r2) => fetchControllers.delete(r2.key));
        let redirect4 = findRedirect(results);
        if (redirect4)
          return startRedirectNavigation(state, redirect4);
        let {
          loaderData,
          errors
        } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, void 0, revalidatingFetchers, fetcherResults, activeDeferreds);
        if (state.fetchers.has(key)) {
          let doneFetcher = {
            state: "idle",
            data: actionResult.data,
            formMethod: void 0,
            formAction: void 0,
            formEncType: void 0,
            formData: void 0,
            " _hasFetcherDoneAnything ": !0
          };
          state.fetchers.set(key, doneFetcher);
        }
        let didAbortFetchLoads = abortStaleFetchLoads(loadId);
        state.navigation.state === "loading" && loadId > pendingNavigationLoadId ? (invariant(pendingAction, "Expected pending action"), pendingNavigationController && pendingNavigationController.abort(), completeNavigation(state.navigation.location, {
          matches,
          loaderData,
          errors,
          fetchers: new Map(state.fetchers)
        })) : (updateState(_extends({
          errors,
          loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors)
        }, didAbortFetchLoads || revalidatingFetchers.length > 0 ? {
          fetchers: new Map(state.fetchers)
        } : {})), isRevalidationRequired = !1);
      }
      async function handleFetcherLoader(key, routeId, path, match, matches, submission) {
        let existingFetcher = state.fetchers.get(key), loadingFetcher = _extends({
          state: "loading",
          formMethod: void 0,
          formAction: void 0,
          formEncType: void 0,
          formData: void 0
        }, submission, {
          data: existingFetcher && existingFetcher.data,
          " _hasFetcherDoneAnything ": !0
        });
        state.fetchers.set(key, loadingFetcher), updateState({
          fetchers: new Map(state.fetchers)
        });
        let abortController = new AbortController(), fetchRequest = createClientSideRequest(init.history, path, abortController.signal);
        fetchControllers.set(key, abortController);
        let result = await callLoaderOrAction("loader", fetchRequest, match, matches, manifest, mapRouteProperties, basename);
        if (isDeferredResult(result) && (result = await resolveDeferredData(result, fetchRequest.signal, !0) || result), fetchControllers.get(key) === abortController && fetchControllers.delete(key), fetchRequest.signal.aborted)
          return;
        if (isRedirectResult(result)) {
          fetchRedirectIds.add(key), await startRedirectNavigation(state, result);
          return;
        }
        if (isErrorResult(result)) {
          let boundaryMatch = findNearestBoundary(state.matches, routeId);
          state.fetchers.delete(key), updateState({
            fetchers: new Map(state.fetchers),
            errors: {
              [boundaryMatch.route.id]: result.error
            }
          });
          return;
        }
        invariant(!isDeferredResult(result), "Unhandled fetcher deferred data");
        let doneFetcher = {
          state: "idle",
          data: result.data,
          formMethod: void 0,
          formAction: void 0,
          formEncType: void 0,
          formData: void 0,
          " _hasFetcherDoneAnything ": !0
        };
        state.fetchers.set(key, doneFetcher), updateState({
          fetchers: new Map(state.fetchers)
        });
      }
      async function startRedirectNavigation(state2, redirect4, _temp) {
        let {
          submission,
          replace,
          isFetchActionRedirect
        } = _temp === void 0 ? {} : _temp;
        redirect4.revalidate && (isRevalidationRequired = !0);
        let redirectLocation = createLocation(
          state2.location,
          redirect4.location,
          // TODO: This can be removed once we get rid of useTransition in Remix v2
          _extends({
            _isRedirect: !0
          }, isFetchActionRedirect ? {
            _isFetchActionRedirect: !0
          } : {})
        );
        if (invariant(redirectLocation, "Expected a location on the redirect navigation"), ABSOLUTE_URL_REGEX.test(redirect4.location) && isBrowser) {
          let url = init.history.createURL(redirect4.location), isDifferentBasename = stripBasename(url.pathname, basename) == null;
          if (routerWindow.location.origin !== url.origin || isDifferentBasename) {
            replace ? routerWindow.location.replace(redirect4.location) : routerWindow.location.assign(redirect4.location);
            return;
          }
        }
        pendingNavigationController = null;
        let redirectHistoryAction = replace === !0 ? exports.Action.Replace : exports.Action.Push, {
          formMethod,
          formAction,
          formEncType,
          formData
        } = state2.navigation;
        !submission && formMethod && formAction && formData && formEncType && (submission = {
          formMethod,
          formAction,
          formEncType,
          formData
        }), redirectPreserveMethodStatusCodes.has(redirect4.status) && submission && isMutationMethod(submission.formMethod) ? await startNavigation(redirectHistoryAction, redirectLocation, {
          submission: _extends({}, submission, {
            formAction: redirect4.location
          }),
          // Preserve this flag across redirects
          preventScrollReset: pendingPreventScrollReset
        }) : isFetchActionRedirect ? await startNavigation(redirectHistoryAction, redirectLocation, {
          overrideNavigation: {
            state: "loading",
            location: redirectLocation,
            formMethod: void 0,
            formAction: void 0,
            formEncType: void 0,
            formData: void 0
          },
          fetcherSubmission: submission,
          // Preserve this flag across redirects
          preventScrollReset: pendingPreventScrollReset
        }) : await startNavigation(redirectHistoryAction, redirectLocation, {
          overrideNavigation: {
            state: "loading",
            location: redirectLocation,
            formMethod: submission ? submission.formMethod : void 0,
            formAction: submission ? submission.formAction : void 0,
            formEncType: submission ? submission.formEncType : void 0,
            formData: submission ? submission.formData : void 0
          },
          // Preserve this flag across redirects
          preventScrollReset: pendingPreventScrollReset
        });
      }
      async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {
        let results = await Promise.all([...matchesToLoad.map((match) => callLoaderOrAction("loader", request, match, matches, manifest, mapRouteProperties, basename)), ...fetchersToLoad.map((f3) => f3.matches && f3.match && f3.controller ? callLoaderOrAction("loader", createClientSideRequest(init.history, f3.path, f3.controller.signal), f3.match, f3.matches, manifest, mapRouteProperties, basename) : {
          type: ResultType.error,
          error: getInternalRouterError(404, {
            pathname: f3.path
          })
        })]), loaderResults = results.slice(0, matchesToLoad.length), fetcherResults = results.slice(matchesToLoad.length);
        return await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(() => request.signal), !1, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map((f3) => f3.match), fetcherResults, fetchersToLoad.map((f3) => f3.controller ? f3.controller.signal : null), !0)]), {
          results,
          loaderResults,
          fetcherResults
        };
      }
      function interruptActiveLoads() {
        isRevalidationRequired = !0, cancelledDeferredRoutes.push(...cancelActiveDeferreds()), fetchLoadMatches.forEach((_, key) => {
          fetchControllers.has(key) && (cancelledFetcherLoads.push(key), abortFetcher(key));
        });
      }
      function setFetcherError(key, routeId, error) {
        let boundaryMatch = findNearestBoundary(state.matches, routeId);
        deleteFetcher(key), updateState({
          errors: {
            [boundaryMatch.route.id]: error
          },
          fetchers: new Map(state.fetchers)
        });
      }
      function deleteFetcher(key) {
        let fetcher2 = state.fetchers.get(key);
        fetchControllers.has(key) && !(fetcher2 && fetcher2.state === "loading" && fetchReloadIds.has(key)) && abortFetcher(key), fetchLoadMatches.delete(key), fetchReloadIds.delete(key), fetchRedirectIds.delete(key), state.fetchers.delete(key);
      }
      function abortFetcher(key) {
        let controller = fetchControllers.get(key);
        invariant(controller, "Expected fetch controller: " + key), controller.abort(), fetchControllers.delete(key);
      }
      function markFetchersDone(keys) {
        for (let key of keys) {
          let doneFetcher = {
            state: "idle",
            data: getFetcher(key).data,
            formMethod: void 0,
            formAction: void 0,
            formEncType: void 0,
            formData: void 0,
            " _hasFetcherDoneAnything ": !0
          };
          state.fetchers.set(key, doneFetcher);
        }
      }
      function markFetchRedirectsDone() {
        let doneKeys = [], updatedFetchers = !1;
        for (let key of fetchRedirectIds) {
          let fetcher2 = state.fetchers.get(key);
          invariant(fetcher2, "Expected fetcher: " + key), fetcher2.state === "loading" && (fetchRedirectIds.delete(key), doneKeys.push(key), updatedFetchers = !0);
        }
        return markFetchersDone(doneKeys), updatedFetchers;
      }
      function abortStaleFetchLoads(landedId) {
        let yeetedKeys = [];
        for (let [key, id] of fetchReloadIds)
          if (id < landedId) {
            let fetcher2 = state.fetchers.get(key);
            invariant(fetcher2, "Expected fetcher: " + key), fetcher2.state === "loading" && (abortFetcher(key), fetchReloadIds.delete(key), yeetedKeys.push(key));
          }
        return markFetchersDone(yeetedKeys), yeetedKeys.length > 0;
      }
      function getBlocker(key, fn) {
        let blocker = state.blockers.get(key) || IDLE_BLOCKER;
        return blockerFunctions.get(key) !== fn && blockerFunctions.set(key, fn), blocker;
      }
      function deleteBlocker(key) {
        state.blockers.delete(key), blockerFunctions.delete(key);
      }
      function updateBlocker(key, newBlocker) {
        let blocker = state.blockers.get(key) || IDLE_BLOCKER;
        invariant(blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked", "Invalid blocker state transition: " + blocker.state + " -> " + newBlocker.state), state.blockers.set(key, newBlocker), updateState({
          blockers: new Map(state.blockers)
        });
      }
      function shouldBlockNavigation(_ref2) {
        let {
          currentLocation,
          nextLocation,
          historyAction
        } = _ref2;
        if (blockerFunctions.size === 0)
          return;
        blockerFunctions.size > 1 && warning(!1, "A router only supports one blocker at a time");
        let entries = Array.from(blockerFunctions.entries()), [blockerKey, blockerFunction] = entries[entries.length - 1], blocker = state.blockers.get(blockerKey);
        if (!(blocker && blocker.state === "proceeding") && blockerFunction({
          currentLocation,
          nextLocation,
          historyAction
        }))
          return blockerKey;
      }
      function cancelActiveDeferreds(predicate) {
        let cancelledRouteIds = [];
        return activeDeferreds.forEach((dfd, routeId) => {
          (!predicate || predicate(routeId)) && (dfd.cancel(), cancelledRouteIds.push(routeId), activeDeferreds.delete(routeId));
        }), cancelledRouteIds;
      }
      function enableScrollRestoration(positions, getPosition, getKey) {
        if (savedScrollPositions = positions, getScrollPosition = getPosition, getScrollRestorationKey = getKey || ((location) => location.key), !initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
          initialScrollRestored = !0;
          let y = getSavedScrollPosition(state.location, state.matches);
          y != null && updateState({
            restoreScrollPosition: y
          });
        }
        return () => {
          savedScrollPositions = null, getScrollPosition = null, getScrollRestorationKey = null;
        };
      }
      function saveScrollPosition(location, matches) {
        if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) {
          let userMatches = matches.map((m2) => createUseMatchesMatch(m2, state.loaderData)), key = getScrollRestorationKey(location, userMatches) || location.key;
          savedScrollPositions[key] = getScrollPosition();
        }
      }
      function getSavedScrollPosition(location, matches) {
        if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) {
          let userMatches = matches.map((m2) => createUseMatchesMatch(m2, state.loaderData)), key = getScrollRestorationKey(location, userMatches) || location.key, y = savedScrollPositions[key];
          if (typeof y == "number")
            return y;
        }
        return null;
      }
      function _internalSetRoutes(newRoutes) {
        manifest = {}, inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties, void 0, manifest);
      }
      return router = {
        get basename() {
          return basename;
        },
        get state() {
          return state;
        },
        get routes() {
          return dataRoutes;
        },
        initialize,
        subscribe,
        enableScrollRestoration,
        navigate,
        fetch: fetch4,
        revalidate,
        // Passthrough to history-aware createHref used by useHref so we get proper
        // hash-aware URLs in DOM paths
        createHref: (to) => init.history.createHref(to),
        encodeLocation: (to) => init.history.encodeLocation(to),
        getFetcher,
        deleteFetcher,
        dispose,
        getBlocker,
        deleteBlocker,
        _internalFetchControllers: fetchControllers,
        _internalActiveDeferreds: activeDeferreds,
        // TODO: Remove setRoutes, it's temporary to avoid dealing with
        // updating the tree while validating the update algorithm.
        _internalSetRoutes
      }, router;
    }
    var UNSAFE_DEFERRED_SYMBOL = Symbol("deferred");
    function createStaticHandler(routes2, opts) {
      invariant(routes2.length > 0, "You must provide a non-empty routes array to createStaticHandler");
      let manifest = {}, basename = (opts ? opts.basename : null) || "/", mapRouteProperties;
      if (opts != null && opts.mapRouteProperties)
        mapRouteProperties = opts.mapRouteProperties;
      else if (opts != null && opts.detectErrorBoundary) {
        let detectErrorBoundary = opts.detectErrorBoundary;
        mapRouteProperties = (route) => ({
          hasErrorBoundary: detectErrorBoundary(route)
        });
      } else
        mapRouteProperties = defaultMapRouteProperties;
      let dataRoutes = convertRoutesToDataRoutes(routes2, mapRouteProperties, void 0, manifest);
      async function query(request, _temp2) {
        let {
          requestContext
        } = _temp2 === void 0 ? {} : _temp2, url = new URL(request.url), method = request.method, location = createLocation("", createPath(url), null, "default"), matches = matchRoutes(dataRoutes, location, basename);
        if (!isValidMethod(method) && method !== "HEAD") {
          let error = getInternalRouterError(405, {
            method
          }), {
            matches: methodNotAllowedMatches,
            route
          } = getShortCircuitMatches(dataRoutes);
          return {
            basename,
            location,
            matches: methodNotAllowedMatches,
            loaderData: {},
            actionData: null,
            errors: {
              [route.id]: error
            },
            statusCode: error.status,
            loaderHeaders: {},
            actionHeaders: {},
            activeDeferreds: null
          };
        } else if (!matches) {
          let error = getInternalRouterError(404, {
            pathname: location.pathname
          }), {
            matches: notFoundMatches,
            route
          } = getShortCircuitMatches(dataRoutes);
          return {
            basename,
            location,
            matches: notFoundMatches,
            loaderData: {},
            actionData: null,
            errors: {
              [route.id]: error
            },
            statusCode: error.status,
            loaderHeaders: {},
            actionHeaders: {},
            activeDeferreds: null
          };
        }
        let result = await queryImpl(request, location, matches, requestContext);
        return isResponse(result) ? result : _extends({
          location,
          basename
        }, result);
      }
      async function queryRoute(request, _temp3) {
        let {
          routeId,
          requestContext
        } = _temp3 === void 0 ? {} : _temp3, url = new URL(request.url), method = request.method, location = createLocation("", createPath(url), null, "default"), matches = matchRoutes(dataRoutes, location, basename);
        if (!isValidMethod(method) && method !== "HEAD" && method !== "OPTIONS")
          throw getInternalRouterError(405, {
            method
          });
        if (!matches)
          throw getInternalRouterError(404, {
            pathname: location.pathname
          });
        let match = routeId ? matches.find((m2) => m2.route.id === routeId) : getTargetMatch(matches, location);
        if (routeId && !match)
          throw getInternalRouterError(403, {
            pathname: location.pathname,
            routeId
          });
        if (!match)
          throw getInternalRouterError(404, {
            pathname: location.pathname
          });
        let result = await queryImpl(request, location, matches, requestContext, match);
        if (isResponse(result))
          return result;
        let error = result.errors ? Object.values(result.errors)[0] : void 0;
        if (error !== void 0)
          throw error;
        if (result.actionData)
          return Object.values(result.actionData)[0];
        if (result.loaderData) {
          var _result$activeDeferre;
          let data = Object.values(result.loaderData)[0];
          return (_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id] && (data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id]), data;
        }
      }
      async function queryImpl(request, location, matches, requestContext, routeMatch) {
        invariant(request.signal, "query()/queryRoute() requests must contain an AbortController signal");
        try {
          if (isMutationMethod(request.method.toLowerCase()))
            return await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, routeMatch != null);
          let result = await loadRouteData(request, matches, requestContext, routeMatch);
          return isResponse(result) ? result : _extends({}, result, {
            actionData: null,
            actionHeaders: {}
          });
        } catch (e2) {
          if (isQueryRouteResponse(e2)) {
            if (e2.type === ResultType.error && !isRedirectResponse(e2.response))
              throw e2.response;
            return e2.response;
          }
          if (isRedirectResponse(e2))
            return e2;
          throw e2;
        }
      }
      async function submit(request, matches, actionMatch, requestContext, isRouteRequest) {
        let result;
        if (!actionMatch.route.action && !actionMatch.route.lazy) {
          let error = getInternalRouterError(405, {
            method: request.method,
            pathname: new URL(request.url).pathname,
            routeId: actionMatch.route.id
          });
          if (isRouteRequest)
            throw error;
          result = {
            type: ResultType.error,
            error
          };
        } else if (result = await callLoaderOrAction("action", request, actionMatch, matches, manifest, mapRouteProperties, basename, !0, isRouteRequest, requestContext), request.signal.aborted) {
          let method = isRouteRequest ? "queryRoute" : "query";
          throw new Error(method + "() call aborted");
        }
        if (isRedirectResult(result))
          throw new Response(null, {
            status: result.status,
            headers: {
              Location: result.location
            }
          });
        if (isDeferredResult(result)) {
          let error = getInternalRouterError(400, {
            type: "defer-action"
          });
          if (isRouteRequest)
            throw error;
          result = {
            type: ResultType.error,
            error
          };
        }
        if (isRouteRequest) {
          if (isErrorResult(result))
            throw result.error;
          return {
            matches: [actionMatch],
            loaderData: {},
            actionData: {
              [actionMatch.route.id]: result.data
            },
            errors: null,
            // Note: statusCode + headers are unused here since queryRoute will
            // return the raw Response or value
            statusCode: 200,
            loaderHeaders: {},
            actionHeaders: {},
            activeDeferreds: null
          };
        }
        if (isErrorResult(result)) {
          let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id), context2 = await loadRouteData(request, matches, requestContext, void 0, {
            [boundaryMatch.route.id]: result.error
          });
          return _extends({}, context2, {
            statusCode: isRouteErrorResponse2(result.error) ? result.error.status : 500,
            actionData: null,
            actionHeaders: _extends({}, result.headers ? {
              [actionMatch.route.id]: result.headers
            } : {})
          });
        }
        let loaderRequest = new Request(request.url, {
          headers: request.headers,
          redirect: request.redirect,
          signal: request.signal
        }), context = await loadRouteData(loaderRequest, matches, requestContext);
        return _extends({}, context, result.statusCode ? {
          statusCode: result.statusCode
        } : {}, {
          actionData: {
            [actionMatch.route.id]: result.data
          },
          actionHeaders: _extends({}, result.headers ? {
            [actionMatch.route.id]: result.headers
          } : {})
        });
      }
      async function loadRouteData(request, matches, requestContext, routeMatch, pendingActionError) {
        let isRouteRequest = routeMatch != null;
        if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy))
          throw getInternalRouterError(400, {
            method: request.method,
            pathname: new URL(request.url).pathname,
            routeId: routeMatch == null ? void 0 : routeMatch.route.id
          });
        let matchesToLoad = (routeMatch ? [routeMatch] : getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || {})[0])).filter((m2) => m2.route.loader || m2.route.lazy);
        if (matchesToLoad.length === 0)
          return {
            matches,
            // Add a null for all matched routes for proper revalidation on the client
            loaderData: matches.reduce((acc, m2) => Object.assign(acc, {
              [m2.route.id]: null
            }), {}),
            errors: pendingActionError || null,
            statusCode: 200,
            loaderHeaders: {},
            activeDeferreds: null
          };
        let results = await Promise.all([...matchesToLoad.map((match) => callLoaderOrAction("loader", request, match, matches, manifest, mapRouteProperties, basename, !0, isRouteRequest, requestContext))]);
        if (request.signal.aborted) {
          let method = isRouteRequest ? "queryRoute" : "query";
          throw new Error(method + "() call aborted");
        }
        let activeDeferreds = /* @__PURE__ */ new Map(), context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionError, activeDeferreds), executedLoaders = new Set(matchesToLoad.map((match) => match.route.id));
        return matches.forEach((match) => {
          executedLoaders.has(match.route.id) || (context.loaderData[match.route.id] = null);
        }), _extends({}, context, {
          matches,
          activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null
        });
      }
      return {
        dataRoutes,
        query,
        queryRoute
      };
    }
    function getStaticContextFromError(routes2, context, error) {
      return _extends({}, context, {
        statusCode: 500,
        errors: {
          [context._deepestRenderedBoundaryId || routes2[0].id]: error
        }
      });
    }
    function isSubmissionNavigation(opts) {
      return opts != null && "formData" in opts;
    }
    function normalizeTo(location, matches, basename, prependBasename, to, fromRouteId, relative) {
      let contextualMatches, activeRouteMatch;
      if (fromRouteId != null && relative !== "path") {
        contextualMatches = [];
        for (let match of matches)
          if (contextualMatches.push(match), match.route.id === fromRouteId) {
            activeRouteMatch = match;
            break;
          }
      } else
        contextualMatches = matches, activeRouteMatch = matches[matches.length - 1];
      let path = resolveTo(to || ".", getPathContributingMatches(contextualMatches).map((m2) => m2.pathnameBase), stripBasename(location.pathname, basename) || location.pathname, relative === "path");
      return to == null && (path.search = location.search, path.hash = location.hash), (to == null || to === "" || to === ".") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search) && (path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index"), prependBasename && basename !== "/" && (path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname])), createPath(path);
    }
    function normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {
      if (!opts || !isSubmissionNavigation(opts))
        return {
          path
        };
      if (opts.formMethod && !isValidMethod(opts.formMethod))
        return {
          path,
          error: getInternalRouterError(405, {
            method: opts.formMethod
          })
        };
      let submission;
      if (opts.formData) {
        let formMethod = opts.formMethod || "get";
        if (submission = {
          formMethod: normalizeFormMethod ? formMethod.toUpperCase() : formMethod.toLowerCase(),
          formAction: stripHashFromPath(path),
          formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
          formData: opts.formData
        }, isMutationMethod(submission.formMethod))
          return {
            path,
            submission
          };
      }
      let parsedPath = parsePath(path), searchParams = convertFormDataToSearchParams(opts.formData);
      return isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search) && searchParams.append("index", ""), parsedPath.search = "?" + searchParams, {
        path: createPath(parsedPath),
        submission
      };
    }
    function getLoaderMatchesUntilBoundary(matches, boundaryId) {
      let boundaryMatches = matches;
      if (boundaryId) {
        let index = matches.findIndex((m2) => m2.route.id === boundaryId);
        index >= 0 && (boundaryMatches = matches.slice(0, index));
      }
      return boundaryMatches;
    }
    function getMatchesToLoad(history, state, matches, submission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, routesToUse, basename, pendingActionData, pendingError) {
      let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : void 0, currentUrl = history.createURL(state.location), nextUrl = history.createURL(location), boundaryId = pendingError ? Object.keys(pendingError)[0] : void 0, navigationMatches = getLoaderMatchesUntilBoundary(matches, boundaryId).filter((match, index) => {
        if (match.route.lazy)
          return !0;
        if (match.route.loader == null)
          return !1;
        if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some((id) => id === match.route.id))
          return !0;
        let currentRouteMatch = state.matches[index], nextRouteMatch = match;
        return shouldRevalidateLoader(match, _extends({
          currentUrl,
          currentParams: currentRouteMatch.params,
          nextUrl,
          nextParams: nextRouteMatch.params
        }, submission, {
          actionResult,
          defaultShouldRevalidate: (
            // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
            isRevalidationRequired || // Clicked the same link, resubmitted a GET form
            currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders
            currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)
          )
        }));
      }), revalidatingFetchers = [];
      return fetchLoadMatches.forEach((f3, key) => {
        if (!matches.some((m2) => m2.route.id === f3.routeId))
          return;
        let fetcherMatches = matchRoutes(routesToUse, f3.path, basename);
        if (!fetcherMatches) {
          revalidatingFetchers.push({
            key,
            routeId: f3.routeId,
            path: f3.path,
            matches: null,
            match: null,
            controller: null
          });
          return;
        }
        let fetcherMatch = getTargetMatch(fetcherMatches, f3.path);
        if (cancelledFetcherLoads.includes(key)) {
          revalidatingFetchers.push({
            key,
            routeId: f3.routeId,
            path: f3.path,
            matches: fetcherMatches,
            match: fetcherMatch,
            controller: new AbortController()
          });
          return;
        }
        shouldRevalidateLoader(fetcherMatch, _extends({
          currentUrl,
          currentParams: state.matches[state.matches.length - 1].params,
          nextUrl,
          nextParams: matches[matches.length - 1].params
        }, submission, {
          actionResult,
          // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
          defaultShouldRevalidate: isRevalidationRequired
        })) && revalidatingFetchers.push({
          key,
          routeId: f3.routeId,
          path: f3.path,
          matches: fetcherMatches,
          match: fetcherMatch,
          controller: new AbortController()
        });
      }), [navigationMatches, revalidatingFetchers];
    }
    function isNewLoader(currentLoaderData, currentMatch, match) {
      let isNew = (
        // [a] -> [a, b]
        !currentMatch || // [a, b] -> [a, c]
        match.route.id !== currentMatch.route.id
      ), isMissingData = currentLoaderData[match.route.id] === void 0;
      return isNew || isMissingData;
    }
    function isNewRouteInstance(currentMatch, match) {
      let currentPath = currentMatch.route.path;
      return (
        // param change for this match, /users/123 -> /users/456
        currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path
        // e.g. /files/images/avatar.jpg -> files/finances.xls
        currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"]
      );
    }
    function shouldRevalidateLoader(loaderMatch, arg) {
      if (loaderMatch.route.shouldRevalidate) {
        let routeChoice = loaderMatch.route.shouldRevalidate(arg);
        if (typeof routeChoice == "boolean")
          return routeChoice;
      }
      return arg.defaultShouldRevalidate;
    }
    async function loadLazyRouteModule(route, mapRouteProperties, manifest) {
      if (!route.lazy)
        return;
      let lazyRoute = await route.lazy();
      if (!route.lazy)
        return;
      let routeToUpdate = manifest[route.id];
      invariant(routeToUpdate, "No route found in manifest");
      let routeUpdates = {};
      for (let lazyRouteProperty in lazyRoute) {
        let isPropertyStaticallyDefined = routeToUpdate[lazyRouteProperty] !== void 0 && // This property isn't static since it should always be updated based
        // on the route updates
        lazyRouteProperty !== "hasErrorBoundary";
        warning(!isPropertyStaticallyDefined, 'Route "' + routeToUpdate.id + '" has a static property "' + lazyRouteProperty + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + lazyRouteProperty + '" will be ignored.')), !isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty) && (routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty]);
      }
      Object.assign(routeToUpdate, routeUpdates), Object.assign(routeToUpdate, _extends({}, mapRouteProperties(routeToUpdate), {
        lazy: void 0
      }));
    }
    async function callLoaderOrAction(type, request, match, matches, manifest, mapRouteProperties, basename, isStaticRequest, isRouteRequest, requestContext) {
      isStaticRequest === void 0 && (isStaticRequest = !1), isRouteRequest === void 0 && (isRouteRequest = !1);
      let resultType, result, onReject, runHandler = (handler) => {
        let reject, abortPromise = new Promise((_, r2) => reject = r2);
        return onReject = () => reject(), request.signal.addEventListener("abort", onReject), Promise.race([handler({
          request,
          params: match.params,
          context: requestContext
        }), abortPromise]);
      };
      try {
        let handler = match.route[type];
        if (match.route.lazy)
          if (handler)
            result = (await Promise.all([runHandler(handler), loadLazyRouteModule(match.route, mapRouteProperties, manifest)]))[0];
          else if (await loadLazyRouteModule(match.route, mapRouteProperties, manifest), handler = match.route[type], handler)
            result = await runHandler(handler);
          else if (type === "action") {
            let url = new URL(request.url), pathname = url.pathname + url.search;
            throw getInternalRouterError(405, {
              method: request.method,
              pathname,
              routeId: match.route.id
            });
          } else
            return {
              type: ResultType.data,
              data: void 0
            };
        else if (handler)
          result = await runHandler(handler);
        else {
          let url = new URL(request.url), pathname = url.pathname + url.search;
          throw getInternalRouterError(404, {
            pathname
          });
        }
        invariant(result !== void 0, "You defined " + (type === "action" ? "an action" : "a loader") + " for route " + ('"' + match.route.id + "\" but didn't return anything from your `" + type + "` ") + "function. Please return a value or `null`.");
      } catch (e2) {
        resultType = ResultType.error, result = e2;
      } finally {
        onReject && request.signal.removeEventListener("abort", onReject);
      }
      if (isResponse(result)) {
        let status = result.status;
        if (redirectStatusCodes.has(status)) {
          let location = result.headers.get("Location");
          if (invariant(location, "Redirects returned/thrown from loaders/actions must have a Location header"), !ABSOLUTE_URL_REGEX.test(location))
            location = normalizeTo(new URL(request.url), matches.slice(0, matches.indexOf(match) + 1), basename, !0, location);
          else if (!isStaticRequest) {
            let currentUrl = new URL(request.url), url = location.startsWith("//") ? new URL(currentUrl.protocol + location) : new URL(location), isSameBasename = stripBasename(url.pathname, basename) != null;
            url.origin === currentUrl.origin && isSameBasename && (location = url.pathname + url.search + url.hash);
          }
          if (isStaticRequest)
            throw result.headers.set("Location", location), result;
          return {
            type: ResultType.redirect,
            status,
            location,
            revalidate: result.headers.get("X-Remix-Revalidate") !== null
          };
        }
        if (isRouteRequest)
          throw {
            type: resultType || ResultType.data,
            response: result
          };
        let data, contentType = result.headers.get("Content-Type");
        return contentType && /\bapplication\/json\b/.test(contentType) ? data = await result.json() : data = await result.text(), resultType === ResultType.error ? {
          type: resultType,
          error: new ErrorResponse(status, result.statusText, data),
          headers: result.headers
        } : {
          type: ResultType.data,
          data,
          statusCode: result.status,
          headers: result.headers
        };
      }
      if (resultType === ResultType.error)
        return {
          type: resultType,
          error: result
        };
      if (isDeferredData(result)) {
        var _result$init, _result$init2;
        return {
          type: ResultType.deferred,
          deferredData: result,
          statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,
          headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)
        };
      }
      return {
        type: ResultType.data,
        data: result
      };
    }
    function createClientSideRequest(history, location, signal, submission) {
      let url = history.createURL(stripHashFromPath(location)).toString(), init = {
        signal
      };
      if (submission && isMutationMethod(submission.formMethod)) {
        let {
          formMethod,
          formEncType,
          formData
        } = submission;
        init.method = formMethod.toUpperCase(), init.body = formEncType === "application/x-www-form-urlencoded" ? convertFormDataToSearchParams(formData) : formData;
      }
      return new Request(url, init);
    }
    function convertFormDataToSearchParams(formData) {
      let searchParams = new URLSearchParams();
      for (let [key, value] of formData.entries())
        searchParams.append(key, value instanceof File ? value.name : value);
      return searchParams;
    }
    function processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {
      let loaderData = {}, errors = null, statusCode, foundError = !1, loaderHeaders = {};
      return results.forEach((result, index) => {
        let id = matchesToLoad[index].route.id;
        if (invariant(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData"), isErrorResult(result)) {
          let boundaryMatch = findNearestBoundary(matches, id), error = result.error;
          pendingError && (error = Object.values(pendingError)[0], pendingError = void 0), errors = errors || {}, errors[boundaryMatch.route.id] == null && (errors[boundaryMatch.route.id] = error), loaderData[id] = void 0, foundError || (foundError = !0, statusCode = isRouteErrorResponse2(result.error) ? result.error.status : 500), result.headers && (loaderHeaders[id] = result.headers);
        } else
          isDeferredResult(result) ? (activeDeferreds.set(id, result.deferredData), loaderData[id] = result.deferredData.data) : loaderData[id] = result.data, result.statusCode != null && result.statusCode !== 200 && !foundError && (statusCode = result.statusCode), result.headers && (loaderHeaders[id] = result.headers);
      }), pendingError && (errors = pendingError, loaderData[Object.keys(pendingError)[0]] = void 0), {
        loaderData,
        errors,
        statusCode: statusCode || 200,
        loaderHeaders
      };
    }
    function processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {
      let {
        loaderData,
        errors
      } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds);
      for (let index = 0; index < revalidatingFetchers.length; index++) {
        let {
          key,
          match,
          controller
        } = revalidatingFetchers[index];
        invariant(fetcherResults !== void 0 && fetcherResults[index] !== void 0, "Did not find corresponding fetcher result");
        let result = fetcherResults[index];
        if (!(controller && controller.signal.aborted))
          if (isErrorResult(result)) {
            let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);
            errors && errors[boundaryMatch.route.id] || (errors = _extends({}, errors, {
              [boundaryMatch.route.id]: result.error
            })), state.fetchers.delete(key);
          } else if (isRedirectResult(result))
            invariant(!1, "Unhandled fetcher revalidation redirect");
          else if (isDeferredResult(result))
            invariant(!1, "Unhandled fetcher deferred data");
          else {
            let doneFetcher = {
              state: "idle",
              data: result.data,
              formMethod: void 0,
              formAction: void 0,
              formEncType: void 0,
              formData: void 0,
              " _hasFetcherDoneAnything ": !0
            };
            state.fetchers.set(key, doneFetcher);
          }
      }
      return {
        loaderData,
        errors
      };
    }
    function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
      let mergedLoaderData = _extends({}, newLoaderData);
      for (let match of matches) {
        let id = match.route.id;
        if (newLoaderData.hasOwnProperty(id) ? newLoaderData[id] !== void 0 && (mergedLoaderData[id] = newLoaderData[id]) : loaderData[id] !== void 0 && match.route.loader && (mergedLoaderData[id] = loaderData[id]), errors && errors.hasOwnProperty(id))
          break;
      }
      return mergedLoaderData;
    }
    function findNearestBoundary(matches, routeId) {
      return (routeId ? matches.slice(0, matches.findIndex((m2) => m2.route.id === routeId) + 1) : [...matches]).reverse().find((m2) => m2.route.hasErrorBoundary === !0) || matches[0];
    }
    function getShortCircuitMatches(routes2) {
      let route = routes2.find((r2) => r2.index || !r2.path || r2.path === "/") || {
        id: "__shim-error-route__"
      };
      return {
        matches: [{
          params: {},
          pathname: "",
          pathnameBase: "",
          route
        }],
        route
      };
    }
    function getInternalRouterError(status, _temp4) {
      let {
        pathname,
        routeId,
        method,
        type
      } = _temp4 === void 0 ? {} : _temp4, statusText = "Unknown Server Error", errorMessage = "Unknown @remix-run/router error";
      return status === 400 ? (statusText = "Bad Request", method && pathname && routeId ? errorMessage = "You made a " + method + ' request to "' + pathname + '" but ' + ('did not provide a `loader` for route "' + routeId + '", ') + "so there is no way to handle the request." : type === "defer-action" && (errorMessage = "defer() is not supported in actions")) : status === 403 ? (statusText = "Forbidden", errorMessage = 'Route "' + routeId + '" does not match URL "' + pathname + '"') : status === 404 ? (statusText = "Not Found", errorMessage = 'No route matches URL "' + pathname + '"') : status === 405 && (statusText = "Method Not Allowed", method && pathname && routeId ? errorMessage = "You made a " + method.toUpperCase() + ' request to "' + pathname + '" but ' + ('did not provide an `action` for route "' + routeId + '", ') + "so there is no way to handle the request." : method && (errorMessage = 'Invalid request method "' + method.toUpperCase() + '"')), new ErrorResponse(status || 500, statusText, new Error(errorMessage), !0);
    }
    function findRedirect(results) {
      for (let i2 = results.length - 1; i2 >= 0; i2--) {
        let result = results[i2];
        if (isRedirectResult(result))
          return result;
      }
    }
    function stripHashFromPath(path) {
      let parsedPath = typeof path == "string" ? parsePath(path) : path;
      return createPath(_extends({}, parsedPath, {
        hash: ""
      }));
    }
    function isHashChangeOnly(a, b) {
      return a.pathname !== b.pathname || a.search !== b.search ? !1 : a.hash === "" ? b.hash !== "" : a.hash === b.hash ? !0 : b.hash !== "";
    }
    function isDeferredResult(result) {
      return result.type === ResultType.deferred;
    }
    function isErrorResult(result) {
      return result.type === ResultType.error;
    }
    function isRedirectResult(result) {
      return (result && result.type) === ResultType.redirect;
    }
    function isDeferredData(value) {
      let deferred = value;
      return deferred && typeof deferred == "object" && typeof deferred.data == "object" && typeof deferred.subscribe == "function" && typeof deferred.cancel == "function" && typeof deferred.resolveData == "function";
    }
    function isResponse(value) {
      return value != null && typeof value.status == "number" && typeof value.statusText == "string" && typeof value.headers == "object" && typeof value.body < "u";
    }
    function isRedirectResponse(result) {
      if (!isResponse(result))
        return !1;
      let status = result.status, location = result.headers.get("Location");
      return status >= 300 && status <= 399 && location != null;
    }
    function isQueryRouteResponse(obj) {
      return obj && isResponse(obj.response) && (obj.type === ResultType.data || ResultType.error);
    }
    function isValidMethod(method) {
      return validRequestMethods.has(method.toLowerCase());
    }
    function isMutationMethod(method) {
      return validMutationMethods.has(method.toLowerCase());
    }
    async function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {
      for (let index = 0; index < results.length; index++) {
        let result = results[index], match = matchesToLoad[index];
        if (!match)
          continue;
        let currentMatch = currentMatches.find((m2) => m2.route.id === match.route.id), isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== void 0;
        if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {
          let signal = signals[index];
          invariant(signal, "Expected an AbortSignal for revalidating fetcher deferred result"), await resolveDeferredData(result, signal, isFetcher).then((result2) => {
            result2 && (results[index] = result2 || results[index]);
          });
        }
      }
    }
    async function resolveDeferredData(result, signal, unwrap) {
      if (unwrap === void 0 && (unwrap = !1), !await result.deferredData.resolveData(signal)) {
        if (unwrap)
          try {
            return {
              type: ResultType.data,
              data: result.deferredData.unwrappedData
            };
          } catch (e2) {
            return {
              type: ResultType.error,
              error: e2
            };
          }
        return {
          type: ResultType.data,
          data: result.deferredData.data
        };
      }
    }
    function hasNakedIndexQuery(search) {
      return new URLSearchParams(search).getAll("index").some((v) => v === "");
    }
    function createUseMatchesMatch(match, loaderData) {
      let {
        route,
        pathname,
        params
      } = match;
      return {
        id: route.id,
        pathname,
        params,
        data: loaderData[route.id],
        handle: route.handle
      };
    }
    function getTargetMatch(matches, location) {
      let search = typeof location == "string" ? parsePath(location).search : location.search;
      if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || ""))
        return matches[matches.length - 1];
      let pathMatches = getPathContributingMatches(matches);
      return pathMatches[pathMatches.length - 1];
    }
    exports.AbortedDeferredError = AbortedDeferredError;
    exports.ErrorResponse = ErrorResponse;
    exports.IDLE_BLOCKER = IDLE_BLOCKER;
    exports.IDLE_FETCHER = IDLE_FETCHER;
    exports.IDLE_NAVIGATION = IDLE_NAVIGATION;
    exports.UNSAFE_DEFERRED_SYMBOL = UNSAFE_DEFERRED_SYMBOL;
    exports.UNSAFE_DeferredData = DeferredData;
    exports.UNSAFE_convertRoutesToDataRoutes = convertRoutesToDataRoutes;
    exports.UNSAFE_getPathContributingMatches = getPathContributingMatches;
    exports.UNSAFE_invariant = invariant;
    exports.UNSAFE_warning = warning;
    exports.createBrowserHistory = createBrowserHistory;
    exports.createHashHistory = createHashHistory;
    exports.createMemoryHistory = createMemoryHistory;
    exports.createPath = createPath;
    exports.createRouter = createRouter;
    exports.createStaticHandler = createStaticHandler;
    exports.defer = defer;
    exports.generatePath = generatePath;
    exports.getStaticContextFromError = getStaticContextFromError;
    exports.getToPathname = getToPathname;
    exports.isDeferredData = isDeferredData;
    exports.isRouteErrorResponse = isRouteErrorResponse2;
    exports.joinPaths = joinPaths;
    exports.json = json3;
    exports.matchPath = matchPath;
    exports.matchRoutes = matchRoutes;
    exports.normalizePathname = normalizePathname;
    exports.parsePath = parsePath;
    exports.redirect = redirect3;
    exports.resolvePath = resolvePath;
    exports.resolveTo = resolveTo;
    exports.stripBasename = stripBasename;
  }
});

// node_modules/@remix-run/server-runtime/dist/mode.js
var require_mode = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var ServerMode = /* @__PURE__ */ function(ServerMode2) {
      return ServerMode2.Development = "development", ServerMode2.Production = "production", ServerMode2.Test = "test", ServerMode2;
    }({});
    function isServerMode(value) {
      return value === ServerMode.Development || value === ServerMode.Production || value === ServerMode.Test;
    }
    exports.ServerMode = ServerMode;
    exports.isServerMode = isServerMode;
  }
});

// node_modules/@remix-run/server-runtime/dist/errors.js
var require_errors = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var router = require_router_cjs(), mode = require_mode();
    function sanitizeError(error, serverMode) {
      if (error instanceof Error && serverMode !== mode.ServerMode.Development) {
        let sanitized = new Error("Unexpected Server Error");
        return sanitized.stack = void 0, sanitized;
      }
      return error;
    }
    function sanitizeErrors(errors, serverMode) {
      return Object.entries(errors).reduce((acc, [routeId, error]) => Object.assign(acc, {
        [routeId]: sanitizeError(error, serverMode)
      }), {});
    }
    function serializeError(error, serverMode) {
      let sanitized = sanitizeError(error, serverMode);
      return {
        message: sanitized.message,
        stack: sanitized.stack
      };
    }
    function serializeErrors(errors, serverMode) {
      if (!errors)
        return null;
      let entries = Object.entries(errors), serialized = {};
      for (let [key, val] of entries)
        if (router.isRouteErrorResponse(val))
          serialized[key] = {
            ...val,
            __type: "RouteErrorResponse"
          };
        else if (val instanceof Error) {
          let sanitized = sanitizeError(val, serverMode);
          serialized[key] = {
            message: sanitized.message,
            stack: sanitized.stack,
            __type: "Error"
          };
        } else
          serialized[key] = val;
      return serialized;
    }
    exports.sanitizeError = sanitizeError;
    exports.sanitizeErrors = sanitizeErrors;
    exports.serializeError = serializeError;
    exports.serializeErrors = serializeErrors;
  }
});

// node_modules/@remix-run/server-runtime/dist/responses.js
var require_responses = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var router = require_router_cjs(), errors = require_errors(), json3 = (data, init = {}) => router.json(data, init), defer = (data, init = {}) => router.defer(data, init), redirect3 = (url, init = 302) => router.redirect(url, init);
    function isDeferredData(value) {
      let deferred = value;
      return deferred && typeof deferred == "object" && typeof deferred.data == "object" && typeof deferred.subscribe == "function" && typeof deferred.cancel == "function" && typeof deferred.resolveData == "function";
    }
    function isResponse(value) {
      return value != null && typeof value.status == "number" && typeof value.statusText == "string" && typeof value.headers == "object" && typeof value.body < "u";
    }
    var redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
    function isRedirectStatusCode(statusCode) {
      return redirectStatusCodes.has(statusCode);
    }
    function isRedirectResponse(response) {
      return isRedirectStatusCode(response.status);
    }
    function isTrackedPromise(value) {
      return value != null && typeof value.then == "function" && value._tracked === !0;
    }
    var DEFERRED_VALUE_PLACEHOLDER_PREFIX = "__deferred_promise:";
    function createDeferredReadableStream(deferredData, signal, serverMode) {
      let encoder = new TextEncoder();
      return new ReadableStream({
        async start(controller) {
          let criticalData = {}, preresolvedKeys = [];
          for (let [key, value] of Object.entries(deferredData.data))
            isTrackedPromise(value) ? (criticalData[key] = `${DEFERRED_VALUE_PLACEHOLDER_PREFIX}${key}`, (typeof value._data < "u" || typeof value._error < "u") && preresolvedKeys.push(key)) : criticalData[key] = value;
          controller.enqueue(encoder.encode(JSON.stringify(criticalData) + `

`));
          for (let preresolvedKey of preresolvedKeys)
            enqueueTrackedPromise(controller, encoder, preresolvedKey, deferredData.data[preresolvedKey], serverMode);
          let unsubscribe = deferredData.subscribe((aborted, settledKey) => {
            settledKey && enqueueTrackedPromise(controller, encoder, settledKey, deferredData.data[settledKey], serverMode);
          });
          await deferredData.resolveData(signal), unsubscribe(), controller.close();
        }
      });
    }
    function enqueueTrackedPromise(controller, encoder, settledKey, promise, serverMode) {
      "_error" in promise ? controller.enqueue(encoder.encode("error:" + JSON.stringify({
        [settledKey]: promise._error instanceof Error ? errors.serializeError(promise._error, serverMode) : promise._error
      }) + `

`)) : controller.enqueue(encoder.encode("data:" + JSON.stringify({
        [settledKey]: promise._data ?? null
      }) + `

`));
    }
    exports.createDeferredReadableStream = createDeferredReadableStream;
    exports.defer = defer;
    exports.isDeferredData = isDeferredData;
    exports.isRedirectResponse = isRedirectResponse;
    exports.isRedirectStatusCode = isRedirectStatusCode;
    exports.isResponse = isResponse;
    exports.json = json3;
    exports.redirect = redirect3;
  }
});

// node_modules/@remix-run/server-runtime/dist/entry.js
var require_entry = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/entry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function createEntryRouteModules(manifest) {
      return Object.keys(manifest).reduce((memo2, routeId) => (memo2[routeId] = manifest[routeId].module, memo2), {});
    }
    exports.createEntryRouteModules = createEntryRouteModules;
  }
});

// node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS({
  "node_modules/set-cookie-parser/lib/set-cookie.js"(exports, module2) {
    "use strict";
    var defaultParseOptions = {
      decodeValues: !0,
      map: !1,
      silent: !1
    };
    function isNonEmptyString(str) {
      return typeof str == "string" && !!str.trim();
    }
    function parseString(setCookieValue, options) {
      var parts = setCookieValue.split(";").filter(isNonEmptyString), nameValuePairStr = parts.shift(), parsed = parseNameValuePair(nameValuePairStr), name = parsed.name, value = parsed.value;
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      try {
        value = options.decodeValues ? decodeURIComponent(value) : value;
      } catch (e2) {
        console.error(
          "set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.",
          e2
        );
      }
      var cookie = {
        name,
        value
      };
      return parts.forEach(function(part) {
        var sides = part.split("="), key = sides.shift().trimLeft().toLowerCase(), value2 = sides.join("=");
        key === "expires" ? cookie.expires = new Date(value2) : key === "max-age" ? cookie.maxAge = parseInt(value2, 10) : key === "secure" ? cookie.secure = !0 : key === "httponly" ? cookie.httpOnly = !0 : key === "samesite" ? cookie.sameSite = value2 : cookie[key] = value2;
      }), cookie;
    }
    function parseNameValuePair(nameValuePairStr) {
      var name = "", value = "", nameValueArr = nameValuePairStr.split("=");
      return nameValueArr.length > 1 ? (name = nameValueArr.shift(), value = nameValueArr.join("=")) : value = nameValuePairStr, { name, value };
    }
    function parse(input, options) {
      if (options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions, !input)
        return options.map ? {} : [];
      if (input.headers)
        if (typeof input.headers.getSetCookie == "function")
          input = input.headers.getSetCookie();
        else if (input.headers["set-cookie"])
          input = input.headers["set-cookie"];
        else {
          var sch = input.headers[Object.keys(input.headers).find(function(key) {
            return key.toLowerCase() === "set-cookie";
          })];
          !sch && input.headers.cookie && !options.silent && console.warn(
            "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
          ), input = sch;
        }
      if (Array.isArray(input) || (input = [input]), options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions, options.map) {
        var cookies = {};
        return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
          var cookie = parseString(str, options);
          return cookies2[cookie.name] = cookie, cookies2;
        }, cookies);
      } else
        return input.filter(isNonEmptyString).map(function(str) {
          return parseString(str, options);
        });
    }
    function splitCookiesString(cookiesString) {
      if (Array.isArray(cookiesString))
        return cookiesString;
      if (typeof cookiesString != "string")
        return [];
      var cookiesStrings = [], pos = 0, start, ch, lastComma, nextStart, cookiesSeparatorFound;
      function skipWhitespace() {
        for (; pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos)); )
          pos += 1;
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        return ch = cookiesString.charAt(pos), ch !== "=" && ch !== ";" && ch !== ",";
      }
      for (; pos < cookiesString.length; ) {
        for (start = pos, cookiesSeparatorFound = !1; skipWhitespace(); )
          if (ch = cookiesString.charAt(pos), ch === ",") {
            for (lastComma = pos, pos += 1, skipWhitespace(), nextStart = pos; pos < cookiesString.length && notSpecialChar(); )
              pos += 1;
            pos < cookiesString.length && cookiesString.charAt(pos) === "=" ? (cookiesSeparatorFound = !0, pos = nextStart, cookiesStrings.push(cookiesString.substring(start, lastComma)), start = pos) : pos = lastComma + 1;
          } else
            pos += 1;
        (!cookiesSeparatorFound || pos >= cookiesString.length) && cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
      }
      return cookiesStrings;
    }
    module2.exports = parse;
    module2.exports.parse = parse;
    module2.exports.parseString = parseString;
    module2.exports.splitCookiesString = splitCookiesString;
  }
});

// node_modules/@remix-run/server-runtime/dist/headers.js
var require_headers = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/headers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var setCookieParser = require_set_cookie();
    function getDocumentHeadersRR(build, context) {
      let boundaryIdx = context.errors ? context.matches.findIndex((m2) => context.errors[m2.route.id]) : -1, matches = boundaryIdx >= 0 ? context.matches.slice(0, boundaryIdx + 1) : context.matches, errorHeaders;
      if (boundaryIdx >= 0) {
        let {
          actionHeaders,
          actionData,
          loaderHeaders,
          loaderData
        } = context;
        context.matches.slice(boundaryIdx).some((match) => {
          let id = match.route.id;
          return actionHeaders[id] && (!actionData || actionData[id] === void 0) ? errorHeaders = actionHeaders[id] : loaderHeaders[id] && loaderData[id] === void 0 && (errorHeaders = loaderHeaders[id]), errorHeaders != null;
        });
      }
      return matches.reduce((parentHeaders, match, idx) => {
        let {
          id
        } = match.route, routeModule = build.routes[id].module, loaderHeaders = context.loaderHeaders[id] || new Headers(), actionHeaders = context.actionHeaders[id] || new Headers(), includeErrorHeaders = errorHeaders != null && idx === matches.length - 1, includeErrorCookies = includeErrorHeaders && errorHeaders !== loaderHeaders && errorHeaders !== actionHeaders;
        if (routeModule.headers == null && build.future.v2_headers) {
          let headers2 = new Headers(parentHeaders);
          return includeErrorCookies && prependCookies(errorHeaders, headers2), prependCookies(actionHeaders, headers2), prependCookies(loaderHeaders, headers2), headers2;
        }
        let headers = new Headers(routeModule.headers ? typeof routeModule.headers == "function" ? routeModule.headers({
          loaderHeaders,
          parentHeaders,
          actionHeaders,
          errorHeaders: includeErrorHeaders ? errorHeaders : void 0
        }) : routeModule.headers : void 0);
        return includeErrorCookies && prependCookies(errorHeaders, headers), prependCookies(actionHeaders, headers), prependCookies(loaderHeaders, headers), prependCookies(parentHeaders, headers), headers;
      }, new Headers());
    }
    function prependCookies(parentHeaders, childHeaders) {
      let parentSetCookieString = parentHeaders.get("Set-Cookie");
      parentSetCookieString && setCookieParser.splitCookiesString(parentSetCookieString).forEach((cookie) => {
        childHeaders.append("Set-Cookie", cookie);
      });
    }
    exports.getDocumentHeadersRR = getDocumentHeadersRR;
  }
});

// node_modules/@remix-run/server-runtime/dist/invariant.js
var require_invariant = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/invariant.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function invariant(value, message) {
      if (value === !1 || value === null || typeof value > "u")
        throw console.error("The following error is a bug in Remix; please open an issue! https://github.com/remix-run/remix/issues/new"), new Error(message);
    }
    exports.default = invariant;
  }
});

// node_modules/@remix-run/server-runtime/dist/routeMatching.js
var require_routeMatching = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/routeMatching.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var router = require_router_cjs();
    function matchServerRoutes(routes2, pathname) {
      let matches = router.matchRoutes(routes2, pathname);
      return matches ? matches.map((match) => ({
        params: match.params,
        pathname: match.pathname,
        route: match.route
      })) : null;
    }
    exports.matchServerRoutes = matchServerRoutes;
  }
});

// node_modules/@remix-run/server-runtime/dist/data.js
var require_data = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/data.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var responses = require_responses();
    async function callRouteActionRR({
      loadContext,
      action: action3,
      params,
      request,
      routeId
    }) {
      let result = await action3({
        request: stripDataParam(stripIndexParam(request)),
        context: loadContext,
        params
      });
      if (result === void 0)
        throw new Error(`You defined an action for route "${routeId}" but didn't return anything from your \`action\` function. Please return a value or \`null\`.`);
      return responses.isResponse(result) ? result : responses.json(result);
    }
    async function callRouteLoaderRR({
      loadContext,
      loader: loader3,
      params,
      request,
      routeId
    }) {
      let result = await loader3({
        request: stripDataParam(stripIndexParam(request)),
        context: loadContext,
        params
      });
      if (result === void 0)
        throw new Error(`You defined a loader for route "${routeId}" but didn't return anything from your \`loader\` function. Please return a value or \`null\`.`);
      return responses.isDeferredData(result) ? result.init && responses.isRedirectStatusCode(result.init.status || 200) ? responses.redirect(new Headers(result.init.headers).get("Location"), result.init) : result : responses.isResponse(result) ? result : responses.json(result);
    }
    function stripIndexParam(request) {
      let url = new URL(request.url), indexValues = url.searchParams.getAll("index");
      url.searchParams.delete("index");
      let indexValuesToKeep = [];
      for (let indexValue of indexValues)
        indexValue && indexValuesToKeep.push(indexValue);
      for (let toKeep of indexValuesToKeep)
        url.searchParams.append("index", toKeep);
      return new Request(url.href, request);
    }
    function stripDataParam(request) {
      let url = new URL(request.url);
      return url.searchParams.delete("_data"), new Request(url.href, request);
    }
    exports.callRouteActionRR = callRouteActionRR;
    exports.callRouteLoaderRR = callRouteLoaderRR;
  }
});

// node_modules/@remix-run/server-runtime/dist/routes.js
var require_routes = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/routes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var data = require_data();
    function groupRoutesByParentId(manifest) {
      let routes2 = {};
      return Object.values(manifest).forEach((route) => {
        let parentId = route.parentId || "";
        routes2[parentId] || (routes2[parentId] = []), routes2[parentId].push(route);
      }), routes2;
    }
    function createRoutes(manifest, parentId = "", routesByParentId = groupRoutesByParentId(manifest)) {
      return (routesByParentId[parentId] || []).map((route) => ({
        ...route,
        children: createRoutes(manifest, route.id, routesByParentId)
      }));
    }
    function createStaticHandlerDataRoutes(manifest, future2, parentId = "", routesByParentId = groupRoutesByParentId(manifest)) {
      return (routesByParentId[parentId] || []).map((route) => {
        let commonRoute = {
          // Always include root due to default boundaries
          hasErrorBoundary: future2.v2_errorBoundary === !0 ? route.id === "root" || route.module.ErrorBoundary != null : route.id === "root" || route.module.CatchBoundary != null || route.module.ErrorBoundary != null,
          id: route.id,
          path: route.path,
          loader: route.module.loader ? (args) => data.callRouteLoaderRR({
            request: args.request,
            params: args.params,
            loadContext: args.context,
            loader: route.module.loader,
            routeId: route.id
          }) : void 0,
          action: route.module.action ? (args) => data.callRouteActionRR({
            request: args.request,
            params: args.params,
            loadContext: args.context,
            action: route.module.action,
            routeId: route.id
          }) : void 0,
          handle: route.module.handle
        };
        return route.index ? {
          index: !0,
          ...commonRoute
        } : {
          caseSensitive: route.caseSensitive,
          children: createStaticHandlerDataRoutes(manifest, future2, route.id, routesByParentId),
          ...commonRoute
        };
      });
    }
    exports.createRoutes = createRoutes;
    exports.createStaticHandlerDataRoutes = createStaticHandlerDataRoutes;
  }
});

// node_modules/@remix-run/server-runtime/dist/markup.js
var require_markup = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/markup.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var ESCAPE_LOOKUP = {
      "&": "\\u0026",
      ">": "\\u003e",
      "<": "\\u003c",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    }, ESCAPE_REGEX = /[&><\u2028\u2029]/g;
    function escapeHtml(html) {
      return html.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
    }
    exports.escapeHtml = escapeHtml;
  }
});

// node_modules/@remix-run/server-runtime/dist/serverHandoff.js
var require_serverHandoff = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/serverHandoff.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var markup = require_markup();
    function createServerHandoffString(serverHandoff) {
      return markup.escapeHtml(JSON.stringify(serverHandoff));
    }
    exports.createServerHandoffString = createServerHandoffString;
  }
});

// node_modules/@remix-run/server-runtime/dist/server.js
var require_server = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/server.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var router = require_router_cjs(), entry2 = require_entry(), errors = require_errors(), headers = require_headers(), invariant = require_invariant(), mode = require_mode(), routeMatching = require_routeMatching(), routes2 = require_routes(), responses = require_responses(), serverHandoff = require_serverHandoff(), createRequestHandler = (build, mode$1) => {
      let routes$1 = routes2.createRoutes(build.routes), dataRoutes = routes2.createStaticHandlerDataRoutes(build.routes, build.future), serverMode = mode.isServerMode(mode$1) ? mode$1 : mode.ServerMode.Production, staticHandler = router.createStaticHandler(dataRoutes), errorHandler = build.entry.module.handleError || ((error, {
        request
      }) => {
        serverMode !== mode.ServerMode.Test && !request.signal.aborted && console.error(error);
      });
      return async function(request, loadContext = {}) {
        let url = new URL(request.url), matches = routeMatching.matchServerRoutes(routes$1, url.pathname), handleError = (error) => errorHandler(error, {
          context: loadContext,
          params: matches && matches.length > 0 ? matches[0].params : {},
          request
        }), response;
        if (url.searchParams.has("_data")) {
          let routeId = url.searchParams.get("_data");
          if (response = await handleDataRequestRR(serverMode, staticHandler, routeId, request, loadContext, handleError), build.entry.module.handleDataRequest) {
            let match = matches.find((match2) => match2.route.id == routeId);
            response = await build.entry.module.handleDataRequest(response, {
              context: loadContext,
              params: match ? match.params : {},
              request
            });
          }
        } else
          matches && matches[matches.length - 1].route.module.default == null ? response = await handleResourceRequestRR(serverMode, staticHandler, matches.slice(-1)[0].route.id, request, loadContext, handleError) : response = await handleDocumentRequestRR(serverMode, build, staticHandler, request, loadContext, handleError);
        return request.method === "HEAD" ? new Response(null, {
          headers: response.headers,
          status: response.status,
          statusText: response.statusText
        }) : response;
      };
    };
    async function handleDataRequestRR(serverMode, staticHandler, routeId, request, loadContext, handleError) {
      try {
        let response = await staticHandler.queryRoute(request, {
          routeId,
          requestContext: loadContext
        });
        if (responses.isRedirectResponse(response)) {
          let headers2 = new Headers(response.headers);
          return headers2.set("X-Remix-Redirect", headers2.get("Location")), headers2.set("X-Remix-Status", response.status), headers2.delete("Location"), response.headers.get("Set-Cookie") !== null && headers2.set("X-Remix-Revalidate", "yes"), new Response(null, {
            status: 204,
            headers: headers2
          });
        }
        if (router.UNSAFE_DEFERRED_SYMBOL in response) {
          let deferredData = response[router.UNSAFE_DEFERRED_SYMBOL], body = responses.createDeferredReadableStream(deferredData, request.signal, serverMode), init = deferredData.init || {}, headers2 = new Headers(init.headers);
          return headers2.set("Content-Type", "text/remix-deferred"), init.headers = headers2, new Response(body, init);
        }
        return response;
      } catch (error) {
        if (responses.isResponse(error))
          return error.headers.set("X-Remix-Catch", "yes"), error;
        if (router.isRouteErrorResponse(error))
          return error.error && handleError(error.error), errorResponseToJson(error, serverMode);
        let errorInstance = error instanceof Error ? error : new Error("Unexpected Server Error");
        return handleError(errorInstance), router.json(errors.serializeError(errorInstance, serverMode), {
          status: 500,
          headers: {
            "X-Remix-Error": "yes"
          }
        });
      }
    }
    function findParentBoundary(routes3, routeId, error) {
      let route = routes3[routeId] || routes3.root, isCatch = router.isRouteErrorResponse(error) && (!error.error || error.status === 404);
      return isCatch && route.module.CatchBoundary || !isCatch && route.module.ErrorBoundary || !route.parentId ? route.id : findParentBoundary(routes3, route.parentId, error);
    }
    function differentiateCatchVersusErrorBoundaries(build, context) {
      if (!context.errors)
        return;
      let errors2 = {};
      for (let routeId of Object.keys(context.errors)) {
        let error = context.errors[routeId], handlingRouteId = findParentBoundary(build.routes, routeId, error);
        errors2[handlingRouteId] = error;
      }
      context.errors = errors2;
    }
    async function handleDocumentRequestRR(serverMode, build, staticHandler, request, loadContext, handleError) {
      let context;
      try {
        context = await staticHandler.query(request, {
          requestContext: loadContext
        });
      } catch (error) {
        return handleError(error), new Response(null, {
          status: 500
        });
      }
      if (responses.isResponse(context))
        return context;
      context.errors && (Object.values(context.errors).forEach((err) => {
        (!router.isRouteErrorResponse(err) || err.error) && handleError(err);
      }), context.errors = errors.sanitizeErrors(context.errors, serverMode)), build.future.v2_errorBoundary !== !0 && differentiateCatchVersusErrorBoundaries(build, context);
      let headers$1 = headers.getDocumentHeadersRR(build, context), entryContext = {
        manifest: build.assets,
        routeModules: entry2.createEntryRouteModules(build.routes),
        staticHandlerContext: context,
        serverHandoffString: serverHandoff.createServerHandoffString({
          state: {
            loaderData: context.loaderData,
            actionData: context.actionData,
            errors: errors.serializeErrors(context.errors, serverMode)
          },
          future: build.future,
          dev: build.dev
        }),
        future: build.future
      }, handleDocumentRequestFunction = build.entry.module.default;
      try {
        return await handleDocumentRequestFunction(request, context.statusCode, headers$1, entryContext, loadContext);
      } catch (error) {
        handleError(error), context = router.getStaticContextFromError(staticHandler.dataRoutes, context, error), context.errors && (context.errors = errors.sanitizeErrors(context.errors, serverMode)), build.future.v2_errorBoundary !== !0 && differentiateCatchVersusErrorBoundaries(build, context), entryContext = {
          ...entryContext,
          staticHandlerContext: context,
          serverHandoffString: serverHandoff.createServerHandoffString({
            state: {
              loaderData: context.loaderData,
              actionData: context.actionData,
              errors: errors.serializeErrors(context.errors, serverMode)
            },
            future: build.future
          })
        };
        try {
          return await handleDocumentRequestFunction(request, context.statusCode, headers$1, entryContext, loadContext);
        } catch (error2) {
          return handleError(error2), returnLastResortErrorResponse(error2, serverMode);
        }
      }
    }
    async function handleResourceRequestRR(serverMode, staticHandler, routeId, request, loadContext, handleError) {
      try {
        let response = await staticHandler.queryRoute(request, {
          routeId,
          requestContext: loadContext
        });
        return invariant.default(responses.isResponse(response), "Expected a Response to be returned from queryRoute"), response;
      } catch (error) {
        return responses.isResponse(error) ? (error.headers.set("X-Remix-Catch", "yes"), error) : router.isRouteErrorResponse(error) ? (error.error && handleError(error.error), errorResponseToJson(error, serverMode)) : (handleError(error), returnLastResortErrorResponse(error, serverMode));
      }
    }
    function errorResponseToJson(errorResponse, serverMode) {
      return router.json(errors.serializeError(errorResponse.error || new Error("Unexpected Server Error"), serverMode), {
        status: errorResponse.status,
        statusText: errorResponse.statusText,
        headers: {
          "X-Remix-Error": "yes"
        }
      });
    }
    function returnLastResortErrorResponse(error, serverMode) {
      let message = "Unexpected Server Error";
      return serverMode !== mode.ServerMode.Production && (message += `

${String(error)}`), new Response(message, {
        status: 500,
        headers: {
          "Content-Type": "text/plain"
        }
      });
    }
    exports.createRequestHandler = createRequestHandler;
    exports.differentiateCatchVersusErrorBoundaries = differentiateCatchVersusErrorBoundaries;
  }
});

// node_modules/@remix-run/server-runtime/dist/sessions.js
var require_sessions = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/sessions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var cookies = require_cookies(), warnings = require_warnings();
    function flash(name) {
      return `__flash_${name}__`;
    }
    var createSession = (initialData = {}, id = "") => {
      let map = new Map(Object.entries(initialData));
      return {
        get id() {
          return id;
        },
        get data() {
          return Object.fromEntries(map);
        },
        has(name) {
          return map.has(name) || map.has(flash(name));
        },
        get(name) {
          if (map.has(name))
            return map.get(name);
          let flashName = flash(name);
          if (map.has(flashName)) {
            let value = map.get(flashName);
            return map.delete(flashName), value;
          }
        },
        set(name, value) {
          map.set(name, value);
        },
        flash(name, value) {
          map.set(flash(name), value);
        },
        unset(name) {
          map.delete(name);
        }
      };
    }, isSession = (object) => object != null && typeof object.id == "string" && typeof object.data < "u" && typeof object.has == "function" && typeof object.get == "function" && typeof object.set == "function" && typeof object.flash == "function" && typeof object.unset == "function", createSessionStorageFactory = (createCookie) => ({
      cookie: cookieArg,
      createData,
      readData,
      updateData,
      deleteData
    }) => {
      let cookie = cookies.isCookie(cookieArg) ? cookieArg : createCookie((cookieArg == null ? void 0 : cookieArg.name) || "__session", cookieArg);
      return warnOnceAboutSigningSessionCookie(cookie), {
        async getSession(cookieHeader, options) {
          let id = cookieHeader && await cookie.parse(cookieHeader, options), data = id && await readData(id);
          return createSession(data || {}, id || "");
        },
        async commitSession(session, options) {
          let {
            id,
            data
          } = session;
          return id ? await updateData(id, data, cookie.expires) : id = await createData(data, cookie.expires), cookie.serialize(id, options);
        },
        async destroySession(session, options) {
          return await deleteData(session.id), cookie.serialize("", {
            ...options,
            expires: /* @__PURE__ */ new Date(0)
          });
        }
      };
    };
    function warnOnceAboutSigningSessionCookie(cookie) {
      warnings.warnOnce(cookie.isSigned, `The "${cookie.name}" cookie is not signed, but session cookies should be signed to prevent tampering on the client before they are sent back to the server. See https://remix.run/utils/cookies#signing-cookies for more information.`);
    }
    exports.createSession = createSession;
    exports.createSessionStorageFactory = createSessionStorageFactory;
    exports.isSession = isSession;
    exports.warnOnceAboutSigningSessionCookie = warnOnceAboutSigningSessionCookie;
  }
});

// node_modules/@remix-run/server-runtime/dist/sessions/cookieStorage.js
var require_cookieStorage = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/sessions/cookieStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var cookies = require_cookies(), sessions = require_sessions(), createCookieSessionStorageFactory = (createCookie) => ({
      cookie: cookieArg
    } = {}) => {
      let cookie = cookies.isCookie(cookieArg) ? cookieArg : createCookie((cookieArg == null ? void 0 : cookieArg.name) || "__session", cookieArg);
      return sessions.warnOnceAboutSigningSessionCookie(cookie), {
        async getSession(cookieHeader, options) {
          return sessions.createSession(cookieHeader && await cookie.parse(cookieHeader, options) || {});
        },
        async commitSession(session, options) {
          let serializedCookie = await cookie.serialize(session.data, options);
          if (serializedCookie.length > 4096)
            throw new Error("Cookie length will exceed browser maximum. Length: " + serializedCookie.length);
          return serializedCookie;
        },
        async destroySession(_session, options) {
          return cookie.serialize("", {
            ...options,
            expires: /* @__PURE__ */ new Date(0)
          });
        }
      };
    };
    exports.createCookieSessionStorageFactory = createCookieSessionStorageFactory;
  }
});

// node_modules/@remix-run/server-runtime/dist/sessions/memoryStorage.js
var require_memoryStorage = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/sessions/memoryStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var createMemorySessionStorageFactory = (createSessionStorage) => ({
      cookie
    } = {}) => {
      let uniqueId = 0, map = /* @__PURE__ */ new Map();
      return createSessionStorage({
        cookie,
        async createData(data, expires) {
          let id = (++uniqueId).toString();
          return map.set(id, {
            data,
            expires
          }), id;
        },
        async readData(id) {
          if (map.has(id)) {
            let {
              data,
              expires
            } = map.get(id);
            if (!expires || expires > /* @__PURE__ */ new Date())
              return data;
            expires && map.delete(id);
          }
          return null;
        },
        async updateData(id, data, expires) {
          map.set(id, {
            data,
            expires
          });
        },
        async deleteData(id) {
          map.delete(id);
        }
      });
    };
    exports.createMemorySessionStorageFactory = createMemorySessionStorageFactory;
  }
});

// node_modules/@remix-run/server-runtime/dist/upload/errors.js
var require_errors2 = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/upload/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var MaxPartSizeExceededError = class extends Error {
      constructor(field, maxBytes) {
        super(`Field "${field}" exceeded upload size of ${maxBytes} bytes.`), this.field = field, this.maxBytes = maxBytes;
      }
    };
    exports.MaxPartSizeExceededError = MaxPartSizeExceededError;
  }
});

// node_modules/@remix-run/server-runtime/dist/upload/memoryUploadHandler.js
var require_memoryUploadHandler = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/upload/memoryUploadHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var errors = require_errors2();
    function createMemoryUploadHandler({
      filter,
      maxPartSize = 3e6
    } = {}) {
      return async ({
        filename,
        contentType,
        name,
        data
      }) => {
        if (filter && !await filter({
          filename,
          contentType,
          name
        }))
          return;
        let size = 0, chunks = [];
        for await (let chunk of data) {
          if (size += chunk.byteLength, size > maxPartSize)
            throw new errors.MaxPartSizeExceededError(name, maxPartSize);
          chunks.push(chunk);
        }
        return typeof filename == "string" ? new File(chunks, filename, {
          type: contentType
        }) : await new Blob(chunks, {
          type: contentType
        }).text();
      };
    }
    exports.createMemoryUploadHandler = createMemoryUploadHandler;
  }
});

// node_modules/@remix-run/server-runtime/dist/dev.js
var require_dev = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function broadcastDevReady(build, origin) {
      if (origin ?? (origin = ""), !origin)
        throw Error("Dev server origin not set");
      fetch(`${origin}/ping`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          buildHash: build.assets.version
        })
      }).catch((error) => {
        console.error(`Could not reach Remix dev server at ${origin}`);
      });
    }
    function logDevReady(build) {
      console.log(`[REMIX DEV] ${build.assets.version} ready`);
    }
    exports.broadcastDevReady = broadcastDevReady;
    exports.logDevReady = logDevReady;
  }
});

// node_modules/@remix-run/server-runtime/dist/index.js
var require_dist = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var cookies = require_cookies(), formData = require_formData(), responses = require_responses(), server = require_server(), sessions = require_sessions(), cookieStorage = require_cookieStorage(), memoryStorage = require_memoryStorage(), memoryUploadHandler = require_memoryUploadHandler(), errors = require_errors2(), dev = require_dev();
    exports.createCookieFactory = cookies.createCookieFactory;
    exports.isCookie = cookies.isCookie;
    exports.unstable_composeUploadHandlers = formData.composeUploadHandlers;
    exports.unstable_parseMultipartFormData = formData.parseMultipartFormData;
    exports.defer = responses.defer;
    exports.json = responses.json;
    exports.redirect = responses.redirect;
    exports.createRequestHandler = server.createRequestHandler;
    exports.createSession = sessions.createSession;
    exports.createSessionStorageFactory = sessions.createSessionStorageFactory;
    exports.isSession = sessions.isSession;
    exports.createCookieSessionStorageFactory = cookieStorage.createCookieSessionStorageFactory;
    exports.createMemorySessionStorageFactory = memoryStorage.createMemorySessionStorageFactory;
    exports.unstable_createMemoryUploadHandler = memoryUploadHandler.createMemoryUploadHandler;
    exports.MaxPartSizeExceededError = errors.MaxPartSizeExceededError;
    exports.broadcastDevReady = dev.broadcastDevReady;
    exports.logDevReady = dev.logDevReady;
  }
});

// node_modules/cookie-signature/index.js
var require_cookie_signature = __commonJS({
  "node_modules/cookie-signature/index.js"(exports) {
    var crypto = require("crypto");
    exports.sign = function(val, secret) {
      if (typeof val != "string")
        throw new TypeError("Cookie value must be provided as a string.");
      if (secret == null)
        throw new TypeError("Secret key must be provided.");
      return val + "." + crypto.createHmac("sha256", secret).update(val).digest("base64").replace(/\=+$/, "");
    };
    exports.unsign = function(input, secret) {
      if (typeof input != "string")
        throw new TypeError("Signed cookie string must be provided.");
      if (secret == null)
        throw new TypeError("Secret key must be provided.");
      var tentativeValue = input.slice(0, input.lastIndexOf(".")), expectedInput = exports.sign(tentativeValue, secret), expectedBuffer = Buffer.from(expectedInput), inputBuffer = Buffer.from(input);
      return expectedBuffer.length === inputBuffer.length && crypto.timingSafeEqual(expectedBuffer, inputBuffer) ? tentativeValue : !1;
    };
  }
});

// node_modules/@remix-run/node/dist/crypto.js
var require_crypto = __commonJS({
  "node_modules/@remix-run/node/dist/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var cookieSignature = require_cookie_signature();
    function _interopDefaultLegacy(e2) {
      return e2 && typeof e2 == "object" && "default" in e2 ? e2 : { default: e2 };
    }
    var cookieSignature__default = /* @__PURE__ */ _interopDefaultLegacy(cookieSignature), sign = async (value, secret) => cookieSignature__default.default.sign(value, secret), unsign = async (signed, secret) => cookieSignature__default.default.unsign(signed, secret);
    exports.sign = sign;
    exports.unsign = unsign;
  }
});

// node_modules/@remix-run/node/dist/implementations.js
var require_implementations = __commonJS({
  "node_modules/@remix-run/node/dist/implementations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var serverRuntime = require_dist(), crypto = require_crypto(), createCookie = serverRuntime.createCookieFactory({
      sign: crypto.sign,
      unsign: crypto.unsign
    }), createCookieSessionStorage = serverRuntime.createCookieSessionStorageFactory(createCookie), createSessionStorage = serverRuntime.createSessionStorageFactory(createCookie), createMemorySessionStorage = serverRuntime.createMemorySessionStorageFactory(createSessionStorage);
    exports.createCookie = createCookie;
    exports.createCookieSessionStorage = createCookieSessionStorage;
    exports.createMemorySessionStorage = createMemorySessionStorage;
    exports.createSessionStorage = createSessionStorage;
  }
});

// node_modules/@remix-run/node/dist/sessions/fileStorage.js
var require_fileStorage = __commonJS({
  "node_modules/@remix-run/node/dist/sessions/fileStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var crypto = require("crypto"), fs2 = require("fs"), path = require("path"), implementations = require_implementations();
    function _interopNamespace(e2) {
      if (e2 && e2.__esModule)
        return e2;
      var n = /* @__PURE__ */ Object.create(null);
      return e2 && Object.keys(e2).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e2, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e2[k];
            }
          });
        }
      }), n.default = e2, Object.freeze(n);
    }
    var crypto__namespace = /* @__PURE__ */ _interopNamespace(crypto), path__namespace = /* @__PURE__ */ _interopNamespace(path);
    function createFileSessionStorage({
      cookie,
      dir
    }) {
      return implementations.createSessionStorage({
        cookie,
        async createData(data, expires) {
          let content = JSON.stringify({
            data,
            expires
          });
          for (; ; ) {
            let randomBytes = crypto__namespace.randomBytes(8), id = Buffer.from(randomBytes).toString("hex");
            try {
              let file = getFile(dir, id);
              return await fs2.promises.mkdir(path__namespace.dirname(file), {
                recursive: !0
              }), await fs2.promises.writeFile(file, content, {
                encoding: "utf-8",
                flag: "wx"
              }), id;
            } catch (error) {
              if (error.code !== "EEXIST")
                throw error;
            }
          }
        },
        async readData(id) {
          try {
            let file = getFile(dir, id), content = JSON.parse(await fs2.promises.readFile(file, "utf-8")), data = content.data, expires = typeof content.expires == "string" ? new Date(content.expires) : null;
            return !expires || expires > /* @__PURE__ */ new Date() ? data : (expires && await fs2.promises.unlink(file), null);
          } catch (error) {
            if (error.code !== "ENOENT")
              throw error;
            return null;
          }
        },
        async updateData(id, data, expires) {
          let content = JSON.stringify({
            data,
            expires
          }), file = getFile(dir, id);
          await fs2.promises.mkdir(path__namespace.dirname(file), {
            recursive: !0
          }), await fs2.promises.writeFile(file, content, "utf-8");
        },
        async deleteData(id) {
          if (id)
            try {
              await fs2.promises.unlink(getFile(dir, id));
            } catch (error) {
              if (error.code !== "ENOENT")
                throw error;
            }
        }
      });
    }
    function getFile(dir, id) {
      return path__namespace.join(dir, id.slice(0, 4), id.slice(4));
    }
    exports.createFileSessionStorage = createFileSessionStorage;
  }
});

// node_modules/stream-slice/index.js
var require_stream_slice = __commonJS({
  "node_modules/stream-slice/index.js"(exports) {
    var util = require("util"), Transform = require("stream").Transform;
    util.inherits(SliceStream, Transform);
    function SliceStream(start, end) {
      if (!(this instanceof SliceStream))
        return new SliceStream();
      Transform.call(this), this._start = start || 0, this._end = end || 1 / 0, this._offset = 0, this._state = 0, this._emitUp = !1, this._emitDown = !1;
    }
    SliceStream.prototype._transform = function(chunk, encoding, done) {
      if (this._offset += chunk.length, !this._emitUp && this._offset >= this._start) {
        this._emitUp = !0;
        var start = chunk.length - (this._offset - this._start);
        if (this._offset > this._end) {
          var end = chunk.length - (this._offset - this._end);
          this._emitDown = !0, this.push(chunk.slice(start, end));
        } else
          this.push(chunk.slice(start, chunk.length));
        return done();
      }
      return this._emitUp && !this._emitDown && (this._offset >= this._end ? (this._emitDown = !0, this.push(chunk.slice(0, chunk.length - (this._offset - this._end)))) : this.push(chunk)), done();
    };
    exports.slice = function(start, end) {
      return new SliceStream(start, end);
    };
  }
});

// node_modules/@remix-run/node/dist/stream.js
var require_stream2 = __commonJS({
  "node_modules/@remix-run/node/dist/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var stream = require("stream");
    async function writeReadableStreamToWritable(stream2, writable) {
      let reader = stream2.getReader();
      async function read() {
        let {
          done,
          value
        } = await reader.read();
        if (done) {
          writable.end();
          return;
        }
        writable.write(value);
        let flushable = writable;
        typeof flushable.flush == "function" && flushable.flush(), await read();
      }
      try {
        await read();
      } catch (error) {
        throw writable.destroy(error), error;
      }
    }
    async function writeAsyncIterableToWritable(iterable, writable) {
      try {
        for await (let chunk of iterable)
          writable.write(chunk);
        writable.end();
      } catch (error) {
        throw writable.destroy(error), error;
      }
    }
    async function readableStreamToString(stream2, encoding) {
      let reader = stream2.getReader(), chunks = [];
      async function read() {
        let {
          done,
          value
        } = await reader.read();
        done || (value && chunks.push(value), await read());
      }
      return await read(), Buffer.concat(chunks).toString(encoding);
    }
    var createReadableStreamFromReadable = (source) => {
      let pump2 = new StreamPump(source);
      return new ReadableStream(pump2, pump2);
    }, StreamPump = class {
      constructor(stream$1) {
        this.highWaterMark = stream$1.readableHighWaterMark || new stream.Stream.Readable().readableHighWaterMark, this.accumalatedSize = 0, this.stream = stream$1, this.enqueue = this.enqueue.bind(this), this.error = this.error.bind(this), this.close = this.close.bind(this);
      }
      size(chunk) {
        return (chunk == null ? void 0 : chunk.byteLength) || 0;
      }
      start(controller) {
        this.controller = controller, this.stream.on("data", this.enqueue), this.stream.once("error", this.error), this.stream.once("end", this.close), this.stream.once("close", this.close);
      }
      pull() {
        this.resume();
      }
      cancel(reason) {
        this.stream.destroy && this.stream.destroy(reason), this.stream.off("data", this.enqueue), this.stream.off("error", this.error), this.stream.off("end", this.close), this.stream.off("close", this.close);
      }
      enqueue(chunk) {
        if (this.controller)
          try {
            let bytes = chunk instanceof Uint8Array ? chunk : Buffer.from(chunk), available = (this.controller.desiredSize || 0) - bytes.byteLength;
            this.controller.enqueue(bytes), available <= 0 && this.pause();
          } catch {
            this.controller.error(new Error("Could not create Buffer, chunk must be of type string or an instance of Buffer, ArrayBuffer, or Array or an Array-like Object")), this.cancel();
          }
      }
      pause() {
        this.stream.pause && this.stream.pause();
      }
      resume() {
        this.stream.readable && this.stream.resume && this.stream.resume();
      }
      close() {
        this.controller && (this.controller.close(), delete this.controller);
      }
      error(error) {
        this.controller && (this.controller.error(error), delete this.controller);
      }
    };
    exports.createReadableStreamFromReadable = createReadableStreamFromReadable;
    exports.readableStreamToString = readableStreamToString;
    exports.writeAsyncIterableToWritable = writeAsyncIterableToWritable;
    exports.writeReadableStreamToWritable = writeReadableStreamToWritable;
  }
});

// node_modules/@remix-run/node/dist/upload/fileUploadHandler.js
var require_fileUploadHandler = __commonJS({
  "node_modules/@remix-run/node/dist/upload/fileUploadHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var crypto = require("crypto"), fs2 = require("fs"), promises = require("fs/promises"), os = require("os"), path = require("path"), stream = require("stream"), util = require("util"), serverRuntime = require_dist(), streamSlice = require_stream_slice(), stream$1 = require_stream2();
    function _interopNamespace(e2) {
      if (e2 && e2.__esModule)
        return e2;
      var n = /* @__PURE__ */ Object.create(null);
      return e2 && Object.keys(e2).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e2, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e2[k];
            }
          });
        }
      }), n.default = e2, Object.freeze(n);
    }
    var streamSlice__namespace = /* @__PURE__ */ _interopNamespace(streamSlice), defaultFilePathResolver = ({
      filename
    }) => {
      let ext = filename ? path.extname(filename) : "";
      return "upload_" + crypto.randomBytes(4).readUInt32LE(0) + ext;
    };
    async function uniqueFile(filepath) {
      let ext = path.extname(filepath), uniqueFilepath = filepath;
      for (let i2 = 1; await promises.stat(uniqueFilepath).then(() => !0).catch(() => !1); i2++)
        uniqueFilepath = (ext ? filepath.slice(0, -ext.length) : filepath) + `-${(/* @__PURE__ */ new Date()).getTime()}${ext}`;
      return uniqueFilepath;
    }
    function createFileUploadHandler({
      directory = os.tmpdir(),
      avoidFileConflicts = !0,
      file = defaultFilePathResolver,
      filter,
      maxPartSize = 3e6
    } = {}) {
      return async ({
        name,
        filename,
        contentType,
        data
      }) => {
        if (!filename || filter && !await filter({
          name,
          filename,
          contentType
        }))
          return;
        let dir = typeof directory == "string" ? directory : directory({
          name,
          filename,
          contentType
        });
        if (!dir)
          return;
        let filedir = path.resolve(dir), path$1 = typeof file == "string" ? file : file({
          name,
          filename,
          contentType
        });
        if (!path$1)
          return;
        let filepath = path.resolve(filedir, path$1);
        avoidFileConflicts && (filepath = await uniqueFile(filepath)), await promises.mkdir(path.dirname(filepath), {
          recursive: !0
        }).catch(() => {
        });
        let writeFileStream = fs2.createWriteStream(filepath), size = 0, deleteFile = !1;
        try {
          for await (let chunk of data) {
            if (size += chunk.byteLength, size > maxPartSize)
              throw deleteFile = !0, new serverRuntime.MaxPartSizeExceededError(name, maxPartSize);
            writeFileStream.write(chunk);
          }
        } finally {
          writeFileStream.end(), await util.promisify(stream.finished)(writeFileStream), deleteFile && await promises.rm(filepath).catch(() => {
          });
        }
        return new NodeOnDiskFile(filepath, contentType);
      };
    }
    var NodeOnDiskFile = class {
      lastModified = 0;
      webkitRelativePath = "";
      constructor(filepath, type, slicer) {
        this.filepath = filepath, this.type = type, this.slicer = slicer, this.name = path.basename(filepath);
      }
      get size() {
        let stats = fs2.statSync(this.filepath);
        if (this.slicer) {
          let slice = this.slicer.end - this.slicer.start;
          return slice < 0 ? 0 : slice > stats.size ? stats.size : slice;
        }
        return stats.size;
      }
      slice(start, end, type) {
        var _this$slicer;
        typeof start == "number" && start < 0 && (start = this.size + start), typeof end == "number" && end < 0 && (end = this.size + end);
        let startOffset = ((_this$slicer = this.slicer) === null || _this$slicer === void 0 ? void 0 : _this$slicer.start) || 0;
        return start = startOffset + (start || 0), end = startOffset + (end || this.size), new NodeOnDiskFile(this.filepath, typeof type == "string" ? type : this.type, {
          start,
          end
        });
      }
      async arrayBuffer() {
        let stream2 = fs2.createReadStream(this.filepath);
        return this.slicer && (stream2 = stream2.pipe(streamSlice__namespace.slice(this.slicer.start, this.slicer.end))), new Promise((resolve, reject) => {
          let buf = [];
          stream2.on("data", (chunk) => buf.push(chunk)), stream2.on("end", () => resolve(Buffer.concat(buf))), stream2.on("error", (err) => reject(err));
        });
      }
      stream() {
        let stream2 = fs2.createReadStream(this.filepath);
        return this.slicer && (stream2 = stream2.pipe(streamSlice__namespace.slice(this.slicer.start, this.slicer.end))), stream$1.createReadableStreamFromReadable(stream2);
      }
      async text() {
        return stream$1.readableStreamToString(this.stream());
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
      remove() {
        return promises.unlink(this.filepath);
      }
      getFilePath() {
        return this.filepath;
      }
    };
    exports.NodeOnDiskFile = NodeOnDiskFile;
    exports.createFileUploadHandler = createFileUploadHandler;
  }
});

// node_modules/@remix-run/node/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@remix-run/node/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var sourceMapSupport = require_source_map_support(), abortController = require_abort_controller(), fetch4 = require_fetch(), globals = require_globals(), fileStorage = require_fileStorage(), fileUploadHandler = require_fileUploadHandler(), implementations = require_implementations(), stream = require_stream2(), serverRuntime = require_dist(), webFetch = require_lib_node3();
    function _interopDefaultLegacy(e2) {
      return e2 && typeof e2 == "object" && "default" in e2 ? e2 : { default: e2 };
    }
    var sourceMapSupport__default = /* @__PURE__ */ _interopDefaultLegacy(sourceMapSupport);
    sourceMapSupport__default.default.install();
    Object.defineProperty(exports, "AbortController", {
      enumerable: !0,
      get: function() {
        return abortController.AbortController;
      }
    });
    exports.Request = fetch4.Request;
    exports.Response = fetch4.Response;
    exports.fetch = fetch4.fetch;
    exports.installGlobals = globals.installGlobals;
    exports.createFileSessionStorage = fileStorage.createFileSessionStorage;
    exports.NodeOnDiskFile = fileUploadHandler.NodeOnDiskFile;
    exports.unstable_createFileUploadHandler = fileUploadHandler.createFileUploadHandler;
    exports.createCookie = implementations.createCookie;
    exports.createCookieSessionStorage = implementations.createCookieSessionStorage;
    exports.createMemorySessionStorage = implementations.createMemorySessionStorage;
    exports.createSessionStorage = implementations.createSessionStorage;
    exports.createReadableStreamFromReadable = stream.createReadableStreamFromReadable;
    exports.readableStreamToString = stream.readableStreamToString;
    exports.writeAsyncIterableToWritable = stream.writeAsyncIterableToWritable;
    exports.writeReadableStreamToWritable = stream.writeReadableStreamToWritable;
    Object.defineProperty(exports, "MaxPartSizeExceededError", {
      enumerable: !0,
      get: function() {
        return serverRuntime.MaxPartSizeExceededError;
      }
    });
    Object.defineProperty(exports, "broadcastDevReady", {
      enumerable: !0,
      get: function() {
        return serverRuntime.broadcastDevReady;
      }
    });
    Object.defineProperty(exports, "createRequestHandler", {
      enumerable: !0,
      get: function() {
        return serverRuntime.createRequestHandler;
      }
    });
    Object.defineProperty(exports, "createSession", {
      enumerable: !0,
      get: function() {
        return serverRuntime.createSession;
      }
    });
    Object.defineProperty(exports, "defer", {
      enumerable: !0,
      get: function() {
        return serverRuntime.defer;
      }
    });
    Object.defineProperty(exports, "isCookie", {
      enumerable: !0,
      get: function() {
        return serverRuntime.isCookie;
      }
    });
    Object.defineProperty(exports, "isSession", {
      enumerable: !0,
      get: function() {
        return serverRuntime.isSession;
      }
    });
    Object.defineProperty(exports, "json", {
      enumerable: !0,
      get: function() {
        return serverRuntime.json;
      }
    });
    Object.defineProperty(exports, "logDevReady", {
      enumerable: !0,
      get: function() {
        return serverRuntime.logDevReady;
      }
    });
    Object.defineProperty(exports, "redirect", {
      enumerable: !0,
      get: function() {
        return serverRuntime.redirect;
      }
    });
    Object.defineProperty(exports, "unstable_composeUploadHandlers", {
      enumerable: !0,
      get: function() {
        return serverRuntime.unstable_composeUploadHandlers;
      }
    });
    Object.defineProperty(exports, "unstable_createMemoryUploadHandler", {
      enumerable: !0,
      get: function() {
        return serverRuntime.unstable_createMemoryUploadHandler;
      }
    });
    Object.defineProperty(exports, "unstable_parseMultipartFormData", {
      enumerable: !0,
      get: function() {
        return serverRuntime.unstable_parseMultipartFormData;
      }
    });
    Object.defineProperty(exports, "FormData", {
      enumerable: !0,
      get: function() {
        return webFetch.FormData;
      }
    });
    Object.defineProperty(exports, "Headers", {
      enumerable: !0,
      get: function() {
        return webFetch.Headers;
      }
    });
  }
});

// node_modules/react/cjs/react.production.min.js
var require_react_production_min = __commonJS({
  "node_modules/react/cjs/react.production.min.js"(exports) {
    "use strict";
    var l = Symbol.for("react.element"), n = Symbol.for("react.portal"), p = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), r2 = Symbol.for("react.profiler"), t2 = Symbol.for("react.provider"), u = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x2 = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z = Symbol.iterator;
    function A2(a) {
      return a === null || typeof a != "object" ? null : (a = z && a[z] || a["@@iterator"], typeof a == "function" ? a : null);
    }
    var B = { isMounted: function() {
      return !1;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } }, C = Object.assign, D = {};
    function E(a, b, e2) {
      this.props = a, this.context = b, this.refs = D, this.updater = e2 || B;
    }
    E.prototype.isReactComponent = {};
    E.prototype.setState = function(a, b) {
      if (typeof a != "object" && typeof a != "function" && a != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, a, b, "setState");
    };
    E.prototype.forceUpdate = function(a) {
      this.updater.enqueueForceUpdate(this, a, "forceUpdate");
    };
    function F2() {
    }
    F2.prototype = E.prototype;
    function G(a, b, e2) {
      this.props = a, this.context = b, this.refs = D, this.updater = e2 || B;
    }
    var H = G.prototype = new F2();
    H.constructor = G;
    C(H, E.prototype);
    H.isPureReactComponent = !0;
    var I = Array.isArray, J = Object.prototype.hasOwnProperty, K = { current: null }, L = { key: !0, ref: !0, __self: !0, __source: !0 };
    function M(a, b, e2) {
      var d, c = {}, k = null, h2 = null;
      if (b != null)
        for (d in b.ref !== void 0 && (h2 = b.ref), b.key !== void 0 && (k = "" + b.key), b)
          J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
      var g = arguments.length - 2;
      if (g === 1)
        c.children = e2;
      else if (1 < g) {
        for (var f3 = Array(g), m2 = 0; m2 < g; m2++)
          f3[m2] = arguments[m2 + 2];
        c.children = f3;
      }
      if (a && a.defaultProps)
        for (d in g = a.defaultProps, g)
          c[d] === void 0 && (c[d] = g[d]);
      return { $$typeof: l, type: a, key: k, ref: h2, props: c, _owner: K.current };
    }
    function N(a, b) {
      return { $$typeof: l, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
    }
    function O(a) {
      return typeof a == "object" && a !== null && a.$$typeof === l;
    }
    function escape2(a) {
      var b = { "=": "=0", ":": "=2" };
      return "$" + a.replace(/[=:]/g, function(a2) {
        return b[a2];
      });
    }
    var P = /\/+/g;
    function Q(a, b) {
      return typeof a == "object" && a !== null && a.key != null ? escape2("" + a.key) : b.toString(36);
    }
    function R(a, b, e2, d, c) {
      var k = typeof a;
      (k === "undefined" || k === "boolean") && (a = null);
      var h2 = !1;
      if (a === null)
        h2 = !0;
      else
        switch (k) {
          case "string":
          case "number":
            h2 = !0;
            break;
          case "object":
            switch (a.$$typeof) {
              case l:
              case n:
                h2 = !0;
            }
        }
      if (h2)
        return h2 = a, c = c(h2), a = d === "" ? "." + Q(h2, 0) : d, I(c) ? (e2 = "", a != null && (e2 = a.replace(P, "$&/") + "/"), R(c, b, e2, "", function(a2) {
          return a2;
        })) : c != null && (O(c) && (c = N(c, e2 + (!c.key || h2 && h2.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
      if (h2 = 0, d = d === "" ? "." : d + ":", I(a))
        for (var g = 0; g < a.length; g++) {
          k = a[g];
          var f3 = d + Q(k, g);
          h2 += R(k, b, e2, f3, c);
        }
      else if (f3 = A2(a), typeof f3 == "function")
        for (a = f3.call(a), g = 0; !(k = a.next()).done; )
          k = k.value, f3 = d + Q(k, g++), h2 += R(k, b, e2, f3, c);
      else if (k === "object")
        throw b = String(a), Error("Objects are not valid as a React child (found: " + (b === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
      return h2;
    }
    function S2(a, b, e2) {
      if (a == null)
        return a;
      var d = [], c = 0;
      return R(a, d, "", "", function(a2) {
        return b.call(e2, a2, c++);
      }), d;
    }
    function T(a) {
      if (a._status === -1) {
        var b = a._result;
        b = b(), b.then(function(b2) {
          (a._status === 0 || a._status === -1) && (a._status = 1, a._result = b2);
        }, function(b2) {
          (a._status === 0 || a._status === -1) && (a._status = 2, a._result = b2);
        }), a._status === -1 && (a._status = 0, a._result = b);
      }
      if (a._status === 1)
        return a._result.default;
      throw a._result;
    }
    var U = { current: null }, V = { transition: null }, W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
    exports.Children = { map: S2, forEach: function(a, b, e2) {
      S2(a, function() {
        b.apply(this, arguments);
      }, e2);
    }, count: function(a) {
      var b = 0;
      return S2(a, function() {
        b++;
      }), b;
    }, toArray: function(a) {
      return S2(a, function(a2) {
        return a2;
      }) || [];
    }, only: function(a) {
      if (!O(a))
        throw Error("React.Children.only expected to receive a single React element child.");
      return a;
    } };
    exports.Component = E;
    exports.Fragment = p;
    exports.Profiler = r2;
    exports.PureComponent = G;
    exports.StrictMode = q;
    exports.Suspense = w;
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
    exports.cloneElement = function(a, b, e2) {
      if (a == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
      var d = C({}, a.props), c = a.key, k = a.ref, h2 = a._owner;
      if (b != null) {
        if (b.ref !== void 0 && (k = b.ref, h2 = K.current), b.key !== void 0 && (c = "" + b.key), a.type && a.type.defaultProps)
          var g = a.type.defaultProps;
        for (f3 in b)
          J.call(b, f3) && !L.hasOwnProperty(f3) && (d[f3] = b[f3] === void 0 && g !== void 0 ? g[f3] : b[f3]);
      }
      var f3 = arguments.length - 2;
      if (f3 === 1)
        d.children = e2;
      else if (1 < f3) {
        g = Array(f3);
        for (var m2 = 0; m2 < f3; m2++)
          g[m2] = arguments[m2 + 2];
        d.children = g;
      }
      return { $$typeof: l, type: a.type, key: c, ref: k, props: d, _owner: h2 };
    };
    exports.createContext = function(a) {
      return a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, a.Provider = { $$typeof: t2, _context: a }, a.Consumer = a;
    };
    exports.createElement = M;
    exports.createFactory = function(a) {
      var b = M.bind(null, a);
      return b.type = a, b;
    };
    exports.createRef = function() {
      return { current: null };
    };
    exports.forwardRef = function(a) {
      return { $$typeof: v, render: a };
    };
    exports.isValidElement = O;
    exports.lazy = function(a) {
      return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };
    };
    exports.memo = function(a, b) {
      return { $$typeof: x2, type: a, compare: b === void 0 ? null : b };
    };
    exports.startTransition = function(a) {
      var b = V.transition;
      V.transition = {};
      try {
        a();
      } finally {
        V.transition = b;
      }
    };
    exports.unstable_act = function() {
      throw Error("act(...) is not supported in production builds of React.");
    };
    exports.useCallback = function(a, b) {
      return U.current.useCallback(a, b);
    };
    exports.useContext = function(a) {
      return U.current.useContext(a);
    };
    exports.useDebugValue = function() {
    };
    exports.useDeferredValue = function(a) {
      return U.current.useDeferredValue(a);
    };
    exports.useEffect = function(a, b) {
      return U.current.useEffect(a, b);
    };
    exports.useId = function() {
      return U.current.useId();
    };
    exports.useImperativeHandle = function(a, b, e2) {
      return U.current.useImperativeHandle(a, b, e2);
    };
    exports.useInsertionEffect = function(a, b) {
      return U.current.useInsertionEffect(a, b);
    };
    exports.useLayoutEffect = function(a, b) {
      return U.current.useLayoutEffect(a, b);
    };
    exports.useMemo = function(a, b) {
      return U.current.useMemo(a, b);
    };
    exports.useReducer = function(a, b, e2) {
      return U.current.useReducer(a, b, e2);
    };
    exports.useRef = function(a) {
      return U.current.useRef(a);
    };
    exports.useState = function(a) {
      return U.current.useState(a);
    };
    exports.useSyncExternalStore = function(a, b, e2) {
      return U.current.useSyncExternalStore(a, b, e2);
    };
    exports.useTransition = function() {
      return U.current.useTransition();
    };
    exports.version = "18.2.0";
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_react_production_min();
  }
});

// node_modules/react-router/dist/umd/react-router.production.min.js
var require_react_router_production_min = __commonJS({
  "node_modules/react-router/dist/umd/react-router.production.min.js"(exports, module2) {
    (function(e2, t2) {
      typeof exports == "object" && typeof module2 < "u" ? t2(exports, require_react(), require_router_cjs()) : typeof define == "function" && define.amd ? define(["exports", "react", "@remix-run/router"], t2) : t2((e2 = typeof globalThis < "u" ? globalThis : e2 || self).ReactRouter = {}, e2.React, e2.RemixRouter);
    })(exports, function(e2, t2, r2) {
      "use strict";
      function n(e3) {
        if (e3 && e3.__esModule)
          return e3;
        var t3 = /* @__PURE__ */ Object.create(null);
        return e3 && Object.keys(e3).forEach(function(r3) {
          if (r3 !== "default") {
            var n2 = Object.getOwnPropertyDescriptor(e3, r3);
            Object.defineProperty(t3, r3, n2.get ? n2 : { enumerable: !0, get: function() {
              return e3[r3];
            } });
          }
        }), t3.default = e3, Object.freeze(t3);
      }
      var a = n(t2);
      function o() {
        return o = Object.assign ? Object.assign.bind() : function(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var r3 = arguments[t3];
            for (var n2 in r3)
              Object.prototype.hasOwnProperty.call(r3, n2) && (e3[n2] = r3[n2]);
          }
          return e3;
        }, o.apply(this, arguments);
      }
      let i2 = a.createContext(null), u = a.createContext(null), l = a.createContext(null), s2 = a.createContext(null), c = a.createContext(null), d = a.createContext({ outlet: null, matches: [], isDataRoute: !1 }), p = a.createContext(null);
      function m2() {
        return a.useContext(c) != null;
      }
      function h2() {
        return m2() || r2.UNSAFE_invariant(!1), a.useContext(c).location;
      }
      function f3(e3) {
        a.useContext(s2).static || a.useLayoutEffect(e3);
      }
      function v() {
        let { isDataRoute: e3 } = a.useContext(d);
        return e3 ? function() {
          let { router: e4 } = O(N.UseNavigateStable), t3 = j(_.UseNavigateStable), r3 = a.useRef(!1);
          return f3(() => {
            r3.current = !0;
          }), a.useCallback(function(n2, a2) {
            a2 === void 0 && (a2 = {}), r3.current && (typeof n2 == "number" ? e4.navigate(n2) : e4.navigate(n2, o({ fromRouteId: t3 }, a2)));
          }, [e4, t3]);
        }() : function() {
          m2() || r2.UNSAFE_invariant(!1);
          let e4 = a.useContext(i2), { basename: t3, navigator: n2 } = a.useContext(s2), { matches: o2 } = a.useContext(d), { pathname: u2 } = h2(), l2 = JSON.stringify(r2.UNSAFE_getPathContributingMatches(o2).map((e5) => e5.pathnameBase)), c2 = a.useRef(!1);
          return f3(() => {
            c2.current = !0;
          }), a.useCallback(function(a2, o3) {
            if (o3 === void 0 && (o3 = {}), !c2.current)
              return;
            if (typeof a2 == "number")
              return void n2.go(a2);
            let i3 = r2.resolveTo(a2, JSON.parse(l2), u2, o3.relative === "path");
            e4 == null && t3 !== "/" && (i3.pathname = i3.pathname === "/" ? t3 : r2.joinPaths([t3, i3.pathname])), (o3.replace ? n2.replace : n2.push)(i3, o3.state, o3);
          }, [t3, n2, l2, u2, e4]);
        }();
      }
      let g = a.createContext(null);
      function E(e3) {
        let t3 = a.useContext(d).outlet;
        return t3 && a.createElement(g.Provider, { value: e3 }, t3);
      }
      function y(e3, t3) {
        let { relative: n2 } = t3 === void 0 ? {} : t3, { matches: o2 } = a.useContext(d), { pathname: i3 } = h2(), u2 = JSON.stringify(r2.UNSAFE_getPathContributingMatches(o2).map((e4) => e4.pathnameBase));
        return a.useMemo(() => r2.resolveTo(e3, JSON.parse(u2), i3, n2 === "path"), [e3, u2, i3, n2]);
      }
      function b(e3, t3) {
        return R(e3, t3);
      }
      function R(e3, t3, n2) {
        m2() || r2.UNSAFE_invariant(!1);
        let { navigator: i3 } = a.useContext(s2), { matches: u2 } = a.useContext(d), l2 = u2[u2.length - 1], p2 = l2 ? l2.params : {};
        !l2 || l2.pathname;
        let f4 = l2 ? l2.pathnameBase : "/";
        l2 && l2.route;
        let v2, g2 = h2();
        if (t3) {
          var E2;
          let e4 = typeof t3 == "string" ? r2.parsePath(t3) : t3;
          f4 === "/" || (E2 = e4.pathname) != null && E2.startsWith(f4) || r2.UNSAFE_invariant(!1), v2 = e4;
        } else
          v2 = g2;
        let y2 = v2.pathname || "/", b2 = f4 === "/" ? y2 : y2.slice(f4.length) || "/", R2 = r2.matchRoutes(e3, { pathname: b2 }), C2 = S2(R2 && R2.map((e4) => Object.assign({}, e4, { params: Object.assign({}, p2, e4.params), pathname: r2.joinPaths([f4, i3.encodeLocation ? i3.encodeLocation(e4.pathname).pathname : e4.pathname]), pathnameBase: e4.pathnameBase === "/" ? f4 : r2.joinPaths([f4, i3.encodeLocation ? i3.encodeLocation(e4.pathnameBase).pathname : e4.pathnameBase]) })), u2, n2);
        return t3 && C2 ? a.createElement(c.Provider, { value: { location: o({ pathname: "/", search: "", hash: "", state: null, key: "default" }, v2), navigationType: r2.Action.Pop } }, C2) : C2;
      }
      function C() {
        let e3 = F2(), t3 = r2.isRouteErrorResponse(e3) ? e3.status + " " + e3.statusText : e3 instanceof Error ? e3.message : JSON.stringify(e3), n2 = e3 instanceof Error ? e3.stack : null, o2 = { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" };
        return a.createElement(a.Fragment, null, a.createElement("h2", null, "Unexpected Application Error!"), a.createElement("h3", { style: { fontStyle: "italic" } }, t3), n2 ? a.createElement("pre", { style: o2 }, n2) : null, null);
      }
      let P = a.createElement(C, null);
      class x2 extends a.Component {
        constructor(e3) {
          super(e3), this.state = { location: e3.location, revalidation: e3.revalidation, error: e3.error };
        }
        static getDerivedStateFromError(e3) {
          return { error: e3 };
        }
        static getDerivedStateFromProps(e3, t3) {
          return t3.location !== e3.location || t3.revalidation !== "idle" && e3.revalidation === "idle" ? { error: e3.error, location: e3.location, revalidation: e3.revalidation } : { error: e3.error || t3.error, location: t3.location, revalidation: e3.revalidation || t3.revalidation };
        }
        componentDidCatch(e3, t3) {
          console.error("React Router caught the following error during render", e3, t3);
        }
        render() {
          return this.state.error ? a.createElement(d.Provider, { value: this.props.routeContext }, a.createElement(p.Provider, { value: this.state.error, children: this.props.component })) : this.props.children;
        }
      }
      function U(e3) {
        let { routeContext: t3, match: r3, children: n2 } = e3, o2 = a.useContext(i2);
        return o2 && o2.static && o2.staticContext && (r3.route.errorElement || r3.route.ErrorBoundary) && (o2.staticContext._deepestRenderedBoundaryId = r3.route.id), a.createElement(d.Provider, { value: t3 }, n2);
      }
      function S2(e3, t3, n2) {
        var o2;
        if (t3 === void 0 && (t3 = []), n2 === void 0 && (n2 = null), e3 == null) {
          var i3;
          if ((i3 = n2) == null || !i3.errors)
            return null;
          e3 = n2.matches;
        }
        let u2 = e3, l2 = (o2 = n2) == null ? void 0 : o2.errors;
        if (l2 != null) {
          let e4 = u2.findIndex((e5) => e5.route.id && (l2 == null ? void 0 : l2[e5.route.id]));
          e4 >= 0 || r2.UNSAFE_invariant(!1), u2 = u2.slice(0, Math.min(u2.length, e4 + 1));
        }
        return u2.reduceRight((e4, r3, o3) => {
          let i4 = r3.route.id ? l2 == null ? void 0 : l2[r3.route.id] : null, s3 = null;
          n2 && (s3 = r3.route.errorElement || P);
          let c2 = t3.concat(u2.slice(0, o3 + 1)), d2 = () => {
            let t4;
            return t4 = i4 ? s3 : r3.route.Component ? a.createElement(r3.route.Component, null) : r3.route.element ? r3.route.element : e4, a.createElement(U, { match: r3, routeContext: { outlet: e4, matches: c2, isDataRoute: n2 != null }, children: t4 });
          };
          return n2 && (r3.route.ErrorBoundary || r3.route.errorElement || o3 === 0) ? a.createElement(x2, { location: n2.location, revalidation: n2.revalidation, component: s3, error: i4, children: d2(), routeContext: { outlet: null, matches: c2, isDataRoute: !0 } }) : d2();
        }, null);
      }
      var N, _;
      function O(e3) {
        let t3 = a.useContext(i2);
        return t3 || r2.UNSAFE_invariant(!1), t3;
      }
      function A2(e3) {
        let t3 = a.useContext(u);
        return t3 || r2.UNSAFE_invariant(!1), t3;
      }
      function j(e3) {
        let t3 = function(e4) {
          let t4 = a.useContext(d);
          return t4 || r2.UNSAFE_invariant(!1), t4;
        }(), n2 = t3.matches[t3.matches.length - 1];
        return n2.route.id || r2.UNSAFE_invariant(!1), n2.route.id;
      }
      function F2() {
        var e3;
        let t3 = a.useContext(p), r3 = A2(_.UseRouteError), n2 = j(_.UseRouteError);
        return t3 || ((e3 = r3.errors) == null ? void 0 : e3[n2]);
      }
      function D() {
        let e3 = a.useContext(l);
        return e3 == null ? void 0 : e3._data;
      }
      (function(e3) {
        e3.UseBlocker = "useBlocker", e3.UseRevalidator = "useRevalidator", e3.UseNavigateStable = "useNavigate";
      })(N || (N = {})), function(e3) {
        e3.UseBlocker = "useBlocker", e3.UseLoaderData = "useLoaderData", e3.UseActionData = "useActionData", e3.UseRouteError = "useRouteError", e3.UseNavigation = "useNavigation", e3.UseRouteLoaderData = "useRouteLoaderData", e3.UseMatches = "useMatches", e3.UseRevalidator = "useRevalidator", e3.UseNavigateStable = "useNavigate", e3.UseRouteId = "useRouteId";
      }(_ || (_ = {}));
      let B = 0;
      function k(e3) {
        let { routes: t3, state: r3 } = e3;
        return R(t3, void 0, r3);
      }
      function M(e3) {
        r2.UNSAFE_invariant(!1);
      }
      function L(e3) {
        let { basename: t3 = "/", children: n2 = null, location: o2, navigationType: i3 = r2.Action.Pop, navigator: u2, static: l2 = !1 } = e3;
        m2() && r2.UNSAFE_invariant(!1);
        let d2 = t3.replace(/^\/*/, "/"), p2 = a.useMemo(() => ({ basename: d2, navigator: u2, static: l2 }), [d2, u2, l2]);
        typeof o2 == "string" && (o2 = r2.parsePath(o2));
        let { pathname: h3 = "/", search: f4 = "", hash: v2 = "", state: g2 = null, key: E2 = "default" } = o2, y2 = a.useMemo(() => {
          let e4 = r2.stripBasename(h3, d2);
          return e4 == null ? null : { location: { pathname: e4, search: f4, hash: v2, state: g2, key: E2 }, navigationType: i3 };
        }, [d2, h3, f4, v2, g2, E2, i3]);
        return y2 == null ? null : a.createElement(s2.Provider, { value: p2 }, a.createElement(c.Provider, { children: n2, value: y2 }));
      }
      var T;
      (function(e3) {
        e3[e3.pending = 0] = "pending", e3[e3.success = 1] = "success", e3[e3.error = 2] = "error";
      })(T || (T = {}));
      let I = new Promise(() => {
      });
      class w extends a.Component {
        constructor(e3) {
          super(e3), this.state = { error: null };
        }
        static getDerivedStateFromError(e3) {
          return { error: e3 };
        }
        componentDidCatch(e3, t3) {
          console.error("<Await> caught the following error during render", e3, t3);
        }
        render() {
          let { children: e3, errorElement: t3, resolve: n2 } = this.props, o2 = null, i3 = T.pending;
          if (n2 instanceof Promise)
            if (this.state.error) {
              i3 = T.error;
              let e4 = this.state.error;
              o2 = Promise.reject().catch(() => {
              }), Object.defineProperty(o2, "_tracked", { get: () => !0 }), Object.defineProperty(o2, "_error", { get: () => e4 });
            } else
              n2._tracked ? (o2 = n2, i3 = o2._error !== void 0 ? T.error : o2._data !== void 0 ? T.success : T.pending) : (i3 = T.pending, Object.defineProperty(n2, "_tracked", { get: () => !0 }), o2 = n2.then((e4) => Object.defineProperty(n2, "_data", { get: () => e4 }), (e4) => Object.defineProperty(n2, "_error", { get: () => e4 })));
          else
            i3 = T.success, o2 = Promise.resolve(), Object.defineProperty(o2, "_tracked", { get: () => !0 }), Object.defineProperty(o2, "_data", { get: () => n2 });
          if (i3 === T.error && o2._error instanceof r2.AbortedDeferredError)
            throw I;
          if (i3 === T.error && !t3)
            throw o2._error;
          if (i3 === T.error)
            return a.createElement(l.Provider, { value: o2, children: t3 });
          if (i3 === T.success)
            return a.createElement(l.Provider, { value: o2, children: e3 });
          throw o2;
        }
      }
      function J(e3) {
        let { children: t3 } = e3, r3 = D(), n2 = typeof t3 == "function" ? t3(r3) : t3;
        return a.createElement(a.Fragment, null, n2);
      }
      function H(e3, t3) {
        t3 === void 0 && (t3 = []);
        let n2 = [];
        return a.Children.forEach(e3, (e4, o2) => {
          if (!a.isValidElement(e4))
            return;
          let i3 = [...t3, o2];
          if (e4.type === a.Fragment)
            return void n2.push.apply(n2, H(e4.props.children, i3));
          e4.type !== M && r2.UNSAFE_invariant(!1), e4.props.index && e4.props.children && r2.UNSAFE_invariant(!1);
          let u2 = { id: e4.props.id || i3.join("-"), caseSensitive: e4.props.caseSensitive, element: e4.props.element, Component: e4.props.Component, index: e4.props.index, path: e4.props.path, loader: e4.props.loader, action: e4.props.action, errorElement: e4.props.errorElement, ErrorBoundary: e4.props.ErrorBoundary, hasErrorBoundary: e4.props.ErrorBoundary != null || e4.props.errorElement != null, shouldRevalidate: e4.props.shouldRevalidate, handle: e4.props.handle, lazy: e4.props.lazy };
          e4.props.children && (u2.children = H(e4.props.children, i3)), n2.push(u2);
        }), n2;
      }
      function z(e3) {
        let t3 = { hasErrorBoundary: e3.ErrorBoundary != null || e3.errorElement != null };
        return e3.Component && Object.assign(t3, { element: a.createElement(e3.Component), Component: void 0 }), e3.ErrorBoundary && Object.assign(t3, { errorElement: a.createElement(e3.ErrorBoundary), ErrorBoundary: void 0 }), t3;
      }
      Object.defineProperty(e2, "AbortedDeferredError", { enumerable: !0, get: function() {
        return r2.AbortedDeferredError;
      } }), Object.defineProperty(e2, "NavigationType", { enumerable: !0, get: function() {
        return r2.Action;
      } }), Object.defineProperty(e2, "createPath", { enumerable: !0, get: function() {
        return r2.createPath;
      } }), Object.defineProperty(e2, "defer", { enumerable: !0, get: function() {
        return r2.defer;
      } }), Object.defineProperty(e2, "generatePath", { enumerable: !0, get: function() {
        return r2.generatePath;
      } }), Object.defineProperty(e2, "isRouteErrorResponse", { enumerable: !0, get: function() {
        return r2.isRouteErrorResponse;
      } }), Object.defineProperty(e2, "json", { enumerable: !0, get: function() {
        return r2.json;
      } }), Object.defineProperty(e2, "matchPath", { enumerable: !0, get: function() {
        return r2.matchPath;
      } }), Object.defineProperty(e2, "matchRoutes", { enumerable: !0, get: function() {
        return r2.matchRoutes;
      } }), Object.defineProperty(e2, "parsePath", { enumerable: !0, get: function() {
        return r2.parsePath;
      } }), Object.defineProperty(e2, "redirect", { enumerable: !0, get: function() {
        return r2.redirect;
      } }), Object.defineProperty(e2, "resolvePath", { enumerable: !0, get: function() {
        return r2.resolvePath;
      } }), e2.Await = function(e3) {
        let { children: t3, errorElement: r3, resolve: n2 } = e3;
        return a.createElement(w, { resolve: n2, errorElement: r3 }, a.createElement(J, null, t3));
      }, e2.MemoryRouter = function(e3) {
        let { basename: t3, children: n2, initialEntries: o2, initialIndex: i3 } = e3, u2 = a.useRef();
        u2.current == null && (u2.current = r2.createMemoryHistory({ initialEntries: o2, initialIndex: i3, v5Compat: !0 }));
        let l2 = u2.current, [s3, c2] = a.useState({ action: l2.action, location: l2.location }), d2 = a.useCallback((e4) => {
          "startTransition" in a ? a.startTransition(() => c2(e4)) : c2(e4);
        }, [c2]);
        return a.useLayoutEffect(() => l2.listen(d2), [l2, d2]), a.createElement(L, { basename: t3, children: n2, location: s3.location, navigationType: s3.action, navigator: l2 });
      }, e2.Navigate = function(e3) {
        let { to: t3, replace: n2, state: o2, relative: i3 } = e3;
        m2() || r2.UNSAFE_invariant(!1);
        let { matches: u2 } = a.useContext(d), { pathname: l2 } = h2(), s3 = v(), c2 = r2.resolveTo(t3, r2.UNSAFE_getPathContributingMatches(u2).map((e4) => e4.pathnameBase), l2, i3 === "path"), p2 = JSON.stringify(c2);
        return a.useEffect(() => s3(JSON.parse(p2), { replace: n2, state: o2, relative: i3 }), [s3, p2, i3, n2, o2]), null;
      }, e2.Outlet = function(e3) {
        return E(e3.context);
      }, e2.Route = M, e2.Router = L, e2.RouterProvider = function(e3) {
        let { fallbackElement: t3, router: r3 } = e3, [n2, o2] = a.useState(r3.state), l2 = a.useCallback((e4) => {
          "startTransition" in a ? a.startTransition(() => o2(e4)) : o2(e4);
        }, [o2]);
        a.useLayoutEffect(() => r3.subscribe(l2), [r3, l2]);
        let s3 = a.useMemo(() => ({ createHref: r3.createHref, encodeLocation: r3.encodeLocation, go: (e4) => r3.navigate(e4), push: (e4, t4, n3) => r3.navigate(e4, { state: t4, preventScrollReset: n3 == null ? void 0 : n3.preventScrollReset }), replace: (e4, t4, n3) => r3.navigate(e4, { replace: !0, state: t4, preventScrollReset: n3 == null ? void 0 : n3.preventScrollReset }) }), [r3]), c2 = r3.basename || "/", d2 = a.useMemo(() => ({ router: r3, navigator: s3, static: !1, basename: c2 }), [r3, s3, c2]);
        return a.createElement(a.Fragment, null, a.createElement(i2.Provider, { value: d2 }, a.createElement(u.Provider, { value: n2 }, a.createElement(L, { basename: c2, location: n2.location, navigationType: n2.historyAction, navigator: s3 }, n2.initialized ? a.createElement(k, { routes: r3.routes, state: n2 }) : t3))), null);
      }, e2.Routes = function(e3) {
        let { children: t3, location: r3 } = e3;
        return b(H(t3), r3);
      }, e2.UNSAFE_DataRouterContext = i2, e2.UNSAFE_DataRouterStateContext = u, e2.UNSAFE_LocationContext = c, e2.UNSAFE_NavigationContext = s2, e2.UNSAFE_RouteContext = d, e2.UNSAFE_mapRouteProperties = z, e2.UNSAFE_useRouteId = function() {
        return j(_.UseRouteId);
      }, e2.UNSAFE_useRoutesImpl = R, e2.createMemoryRouter = function(e3, t3) {
        return r2.createRouter({ basename: t3 == null ? void 0 : t3.basename, future: o({}, t3 == null ? void 0 : t3.future, { v7_prependBasename: !0 }), history: r2.createMemoryHistory({ initialEntries: t3 == null ? void 0 : t3.initialEntries, initialIndex: t3 == null ? void 0 : t3.initialIndex }), hydrationData: t3 == null ? void 0 : t3.hydrationData, routes: e3, mapRouteProperties: z }).initialize();
      }, e2.createRoutesFromChildren = H, e2.createRoutesFromElements = H, e2.renderMatches = function(e3) {
        return S2(e3);
      }, e2.unstable_useBlocker = function(e3) {
        let { router: t3 } = O(N.UseBlocker), r3 = A2(_.UseBlocker), [n2] = a.useState(() => String(++B)), o2 = a.useCallback((t4) => typeof e3 == "function" ? !!e3(t4) : !!e3, [e3]), i3 = t3.getBlocker(n2, o2);
        return a.useEffect(() => () => t3.deleteBlocker(n2), [t3, n2]), r3.blockers.get(n2) || i3;
      }, e2.useActionData = function() {
        let e3 = A2(_.UseActionData);
        return a.useContext(d) || r2.UNSAFE_invariant(!1), Object.values((e3 == null ? void 0 : e3.actionData) || {})[0];
      }, e2.useAsyncError = function() {
        let e3 = a.useContext(l);
        return e3 == null ? void 0 : e3._error;
      }, e2.useAsyncValue = D, e2.useHref = function(e3, t3) {
        let { relative: n2 } = t3 === void 0 ? {} : t3;
        m2() || r2.UNSAFE_invariant(!1);
        let { basename: o2, navigator: i3 } = a.useContext(s2), { hash: u2, pathname: l2, search: c2 } = y(e3, { relative: n2 }), d2 = l2;
        return o2 !== "/" && (d2 = l2 === "/" ? o2 : r2.joinPaths([o2, l2])), i3.createHref({ pathname: d2, search: c2, hash: u2 });
      }, e2.useInRouterContext = m2, e2.useLoaderData = function() {
        let e3 = A2(_.UseLoaderData), t3 = j(_.UseLoaderData);
        if (!e3.errors || e3.errors[t3] == null)
          return e3.loaderData[t3];
        console.error("You cannot `useLoaderData` in an errorElement (routeId: " + t3 + ")");
      }, e2.useLocation = h2, e2.useMatch = function(e3) {
        m2() || r2.UNSAFE_invariant(!1);
        let { pathname: t3 } = h2();
        return a.useMemo(() => r2.matchPath(e3, t3), [t3, e3]);
      }, e2.useMatches = function() {
        let { matches: e3, loaderData: t3 } = A2(_.UseMatches);
        return a.useMemo(() => e3.map((e4) => {
          let { pathname: r3, params: n2 } = e4;
          return { id: e4.route.id, pathname: r3, params: n2, data: t3[e4.route.id], handle: e4.route.handle };
        }), [e3, t3]);
      }, e2.useNavigate = v, e2.useNavigation = function() {
        return A2(_.UseNavigation).navigation;
      }, e2.useNavigationType = function() {
        return a.useContext(c).navigationType;
      }, e2.useOutlet = E, e2.useOutletContext = function() {
        return a.useContext(g);
      }, e2.useParams = function() {
        let { matches: e3 } = a.useContext(d), t3 = e3[e3.length - 1];
        return t3 ? t3.params : {};
      }, e2.useResolvedPath = y, e2.useRevalidator = function() {
        let e3 = O(N.UseRevalidator), t3 = A2(_.UseRevalidator);
        return { revalidate: e3.router.revalidate, state: t3.revalidation };
      }, e2.useRouteError = F2, e2.useRouteLoaderData = function(e3) {
        return A2(_.UseRouteLoaderData).loaderData[e3];
      }, e2.useRoutes = b, Object.defineProperty(e2, "__esModule", { value: !0 });
    });
  }
});

// node_modules/react-router/dist/main.js
var require_main = __commonJS({
  "node_modules/react-router/dist/main.js"(exports, module2) {
    "use strict";
    module2.exports = require_react_router_production_min();
  }
});

// node_modules/react-router-dom/dist/umd/react-router-dom.production.min.js
var require_react_router_dom_production_min = __commonJS({
  "node_modules/react-router-dom/dist/umd/react-router-dom.production.min.js"(exports, module2) {
    (function(e2, t2) {
      typeof exports == "object" && typeof module2 < "u" ? t2(exports, require_react(), require_main(), require_router_cjs()) : typeof define == "function" && define.amd ? define(["exports", "react", "react-router", "@remix-run/router"], t2) : t2((e2 = typeof globalThis < "u" ? globalThis : e2 || self).ReactRouterDOM = {}, e2.React, e2.ReactRouter, e2.RemixRouter);
    })(exports, function(e2, t2, r2, n) {
      "use strict";
      function o(e3) {
        if (e3 && e3.__esModule)
          return e3;
        var t3 = /* @__PURE__ */ Object.create(null);
        return e3 && Object.keys(e3).forEach(function(r3) {
          if (r3 !== "default") {
            var n2 = Object.getOwnPropertyDescriptor(e3, r3);
            Object.defineProperty(t3, r3, n2.get ? n2 : { enumerable: !0, get: function() {
              return e3[r3];
            } });
          }
        }), t3.default = e3, Object.freeze(t3);
      }
      var a = o(t2);
      function u() {
        return u = Object.assign ? Object.assign.bind() : function(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var r3 = arguments[t3];
            for (var n2 in r3)
              Object.prototype.hasOwnProperty.call(r3, n2) && (e3[n2] = r3[n2]);
          }
          return e3;
        }, u.apply(this, arguments);
      }
      function i2(e3, t3) {
        if (e3 == null)
          return {};
        var r3, n2, o2 = {}, a2 = Object.keys(e3);
        for (n2 = 0; n2 < a2.length; n2++)
          r3 = a2[n2], t3.indexOf(r3) >= 0 || (o2[r3] = e3[r3]);
        return o2;
      }
      let c = "get", s2 = "application/x-www-form-urlencoded";
      function l(e3) {
        return e3 != null && typeof e3.tagName == "string";
      }
      function f3(e3) {
        return e3 === void 0 && (e3 = ""), new URLSearchParams(typeof e3 == "string" || Array.isArray(e3) || e3 instanceof URLSearchParams ? e3 : Object.keys(e3).reduce((t3, r3) => {
          let n2 = e3[r3];
          return t3.concat(Array.isArray(n2) ? n2.map((e4) => [r3, e4]) : [[r3, n2]]);
        }, []));
      }
      function d(e3, t3, r3) {
        let o2, a2, u2, i3 = null;
        if (l(f4 = e3) && f4.tagName.toLowerCase() === "form") {
          let l2 = t3.submissionTrigger;
          if (t3.action)
            i3 = t3.action;
          else {
            let t4 = e3.getAttribute("action");
            i3 = t4 ? n.stripBasename(t4, r3) : null;
          }
          o2 = t3.method || e3.getAttribute("method") || c, a2 = t3.encType || e3.getAttribute("enctype") || s2, u2 = new FormData(e3), l2 && l2.name && u2.append(l2.name, l2.value);
        } else if (function(e4) {
          return l(e4) && e4.tagName.toLowerCase() === "button";
        }(e3) || function(e4) {
          return l(e4) && e4.tagName.toLowerCase() === "input";
        }(e3) && (e3.type === "submit" || e3.type === "image")) {
          let l2 = e3.form;
          if (l2 == null)
            throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
          if (t3.action)
            i3 = t3.action;
          else {
            let t4 = e3.getAttribute("formaction") || l2.getAttribute("action");
            i3 = t4 ? n.stripBasename(t4, r3) : null;
          }
          o2 = t3.method || e3.getAttribute("formmethod") || l2.getAttribute("method") || c, a2 = t3.encType || e3.getAttribute("formenctype") || l2.getAttribute("enctype") || s2, u2 = new FormData(l2), e3.name && u2.append(e3.name, e3.value);
        } else {
          if (l(e3))
            throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
          if (o2 = t3.method || c, i3 = t3.action || null, a2 = t3.encType || s2, e3 instanceof FormData)
            u2 = e3;
          else if (u2 = new FormData(), e3 instanceof URLSearchParams)
            for (let [t4, r4] of e3)
              u2.append(t4, r4);
          else if (e3 != null)
            for (let t4 of Object.keys(e3))
              u2.append(t4, e3[t4]);
        }
        var f4;
        return { action: i3, method: o2.toLowerCase(), encType: a2, formData: u2 };
      }
      let m2 = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"], p = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"], b = ["reloadDocument", "replace", "method", "action", "onSubmit", "fetcherKey", "routeId", "relative", "preventScrollReset"];
      function g() {
        var e3;
        let t3 = (e3 = window) == null ? void 0 : e3.__staticRouterHydrationData;
        return t3 && t3.errors && (t3 = u({}, t3, { errors: h2(t3.errors) })), t3;
      }
      function h2(e3) {
        if (!e3)
          return null;
        let t3 = Object.entries(e3), r3 = {};
        for (let [e4, o2] of t3)
          if (o2 && o2.__type === "RouteErrorResponse")
            r3[e4] = new n.ErrorResponse(o2.status, o2.statusText, o2.data, o2.internal === !0);
          else if (o2 && o2.__type === "Error") {
            let t4 = new Error(o2.message);
            t4.stack = "", r3[e4] = t4;
          } else
            r3[e4] = o2;
        return r3;
      }
      let y = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, v = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, R = a.forwardRef(function(e3, t3) {
        let o2, { onClick: c2, relative: s3, reloadDocument: l2, replace: f4, state: d2, target: p2, to: b2, preventScrollReset: g2 } = e3, h3 = i2(e3, m2), { basename: R2 } = a.useContext(r2.UNSAFE_NavigationContext), w2 = !1;
        if (typeof b2 == "string" && v.test(b2) && (o2 = b2, y))
          try {
            let e4 = new URL(window.location.href), t4 = b2.startsWith("//") ? new URL(e4.protocol + b2) : new URL(b2), r3 = n.stripBasename(t4.pathname, R2);
            t4.origin === e4.origin && r3 != null ? b2 = r3 + t4.search + t4.hash : w2 = !0;
          } catch {
          }
        let P2 = r2.useHref(b2, { relative: s3 }), S3 = N(b2, { replace: f4, state: d2, target: p2, preventScrollReset: g2, relative: s3 });
        return a.createElement("a", u({}, h3, { href: o2 || P2, onClick: w2 || l2 ? c2 : function(e4) {
          c2 && c2(e4), e4.defaultPrevented || S3(e4);
        }, ref: t3, target: p2 }));
      }), w = a.forwardRef(function(e3, t3) {
        let { "aria-current": n2 = "page", caseSensitive: o2 = !1, className: c2 = "", end: s3 = !1, style: l2, to: f4, children: d2 } = e3, m3 = i2(e3, p), b2 = r2.useResolvedPath(f4, { relative: m3.relative }), g2 = r2.useLocation(), h3 = a.useContext(r2.UNSAFE_DataRouterStateContext), { navigator: y2 } = a.useContext(r2.UNSAFE_NavigationContext), v2 = y2.encodeLocation ? y2.encodeLocation(b2).pathname : b2.pathname, w2 = g2.pathname, P2 = h3 && h3.navigation && h3.navigation.location ? h3.navigation.location.pathname : null;
        o2 || (w2 = w2.toLowerCase(), P2 = P2 ? P2.toLowerCase() : null, v2 = v2.toLowerCase());
        let S3, E2 = w2 === v2 || !s3 && w2.startsWith(v2) && w2.charAt(v2.length) === "/", O2 = P2 != null && (P2 === v2 || !s3 && P2.startsWith(v2) && P2.charAt(v2.length) === "/"), j2 = E2 ? n2 : void 0;
        S3 = typeof c2 == "function" ? c2({ isActive: E2, isPending: O2 }) : [c2, E2 ? "active" : null, O2 ? "pending" : null].filter(Boolean).join(" ");
        let A3 = typeof l2 == "function" ? l2({ isActive: E2, isPending: O2 }) : l2;
        return a.createElement(R, u({}, m3, { "aria-current": j2, className: S3, ref: t3, style: A3, to: f4 }), typeof d2 == "function" ? d2({ isActive: E2, isPending: O2 }) : d2);
      }), P = a.forwardRef((e3, t3) => a.createElement(S2, u({}, e3, { ref: t3 }))), S2 = a.forwardRef((e3, t3) => {
        let { reloadDocument: r3, replace: n2, method: o2 = c, action: s3, onSubmit: l2, fetcherKey: f4, routeId: d2, relative: m3, preventScrollReset: p2 } = e3, g2 = i2(e3, b), h3 = C(f4, d2), y2 = o2.toLowerCase() === "get" ? "get" : "post", v2 = F2(s3, { relative: m3 });
        return a.createElement("form", u({ ref: t3, method: y2, action: v2, onSubmit: r3 ? l2 : (e4) => {
          if (l2 && l2(e4), e4.defaultPrevented)
            return;
          e4.preventDefault();
          let t4 = e4.nativeEvent.submitter, r4 = (t4 == null ? void 0 : t4.getAttribute("formmethod")) || o2;
          h3(t4 || e4.currentTarget, { method: r4, replace: n2, relative: m3, preventScrollReset: p2 });
        } }, g2));
      });
      var E, O;
      function j(e3) {
        let t3 = a.useContext(r2.UNSAFE_DataRouterContext);
        return t3 || n.UNSAFE_invariant(!1), t3;
      }
      function A2(e3) {
        let t3 = a.useContext(r2.UNSAFE_DataRouterStateContext);
        return t3 || n.UNSAFE_invariant(!1), t3;
      }
      function N(e3, t3) {
        let { target: n2, replace: o2, state: u2, preventScrollReset: i3, relative: c2 } = t3 === void 0 ? {} : t3, s3 = r2.useNavigate(), l2 = r2.useLocation(), f4 = r2.useResolvedPath(e3, { relative: c2 });
        return a.useCallback((t4) => {
          if (function(e4, t5) {
            return !(e4.button !== 0 || t5 && t5 !== "_self" || function(e5) {
              return !!(e5.metaKey || e5.altKey || e5.ctrlKey || e5.shiftKey);
            }(e4));
          }(t4, n2)) {
            t4.preventDefault();
            let n3 = o2 !== void 0 ? o2 : r2.createPath(l2) === r2.createPath(f4);
            s3(e3, { replace: n3, state: u2, preventScrollReset: i3, relative: c2 });
          }
        }, [l2, s3, f4, o2, u2, n2, e3, i3, c2]);
      }
      function C(e3, t3) {
        let { router: o2 } = j(E.UseSubmitImpl), { basename: i3 } = a.useContext(r2.UNSAFE_NavigationContext), c2 = r2.UNSAFE_useRouteId();
        return a.useCallback(function(r3, a2) {
          if (a2 === void 0 && (a2 = {}), typeof document > "u")
            throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
          let { action: s3, method: l2, encType: f4, formData: m3 } = d(r3, a2, i3), p2 = { preventScrollReset: a2.preventScrollReset, formData: m3, formMethod: l2, formEncType: f4 };
          e3 ? (t3 == null && n.UNSAFE_invariant(!1), o2.fetch(e3, t3, s3, p2)) : o2.navigate(s3, u({}, p2, { replace: a2.replace, fromRouteId: c2 }));
        }, [o2, i3, e3, t3, c2]);
      }
      function F2(e3, t3) {
        let { relative: o2 } = t3 === void 0 ? {} : t3, { basename: i3 } = a.useContext(r2.UNSAFE_NavigationContext), c2 = a.useContext(r2.UNSAFE_RouteContext);
        c2 || n.UNSAFE_invariant(!1);
        let [s3] = c2.matches.slice(-1), l2 = u({}, r2.useResolvedPath(e3 || ".", { relative: o2 })), f4 = r2.useLocation();
        if (e3 == null && (l2.search = f4.search, l2.hash = f4.hash, s3.route.index)) {
          let e4 = new URLSearchParams(l2.search);
          e4.delete("index"), l2.search = e4.toString() ? "?" + e4.toString() : "";
        }
        return e3 && e3 !== "." || !s3.route.index || (l2.search = l2.search ? l2.search.replace(/^\?/, "?index&") : "?index"), i3 !== "/" && (l2.pathname = l2.pathname === "/" ? i3 : n.joinPaths([i3, l2.pathname])), r2.createPath(l2);
      }
      (function(e3) {
        e3.UseScrollRestoration = "useScrollRestoration", e3.UseSubmitImpl = "useSubmitImpl", e3.UseFetcher = "useFetcher";
      })(E || (E = {})), function(e3) {
        e3.UseFetchers = "useFetchers", e3.UseScrollRestoration = "useScrollRestoration";
      }(O || (O = {}));
      let U = 0, _ = "react-router-scroll-positions", x2 = {};
      function L(e3) {
        let { getKey: t3, storageKey: n2 } = e3 === void 0 ? {} : e3, { router: o2 } = j(E.UseScrollRestoration), { restoreScrollPosition: u2, preventScrollReset: i3 } = A2(O.UseScrollRestoration), c2 = r2.useLocation(), s3 = r2.useMatches(), l2 = r2.useNavigation();
        a.useEffect(() => (window.history.scrollRestoration = "manual", () => {
          window.history.scrollRestoration = "auto";
        }), []), function(e4, t4) {
          let { capture: r3 } = t4 || {};
          a.useEffect(() => {
            let t5 = r3 != null ? { capture: r3 } : void 0;
            return window.addEventListener("pagehide", e4, t5), () => {
              window.removeEventListener("pagehide", e4, t5);
            };
          }, [e4, r3]);
        }(a.useCallback(() => {
          if (l2.state === "idle") {
            let e4 = (t3 ? t3(c2, s3) : null) || c2.key;
            x2[e4] = window.scrollY;
          }
          sessionStorage.setItem(n2 || _, JSON.stringify(x2)), window.history.scrollRestoration = "auto";
        }, [n2, t3, l2.state, c2, s3])), typeof document < "u" && (a.useLayoutEffect(() => {
          try {
            let e4 = sessionStorage.getItem(n2 || _);
            e4 && (x2 = JSON.parse(e4));
          } catch {
          }
        }, [n2]), a.useLayoutEffect(() => {
          let e4 = o2 == null ? void 0 : o2.enableScrollRestoration(x2, () => window.scrollY, t3);
          return () => e4 && e4();
        }, [o2, t3]), a.useLayoutEffect(() => {
          if (u2 !== !1)
            if (typeof u2 != "number") {
              if (c2.hash) {
                let e4 = document.getElementById(c2.hash.slice(1));
                if (e4)
                  return void e4.scrollIntoView();
              }
              i3 !== !0 && window.scrollTo(0, 0);
            } else
              window.scrollTo(0, u2);
        }, [c2, u2, i3]));
      }
      Object.defineProperty(e2, "AbortedDeferredError", { enumerable: !0, get: function() {
        return r2.AbortedDeferredError;
      } }), Object.defineProperty(e2, "Await", { enumerable: !0, get: function() {
        return r2.Await;
      } }), Object.defineProperty(e2, "MemoryRouter", { enumerable: !0, get: function() {
        return r2.MemoryRouter;
      } }), Object.defineProperty(e2, "Navigate", { enumerable: !0, get: function() {
        return r2.Navigate;
      } }), Object.defineProperty(e2, "NavigationType", { enumerable: !0, get: function() {
        return r2.NavigationType;
      } }), Object.defineProperty(e2, "Outlet", { enumerable: !0, get: function() {
        return r2.Outlet;
      } }), Object.defineProperty(e2, "Route", { enumerable: !0, get: function() {
        return r2.Route;
      } }), Object.defineProperty(e2, "Router", { enumerable: !0, get: function() {
        return r2.Router;
      } }), Object.defineProperty(e2, "RouterProvider", { enumerable: !0, get: function() {
        return r2.RouterProvider;
      } }), Object.defineProperty(e2, "Routes", { enumerable: !0, get: function() {
        return r2.Routes;
      } }), Object.defineProperty(e2, "UNSAFE_DataRouterContext", { enumerable: !0, get: function() {
        return r2.UNSAFE_DataRouterContext;
      } }), Object.defineProperty(e2, "UNSAFE_DataRouterStateContext", { enumerable: !0, get: function() {
        return r2.UNSAFE_DataRouterStateContext;
      } }), Object.defineProperty(e2, "UNSAFE_LocationContext", { enumerable: !0, get: function() {
        return r2.UNSAFE_LocationContext;
      } }), Object.defineProperty(e2, "UNSAFE_NavigationContext", { enumerable: !0, get: function() {
        return r2.UNSAFE_NavigationContext;
      } }), Object.defineProperty(e2, "UNSAFE_RouteContext", { enumerable: !0, get: function() {
        return r2.UNSAFE_RouteContext;
      } }), Object.defineProperty(e2, "UNSAFE_useRouteId", { enumerable: !0, get: function() {
        return r2.UNSAFE_useRouteId;
      } }), Object.defineProperty(e2, "createMemoryRouter", { enumerable: !0, get: function() {
        return r2.createMemoryRouter;
      } }), Object.defineProperty(e2, "createPath", { enumerable: !0, get: function() {
        return r2.createPath;
      } }), Object.defineProperty(e2, "createRoutesFromChildren", { enumerable: !0, get: function() {
        return r2.createRoutesFromChildren;
      } }), Object.defineProperty(e2, "createRoutesFromElements", { enumerable: !0, get: function() {
        return r2.createRoutesFromElements;
      } }), Object.defineProperty(e2, "defer", { enumerable: !0, get: function() {
        return r2.defer;
      } }), Object.defineProperty(e2, "generatePath", { enumerable: !0, get: function() {
        return r2.generatePath;
      } }), Object.defineProperty(e2, "isRouteErrorResponse", { enumerable: !0, get: function() {
        return r2.isRouteErrorResponse;
      } }), Object.defineProperty(e2, "json", { enumerable: !0, get: function() {
        return r2.json;
      } }), Object.defineProperty(e2, "matchPath", { enumerable: !0, get: function() {
        return r2.matchPath;
      } }), Object.defineProperty(e2, "matchRoutes", { enumerable: !0, get: function() {
        return r2.matchRoutes;
      } }), Object.defineProperty(e2, "parsePath", { enumerable: !0, get: function() {
        return r2.parsePath;
      } }), Object.defineProperty(e2, "redirect", { enumerable: !0, get: function() {
        return r2.redirect;
      } }), Object.defineProperty(e2, "renderMatches", { enumerable: !0, get: function() {
        return r2.renderMatches;
      } }), Object.defineProperty(e2, "resolvePath", { enumerable: !0, get: function() {
        return r2.resolvePath;
      } }), Object.defineProperty(e2, "unstable_useBlocker", { enumerable: !0, get: function() {
        return r2.unstable_useBlocker;
      } }), Object.defineProperty(e2, "useActionData", { enumerable: !0, get: function() {
        return r2.useActionData;
      } }), Object.defineProperty(e2, "useAsyncError", { enumerable: !0, get: function() {
        return r2.useAsyncError;
      } }), Object.defineProperty(e2, "useAsyncValue", { enumerable: !0, get: function() {
        return r2.useAsyncValue;
      } }), Object.defineProperty(e2, "useHref", { enumerable: !0, get: function() {
        return r2.useHref;
      } }), Object.defineProperty(e2, "useInRouterContext", { enumerable: !0, get: function() {
        return r2.useInRouterContext;
      } }), Object.defineProperty(e2, "useLoaderData", { enumerable: !0, get: function() {
        return r2.useLoaderData;
      } }), Object.defineProperty(e2, "useLocation", { enumerable: !0, get: function() {
        return r2.useLocation;
      } }), Object.defineProperty(e2, "useMatch", { enumerable: !0, get: function() {
        return r2.useMatch;
      } }), Object.defineProperty(e2, "useMatches", { enumerable: !0, get: function() {
        return r2.useMatches;
      } }), Object.defineProperty(e2, "useNavigate", { enumerable: !0, get: function() {
        return r2.useNavigate;
      } }), Object.defineProperty(e2, "useNavigation", { enumerable: !0, get: function() {
        return r2.useNavigation;
      } }), Object.defineProperty(e2, "useNavigationType", { enumerable: !0, get: function() {
        return r2.useNavigationType;
      } }), Object.defineProperty(e2, "useOutlet", { enumerable: !0, get: function() {
        return r2.useOutlet;
      } }), Object.defineProperty(e2, "useOutletContext", { enumerable: !0, get: function() {
        return r2.useOutletContext;
      } }), Object.defineProperty(e2, "useParams", { enumerable: !0, get: function() {
        return r2.useParams;
      } }), Object.defineProperty(e2, "useResolvedPath", { enumerable: !0, get: function() {
        return r2.useResolvedPath;
      } }), Object.defineProperty(e2, "useRevalidator", { enumerable: !0, get: function() {
        return r2.useRevalidator;
      } }), Object.defineProperty(e2, "useRouteError", { enumerable: !0, get: function() {
        return r2.useRouteError;
      } }), Object.defineProperty(e2, "useRouteLoaderData", { enumerable: !0, get: function() {
        return r2.useRouteLoaderData;
      } }), Object.defineProperty(e2, "useRoutes", { enumerable: !0, get: function() {
        return r2.useRoutes;
      } }), e2.BrowserRouter = function(e3) {
        let { basename: t3, children: o2, window: u2 } = e3, i3 = a.useRef();
        i3.current == null && (i3.current = n.createBrowserHistory({ window: u2, v5Compat: !0 }));
        let c2 = i3.current, [s3, l2] = a.useState({ action: c2.action, location: c2.location }), f4 = a.useCallback((e4) => {
          "startTransition" in a ? a.startTransition(() => l2(e4)) : l2(e4);
        }, [l2]);
        return a.useLayoutEffect(() => c2.listen(f4), [c2, f4]), a.createElement(r2.Router, { basename: t3, children: o2, location: s3.location, navigationType: s3.action, navigator: c2 });
      }, e2.Form = P, e2.HashRouter = function(e3) {
        let { basename: t3, children: o2, window: u2 } = e3, i3 = a.useRef();
        i3.current == null && (i3.current = n.createHashHistory({ window: u2, v5Compat: !0 }));
        let c2 = i3.current, [s3, l2] = a.useState({ action: c2.action, location: c2.location }), f4 = a.useCallback((e4) => {
          "startTransition" in a ? a.startTransition(() => l2(e4)) : l2(e4);
        }, [l2]);
        return a.useLayoutEffect(() => c2.listen(f4), [c2, f4]), a.createElement(r2.Router, { basename: t3, children: o2, location: s3.location, navigationType: s3.action, navigator: c2 });
      }, e2.Link = R, e2.NavLink = w, e2.ScrollRestoration = function(e3) {
        let { getKey: t3, storageKey: r3 } = e3;
        return L({ getKey: t3, storageKey: r3 }), null;
      }, e2.UNSAFE_useScrollRestoration = L, e2.createBrowserRouter = function(e3, t3) {
        return n.createRouter({ basename: t3 == null ? void 0 : t3.basename, future: u({}, t3 == null ? void 0 : t3.future, { v7_prependBasename: !0 }), history: n.createBrowserHistory({ window: t3 == null ? void 0 : t3.window }), hydrationData: (t3 == null ? void 0 : t3.hydrationData) || g(), routes: e3, mapRouteProperties: r2.UNSAFE_mapRouteProperties }).initialize();
      }, e2.createHashRouter = function(e3, t3) {
        return n.createRouter({ basename: t3 == null ? void 0 : t3.basename, future: u({}, t3 == null ? void 0 : t3.future, { v7_prependBasename: !0 }), history: n.createHashHistory({ window: t3 == null ? void 0 : t3.window }), hydrationData: (t3 == null ? void 0 : t3.hydrationData) || g(), routes: e3, mapRouteProperties: r2.UNSAFE_mapRouteProperties }).initialize();
      }, e2.createSearchParams = f3, e2.unstable_HistoryRouter = function(e3) {
        let { basename: t3, children: n2, history: o2 } = e3, [u2, i3] = a.useState({ action: o2.action, location: o2.location }), c2 = a.useCallback((e4) => {
          "startTransition" in a ? a.startTransition(() => i3(e4)) : i3(e4);
        }, [i3]);
        return a.useLayoutEffect(() => o2.listen(c2), [o2, c2]), a.createElement(r2.Router, { basename: t3, children: n2, location: u2.location, navigationType: u2.action, navigator: o2 });
      }, e2.unstable_usePrompt = function(e3) {
        let { when: t3, message: n2 } = e3, o2 = r2.unstable_useBlocker(t3);
        a.useEffect(() => {
          o2.state !== "blocked" || t3 || o2.reset();
        }, [o2, t3]), a.useEffect(() => {
          o2.state === "blocked" && (window.confirm(n2) ? setTimeout(o2.proceed, 0) : o2.reset());
        }, [o2, n2]);
      }, e2.useBeforeUnload = function(e3, t3) {
        let { capture: r3 } = t3 || {};
        a.useEffect(() => {
          let t4 = r3 != null ? { capture: r3 } : void 0;
          return window.addEventListener("beforeunload", e3, t4), () => {
            window.removeEventListener("beforeunload", e3, t4);
          };
        }, [e3, r3]);
      }, e2.useFetcher = function() {
        var e3;
        let { router: t3 } = j(E.UseFetcher), o2 = a.useContext(r2.UNSAFE_RouteContext);
        o2 || n.UNSAFE_invariant(!1);
        let i3 = (e3 = o2.matches[o2.matches.length - 1]) == null ? void 0 : e3.route.id;
        i3 == null && n.UNSAFE_invariant(!1);
        let [c2] = a.useState(() => String(++U)), [s3] = a.useState(() => (i3 || n.UNSAFE_invariant(!1), function(e4, t4) {
          return a.forwardRef((r3, n2) => a.createElement(S2, u({}, r3, { ref: n2, fetcherKey: e4, routeId: t4 })));
        }(c2, i3))), [l2] = a.useState(() => (e4) => {
          t3 || n.UNSAFE_invariant(!1), i3 || n.UNSAFE_invariant(!1), t3.fetch(c2, i3, e4);
        }), f4 = C(c2, i3), d2 = t3.getFetcher(c2), m3 = a.useMemo(() => u({ Form: s3, submit: f4, load: l2 }, d2), [d2, s3, f4, l2]);
        return a.useEffect(() => () => {
          t3 ? t3.deleteFetcher(c2) : console.warn("No router available to clean up from useFetcher()");
        }, [t3, c2]), m3;
      }, e2.useFetchers = function() {
        return [...A2(O.UseFetchers).fetchers.values()];
      }, e2.useFormAction = F2, e2.useLinkClickHandler = N, e2.useSearchParams = function(e3) {
        let t3 = a.useRef(f3(e3)), n2 = a.useRef(!1), o2 = r2.useLocation(), u2 = a.useMemo(() => function(e4, t4) {
          let r3 = f3(e4);
          if (t4)
            for (let e5 of t4.keys())
              r3.has(e5) || t4.getAll(e5).forEach((t5) => {
                r3.append(e5, t5);
              });
          return r3;
        }(o2.search, n2.current ? null : t3.current), [o2.search]), i3 = r2.useNavigate(), c2 = a.useCallback((e4, t4) => {
          let r3 = f3(typeof e4 == "function" ? e4(u2) : e4);
          n2.current = !0, i3("?" + r3, t4);
        }, [i3, u2]);
        return [u2, c2];
      }, e2.useSubmit = function() {
        return C();
      }, Object.defineProperty(e2, "__esModule", { value: !0 });
    });
  }
});

// node_modules/react-router-dom/dist/main.js
var require_main2 = __commonJS({
  "node_modules/react-router-dom/dist/main.js"(exports, module2) {
    "use strict";
    module2.exports = require_react_router_dom_production_min();
  }
});

// node_modules/@remix-run/react/dist/_virtual/_rollupPluginBabelHelpers.js
var require_rollupPluginBabelHelpers = __commonJS({
  "node_modules/@remix-run/react/dist/_virtual/_rollupPluginBabelHelpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function _extends() {
      return _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    exports.extends = _extends;
  }
});

// node_modules/@remix-run/react/dist/errorBoundaries.js
var require_errorBoundaries = __commonJS({
  "node_modules/@remix-run/react/dist/errorBoundaries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var React5 = require_react(), reactRouterDom = require_main2();
    function _interopDefaultLegacy(e2) {
      return e2 && typeof e2 == "object" && "default" in e2 ? e2 : { default: e2 };
    }
    var React__default = /* @__PURE__ */ _interopDefaultLegacy(React5), RemixErrorBoundary = class extends React__default.default.Component {
      constructor(props) {
        super(props), this.state = {
          error: props.error || null,
          location: props.location
        };
      }
      static getDerivedStateFromError(error) {
        return {
          error
        };
      }
      static getDerivedStateFromProps(props, state) {
        return state.location !== props.location ? {
          error: props.error || null,
          location: props.location
        } : {
          error: props.error || state.error,
          location: state.location
        };
      }
      render() {
        return this.state.error ? /* @__PURE__ */ React__default.default.createElement(this.props.component, {
          error: this.state.error
        }) : this.props.children;
      }
    };
    function RemixRootDefaultErrorBoundary({
      error
    }) {
      return React__default.default.useEffect(() => {
        console.error(error);
      }, [error]), /* @__PURE__ */ React__default.default.createElement("html", {
        lang: "en"
      }, /* @__PURE__ */ React__default.default.createElement("head", null, /* @__PURE__ */ React__default.default.createElement("meta", {
        charSet: "utf-8"
      }), /* @__PURE__ */ React__default.default.createElement("meta", {
        name: "viewport",
        content: "width=device-width, initial-scale=1, viewport-fit=cover"
      }), /* @__PURE__ */ React__default.default.createElement("title", null, "Application Error!")), /* @__PURE__ */ React__default.default.createElement("body", null, /* @__PURE__ */ React__default.default.createElement("main", {
        style: {
          fontFamily: "system-ui, sans-serif",
          padding: "2rem"
        }
      }, /* @__PURE__ */ React__default.default.createElement("h1", {
        style: {
          fontSize: "24px"
        }
      }, "Application Error"), error.stack ? /* @__PURE__ */ React__default.default.createElement("pre", {
        style: {
          padding: "2rem",
          background: "hsla(10, 50%, 50%, 0.1)",
          color: "red",
          overflow: "auto"
        }
      }, error.stack) : null), /* @__PURE__ */ React__default.default.createElement("script", {
        dangerouslySetInnerHTML: {
          __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://remix.run/guides/errors for more information."
              );
            `
        }
      })));
    }
    function V2_RemixRootDefaultErrorBoundary() {
      let error = reactRouterDom.useRouteError();
      if (reactRouterDom.isRouteErrorResponse(error))
        return /* @__PURE__ */ React__default.default.createElement(RemixRootDefaultCatchBoundaryImpl, {
          caught: error
        });
      if (error instanceof Error)
        return /* @__PURE__ */ React__default.default.createElement(RemixRootDefaultErrorBoundary, {
          error
        });
      {
        let errorString = error == null ? "Unknown Error" : typeof error == "object" && "toString" in error ? error.toString() : JSON.stringify(error);
        return /* @__PURE__ */ React__default.default.createElement(RemixRootDefaultErrorBoundary, {
          error: new Error(errorString)
        });
      }
    }
    var RemixCatchContext = /* @__PURE__ */ React__default.default.createContext(void 0);
    function useCatch() {
      return React5.useContext(RemixCatchContext);
    }
    function RemixCatchBoundary({
      catch: catchVal,
      component: Component,
      children
    }) {
      return catchVal ? /* @__PURE__ */ React__default.default.createElement(RemixCatchContext.Provider, {
        value: catchVal
      }, /* @__PURE__ */ React__default.default.createElement(Component, null)) : /* @__PURE__ */ React__default.default.createElement(React__default.default.Fragment, null, children);
    }
    function RemixRootDefaultCatchBoundary() {
      let caught = useCatch();
      return /* @__PURE__ */ React__default.default.createElement(RemixRootDefaultCatchBoundaryImpl, {
        caught
      });
    }
    function RemixRootDefaultCatchBoundaryImpl({
      caught
    }) {
      return /* @__PURE__ */ React__default.default.createElement("html", {
        lang: "en"
      }, /* @__PURE__ */ React__default.default.createElement("head", null, /* @__PURE__ */ React__default.default.createElement("meta", {
        charSet: "utf-8"
      }), /* @__PURE__ */ React__default.default.createElement("meta", {
        name: "viewport",
        content: "width=device-width, initial-scale=1, viewport-fit=cover"
      }), /* @__PURE__ */ React__default.default.createElement("title", null, "Unhandled Thrown Response!")), /* @__PURE__ */ React__default.default.createElement("body", null, /* @__PURE__ */ React__default.default.createElement("h1", {
        style: {
          fontFamily: "system-ui, sans-serif",
          padding: "2rem"
        }
      }, caught.status, " ", caught.statusText), /* @__PURE__ */ React__default.default.createElement("script", {
        dangerouslySetInnerHTML: {
          __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX than this when your app throws 404s (and other responses). Check out https://remix.run/guides/not-found for more information."
              );
            `
        }
      })));
    }
    exports.RemixCatchBoundary = RemixCatchBoundary;
    exports.RemixErrorBoundary = RemixErrorBoundary;
    exports.RemixRootDefaultCatchBoundary = RemixRootDefaultCatchBoundary;
    exports.RemixRootDefaultErrorBoundary = RemixRootDefaultErrorBoundary;
    exports.V2_RemixRootDefaultErrorBoundary = V2_RemixRootDefaultErrorBoundary;
    exports.useCatch = useCatch;
  }
});

// node_modules/@remix-run/react/dist/invariant.js
var require_invariant2 = __commonJS({
  "node_modules/@remix-run/react/dist/invariant.js"(exports, module2) {
    "use strict";
    function invariant(value, message) {
      if (value === !1 || value === null || typeof value > "u")
        throw new Error(message);
    }
    module2.exports = invariant;
  }
});

// node_modules/@remix-run/react/dist/routeModules.js
var require_routeModules = __commonJS({
  "node_modules/@remix-run/react/dist/routeModules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function _interopNamespace(e2) {
      if (e2 && e2.__esModule)
        return e2;
      var n = /* @__PURE__ */ Object.create(null);
      return e2 && Object.keys(e2).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e2, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e2[k];
            }
          });
        }
      }), n.default = e2, Object.freeze(n);
    }
    async function loadRouteModule(route, routeModulesCache) {
      if (route.id in routeModulesCache)
        return routeModulesCache[route.id];
      try {
        let routeModule = await function(t2) {
          return Promise.resolve().then(function() {
            return /* @__PURE__ */ _interopNamespace(require(t2));
          });
        }(
          /* webpackIgnore: true */
          route.module
        );
        return routeModulesCache[route.id] = routeModule, routeModule;
      } catch {
        return window.location.reload(), new Promise(() => {
        });
      }
    }
    exports.loadRouteModule = loadRouteModule;
  }
});

// node_modules/@remix-run/react/dist/links.js
var require_links = __commonJS({
  "node_modules/@remix-run/react/dist/links.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var reactRouterDom = require_main2(), routeModules = require_routeModules();
    function getLinksForMatches(matches, routeModules2, manifest) {
      let descriptors = matches.map((match) => {
        var _module$links;
        let module3 = routeModules2[match.route.id];
        return ((_module$links = module3.links) === null || _module$links === void 0 ? void 0 : _module$links.call(module3)) || [];
      }).flat(1), preloads = getCurrentPageModulePreloadHrefs(matches, manifest);
      return dedupe(descriptors, preloads);
    }
    async function prefetchStyleLinks(routeModule) {
      if (!routeModule.links)
        return;
      let descriptors = routeModule.links();
      if (!descriptors)
        return;
      let styleLinks = [];
      for (let descriptor of descriptors)
        !isPageLinkDescriptor(descriptor) && descriptor.rel === "stylesheet" && styleLinks.push({
          ...descriptor,
          rel: "preload",
          as: "style"
        });
      let matchingLinks = styleLinks.filter((link) => !link.media || window.matchMedia(link.media).matches);
      await Promise.all(matchingLinks.map(prefetchStyleLink));
    }
    async function prefetchStyleLink(descriptor) {
      return new Promise((resolve) => {
        let link = document.createElement("link");
        Object.assign(link, descriptor);
        function removeLink() {
          document.head.contains(link) && document.head.removeChild(link);
        }
        link.onload = () => {
          removeLink(), resolve();
        }, link.onerror = () => {
          removeLink(), resolve();
        }, document.head.appendChild(link);
      });
    }
    function isPageLinkDescriptor(object) {
      return object != null && typeof object.page == "string";
    }
    function isHtmlLinkDescriptor(object) {
      return object == null ? !1 : object.href == null ? object.rel === "preload" && (typeof object.imageSrcSet == "string" || typeof object.imagesrcset == "string") && (typeof object.imageSizes == "string" || typeof object.imagesizes == "string") : typeof object.rel == "string" && typeof object.href == "string";
    }
    async function getStylesheetPrefetchLinks(matches, manifest, routeModules$1) {
      return (await Promise.all(matches.map(async (match) => {
        let mod = await routeModules.loadRouteModule(manifest.routes[match.route.id], routeModules$1);
        return mod.links ? mod.links() : [];
      }))).flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map((link) => link.rel === "preload" ? {
        ...link,
        rel: "prefetch"
      } : {
        ...link,
        rel: "prefetch",
        as: "style"
      });
    }
    function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {
      let path = parsePathPatch(page), isNew = (match, index) => currentMatches[index] ? match.route.id !== currentMatches[index].route.id : !0, matchPathChanged = (match, index) => {
        var _currentMatches$index;
        return (
          // param change, /users/123 -> /users/456
          currentMatches[index].pathname !== match.pathname || // splat param changed, which is not present in match.path
          // e.g. /files/images/avatar.jpg -> files/finances.xls
          ((_currentMatches$index = currentMatches[index].route.path) === null || _currentMatches$index === void 0 ? void 0 : _currentMatches$index.endsWith("*")) && currentMatches[index].params["*"] !== match.params["*"]
        );
      };
      return mode === "data" && location.search !== path.search ? (
        // this is really similar to stuff in transition.ts, maybe somebody smarter
        // than me (or in less of a hurry) can share some of it. You're the best.
        nextMatches.filter((match, index) => {
          if (!manifest.routes[match.route.id].hasLoader)
            return !1;
          if (isNew(match, index) || matchPathChanged(match, index))
            return !0;
          if (match.route.shouldRevalidate) {
            var _currentMatches$;
            let routeChoice = match.route.shouldRevalidate({
              currentUrl: new URL(location.pathname + location.search + location.hash, window.origin),
              currentParams: ((_currentMatches$ = currentMatches[0]) === null || _currentMatches$ === void 0 ? void 0 : _currentMatches$.params) || {},
              nextUrl: new URL(page, window.origin),
              nextParams: match.params,
              defaultShouldRevalidate: !0
            });
            if (typeof routeChoice == "boolean")
              return routeChoice;
          }
          return !0;
        })
      ) : nextMatches.filter((match, index) => {
        let manifestRoute = manifest.routes[match.route.id];
        return (mode === "assets" || manifestRoute.hasLoader) && (isNew(match, index) || matchPathChanged(match, index));
      });
    }
    function getDataLinkHrefs(page, matches, manifest) {
      let path = parsePathPatch(page);
      return dedupeHrefs(matches.filter((match) => manifest.routes[match.route.id].hasLoader).map((match) => {
        let {
          pathname,
          search
        } = path, searchParams = new URLSearchParams(search);
        return searchParams.set("_data", match.route.id), `${pathname}?${searchParams}`;
      }));
    }
    function getModuleLinkHrefs(matches, manifestPatch) {
      return dedupeHrefs(matches.map((match) => {
        let route = manifestPatch.routes[match.route.id], hrefs = [route.module];
        return route.imports && (hrefs = hrefs.concat(route.imports)), hrefs;
      }).flat(1));
    }
    function getCurrentPageModulePreloadHrefs(matches, manifest) {
      return dedupeHrefs(matches.map((match) => {
        let route = manifest.routes[match.route.id], hrefs = [route.module];
        return route.imports && (hrefs = hrefs.concat(route.imports)), hrefs;
      }).flat(1));
    }
    function dedupeHrefs(hrefs) {
      return [...new Set(hrefs)];
    }
    function dedupe(descriptors, preloads) {
      let set = /* @__PURE__ */ new Set(), preloadsSet = new Set(preloads);
      return descriptors.reduce((deduped, descriptor) => {
        if (!isPageLinkDescriptor(descriptor) && descriptor.as === "script" && descriptor.href && preloadsSet.has(descriptor.href))
          return deduped;
        let str = JSON.stringify(descriptor);
        return set.has(str) || (set.add(str), deduped.push(descriptor)), deduped;
      }, []);
    }
    function parsePathPatch(href) {
      let path = reactRouterDom.parsePath(href);
      return path.search === void 0 && (path.search = ""), path;
    }
    exports.dedupe = dedupe;
    exports.getDataLinkHrefs = getDataLinkHrefs;
    exports.getLinksForMatches = getLinksForMatches;
    exports.getModuleLinkHrefs = getModuleLinkHrefs;
    exports.getNewMatchesForLinks = getNewMatchesForLinks;
    exports.getStylesheetPrefetchLinks = getStylesheetPrefetchLinks;
    exports.isHtmlLinkDescriptor = isHtmlLinkDescriptor;
    exports.isPageLinkDescriptor = isPageLinkDescriptor;
    exports.prefetchStyleLinks = prefetchStyleLinks;
  }
});

// node_modules/@remix-run/react/dist/markup.js
var require_markup2 = __commonJS({
  "node_modules/@remix-run/react/dist/markup.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var ESCAPE_LOOKUP = {
      "&": "\\u0026",
      ">": "\\u003e",
      "<": "\\u003c",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    }, ESCAPE_REGEX = /[&><\u2028\u2029]/g;
    function escapeHtml(html) {
      return html.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
    }
    function createHtml(html) {
      return {
        __html: html
      };
    }
    exports.createHtml = createHtml;
    exports.escapeHtml = escapeHtml;
  }
});

// node_modules/@remix-run/react/dist/transition.js
var require_transition = __commonJS({
  "node_modules/@remix-run/react/dist/transition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var IDLE_TRANSITION = {
      state: "idle",
      submission: void 0,
      location: void 0,
      type: "idle"
    }, IDLE_FETCHER = {
      state: "idle",
      type: "init",
      data: void 0,
      formMethod: void 0,
      formAction: void 0,
      formData: void 0,
      formEncType: void 0,
      submission: void 0
    };
    exports.IDLE_FETCHER = IDLE_FETCHER;
    exports.IDLE_TRANSITION = IDLE_TRANSITION;
  }
});

// node_modules/@remix-run/react/dist/warnings.js
var require_warnings2 = __commonJS({
  "node_modules/@remix-run/react/dist/warnings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function logDeprecationOnce(message, key = message) {
    }
    exports.logDeprecationOnce = logDeprecationOnce;
  }
});

// node_modules/@remix-run/react/dist/components.js
var require_components = __commonJS({
  "node_modules/@remix-run/react/dist/components.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var _rollupPluginBabelHelpers = require_rollupPluginBabelHelpers(), React5 = require_react(), reactRouterDom = require_main2(), errorBoundaries = require_errorBoundaries(), invariant = require_invariant2(), links2 = require_links(), markup = require_markup2(), transition = require_transition(), warnings = require_warnings2();
    function _interopNamespace(e2) {
      if (e2 && e2.__esModule)
        return e2;
      var n = /* @__PURE__ */ Object.create(null);
      return e2 && Object.keys(e2).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e2, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e2[k];
            }
          });
        }
      }), n.default = e2, Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React5);
    function useDataRouterContext() {
      let context = React__namespace.useContext(reactRouterDom.UNSAFE_DataRouterContext);
      return invariant(context, "You must render this element inside a <DataRouterContext.Provider> element"), context;
    }
    function useDataRouterStateContext() {
      let context = React__namespace.useContext(reactRouterDom.UNSAFE_DataRouterStateContext);
      return invariant(context, "You must render this element inside a <DataRouterStateContext.Provider> element"), context;
    }
    var RemixContext = /* @__PURE__ */ React__namespace.createContext(void 0);
    RemixContext.displayName = "Remix";
    function useRemixContext() {
      let context = React__namespace.useContext(RemixContext);
      return invariant(context, "You must render this element inside a <Remix> element"), context;
    }
    function RemixRoute({
      id
    }) {
      let {
        routeModules,
        future: future2
      } = useRemixContext();
      invariant(routeModules, `Cannot initialize 'routeModules'. This normally occurs when you have server code in your client modules.
Check this link for more details:
https://remix.run/pages/gotchas#server-code-in-client-bundles`);
      let {
        default: Component,
        ErrorBoundary: ErrorBoundary2,
        CatchBoundary
      } = routeModules[id];
      return !Component && (ErrorBoundary2 || !future2.v2_errorBoundary && CatchBoundary) && (Component = reactRouterDom.Outlet), invariant(Component, `Route "${id}" has no component! Please go add a \`default\` export in the route module file.
If you were trying to navigate or submit to a resource route, use \`<a>\` instead of \`<Link>\` or \`<Form reloadDocument>\`.`), /* @__PURE__ */ React__namespace.createElement(Component, null);
    }
    function RemixRouteError({
      id
    }) {
      let {
        future: future2,
        routeModules
      } = useRemixContext();
      invariant(routeModules, `Cannot initialize 'routeModules'. This normally occurs when you have server code in your client modules.
Check this link for more details:
https://remix.run/pages/gotchas#server-code-in-client-bundles`);
      let error = reactRouterDom.useRouteError(), {
        CatchBoundary,
        ErrorBoundary: ErrorBoundary2
      } = routeModules[id];
      if (future2.v2_errorBoundary) {
        if (id === "root" && (ErrorBoundary2 || (ErrorBoundary2 = errorBoundaries.V2_RemixRootDefaultErrorBoundary)), ErrorBoundary2)
          return /* @__PURE__ */ React__namespace.createElement(ErrorBoundary2, null);
        throw error;
      }
      if (id === "root" && (CatchBoundary || (CatchBoundary = errorBoundaries.RemixRootDefaultCatchBoundary), ErrorBoundary2 || (ErrorBoundary2 = errorBoundaries.RemixRootDefaultErrorBoundary)), reactRouterDom.isRouteErrorResponse(error)) {
        let tError = error;
        if (tError != null && tError.error && tError.status !== 404 && ErrorBoundary2)
          return /* @__PURE__ */ React__namespace.createElement(ErrorBoundary2, {
            error: tError.error
          });
        if (CatchBoundary)
          return /* @__PURE__ */ React__namespace.createElement(errorBoundaries.RemixCatchBoundary, {
            catch: error,
            component: CatchBoundary
          });
      }
      if (error instanceof Error && ErrorBoundary2)
        return /* @__PURE__ */ React__namespace.createElement(ErrorBoundary2, {
          error
        });
      throw error;
    }
    function usePrefetchBehavior(prefetch, theirElementProps) {
      let [maybePrefetch, setMaybePrefetch] = React__namespace.useState(!1), [shouldPrefetch, setShouldPrefetch] = React__namespace.useState(!1), {
        onFocus,
        onBlur,
        onMouseEnter,
        onMouseLeave,
        onTouchStart
      } = theirElementProps;
      React__namespace.useEffect(() => {
        prefetch === "render" && setShouldPrefetch(!0);
      }, [prefetch]);
      let setIntent = () => {
        prefetch === "intent" && setMaybePrefetch(!0);
      }, cancelIntent = () => {
        prefetch === "intent" && (setMaybePrefetch(!1), setShouldPrefetch(!1));
      };
      return React__namespace.useEffect(() => {
        if (maybePrefetch) {
          let id = setTimeout(() => {
            setShouldPrefetch(!0);
          }, 100);
          return () => {
            clearTimeout(id);
          };
        }
      }, [maybePrefetch]), [shouldPrefetch, {
        onFocus: composeEventHandlers(onFocus, setIntent),
        onBlur: composeEventHandlers(onBlur, cancelIntent),
        onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
        onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
        onTouchStart: composeEventHandlers(onTouchStart, setIntent)
      }];
    }
    var ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, NavLink = /* @__PURE__ */ React__namespace.forwardRef(({
      to,
      prefetch = "none",
      ...props
    }, forwardedRef) => {
      let isAbsolute = typeof to == "string" && ABSOLUTE_URL_REGEX.test(to), href = reactRouterDom.useHref(to), [shouldPrefetch, prefetchHandlers] = usePrefetchBehavior(prefetch, props);
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.NavLink, _rollupPluginBabelHelpers.extends({
        ref: forwardedRef,
        to
      }, props, prefetchHandlers)), shouldPrefetch && !isAbsolute ? /* @__PURE__ */ React__namespace.createElement(PrefetchPageLinks, {
        page: href
      }) : null);
    });
    NavLink.displayName = "NavLink";
    var Link = /* @__PURE__ */ React__namespace.forwardRef(({
      to,
      prefetch = "none",
      ...props
    }, forwardedRef) => {
      let isAbsolute = typeof to == "string" && ABSOLUTE_URL_REGEX.test(to), href = reactRouterDom.useHref(to), [shouldPrefetch, prefetchHandlers] = usePrefetchBehavior(prefetch, props);
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.Link, _rollupPluginBabelHelpers.extends({
        ref: forwardedRef,
        to
      }, props, prefetchHandlers)), shouldPrefetch && !isAbsolute ? /* @__PURE__ */ React__namespace.createElement(PrefetchPageLinks, {
        page: href
      }) : null);
    });
    Link.displayName = "Link";
    function composeEventHandlers(theirHandler, ourHandler) {
      return (event) => {
        theirHandler && theirHandler(event), event.defaultPrevented || ourHandler(event);
      };
    }
    var linksWarning = "\u26A0\uFE0F REMIX FUTURE CHANGE: The behavior of links `imagesizes` and `imagesrcset` will be changing in v2. Only the React camel case versions will be valid. Please change to `imageSizes` and `imageSrcSet`. For instructions on making this change see https://remix.run/docs/en/v1.15.0/pages/v2#links-imagesizes-and-imagesrcset", useTransitionWarning = "\u26A0\uFE0F REMIX FUTURE CHANGE: `useTransition` will be removed in v2 in favor of `useNavigation`. You can prepare for this change at your convenience by updating to `useNavigation`. For instructions on making this change see https://remix.run/docs/en/v1.15.0/pages/v2#usetransition", fetcherTypeWarning = "\u26A0\uFE0F REMIX FUTURE CHANGE: `fetcher.type` will be removed in v2. Please use `fetcher.state`, `fetcher.formData`, and `fetcher.data` to achieve the same UX. For instructions on making this change see https://remix.run/docs/en/v1.15.0/pages/v2#usefetcher", fetcherSubmissionWarning = "\u26A0\uFE0F REMIX FUTURE CHANGE : `fetcher.submission` will be removed in v2. The submission fields are now part of the fetcher object itself (`fetcher.formData`). For instructions on making this change see https://remix.run/docs/en/v1.15.0/pages/v2#usefetcher";
    function Links2() {
      let {
        manifest,
        routeModules
      } = useRemixContext(), {
        errors,
        matches: routerMatches
      } = useDataRouterStateContext(), matches = errors ? routerMatches.slice(0, routerMatches.findIndex((m2) => errors[m2.route.id]) + 1) : routerMatches, links$1 = React__namespace.useMemo(() => links2.getLinksForMatches(matches, routeModules, manifest), [matches, routeModules, manifest]);
      return React__namespace.useEffect(() => {
        links$1.some((link) => "imagesizes" in link || "imagesrcset" in link) && warnings.logDeprecationOnce(linksWarning);
      }, [links$1]), /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, links$1.map((link) => {
        if (links2.isPageLinkDescriptor(link))
          return /* @__PURE__ */ React__namespace.createElement(PrefetchPageLinks, _rollupPluginBabelHelpers.extends({
            key: link.page
          }, link));
        let imageSrcSet = null;
        return "useId" in React__namespace ? (link.imagesrcset && (link.imageSrcSet = imageSrcSet = link.imagesrcset, delete link.imagesrcset), link.imagesizes && (link.imageSizes = link.imagesizes, delete link.imagesizes)) : (link.imageSrcSet && (link.imagesrcset = imageSrcSet = link.imageSrcSet, delete link.imageSrcSet), link.imageSizes && (link.imagesizes = link.imageSizes, delete link.imageSizes)), /* @__PURE__ */ React__namespace.createElement("link", _rollupPluginBabelHelpers.extends({
          key: link.rel + (link.href || "") + (imageSrcSet || "")
        }, link));
      }));
    }
    function PrefetchPageLinks({
      page,
      ...dataLinkProps
    }) {
      let {
        router
      } = useDataRouterContext(), matches = React__namespace.useMemo(() => reactRouterDom.matchRoutes(router.routes, page), [router.routes, page]);
      return matches ? /* @__PURE__ */ React__namespace.createElement(PrefetchPageLinksImpl, _rollupPluginBabelHelpers.extends({
        page,
        matches
      }, dataLinkProps)) : (console.warn(`Tried to prefetch ${page} but no routes matched.`), null);
    }
    function usePrefetchedStylesheets(matches) {
      let {
        manifest,
        routeModules
      } = useRemixContext(), [styleLinks, setStyleLinks] = React__namespace.useState([]);
      return React__namespace.useEffect(() => {
        let interrupted = !1;
        return links2.getStylesheetPrefetchLinks(matches, manifest, routeModules).then((links3) => {
          interrupted || setStyleLinks(links3);
        }), () => {
          interrupted = !0;
        };
      }, [matches, manifest, routeModules]), styleLinks;
    }
    function PrefetchPageLinksImpl({
      page,
      matches: nextMatches,
      ...linkProps
    }) {
      let location = reactRouterDom.useLocation(), {
        manifest
      } = useRemixContext(), {
        matches
      } = useDataRouterStateContext(), newMatchesForData = React__namespace.useMemo(() => links2.getNewMatchesForLinks(page, nextMatches, matches, manifest, location, "data"), [page, nextMatches, matches, manifest, location]), newMatchesForAssets = React__namespace.useMemo(() => links2.getNewMatchesForLinks(page, nextMatches, matches, manifest, location, "assets"), [page, nextMatches, matches, manifest, location]), dataHrefs = React__namespace.useMemo(() => links2.getDataLinkHrefs(page, newMatchesForData, manifest), [newMatchesForData, page, manifest]), moduleHrefs = React__namespace.useMemo(() => links2.getModuleLinkHrefs(newMatchesForAssets, manifest), [newMatchesForAssets, manifest]), styleLinks = usePrefetchedStylesheets(newMatchesForAssets);
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ React__namespace.createElement("link", _rollupPluginBabelHelpers.extends({
        key: href,
        rel: "prefetch",
        as: "fetch",
        href
      }, linkProps))), moduleHrefs.map((href) => /* @__PURE__ */ React__namespace.createElement("link", _rollupPluginBabelHelpers.extends({
        key: href,
        rel: "modulepreload",
        href
      }, linkProps))), styleLinks.map((link) => (
        // these don't spread `linkProps` because they are full link descriptors
        // already with their own props
        /* @__PURE__ */ React__namespace.createElement("link", _rollupPluginBabelHelpers.extends({
          key: link.href
        }, link))
      )));
    }
    function V1Meta() {
      let {
        routeModules
      } = useRemixContext(), {
        errors,
        matches: routerMatches,
        loaderData
      } = useDataRouterStateContext(), location = reactRouterDom.useLocation(), matches = errors ? routerMatches.slice(0, routerMatches.findIndex((m2) => errors[m2.route.id]) + 1) : routerMatches, meta = {}, parentsData = {};
      for (let match of matches) {
        let routeId = match.route.id, data = loaderData[routeId], params = match.params, routeModule = routeModules[routeId];
        if (routeModule.meta) {
          let routeMeta = typeof routeModule.meta == "function" ? routeModule.meta({
            data,
            parentsData,
            params,
            location
          }) : routeModule.meta;
          if (routeMeta && Array.isArray(routeMeta))
            throw new Error(
              "The route at " + match.route.path + " returns an array. This is only supported with the `v2_meta` future flag in the Remix config. Either set the flag to `true` or update the route's meta function to return an object.\n\nTo reference the v1 meta function API, see https://remix.run/route/meta"
              // TODO: Add link to the docs once they are written
              // + "\n\nTo reference future flags and the v2 meta API, see https://remix.run/file-conventions/remix-config#future-v2-meta."
            );
          Object.assign(meta, routeMeta);
        }
        parentsData[routeId] = data;
      }
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, Object.entries(meta).map(([name, value]) => {
        if (!value)
          return null;
        if (["charset", "charSet"].includes(name))
          return /* @__PURE__ */ React__namespace.createElement("meta", {
            key: "charSet",
            charSet: value
          });
        if (name === "title")
          return /* @__PURE__ */ React__namespace.createElement("title", {
            key: "title"
          }, String(value));
        let isOpenGraphTag = /^(og|music|video|article|book|profile|fb):.+$/.test(name);
        return [value].flat().map((content) => isOpenGraphTag ? /* @__PURE__ */ React__namespace.createElement("meta", {
          property: name,
          content,
          key: name + content
        }) : typeof content == "string" ? /* @__PURE__ */ React__namespace.createElement("meta", {
          name,
          content,
          key: name + content
        }) : /* @__PURE__ */ React__namespace.createElement("meta", _rollupPluginBabelHelpers.extends({
          key: name + JSON.stringify(content)
        }, content)));
      }));
    }
    function V2Meta() {
      let {
        routeModules
      } = useRemixContext(), {
        errors,
        matches: routerMatches,
        loaderData
      } = useDataRouterStateContext(), location = reactRouterDom.useLocation(), _matches = errors ? routerMatches.slice(0, routerMatches.findIndex((m2) => errors[m2.route.id]) + 1) : routerMatches, meta = [], leafMeta = null, matches = [];
      for (let i2 = 0; i2 < _matches.length; i2++) {
        let _match = _matches[i2], routeId = _match.route.id, data = loaderData[routeId], params = _match.params, routeModule = routeModules[routeId], routeMeta = [], match = {
          id: routeId,
          data,
          meta: [],
          params: _match.params,
          pathname: _match.pathname,
          handle: _match.route.handle,
          // TODO: Remove in v2. Only leaving it for now because we used it in
          // examples and there's no reason to crash someone's build for one line.
          // They'll get a TS error from the type updates anyway.
          // @ts-expect-error
          get route() {
            return console.warn("The meta function in " + _match.route.path + " accesses the `route` property on `matches`. This is deprecated and will be removed in Remix version 2. See"), _match.route;
          }
        };
        if (matches[i2] = match, routeModule != null && routeModule.meta ? routeMeta = typeof routeModule.meta == "function" ? routeModule.meta({
          data,
          params,
          location,
          matches
        }) : Array.isArray(routeModule.meta) ? [...routeModule.meta] : routeModule.meta : leafMeta && (routeMeta = [...leafMeta]), routeMeta = routeMeta || [], !Array.isArray(routeMeta))
          throw new Error("The `v2_meta` API is enabled in the Remix config, but the route at " + _match.route.path + ` returns an invalid value. In v2, all route meta functions must return an array of meta objects.

To reference the v1 meta function API, see https://remix.run/route/meta`);
        match.meta = routeMeta, matches[i2] = match, meta = [...routeMeta], leafMeta = meta;
      }
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, meta.flat().map((metaProps) => {
        if (!metaProps)
          return null;
        if ("tagName" in metaProps) {
          let tagName = metaProps.tagName;
          if (delete metaProps.tagName, !isValidMetaTag(tagName))
            return console.warn(`A meta object uses an invalid tagName: ${tagName}. Expected either 'link' or 'meta'`), null;
          let Comp = tagName;
          return /* @__PURE__ */ React__namespace.createElement(Comp, _rollupPluginBabelHelpers.extends({
            key: JSON.stringify(metaProps)
          }, metaProps));
        }
        if ("title" in metaProps)
          return /* @__PURE__ */ React__namespace.createElement("title", {
            key: "title"
          }, String(metaProps.title));
        if ("charset" in metaProps && (metaProps.charSet ?? (metaProps.charSet = metaProps.charset), delete metaProps.charset), "charSet" in metaProps && metaProps.charSet != null)
          return typeof metaProps.charSet == "string" ? /* @__PURE__ */ React__namespace.createElement("meta", {
            key: "charSet",
            charSet: metaProps.charSet
          }) : null;
        if ("script:ld+json" in metaProps) {
          let json3 = null;
          try {
            json3 = JSON.stringify(metaProps["script:ld+json"]);
          } catch {
          }
          return json3 != null && /* @__PURE__ */ React__namespace.createElement("script", {
            key: "script:ld+json",
            type: "application/ld+json",
            dangerouslySetInnerHTML: {
              __html: JSON.stringify(metaProps["script:ld+json"])
            }
          });
        }
        return /* @__PURE__ */ React__namespace.createElement("meta", _rollupPluginBabelHelpers.extends({
          key: JSON.stringify(metaProps)
        }, metaProps));
      }));
    }
    function isValidMetaTag(tagName) {
      return typeof tagName == "string" && /^(meta|link)$/.test(tagName);
    }
    function Meta() {
      let {
        future: future2
      } = useRemixContext();
      return future2 != null && future2.v2_meta ? /* @__PURE__ */ React__namespace.createElement(V2Meta, null) : /* @__PURE__ */ React__namespace.createElement(V1Meta, null);
    }
    function Await(props) {
      return /* @__PURE__ */ React__namespace.createElement(reactRouterDom.Await, props);
    }
    var isHydrated = !1;
    function Scripts2(props) {
      let {
        manifest,
        serverHandoffString,
        abortDelay
      } = useRemixContext(), {
        router,
        static: isStatic,
        staticContext
      } = useDataRouterContext(), {
        matches
      } = useDataRouterStateContext(), navigation = reactRouterDom.useNavigation();
      React__namespace.useEffect(() => {
        isHydrated = !0;
      }, []);
      let deferredScripts = [], initialScripts = React__namespace.useMemo(() => {
        var _manifest$hmr;
        let contextScript = staticContext ? `window.__remixContext = ${serverHandoffString};` : " ", activeDeferreds = staticContext == null ? void 0 : staticContext.activeDeferreds;
        contextScript += activeDeferreds ? ["__remixContext.p = function(v,e,p,x) {", "  if (typeof e !== 'undefined') {", `    x=new Error("Unexpected Server Error");
    x.stack=undefined;`, "    p=Promise.reject(x);", "  } else {", "    p=Promise.resolve(v);", "  }", "  return p;", "};", "__remixContext.n = function(i,k) {", "  __remixContext.t = __remixContext.t || {};", "  __remixContext.t[i] = __remixContext.t[i] || {};", "  let p = new Promise((r, e) => {__remixContext.t[i][k] = {r:(v)=>{r(v);},e:(v)=>{e(v);}};});", typeof abortDelay == "number" ? `setTimeout(() => {if(typeof p._error !== "undefined" || typeof p._data !== "undefined"){return;} __remixContext.t[i][k].e(new Error("Server timeout."))}, ${abortDelay});` : "", "  return p;", "};", "__remixContext.r = function(i,k,v,e,p,x) {", "  p = __remixContext.t[i][k];", "  if (typeof e !== 'undefined') {", `    x=new Error("Unexpected Server Error");
    x.stack=undefined;`, "    p.e(x);", "  } else {", "    p.r(v);", "  }", "};"].join(`
`) + Object.entries(activeDeferreds).map(([routeId, deferredData]) => {
          let pendingKeys = new Set(deferredData.pendingKeys), promiseKeyValues = deferredData.deferredKeys.map((key) => {
            if (pendingKeys.has(key))
              return deferredScripts.push(/* @__PURE__ */ React__namespace.createElement(DeferredHydrationScript, {
                key: `${routeId} | ${key}`,
                deferredData,
                routeId,
                dataKey: key
              })), `${JSON.stringify(key)}:__remixContext.n(${JSON.stringify(routeId)}, ${JSON.stringify(key)})`;
            {
              let trackedPromise = deferredData.data[key];
              if (typeof trackedPromise._error < "u") {
                let toSerialize = {
                  message: "Unexpected Server Error",
                  stack: void 0
                };
                return `${JSON.stringify(key)}:__remixContext.p(!1, ${markup.escapeHtml(JSON.stringify(toSerialize))})`;
              } else {
                if (typeof trackedPromise._data > "u")
                  throw new Error(`The deferred data for ${key} was not resolved, did you forget to return data from a deferred promise?`);
                return `${JSON.stringify(key)}:__remixContext.p(${markup.escapeHtml(JSON.stringify(trackedPromise._data))})`;
              }
            }
          }).join(`,
`);
          return `Object.assign(__remixContext.state.loaderData[${JSON.stringify(routeId)}], {${promiseKeyValues}});`;
        }).join(`
`) + (deferredScripts.length > 0 ? `__remixContext.a=${deferredScripts.length};` : "") : "";
        let routeModulesScript = isStatic ? `${(_manifest$hmr = manifest.hmr) !== null && _manifest$hmr !== void 0 && _manifest$hmr.runtime ? `import ${JSON.stringify(manifest.hmr.runtime)};` : ""}import ${JSON.stringify(manifest.url)};
${matches.map((match, index) => `import * as route${index} from ${JSON.stringify(manifest.routes[match.route.id].module)};`).join(`
`)}
window.__remixRouteModules = {${matches.map((match, index) => `${JSON.stringify(match.route.id)}:route${index}`).join(",")}};

import(${JSON.stringify(manifest.entry.module)});` : " ";
        return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement("script", _rollupPluginBabelHelpers.extends({}, props, {
          suppressHydrationWarning: !0,
          dangerouslySetInnerHTML: markup.createHtml(contextScript),
          type: void 0
        })), /* @__PURE__ */ React__namespace.createElement("script", _rollupPluginBabelHelpers.extends({}, props, {
          suppressHydrationWarning: !0,
          dangerouslySetInnerHTML: markup.createHtml(routeModulesScript),
          type: "module",
          async: !0
        })));
      }, []);
      if (!isStatic && typeof __remixContext == "object" && __remixContext.a)
        for (let i2 = 0; i2 < __remixContext.a; i2++)
          deferredScripts.push(/* @__PURE__ */ React__namespace.createElement(DeferredHydrationScript, {
            key: i2
          }));
      let nextMatches = React__namespace.useMemo(() => {
        if (navigation.location) {
          let matches2 = reactRouterDom.matchRoutes(router.routes, navigation.location);
          return invariant(matches2, `No routes match path "${navigation.location.pathname}"`), matches2;
        }
        return [];
      }, [navigation.location, router.routes]), routePreloads = matches.concat(nextMatches).map((match) => {
        let route = manifest.routes[match.route.id];
        return (route.imports || []).concat([route.module]);
      }).flat(1), preloads = isHydrated ? [] : manifest.entry.imports.concat(routePreloads);
      return isHydrated ? null : /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement("link", {
        rel: "modulepreload",
        href: manifest.entry.module,
        crossOrigin: props.crossOrigin
      }), dedupe(preloads).map((path) => /* @__PURE__ */ React__namespace.createElement("link", {
        key: path,
        rel: "modulepreload",
        href: path,
        crossOrigin: props.crossOrigin
      })), initialScripts, deferredScripts);
    }
    function DeferredHydrationScript({
      dataKey,
      deferredData,
      routeId
    }) {
      return typeof document > "u" && deferredData && dataKey && routeId && invariant(deferredData.pendingKeys.includes(dataKey), `Deferred data for route ${routeId} with key ${dataKey} was not pending but tried to render a script for it.`), /* @__PURE__ */ React__namespace.createElement(React__namespace.Suspense, {
        fallback: (
          // This makes absolutely no sense. The server renders null as a fallback,
          // but when hydrating, we need to render a script tag to avoid a hydration issue.
          // To reproduce a hydration mismatch, just render null as a fallback.
          typeof document > "u" && deferredData && dataKey && routeId ? null : /* @__PURE__ */ React__namespace.createElement("script", {
            async: !0,
            suppressHydrationWarning: !0,
            dangerouslySetInnerHTML: {
              __html: " "
            }
          })
        )
      }, typeof document > "u" && deferredData && dataKey && routeId ? /* @__PURE__ */ React__namespace.createElement(Await, {
        resolve: deferredData.data[dataKey],
        errorElement: /* @__PURE__ */ React__namespace.createElement(ErrorDeferredHydrationScript, {
          dataKey,
          routeId
        }),
        children: (data) => /* @__PURE__ */ React__namespace.createElement("script", {
          async: !0,
          suppressHydrationWarning: !0,
          dangerouslySetInnerHTML: {
            __html: `__remixContext.r(${JSON.stringify(routeId)}, ${JSON.stringify(dataKey)}, ${markup.escapeHtml(JSON.stringify(data))});`
          }
        })
      }) : /* @__PURE__ */ React__namespace.createElement("script", {
        async: !0,
        suppressHydrationWarning: !0,
        dangerouslySetInnerHTML: {
          __html: " "
        }
      }));
    }
    function ErrorDeferredHydrationScript({
      dataKey,
      routeId
    }) {
      let error = reactRouterDom.useAsyncError(), toSerialize = {
        message: "Unexpected Server Error",
        stack: void 0
      };
      return /* @__PURE__ */ React__namespace.createElement("script", {
        suppressHydrationWarning: !0,
        dangerouslySetInnerHTML: {
          __html: `__remixContext.r(${JSON.stringify(routeId)}, ${JSON.stringify(dataKey)}, !1, ${markup.escapeHtml(JSON.stringify(toSerialize))});`
        }
      });
    }
    function dedupe(array) {
      return [...new Set(array)];
    }
    function useMatches() {
      let {
        routeModules
      } = useRemixContext(), matches = reactRouterDom.useMatches();
      return React__namespace.useMemo(() => matches.map((match) => ({
        id: match.id,
        pathname: match.pathname,
        params: match.params,
        data: match.data,
        // Need to grab handle here since we don't have it at client-side route
        // creation time
        handle: routeModules[match.id].handle
      })), [matches, routeModules]);
    }
    function useLoaderData3() {
      return reactRouterDom.useLoaderData();
    }
    function useActionData3() {
      return reactRouterDom.useActionData();
    }
    function useTransition() {
      let navigation = reactRouterDom.useNavigation();
      return React__namespace.useEffect(() => {
        warnings.logDeprecationOnce(useTransitionWarning);
      }, []), React__namespace.useMemo(() => convertNavigationToTransition(navigation), [navigation]);
    }
    function convertNavigationToTransition(navigation) {
      let {
        location,
        state,
        formMethod,
        formAction,
        formEncType,
        formData
      } = navigation;
      if (!location)
        return transition.IDLE_TRANSITION;
      let isActionSubmission = formMethod != null && ["POST", "PUT", "PATCH", "DELETE"].includes(formMethod.toUpperCase());
      if (state === "submitting" && formMethod && formAction && formEncType && formData) {
        if (isActionSubmission)
          return {
            location,
            state,
            submission: {
              method: formMethod.toUpperCase(),
              action: formAction,
              encType: formEncType,
              formData,
              key: ""
            },
            type: "actionSubmission"
          };
        invariant(!1, "Encountered an unexpected navigation scenario in useTransition()");
      }
      if (state === "loading") {
        let {
          _isRedirect,
          _isFetchActionRedirect
        } = location.state || {};
        if (formMethod && formAction && formEncType && formData) {
          if (_isRedirect)
            return isActionSubmission ? {
              location,
              state,
              submission: {
                method: formMethod.toUpperCase(),
                action: formAction,
                encType: formEncType,
                formData,
                key: ""
              },
              type: "actionRedirect"
            } : {
              location,
              state,
              submission: {
                method: formMethod.toUpperCase(),
                action: formAction,
                encType: formEncType,
                formData,
                key: ""
              },
              type: "loaderSubmissionRedirect"
            };
          if (isActionSubmission)
            return {
              location,
              state,
              submission: {
                method: formMethod.toUpperCase(),
                action: formAction,
                encType: formEncType,
                formData,
                key: ""
              },
              type: "actionReload"
            };
          {
            let url = new URL(formAction, window.location.origin);
            return url.search = new URLSearchParams(formData.entries()).toString(), {
              location,
              state: "submitting",
              submission: {
                method: formMethod.toUpperCase(),
                action: url.pathname + url.search,
                encType: formEncType,
                formData,
                key: ""
              },
              type: "loaderSubmission"
            };
          }
        } else if (_isRedirect)
          return _isFetchActionRedirect ? {
            location,
            state,
            submission: void 0,
            type: "fetchActionRedirect"
          } : {
            location,
            state,
            submission: void 0,
            type: "normalRedirect"
          };
      }
      return {
        location,
        state: "loading",
        submission: void 0,
        type: "normalLoad"
      };
    }
    function useFetchers() {
      return reactRouterDom.useFetchers().map((f3) => {
        let fetcher2 = convertRouterFetcherToRemixFetcher({
          state: f3.state,
          data: f3.data,
          formMethod: f3.formMethod,
          formAction: f3.formAction,
          formData: f3.formData,
          formEncType: f3.formEncType,
          " _hasFetcherDoneAnything ": f3[" _hasFetcherDoneAnything "]
        });
        return addFetcherDeprecationWarnings(fetcher2), fetcher2;
      });
    }
    function useFetcher2() {
      let fetcherRR = reactRouterDom.useFetcher();
      return React__namespace.useMemo(() => {
        let fetcherWithComponents = {
          ...convertRouterFetcherToRemixFetcher({
            state: fetcherRR.state,
            data: fetcherRR.data,
            formMethod: fetcherRR.formMethod,
            formAction: fetcherRR.formAction,
            formData: fetcherRR.formData,
            formEncType: fetcherRR.formEncType,
            " _hasFetcherDoneAnything ": fetcherRR[" _hasFetcherDoneAnything "]
          }),
          load: fetcherRR.load,
          submit: fetcherRR.submit,
          Form: fetcherRR.Form
        };
        return addFetcherDeprecationWarnings(fetcherWithComponents), fetcherWithComponents;
      }, [fetcherRR]);
    }
    function addFetcherDeprecationWarnings(fetcher2) {
      let type = fetcher2.type;
      Object.defineProperty(fetcher2, "type", {
        get() {
          return warnings.logDeprecationOnce(fetcherTypeWarning), type;
        },
        set(value) {
          type = value;
        },
        // These settings should make this behave like a normal object `type` field
        configurable: !0,
        enumerable: !0
      });
      let submission = fetcher2.submission;
      Object.defineProperty(fetcher2, "submission", {
        get() {
          return warnings.logDeprecationOnce(fetcherSubmissionWarning), submission;
        },
        set(value) {
          submission = value;
        },
        // These settings should make this behave like a normal object `type` field
        configurable: !0,
        enumerable: !0
      });
    }
    function convertRouterFetcherToRemixFetcher(fetcherRR) {
      let {
        state,
        formMethod,
        formAction,
        formEncType,
        formData,
        data
      } = fetcherRR, isActionSubmission = formMethod != null && ["POST", "PUT", "PATCH", "DELETE"].includes(formMethod.toUpperCase());
      if (state === "idle")
        return fetcherRR[" _hasFetcherDoneAnything "] === !0 ? {
          state: "idle",
          type: "done",
          formMethod: void 0,
          formAction: void 0,
          formData: void 0,
          formEncType: void 0,
          submission: void 0,
          data
        } : transition.IDLE_FETCHER;
      if (state === "submitting" && formMethod && formAction && formEncType && formData) {
        if (isActionSubmission)
          return {
            state,
            type: "actionSubmission",
            formMethod: formMethod.toUpperCase(),
            formAction,
            formEncType,
            formData,
            submission: {
              method: formMethod.toUpperCase(),
              action: formAction,
              encType: formEncType,
              formData,
              key: ""
            },
            data
          };
        invariant(!1, "Encountered an unexpected fetcher scenario in useFetcher()");
      }
      if (state === "loading" && formMethod && formAction && formEncType && formData) {
        if (isActionSubmission)
          return data ? {
            state,
            type: "actionReload",
            formMethod: formMethod.toUpperCase(),
            formAction,
            formEncType,
            formData,
            submission: {
              method: formMethod.toUpperCase(),
              action: formAction,
              encType: formEncType,
              formData,
              key: ""
            },
            data
          } : {
            state,
            type: "actionRedirect",
            formMethod: formMethod.toUpperCase(),
            formAction,
            formEncType,
            formData,
            submission: {
              method: formMethod.toUpperCase(),
              action: formAction,
              encType: formEncType,
              formData,
              key: ""
            },
            data: void 0
          };
        {
          let url = new URL(formAction, window.location.origin);
          return url.search = new URLSearchParams(formData.entries()).toString(), {
            state: "submitting",
            type: "loaderSubmission",
            formMethod: formMethod.toUpperCase(),
            formAction,
            formEncType,
            formData,
            submission: {
              method: formMethod.toUpperCase(),
              action: url.pathname + url.search,
              encType: formEncType,
              formData,
              key: ""
            },
            data
          };
        }
      }
      return {
        state: "loading",
        type: "normalLoad",
        formMethod: void 0,
        formAction: void 0,
        formData: void 0,
        formEncType: void 0,
        submission: void 0,
        data
      };
    }
    var LiveReload2 = () => null;
    exports.Await = Await;
    exports.Link = Link;
    exports.Links = Links2;
    exports.LiveReload = LiveReload2;
    exports.Meta = Meta;
    exports.NavLink = NavLink;
    exports.PrefetchPageLinks = PrefetchPageLinks;
    exports.RemixContext = RemixContext;
    exports.RemixRoute = RemixRoute;
    exports.RemixRouteError = RemixRouteError;
    exports.Scripts = Scripts2;
    exports.composeEventHandlers = composeEventHandlers;
    exports.useActionData = useActionData3;
    exports.useFetcher = useFetcher2;
    exports.useFetchers = useFetchers;
    exports.useLoaderData = useLoaderData3;
    exports.useMatches = useMatches;
    exports.useTransition = useTransition;
  }
});

// node_modules/@remix-run/react/dist/errors.js
var require_errors3 = __commonJS({
  "node_modules/@remix-run/react/dist/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var router = require_router_cjs();
    function deserializeErrors(errors) {
      if (!errors)
        return null;
      let entries = Object.entries(errors), serialized = {};
      for (let [key, val] of entries)
        if (val && val.__type === "RouteErrorResponse")
          serialized[key] = new router.ErrorResponse(val.status, val.statusText, val.data, val.internal === !0);
        else if (val && val.__type === "Error") {
          let error = new Error(val.message);
          error.stack = val.stack, serialized[key] = error;
        } else
          serialized[key] = val;
      return serialized;
    }
    exports.deserializeErrors = deserializeErrors;
  }
});

// node_modules/@remix-run/react/dist/data.js
var require_data2 = __commonJS({
  "node_modules/@remix-run/react/dist/data.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var router = require_router_cjs();
    function isCatchResponse(response) {
      return response.headers.get("X-Remix-Catch") != null;
    }
    function isErrorResponse(response) {
      return response.headers.get("X-Remix-Error") != null;
    }
    function isRedirectResponse(response) {
      return response.headers.get("X-Remix-Redirect") != null;
    }
    function isDeferredResponse(response) {
      var _response$headers$get;
      return !!((_response$headers$get = response.headers.get("Content-Type")) !== null && _response$headers$get !== void 0 && _response$headers$get.match(/text\/remix-deferred/));
    }
    async function fetchData(request, routeId, retry = 0) {
      let url = new URL(request.url);
      url.searchParams.set("_data", routeId);
      let init = {
        signal: request.signal
      };
      if (request.method !== "GET") {
        init.method = request.method;
        let contentType = request.headers.get("Content-Type");
        init.body = // Check between word boundaries instead of startsWith() due to the last
        // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type
        contentType && /\bapplication\/x-www-form-urlencoded\b/.test(contentType) ? new URLSearchParams(await request.text()) : await request.formData();
      }
      retry > 0 && await new Promise((resolve) => setTimeout(resolve, 5 ** retry * 10));
      let revalidation = window.__remixRevalidation, response = await fetch(url.href, init).catch((error) => {
        if (typeof revalidation == "number" && revalidation === window.__remixRevalidation && (error == null ? void 0 : error.name) === "TypeError" && retry < 3)
          return fetchData(request, routeId, retry + 1);
        throw error;
      });
      if (isErrorResponse(response)) {
        let data = await response.json(), error = new Error(data.message);
        return error.stack = data.stack, error;
      }
      return response;
    }
    var DEFERRED_VALUE_PLACEHOLDER_PREFIX = "__deferred_promise:";
    async function parseDeferredReadableStream(stream) {
      if (!stream)
        throw new Error("parseDeferredReadableStream requires stream argument");
      let deferredData, deferredResolvers = {};
      try {
        let sectionReader = readStreamSections(stream), initialSection = (await sectionReader.next()).value;
        if (!initialSection)
          throw new Error("no critical data");
        let criticalData = JSON.parse(initialSection);
        if (typeof criticalData == "object" && criticalData !== null)
          for (let [eventKey, value] of Object.entries(criticalData))
            typeof value != "string" || !value.startsWith(DEFERRED_VALUE_PLACEHOLDER_PREFIX) || (deferredData = deferredData || {}, deferredData[eventKey] = new Promise((resolve, reject) => {
              deferredResolvers[eventKey] = {
                resolve: (value2) => {
                  resolve(value2), delete deferredResolvers[eventKey];
                },
                reject: (error) => {
                  reject(error), delete deferredResolvers[eventKey];
                }
              };
            }));
        return (async () => {
          try {
            for await (let section of sectionReader) {
              let [event, ...sectionDataStrings] = section.split(":"), sectionDataString = sectionDataStrings.join(":"), data = JSON.parse(sectionDataString);
              if (event === "data")
                for (let [key, value] of Object.entries(data))
                  deferredResolvers[key] && deferredResolvers[key].resolve(value);
              else if (event === "error")
                for (let [key, value] of Object.entries(data)) {
                  let err = new Error(value.message);
                  err.stack = value.stack, deferredResolvers[key] && deferredResolvers[key].reject(err);
                }
            }
            for (let [key, resolver] of Object.entries(deferredResolvers))
              resolver.reject(new router.AbortedDeferredError(`Deferred ${key} will never be resolved`));
          } catch (error) {
            for (let resolver of Object.values(deferredResolvers))
              resolver.reject(error);
          }
        })(), new router.UNSAFE_DeferredData({
          ...criticalData,
          ...deferredData
        });
      } catch (error) {
        for (let resolver of Object.values(deferredResolvers))
          resolver.reject(error);
        throw error;
      }
    }
    async function* readStreamSections(stream) {
      let reader = stream.getReader(), buffer = [], sections = [], closed = !1, encoder = new TextEncoder(), decoder = new TextDecoder(), readStreamSection = async () => {
        if (sections.length > 0)
          return sections.shift();
        for (; !closed && sections.length === 0; ) {
          let chunk = await reader.read();
          if (chunk.done) {
            closed = !0;
            break;
          }
          buffer.push(chunk.value);
          try {
            let splitSections = decoder.decode(mergeArrays(...buffer)).split(`

`);
            if (splitSections.length >= 2 && (sections.push(...splitSections.slice(0, -1)), buffer = [encoder.encode(splitSections.slice(-1).join(`

`))]), sections.length > 0)
              break;
          } catch {
            continue;
          }
        }
        return sections.length > 0 || buffer.length > 0 && (sections = decoder.decode(mergeArrays(...buffer)).split(`

`).filter((s2) => s2), buffer = []), sections.shift();
      }, section = await readStreamSection();
      for (; section; )
        yield section, section = await readStreamSection();
    }
    function mergeArrays(...arrays) {
      let out = new Uint8Array(arrays.reduce((total, arr) => total + arr.length, 0)), offset = 0;
      for (let arr of arrays)
        out.set(arr, offset), offset += arr.length;
      return out;
    }
    exports.fetchData = fetchData;
    exports.isCatchResponse = isCatchResponse;
    exports.isDeferredResponse = isDeferredResponse;
    exports.isErrorResponse = isErrorResponse;
    exports.isRedirectResponse = isRedirectResponse;
    exports.parseDeferredReadableStream = parseDeferredReadableStream;
  }
});

// node_modules/@remix-run/react/dist/routes.js
var require_routes2 = __commonJS({
  "node_modules/@remix-run/react/dist/routes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var React5 = require_react(), reactRouterDom = require_main2(), routeModules = require_routeModules(), data = require_data2(), links2 = require_links(), invariant = require_invariant2(), components = require_components();
    function _interopNamespace(e2) {
      if (e2 && e2.__esModule)
        return e2;
      var n = /* @__PURE__ */ Object.create(null);
      return e2 && Object.keys(e2).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e2, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e2[k];
            }
          });
        }
      }), n.default = e2, Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React5);
    function groupRoutesByParentId(manifest) {
      let routes2 = {};
      return Object.values(manifest).forEach((route) => {
        let parentId = route.parentId || "";
        routes2[parentId] || (routes2[parentId] = []), routes2[parentId].push(route);
      }), routes2;
    }
    function createServerRoutes(manifest, routeModules2, future2, parentId = "", routesByParentId = groupRoutesByParentId(manifest)) {
      return (routesByParentId[parentId] || []).map((route) => {
        let hasErrorBoundary = future2.v2_errorBoundary === !0 ? route.id === "root" || route.hasErrorBoundary : route.id === "root" || route.hasCatchBoundary || route.hasErrorBoundary, dataRoute = {
          caseSensitive: route.caseSensitive,
          element: /* @__PURE__ */ React__namespace.createElement(components.RemixRoute, {
            id: route.id
          }),
          errorElement: hasErrorBoundary ? /* @__PURE__ */ React__namespace.createElement(components.RemixRouteError, {
            id: route.id
          }) : void 0,
          id: route.id,
          index: route.index,
          path: route.path,
          handle: routeModules2[route.id].handle
          // Note: we don't need loader/action/shouldRevalidate on these routes
          // since they're for a static render
        }, children = createServerRoutes(manifest, routeModules2, future2, route.id, routesByParentId);
        return children.length > 0 && (dataRoute.children = children), dataRoute;
      });
    }
    function createClientRoutes(manifest, routeModulesCache, future2, parentId = "", routesByParentId = groupRoutesByParentId(manifest), needsRevalidation) {
      return (routesByParentId[parentId] || []).map((route) => {
        let hasErrorBoundary = future2.v2_errorBoundary === !0 ? route.id === "root" || route.hasErrorBoundary : route.id === "root" || route.hasCatchBoundary || route.hasErrorBoundary, dataRoute = {
          caseSensitive: route.caseSensitive,
          element: /* @__PURE__ */ React__namespace.createElement(components.RemixRoute, {
            id: route.id
          }),
          errorElement: hasErrorBoundary ? /* @__PURE__ */ React__namespace.createElement(components.RemixRouteError, {
            id: route.id
          }) : void 0,
          id: route.id,
          index: route.index,
          path: route.path,
          // handle gets added in via useMatches since we aren't guaranteed to
          // have the route module available here
          handle: void 0,
          loader: createDataFunction(route, routeModulesCache, !1),
          action: createDataFunction(route, routeModulesCache, !0),
          shouldRevalidate: createShouldRevalidate(route, routeModulesCache, needsRevalidation)
        }, children = createClientRoutes(manifest, routeModulesCache, future2, route.id, routesByParentId, needsRevalidation);
        return children.length > 0 && (dataRoute.children = children), dataRoute;
      });
    }
    function createShouldRevalidate(route, routeModules2, needsRevalidation) {
      let handledRevalidation = !1;
      return function(arg) {
        let module3 = routeModules2[route.id];
        return invariant(module3, `Expected route module to be loaded for ${route.id}`), needsRevalidation !== void 0 && !handledRevalidation ? (handledRevalidation = !0, needsRevalidation.has(route.id)) : module3.shouldRevalidate ? module3.shouldRevalidate(arg) : arg.defaultShouldRevalidate;
      };
    }
    async function loadRouteModuleWithBlockingLinks(route, routeModules$1) {
      let routeModule = await routeModules.loadRouteModule(route, routeModules$1);
      return await links2.prefetchStyleLinks(routeModule), routeModule;
    }
    function createDataFunction(route, routeModules2, isAction) {
      return async ({
        request
      }) => {
        let routeModulePromise = loadRouteModuleWithBlockingLinks(route, routeModules2);
        try {
          if (isAction && !route.hasAction) {
            let msg = `Route "${route.id}" does not have an action, but you are trying to submit to it. To fix this, please add an \`action\` function to the route`;
            throw console.error(msg), new Error(msg);
          } else if (!isAction && !route.hasLoader)
            return null;
          let result = await data.fetchData(request, route.id);
          if (result instanceof Error)
            throw result;
          if (data.isRedirectResponse(result))
            throw getRedirect(result);
          if (data.isCatchResponse(result))
            throw result;
          return data.isDeferredResponse(result) && result.body ? await data.parseDeferredReadableStream(result.body) : result;
        } finally {
          await routeModulePromise;
        }
      };
    }
    function getRedirect(response) {
      let status = parseInt(response.headers.get("X-Remix-Status"), 10) || 302, url = response.headers.get("X-Remix-Redirect"), headers = {}, revalidate = response.headers.get("X-Remix-Revalidate");
      return revalidate && (headers["X-Remix-Revalidate"] = revalidate), reactRouterDom.redirect(url, {
        status,
        headers
      });
    }
    exports.createClientRoutes = createClientRoutes;
    exports.createServerRoutes = createServerRoutes;
  }
});

// node_modules/@remix-run/react/dist/browser.js
var require_browser = __commonJS({
  "node_modules/@remix-run/react/dist/browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var React5 = require_react(), reactRouterDom = require_main2(), components = require_components(), errorBoundaries = require_errorBoundaries(), errors = require_errors3(), routes2 = require_routes2();
    function _interopNamespace(e2) {
      if (e2 && e2.__esModule)
        return e2;
      var n = /* @__PURE__ */ Object.create(null);
      return e2 && Object.keys(e2).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e2, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e2[k];
            }
          });
        }
      }), n.default = e2, Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React5), router;
    function RemixBrowser(_props) {
      if (!router) {
        let routes$1 = routes2.createClientRoutes(window.__remixManifest.routes, window.__remixRouteModules, window.__remixContext.future), hydrationData = window.__remixContext.state;
        hydrationData && hydrationData.errors && (hydrationData = {
          ...hydrationData,
          errors: errors.deserializeErrors(hydrationData.errors)
        }), router = reactRouterDom.createBrowserRouter(routes$1, {
          hydrationData,
          future: {
            // Pass through the Remix future flag to avoid a v1 breaking change in
            // useNavigation() - users can control the casing via the flag in v1.
            // useFetcher still always uppercases in the back-compat layer in v1.
            // In v2 we can just always pass true here and remove the back-compat
            // layer
            v7_normalizeFormMethod: window.__remixContext.future.v2_normalizeFormMethod
          }
        });
      }
      let [location, setLocation] = React__namespace.useState(router.state.location);
      return React__namespace.useLayoutEffect(() => router.subscribe((newState) => {
        newState.location !== location && setLocation(newState.location);
      }), [location]), /* @__PURE__ */ React__namespace.createElement(components.RemixContext.Provider, {
        value: {
          manifest: window.__remixManifest,
          routeModules: window.__remixRouteModules,
          future: window.__remixContext.future
        }
      }, /* @__PURE__ */ React__namespace.createElement(errorBoundaries.RemixErrorBoundary, {
        location,
        component: errorBoundaries.RemixRootDefaultErrorBoundary
      }, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.RouterProvider, {
        router,
        fallbackElement: null
      })));
    }
    exports.RemixBrowser = RemixBrowser;
  }
});

// node_modules/@remix-run/react/dist/scroll-restoration.js
var require_scroll_restoration = __commonJS({
  "node_modules/@remix-run/react/dist/scroll-restoration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var _rollupPluginBabelHelpers = require_rollupPluginBabelHelpers(), React5 = require_react(), reactRouterDom = require_main2(), components = require_components();
    function _interopNamespace(e2) {
      if (e2 && e2.__esModule)
        return e2;
      var n = /* @__PURE__ */ Object.create(null);
      return e2 && Object.keys(e2).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e2, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e2[k];
            }
          });
        }
      }), n.default = e2, Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React5), STORAGE_KEY = "positions";
    function ScrollRestoration({
      getKey,
      ...props
    }) {
      let location = reactRouterDom.useLocation(), matches = components.useMatches();
      reactRouterDom.UNSAFE_useScrollRestoration({
        getKey,
        storageKey: STORAGE_KEY
      });
      let key = React__namespace.useMemo(
        () => {
          if (!getKey)
            return null;
          let userKey = getKey(location, matches);
          return userKey !== location.key ? userKey : null;
        },
        // Nah, we only need this the first time for the SSR render
        // eslint-disable-next-line react-hooks/exhaustive-deps
        []
      ), restoreScroll = ((STORAGE_KEY2, restoreKey) => {
        if (!window.history.state || !window.history.state.key) {
          let key2 = Math.random().toString(32).slice(2);
          window.history.replaceState({
            key: key2
          }, "");
        }
        try {
          let storedY = JSON.parse(sessionStorage.getItem(STORAGE_KEY2) || "{}")[restoreKey || window.history.state.key];
          typeof storedY == "number" && window.scrollTo(0, storedY);
        } catch (error) {
          console.error(error), sessionStorage.removeItem(STORAGE_KEY2);
        }
      }).toString();
      return /* @__PURE__ */ React__namespace.createElement("script", _rollupPluginBabelHelpers.extends({}, props, {
        suppressHydrationWarning: !0,
        dangerouslySetInnerHTML: {
          __html: `(${restoreScroll})(${JSON.stringify(STORAGE_KEY)}, ${JSON.stringify(key)})`
        }
      }));
    }
    exports.ScrollRestoration = ScrollRestoration;
  }
});

// node_modules/react-router-dom/server.js
var require_server2 = __commonJS({
  "node_modules/react-router-dom/server.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var React5 = require_react(), router = require_router_cjs(), reactRouter = require_main(), reactRouterDom = require_main2();
    function _interopNamespace(e2) {
      if (e2 && e2.__esModule)
        return e2;
      var n = /* @__PURE__ */ Object.create(null);
      return e2 && Object.keys(e2).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e2, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e2[k];
            }
          });
        }
      }), n.default = e2, Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React5);
    function StaticRouter({
      basename,
      children,
      location: locationProp = "/"
    }) {
      typeof locationProp == "string" && (locationProp = reactRouterDom.parsePath(locationProp));
      let action3 = router.Action.Pop, location = {
        pathname: locationProp.pathname || "/",
        search: locationProp.search || "",
        hash: locationProp.hash || "",
        state: locationProp.state || null,
        key: locationProp.key || "default"
      }, staticNavigator = getStatelessNavigator();
      return /* @__PURE__ */ React__namespace.createElement(reactRouterDom.Router, {
        basename,
        children,
        location,
        navigationType: action3,
        navigator: staticNavigator,
        static: !0
      });
    }
    function StaticRouterProvider({
      context,
      router: router$1,
      hydrate = !0,
      nonce
    }) {
      router$1 && context || router.UNSAFE_invariant(!1);
      let dataRouterContext = {
        router: router$1,
        navigator: getStatelessNavigator(),
        static: !0,
        staticContext: context,
        basename: context.basename || "/"
      }, hydrateScript = "";
      if (hydrate !== !1) {
        let data = {
          loaderData: context.loaderData,
          actionData: context.actionData,
          errors: serializeErrors(context.errors)
        };
        hydrateScript = `window.__staticRouterHydrationData = JSON.parse(${htmlEscape(JSON.stringify(JSON.stringify(data)))});`;
      }
      let {
        state
      } = dataRouterContext.router;
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.UNSAFE_DataRouterContext.Provider, {
        value: dataRouterContext
      }, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.UNSAFE_DataRouterStateContext.Provider, {
        value: state
      }, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.Router, {
        basename: dataRouterContext.basename,
        location: state.location,
        navigationType: state.historyAction,
        navigator: dataRouterContext.navigator,
        static: dataRouterContext.static
      }, /* @__PURE__ */ React__namespace.createElement(DataRoutes, {
        routes: router$1.routes,
        state
      })))), hydrateScript ? /* @__PURE__ */ React__namespace.createElement("script", {
        suppressHydrationWarning: !0,
        nonce,
        dangerouslySetInnerHTML: {
          __html: hydrateScript
        }
      }) : null);
    }
    function DataRoutes({
      routes: routes2,
      state
    }) {
      return reactRouter.UNSAFE_useRoutesImpl(routes2, void 0, state);
    }
    function serializeErrors(errors) {
      if (!errors)
        return null;
      let entries = Object.entries(errors), serialized = {};
      for (let [key, val] of entries)
        router.isRouteErrorResponse(val) ? serialized[key] = {
          ...val,
          __type: "RouteErrorResponse"
        } : val instanceof Error ? serialized[key] = {
          message: val.message,
          __type: "Error"
        } : serialized[key] = val;
      return serialized;
    }
    function getStatelessNavigator() {
      return {
        createHref,
        encodeLocation,
        push(to) {
          throw new Error(`You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)})\` somewhere in your app.`);
        },
        replace(to) {
          throw new Error(`You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)}, { replace: true })\` somewhere in your app.`);
        },
        go(delta) {
          throw new Error(`You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${delta})\` somewhere in your app.`);
        },
        back() {
          throw new Error("You cannot use navigator.back() on the server because it is a stateless environment.");
        },
        forward() {
          throw new Error("You cannot use navigator.forward() on the server because it is a stateless environment.");
        }
      };
    }
    function createStaticHandler(routes2, opts) {
      return router.createStaticHandler(routes2, {
        ...opts,
        mapRouteProperties: reactRouter.UNSAFE_mapRouteProperties
      });
    }
    function createStaticRouter(routes2, context) {
      let manifest = {}, dataRoutes = router.UNSAFE_convertRoutesToDataRoutes(routes2, reactRouter.UNSAFE_mapRouteProperties, void 0, manifest), matches = context.matches.map((match) => {
        let route = manifest[match.route.id] || match.route;
        return {
          ...match,
          route
        };
      }), msg = (method) => `You cannot use router.${method}() on the server because it is a stateless environment`;
      return {
        get basename() {
          return context.basename;
        },
        get state() {
          return {
            historyAction: router.Action.Pop,
            location: context.location,
            matches,
            loaderData: context.loaderData,
            actionData: context.actionData,
            errors: context.errors,
            initialized: !0,
            navigation: router.IDLE_NAVIGATION,
            restoreScrollPosition: null,
            preventScrollReset: !1,
            revalidation: "idle",
            fetchers: /* @__PURE__ */ new Map(),
            blockers: /* @__PURE__ */ new Map()
          };
        },
        get routes() {
          return dataRoutes;
        },
        initialize() {
          throw msg("initialize");
        },
        subscribe() {
          throw msg("subscribe");
        },
        enableScrollRestoration() {
          throw msg("enableScrollRestoration");
        },
        navigate() {
          throw msg("navigate");
        },
        fetch() {
          throw msg("fetch");
        },
        revalidate() {
          throw msg("revalidate");
        },
        createHref,
        encodeLocation,
        getFetcher() {
          return router.IDLE_FETCHER;
        },
        deleteFetcher() {
          throw msg("deleteFetcher");
        },
        dispose() {
          throw msg("dispose");
        },
        getBlocker() {
          return router.IDLE_BLOCKER;
        },
        deleteBlocker() {
          throw msg("deleteBlocker");
        },
        _internalFetchControllers: /* @__PURE__ */ new Map(),
        _internalActiveDeferreds: /* @__PURE__ */ new Map(),
        _internalSetRoutes() {
          throw msg("_internalSetRoutes");
        }
      };
    }
    function createHref(to) {
      return typeof to == "string" ? to : reactRouterDom.createPath(to);
    }
    function encodeLocation(to) {
      let path = typeof to == "string" ? reactRouterDom.parsePath(to) : to;
      return {
        pathname: path.pathname || "",
        search: path.search || "",
        hash: path.hash || ""
      };
    }
    var ESCAPE_LOOKUP = {
      "&": "\\u0026",
      ">": "\\u003e",
      "<": "\\u003c",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    }, ESCAPE_REGEX = /[&><\u2028\u2029]/g;
    function htmlEscape(str) {
      return str.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
    }
    exports.StaticRouter = StaticRouter;
    exports.StaticRouterProvider = StaticRouterProvider;
    exports.createStaticHandler = createStaticHandler;
    exports.createStaticRouter = createStaticRouter;
  }
});

// node_modules/@remix-run/react/dist/server.js
var require_server3 = __commonJS({
  "node_modules/@remix-run/react/dist/server.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var React5 = require_react(), server = require_server2(), components = require_components(), errorBoundaries = require_errorBoundaries(), routes2 = require_routes2();
    function _interopNamespace(e2) {
      if (e2 && e2.__esModule)
        return e2;
      var n = /* @__PURE__ */ Object.create(null);
      return e2 && Object.keys(e2).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e2, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e2[k];
            }
          });
        }
      }), n.default = e2, Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React5);
    function RemixServer2({
      context,
      url,
      abortDelay
    }) {
      typeof url == "string" && (url = new URL(url));
      let {
        manifest,
        routeModules,
        serverHandoffString
      } = context, routes$1 = routes2.createServerRoutes(manifest.routes, routeModules, context.future), router = server.createStaticRouter(routes$1, context.staticHandlerContext);
      return /* @__PURE__ */ React__namespace.createElement(components.RemixContext.Provider, {
        value: {
          manifest,
          routeModules,
          serverHandoffString,
          future: context.future,
          abortDelay
        }
      }, /* @__PURE__ */ React__namespace.createElement(errorBoundaries.RemixErrorBoundary, {
        location: router.state.location,
        component: errorBoundaries.RemixRootDefaultErrorBoundary
      }, /* @__PURE__ */ React__namespace.createElement(server.StaticRouterProvider, {
        router,
        context: context.staticHandlerContext,
        hydrate: !1
      })));
    }
    exports.RemixServer = RemixServer2;
  }
});

// node_modules/@remix-run/react/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@remix-run/react/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var browser = require_browser(), reactRouterDom = require_main2(), components = require_components(), errorBoundaries = require_errorBoundaries(), scrollRestoration = require_scroll_restoration(), server = require_server3();
    exports.RemixBrowser = browser.RemixBrowser;
    Object.defineProperty(exports, "Form", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.Form;
      }
    });
    Object.defineProperty(exports, "Outlet", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.Outlet;
      }
    });
    Object.defineProperty(exports, "isRouteErrorResponse", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.isRouteErrorResponse;
      }
    });
    Object.defineProperty(exports, "unstable_useBlocker", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.unstable_useBlocker;
      }
    });
    Object.defineProperty(exports, "unstable_usePrompt", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.unstable_usePrompt;
      }
    });
    Object.defineProperty(exports, "useAsyncError", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useAsyncError;
      }
    });
    Object.defineProperty(exports, "useAsyncValue", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useAsyncValue;
      }
    });
    Object.defineProperty(exports, "useBeforeUnload", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useBeforeUnload;
      }
    });
    Object.defineProperty(exports, "useFormAction", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useFormAction;
      }
    });
    Object.defineProperty(exports, "useHref", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useHref;
      }
    });
    Object.defineProperty(exports, "useLocation", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useLocation;
      }
    });
    Object.defineProperty(exports, "useMatch", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useMatch;
      }
    });
    Object.defineProperty(exports, "useNavigate", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useNavigate;
      }
    });
    Object.defineProperty(exports, "useNavigation", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useNavigation;
      }
    });
    Object.defineProperty(exports, "useNavigationType", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useNavigationType;
      }
    });
    Object.defineProperty(exports, "useOutlet", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useOutlet;
      }
    });
    Object.defineProperty(exports, "useOutletContext", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useOutletContext;
      }
    });
    Object.defineProperty(exports, "useParams", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useParams;
      }
    });
    Object.defineProperty(exports, "useResolvedPath", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useResolvedPath;
      }
    });
    Object.defineProperty(exports, "useRevalidator", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useRevalidator;
      }
    });
    Object.defineProperty(exports, "useRouteError", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useRouteError;
      }
    });
    Object.defineProperty(exports, "useRouteLoaderData", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useRouteLoaderData;
      }
    });
    Object.defineProperty(exports, "useSearchParams", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useSearchParams;
      }
    });
    Object.defineProperty(exports, "useSubmit", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useSubmit;
      }
    });
    exports.Await = components.Await;
    exports.Link = components.Link;
    exports.Links = components.Links;
    exports.LiveReload = components.LiveReload;
    exports.Meta = components.Meta;
    exports.NavLink = components.NavLink;
    exports.PrefetchPageLinks = components.PrefetchPageLinks;
    exports.Scripts = components.Scripts;
    exports.UNSAFE_RemixContext = components.RemixContext;
    exports.useActionData = components.useActionData;
    exports.useFetcher = components.useFetcher;
    exports.useFetchers = components.useFetchers;
    exports.useLoaderData = components.useLoaderData;
    exports.useMatches = components.useMatches;
    exports.useTransition = components.useTransition;
    exports.useCatch = errorBoundaries.useCatch;
    exports.ScrollRestoration = scrollRestoration.ScrollRestoration;
    exports.RemixServer = server.RemixServer;
  }
});

// node_modules/react-dom/cjs/react-dom-server-legacy.node.production.min.js
var require_react_dom_server_legacy_node_production_min = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server-legacy.node.production.min.js"(exports) {
    "use strict";
    var ea = require_react(), fa = require("stream"), n = Object.prototype.hasOwnProperty, ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, ia = {}, ja = {};
    function ka(a) {
      return n.call(ja, a) ? !0 : n.call(ia, a) ? !1 : ha.test(a) ? ja[a] = !0 : (ia[a] = !0, !1);
    }
    function q(a, b, c, d, f3, e2, g) {
      this.acceptsBooleans = b === 2 || b === 3 || b === 4, this.attributeName = d, this.attributeNamespace = f3, this.mustUseProperty = c, this.propertyName = a, this.type = b, this.sanitizeURL = e2, this.removeEmptyString = g;
    }
    var r2 = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
      r2[a] = new q(a, 0, !1, a, null, !1, !1);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
      var b = a[0];
      r2[b] = new q(b, 1, !1, a[1], null, !1, !1);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
      r2[a] = new q(a, 2, !1, a.toLowerCase(), null, !1, !1);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
      r2[a] = new q(a, 2, !1, a, null, !1, !1);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
      r2[a] = new q(a, 3, !1, a.toLowerCase(), null, !1, !1);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a) {
      r2[a] = new q(a, 3, !0, a, null, !1, !1);
    });
    ["capture", "download"].forEach(function(a) {
      r2[a] = new q(a, 4, !1, a, null, !1, !1);
    });
    ["cols", "rows", "size", "span"].forEach(function(a) {
      r2[a] = new q(a, 6, !1, a, null, !1, !1);
    });
    ["rowSpan", "start"].forEach(function(a) {
      r2[a] = new q(a, 5, !1, a.toLowerCase(), null, !1, !1);
    });
    var la = /[\-:]([a-z])/g;
    function ma(a) {
      return a[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
      var b = a.replace(
        la,
        ma
      );
      r2[b] = new q(b, 1, !1, a, null, !1, !1);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
      var b = a.replace(la, ma);
      r2[b] = new q(b, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
      var b = a.replace(la, ma);
      r2[b] = new q(b, 1, !1, a, "http://www.w3.org/XML/1998/namespace", !1, !1);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a) {
      r2[a] = new q(a, 1, !1, a.toLowerCase(), null, !1, !1);
    });
    r2.xlinkHref = new q("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
    ["src", "href", "action", "formAction"].forEach(function(a) {
      r2[a] = new q(a, 1, !1, a.toLowerCase(), null, !0, !0);
    });
    var t2 = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    }, na = ["Webkit", "ms", "Moz", "O"];
    Object.keys(t2).forEach(function(a) {
      na.forEach(function(b) {
        b = b + a.charAt(0).toUpperCase() + a.substring(1), t2[b] = t2[a];
      });
    });
    var oa = /["'&<>]/;
    function u(a) {
      if (typeof a == "boolean" || typeof a == "number")
        return "" + a;
      a = "" + a;
      var b = oa.exec(a);
      if (b) {
        var c = "", d, f3 = 0;
        for (d = b.index; d < a.length; d++) {
          switch (a.charCodeAt(d)) {
            case 34:
              b = "&quot;";
              break;
            case 38:
              b = "&amp;";
              break;
            case 39:
              b = "&#x27;";
              break;
            case 60:
              b = "&lt;";
              break;
            case 62:
              b = "&gt;";
              break;
            default:
              continue;
          }
          f3 !== d && (c += a.substring(f3, d)), f3 = d + 1, c += b;
        }
        a = f3 !== d ? c + a.substring(f3, d) : c;
      }
      return a;
    }
    var pa = /([A-Z])/g, qa = /^ms-/, ra = Array.isArray;
    function v(a, b) {
      return { insertionMode: a, selectedValue: b };
    }
    function sa(a, b, c) {
      switch (b) {
        case "select":
          return v(1, c.value != null ? c.value : c.defaultValue);
        case "svg":
          return v(2, null);
        case "math":
          return v(3, null);
        case "foreignObject":
          return v(1, null);
        case "table":
          return v(4, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return v(5, null);
        case "colgroup":
          return v(7, null);
        case "tr":
          return v(6, null);
      }
      return 4 <= a.insertionMode || a.insertionMode === 0 ? v(1, null) : a;
    }
    var ta = /* @__PURE__ */ new Map();
    function ua(a, b, c) {
      if (typeof c != "object")
        throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      b = !0;
      for (var d in c)
        if (n.call(c, d)) {
          var f3 = c[d];
          if (f3 != null && typeof f3 != "boolean" && f3 !== "") {
            if (d.indexOf("--") === 0) {
              var e2 = u(d);
              f3 = u(("" + f3).trim());
            } else {
              e2 = d;
              var g = ta.get(e2);
              g !== void 0 || (g = u(e2.replace(pa, "-$1").toLowerCase().replace(qa, "-ms-")), ta.set(e2, g)), e2 = g, f3 = typeof f3 == "number" ? f3 === 0 || n.call(
                t2,
                d
              ) ? "" + f3 : f3 + "px" : u(("" + f3).trim());
            }
            b ? (b = !1, a.push(' style="', e2, ":", f3)) : a.push(";", e2, ":", f3);
          }
        }
      b || a.push('"');
    }
    function w(a, b, c, d) {
      switch (c) {
        case "style":
          ua(a, b, d);
          return;
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (!(2 < c.length) || c[0] !== "o" && c[0] !== "O" || c[1] !== "n" && c[1] !== "N") {
        if (b = r2.hasOwnProperty(c) ? r2[c] : null, b !== null) {
          switch (typeof d) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!b.acceptsBooleans)
                return;
          }
          switch (c = b.attributeName, b.type) {
            case 3:
              d && a.push(" ", c, '=""');
              break;
            case 4:
              d === !0 ? a.push(" ", c, '=""') : d !== !1 && a.push(" ", c, '="', u(d), '"');
              break;
            case 5:
              isNaN(d) || a.push(" ", c, '="', u(d), '"');
              break;
            case 6:
              !isNaN(d) && 1 <= d && a.push(" ", c, '="', u(d), '"');
              break;
            default:
              b.sanitizeURL && (d = "" + d), a.push(" ", c, '="', u(d), '"');
          }
        } else if (ka(c)) {
          switch (typeof d) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (b = c.toLowerCase().slice(0, 5), b !== "data-" && b !== "aria-")
                return;
          }
          a.push(" ", c, '="', u(d), '"');
        }
      }
    }
    function x2(a, b, c) {
      if (b != null) {
        if (c != null)
          throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof b != "object" || !("__html" in b))
          throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        b = b.__html, b != null && a.push("" + b);
      }
    }
    function va(a) {
      var b = "";
      return ea.Children.forEach(a, function(a2) {
        a2 != null && (b += a2);
      }), b;
    }
    function wa(a, b, c, d) {
      a.push(z(c));
      var f3 = c = null, e2;
      for (e2 in b)
        if (n.call(b, e2)) {
          var g = b[e2];
          if (g != null)
            switch (e2) {
              case "children":
                c = g;
                break;
              case "dangerouslySetInnerHTML":
                f3 = g;
                break;
              default:
                w(a, d, e2, g);
            }
        }
      return a.push(">"), x2(a, f3, c), typeof c == "string" ? (a.push(u(c)), null) : c;
    }
    var xa = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, ya = /* @__PURE__ */ new Map();
    function z(a) {
      var b = ya.get(a);
      if (b === void 0) {
        if (!xa.test(a))
          throw Error("Invalid tag: " + a);
        b = "<" + a, ya.set(a, b);
      }
      return b;
    }
    function za(a, b, c, d, f3) {
      switch (b) {
        case "select":
          a.push(z("select"));
          var e2 = null, g = null;
          for (l in c)
            if (n.call(c, l)) {
              var h2 = c[l];
              if (h2 != null)
                switch (l) {
                  case "children":
                    e2 = h2;
                    break;
                  case "dangerouslySetInnerHTML":
                    g = h2;
                    break;
                  case "defaultValue":
                  case "value":
                    break;
                  default:
                    w(a, d, l, h2);
                }
            }
          return a.push(">"), x2(a, g, e2), e2;
        case "option":
          g = f3.selectedValue, a.push(z("option"));
          var k = h2 = null, m2 = null, l = null;
          for (e2 in c)
            if (n.call(c, e2)) {
              var p = c[e2];
              if (p != null)
                switch (e2) {
                  case "children":
                    h2 = p;
                    break;
                  case "selected":
                    m2 = p;
                    break;
                  case "dangerouslySetInnerHTML":
                    l = p;
                    break;
                  case "value":
                    k = p;
                  default:
                    w(a, d, e2, p);
                }
            }
          if (g != null)
            if (c = k !== null ? "" + k : va(h2), ra(g)) {
              for (d = 0; d < g.length; d++)
                if ("" + g[d] === c) {
                  a.push(' selected=""');
                  break;
                }
            } else
              "" + g === c && a.push(' selected=""');
          else
            m2 && a.push(' selected=""');
          return a.push(">"), x2(a, l, h2), h2;
        case "textarea":
          a.push(z("textarea")), l = g = e2 = null;
          for (h2 in c)
            if (n.call(c, h2) && (k = c[h2], k != null))
              switch (h2) {
                case "children":
                  l = k;
                  break;
                case "value":
                  e2 = k;
                  break;
                case "defaultValue":
                  g = k;
                  break;
                case "dangerouslySetInnerHTML":
                  throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                default:
                  w(a, d, h2, k);
              }
          if (e2 === null && g !== null && (e2 = g), a.push(">"), l != null) {
            if (e2 != null)
              throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (ra(l) && 1 < l.length)
              throw Error("<textarea> can only have at most one child.");
            e2 = "" + l;
          }
          return typeof e2 == "string" && e2[0] === `
` && a.push(`
`), e2 !== null && a.push(u("" + e2)), null;
        case "input":
          a.push(z("input")), k = l = h2 = e2 = null;
          for (g in c)
            if (n.call(c, g) && (m2 = c[g], m2 != null))
              switch (g) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                case "defaultChecked":
                  k = m2;
                  break;
                case "defaultValue":
                  h2 = m2;
                  break;
                case "checked":
                  l = m2;
                  break;
                case "value":
                  e2 = m2;
                  break;
                default:
                  w(a, d, g, m2);
              }
          return l !== null ? w(a, d, "checked", l) : k !== null && w(a, d, "checked", k), e2 !== null ? w(a, d, "value", e2) : h2 !== null && w(a, d, "value", h2), a.push("/>"), null;
        case "menuitem":
          a.push(z("menuitem"));
          for (var B in c)
            if (n.call(c, B) && (e2 = c[B], e2 != null))
              switch (B) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
                default:
                  w(
                    a,
                    d,
                    B,
                    e2
                  );
              }
          return a.push(">"), null;
        case "title":
          a.push(z("title")), e2 = null;
          for (p in c)
            if (n.call(c, p) && (g = c[p], g != null))
              switch (p) {
                case "children":
                  e2 = g;
                  break;
                case "dangerouslySetInnerHTML":
                  throw Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
                default:
                  w(a, d, p, g);
              }
          return a.push(">"), e2;
        case "listing":
        case "pre":
          a.push(z(b)), g = e2 = null;
          for (k in c)
            if (n.call(c, k) && (h2 = c[k], h2 != null))
              switch (k) {
                case "children":
                  e2 = h2;
                  break;
                case "dangerouslySetInnerHTML":
                  g = h2;
                  break;
                default:
                  w(a, d, k, h2);
              }
          if (a.push(">"), g != null) {
            if (e2 != null)
              throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            if (typeof g != "object" || !("__html" in g))
              throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            c = g.__html, c != null && (typeof c == "string" && 0 < c.length && c[0] === `
` ? a.push(`
`, c) : a.push("" + c));
          }
          return typeof e2 == "string" && e2[0] === `
` && a.push(`
`), e2;
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          a.push(z(b));
          for (var C in c)
            if (n.call(c, C) && (e2 = c[C], e2 != null))
              switch (C) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(b + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                default:
                  w(a, d, C, e2);
              }
          return a.push("/>"), null;
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return wa(a, c, b, d);
        case "html":
          return f3.insertionMode === 0 && a.push("<!DOCTYPE html>"), wa(a, c, b, d);
        default:
          if (b.indexOf("-") === -1 && typeof c.is != "string")
            return wa(a, c, b, d);
          a.push(z(b)), g = e2 = null;
          for (m2 in c)
            if (n.call(c, m2) && (h2 = c[m2], h2 != null))
              switch (m2) {
                case "children":
                  e2 = h2;
                  break;
                case "dangerouslySetInnerHTML":
                  g = h2;
                  break;
                case "style":
                  ua(a, d, h2);
                  break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                  break;
                default:
                  ka(m2) && typeof h2 != "function" && typeof h2 != "symbol" && a.push(" ", m2, '="', u(h2), '"');
              }
          return a.push(">"), x2(a, g, e2), e2;
      }
    }
    function Aa(a, b, c) {
      if (a.push('<!--$?--><template id="'), c === null)
        throw Error("An ID must have been assigned before we can complete the boundary.");
      return a.push(c), a.push('"></template>');
    }
    function Ba(a, b, c, d) {
      switch (c.insertionMode) {
        case 0:
        case 1:
          return a.push('<div hidden id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        case 2:
          return a.push('<svg aria-hidden="true" style="display:none" id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        case 3:
          return a.push('<math aria-hidden="true" style="display:none" id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        case 4:
          return a.push('<table hidden id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        case 5:
          return a.push('<table hidden><tbody id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        case 6:
          return a.push('<table hidden><tr id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        case 7:
          return a.push('<table hidden><colgroup id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        default:
          throw Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function Ca(a, b) {
      switch (b.insertionMode) {
        case 0:
        case 1:
          return a.push("</div>");
        case 2:
          return a.push("</svg>");
        case 3:
          return a.push("</math>");
        case 4:
          return a.push("</table>");
        case 5:
          return a.push("</tbody></table>");
        case 6:
          return a.push("</tr></table>");
        case 7:
          return a.push("</colgroup></table>");
        default:
          throw Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var Da = /[<\u2028\u2029]/g;
    function Ea(a) {
      return JSON.stringify(a).replace(Da, function(a2) {
        switch (a2) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    function Fa(a, b) {
      return b = b === void 0 ? "" : b, { bootstrapChunks: [], startInlineScript: "<script>", placeholderPrefix: b + "P:", segmentPrefix: b + "S:", boundaryPrefix: b + "B:", idPrefix: b, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1, generateStaticMarkup: a };
    }
    function Ga() {
      return { insertionMode: 1, selectedValue: null };
    }
    function Ha(a, b, c, d) {
      return c.generateStaticMarkup ? (a.push(u(b)), !1) : (b === "" ? a = d : (d && a.push("<!-- -->"), a.push(u(b)), a = !0), a);
    }
    var A2 = Object.assign, Ia = Symbol.for("react.element"), Ja = Symbol.for("react.portal"), Ka = Symbol.for("react.fragment"), La = Symbol.for("react.strict_mode"), Ma = Symbol.for("react.profiler"), Na = Symbol.for("react.provider"), Oa = Symbol.for("react.context"), Pa = Symbol.for("react.forward_ref"), Qa = Symbol.for("react.suspense"), Ra = Symbol.for("react.suspense_list"), Sa = Symbol.for("react.memo"), Ta = Symbol.for("react.lazy"), Ua = Symbol.for("react.scope"), Va = Symbol.for("react.debug_trace_mode"), Wa = Symbol.for("react.legacy_hidden"), Xa = Symbol.for("react.default_value"), Ya = Symbol.iterator;
    function Za(a) {
      if (a == null)
        return null;
      if (typeof a == "function")
        return a.displayName || a.name || null;
      if (typeof a == "string")
        return a;
      switch (a) {
        case Ka:
          return "Fragment";
        case Ja:
          return "Portal";
        case Ma:
          return "Profiler";
        case La:
          return "StrictMode";
        case Qa:
          return "Suspense";
        case Ra:
          return "SuspenseList";
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case Oa:
            return (a.displayName || "Context") + ".Consumer";
          case Na:
            return (a._context.displayName || "Context") + ".Provider";
          case Pa:
            var b = a.render;
            return a = a.displayName, a || (a = b.displayName || b.name || "", a = a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef"), a;
          case Sa:
            return b = a.displayName || null, b !== null ? b : Za(a.type) || "Memo";
          case Ta:
            b = a._payload, a = a._init;
            try {
              return Za(a(b));
            } catch {
            }
        }
      return null;
    }
    var $a = {};
    function ab(a, b) {
      if (a = a.contextTypes, !a)
        return $a;
      var c = {}, d;
      for (d in a)
        c[d] = b[d];
      return c;
    }
    var D = null;
    function E(a, b) {
      if (a !== b) {
        a.context._currentValue2 = a.parentValue, a = a.parent;
        var c = b.parent;
        if (a === null) {
          if (c !== null)
            throw Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (c === null)
            throw Error("The stacks must reach the root at the same time. This is a bug in React.");
          E(a, c);
        }
        b.context._currentValue2 = b.value;
      }
    }
    function bb(a) {
      a.context._currentValue2 = a.parentValue, a = a.parent, a !== null && bb(a);
    }
    function cb(a) {
      var b = a.parent;
      b !== null && cb(b), a.context._currentValue2 = a.value;
    }
    function db(a, b) {
      if (a.context._currentValue2 = a.parentValue, a = a.parent, a === null)
        throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      a.depth === b.depth ? E(a, b) : db(a, b);
    }
    function eb(a, b) {
      var c = b.parent;
      if (c === null)
        throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      a.depth === c.depth ? E(a, c) : eb(a, c), b.context._currentValue2 = b.value;
    }
    function F2(a) {
      var b = D;
      b !== a && (b === null ? cb(a) : a === null ? bb(b) : b.depth === a.depth ? E(b, a) : b.depth > a.depth ? db(b, a) : eb(b, a), D = a);
    }
    var fb = { isMounted: function() {
      return !1;
    }, enqueueSetState: function(a, b) {
      a = a._reactInternals, a.queue !== null && a.queue.push(b);
    }, enqueueReplaceState: function(a, b) {
      a = a._reactInternals, a.replace = !0, a.queue = [b];
    }, enqueueForceUpdate: function() {
    } };
    function gb(a, b, c, d) {
      var f3 = a.state !== void 0 ? a.state : null;
      a.updater = fb, a.props = c, a.state = f3;
      var e2 = { queue: [], replace: !1 };
      a._reactInternals = e2;
      var g = b.contextType;
      if (a.context = typeof g == "object" && g !== null ? g._currentValue2 : d, g = b.getDerivedStateFromProps, typeof g == "function" && (g = g(c, f3), f3 = g == null ? f3 : A2({}, f3, g), a.state = f3), typeof b.getDerivedStateFromProps != "function" && typeof a.getSnapshotBeforeUpdate != "function" && (typeof a.UNSAFE_componentWillMount == "function" || typeof a.componentWillMount == "function"))
        if (b = a.state, typeof a.componentWillMount == "function" && a.componentWillMount(), typeof a.UNSAFE_componentWillMount == "function" && a.UNSAFE_componentWillMount(), b !== a.state && fb.enqueueReplaceState(a, a.state, null), e2.queue !== null && 0 < e2.queue.length)
          if (b = e2.queue, g = e2.replace, e2.queue = null, e2.replace = !1, g && b.length === 1)
            a.state = b[0];
          else {
            for (e2 = g ? b[0] : a.state, f3 = !0, g = g ? 1 : 0; g < b.length; g++) {
              var h2 = b[g];
              h2 = typeof h2 == "function" ? h2.call(a, e2, c, d) : h2, h2 != null && (f3 ? (f3 = !1, e2 = A2({}, e2, h2)) : A2(e2, h2));
            }
            a.state = e2;
          }
        else
          e2.queue = null;
    }
    var hb = { id: 1, overflow: "" };
    function ib(a, b, c) {
      var d = a.id;
      a = a.overflow;
      var f3 = 32 - G(d) - 1;
      d &= ~(1 << f3), c += 1;
      var e2 = 32 - G(b) + f3;
      if (30 < e2) {
        var g = f3 - f3 % 5;
        return e2 = (d & (1 << g) - 1).toString(32), d >>= g, f3 -= g, { id: 1 << 32 - G(b) + f3 | c << f3 | d, overflow: e2 + a };
      }
      return { id: 1 << e2 | c << f3 | d, overflow: a };
    }
    var G = Math.clz32 ? Math.clz32 : jb, kb = Math.log, lb = Math.LN2;
    function jb(a) {
      return a >>>= 0, a === 0 ? 32 : 31 - (kb(a) / lb | 0) | 0;
    }
    function mb(a, b) {
      return a === b && (a !== 0 || 1 / a === 1 / b) || a !== a && b !== b;
    }
    var nb = typeof Object.is == "function" ? Object.is : mb, H = null, ob = null, I = null, J = null, K = !1, L = !1, M = 0, N = null, O = 0;
    function P() {
      if (H === null)
        throw Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return H;
    }
    function rb() {
      if (0 < O)
        throw Error("Rendered more hooks than during the previous render");
      return { memoizedState: null, queue: null, next: null };
    }
    function sb() {
      return J === null ? I === null ? (K = !1, I = J = rb()) : (K = !0, J = I) : J.next === null ? (K = !1, J = J.next = rb()) : (K = !0, J = J.next), J;
    }
    function tb() {
      ob = H = null, L = !1, I = null, O = 0, J = N = null;
    }
    function ub(a, b) {
      return typeof b == "function" ? b(a) : b;
    }
    function vb(a, b, c) {
      if (H = P(), J = sb(), K) {
        var d = J.queue;
        if (b = d.dispatch, N !== null && (c = N.get(d), c !== void 0)) {
          N.delete(d), d = J.memoizedState;
          do
            d = a(d, c.action), c = c.next;
          while (c !== null);
          return J.memoizedState = d, [d, b];
        }
        return [J.memoizedState, b];
      }
      return a = a === ub ? typeof b == "function" ? b() : b : c !== void 0 ? c(b) : b, J.memoizedState = a, a = J.queue = { last: null, dispatch: null }, a = a.dispatch = wb.bind(null, H, a), [J.memoizedState, a];
    }
    function xb(a, b) {
      if (H = P(), J = sb(), b = b === void 0 ? null : b, J !== null) {
        var c = J.memoizedState;
        if (c !== null && b !== null) {
          var d = c[1];
          a:
            if (d === null)
              d = !1;
            else {
              for (var f3 = 0; f3 < d.length && f3 < b.length; f3++)
                if (!nb(b[f3], d[f3])) {
                  d = !1;
                  break a;
                }
              d = !0;
            }
          if (d)
            return c[0];
        }
      }
      return a = a(), J.memoizedState = [a, b], a;
    }
    function wb(a, b, c) {
      if (25 <= O)
        throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (a === H)
        if (L = !0, a = { action: c, next: null }, N === null && (N = /* @__PURE__ */ new Map()), c = N.get(b), c === void 0)
          N.set(b, a);
        else {
          for (b = c; b.next !== null; )
            b = b.next;
          b.next = a;
        }
    }
    function yb() {
      throw Error("startTransition cannot be called during server rendering.");
    }
    function Q() {
    }
    var zb = { readContext: function(a) {
      return a._currentValue2;
    }, useContext: function(a) {
      return P(), a._currentValue2;
    }, useMemo: xb, useReducer: vb, useRef: function(a) {
      H = P(), J = sb();
      var b = J.memoizedState;
      return b === null ? (a = { current: a }, J.memoizedState = a) : b;
    }, useState: function(a) {
      return vb(ub, a);
    }, useInsertionEffect: Q, useLayoutEffect: function() {
    }, useCallback: function(a, b) {
      return xb(function() {
        return a;
      }, b);
    }, useImperativeHandle: Q, useEffect: Q, useDebugValue: Q, useDeferredValue: function(a) {
      return P(), a;
    }, useTransition: function() {
      return P(), [!1, yb];
    }, useId: function() {
      var a = ob.treeContext, b = a.overflow;
      a = a.id, a = (a & ~(1 << 32 - G(a) - 1)).toString(32) + b;
      var c = R;
      if (c === null)
        throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      return b = M++, a = ":" + c.idPrefix + "R" + a, 0 < b && (a += "H" + b.toString(32)), a + ":";
    }, useMutableSource: function(a, b) {
      return P(), b(a._source);
    }, useSyncExternalStore: function(a, b, c) {
      if (c === void 0)
        throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return c();
    } }, R = null, Ab = ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
    function Bb(a) {
      return console.error(a), null;
    }
    function S2() {
    }
    function Cb(a, b, c, d, f3, e2, g, h2, k) {
      var m2 = [], l = /* @__PURE__ */ new Set();
      return b = { destination: null, responseState: b, progressiveChunkSize: d === void 0 ? 12800 : d, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: l, pingedTasks: m2, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: f3 === void 0 ? Bb : f3, onAllReady: e2 === void 0 ? S2 : e2, onShellReady: g === void 0 ? S2 : g, onShellError: h2 === void 0 ? S2 : h2, onFatalError: k === void 0 ? S2 : k }, c = T(b, 0, null, c, !1, !1), c.parentFlushed = !0, a = Db(b, a, null, c, l, $a, null, hb), m2.push(a), b;
    }
    function Db(a, b, c, d, f3, e2, g, h2) {
      a.allPendingTasks++, c === null ? a.pendingRootTasks++ : c.pendingTasks++;
      var k = { node: b, ping: function() {
        var b2 = a.pingedTasks;
        b2.push(k), b2.length === 1 && Eb(a);
      }, blockedBoundary: c, blockedSegment: d, abortSet: f3, legacyContext: e2, context: g, treeContext: h2 };
      return f3.add(k), k;
    }
    function T(a, b, c, d, f3, e2) {
      return { status: 0, id: -1, index: b, parentFlushed: !1, chunks: [], children: [], formatContext: d, boundary: c, lastPushedText: f3, textEmbedded: e2 };
    }
    function U(a, b) {
      if (a = a.onError(b), a != null && typeof a != "string")
        throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof a + '" instead');
      return a;
    }
    function V(a, b) {
      var c = a.onShellError;
      c(b), c = a.onFatalError, c(b), a.destination !== null ? (a.status = 2, a.destination.destroy(b)) : (a.status = 1, a.fatalError = b);
    }
    function Fb(a, b, c, d, f3) {
      for (H = {}, ob = b, M = 0, a = c(d, f3); L; )
        L = !1, M = 0, O += 1, J = null, a = c(d, f3);
      return tb(), a;
    }
    function Gb(a, b, c, d) {
      var f3 = c.render(), e2 = d.childContextTypes;
      if (e2 != null) {
        var g = b.legacyContext;
        if (typeof c.getChildContext != "function")
          d = g;
        else {
          c = c.getChildContext();
          for (var h2 in c)
            if (!(h2 in e2))
              throw Error((Za(d) || "Unknown") + '.getChildContext(): key "' + h2 + '" is not defined in childContextTypes.');
          d = A2({}, g, c);
        }
        b.legacyContext = d, W(a, b, f3), b.legacyContext = g;
      } else
        W(a, b, f3);
    }
    function Hb(a, b) {
      if (a && a.defaultProps) {
        b = A2({}, b), a = a.defaultProps;
        for (var c in a)
          b[c] === void 0 && (b[c] = a[c]);
        return b;
      }
      return b;
    }
    function Ib(a, b, c, d, f3) {
      if (typeof c == "function")
        if (c.prototype && c.prototype.isReactComponent) {
          f3 = ab(c, b.legacyContext);
          var e2 = c.contextType;
          e2 = new c(d, typeof e2 == "object" && e2 !== null ? e2._currentValue2 : f3), gb(e2, c, d, f3), Gb(a, b, e2, c);
        } else {
          e2 = ab(c, b.legacyContext), f3 = Fb(a, b, c, d, e2);
          var g = M !== 0;
          if (typeof f3 == "object" && f3 !== null && typeof f3.render == "function" && f3.$$typeof === void 0)
            gb(f3, c, d, e2), Gb(a, b, f3, c);
          else if (g) {
            d = b.treeContext, b.treeContext = ib(d, 1, 0);
            try {
              W(a, b, f3);
            } finally {
              b.treeContext = d;
            }
          } else
            W(a, b, f3);
        }
      else if (typeof c == "string") {
        switch (f3 = b.blockedSegment, e2 = za(f3.chunks, c, d, a.responseState, f3.formatContext), f3.lastPushedText = !1, g = f3.formatContext, f3.formatContext = sa(g, c, d), Jb(a, b, e2), f3.formatContext = g, c) {
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "input":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
            break;
          default:
            f3.chunks.push("</", c, ">");
        }
        f3.lastPushedText = !1;
      } else {
        switch (c) {
          case Wa:
          case Va:
          case La:
          case Ma:
          case Ka:
            W(a, b, d.children);
            return;
          case Ra:
            W(a, b, d.children);
            return;
          case Ua:
            throw Error("ReactDOMServer does not yet support scope components.");
          case Qa:
            a: {
              c = b.blockedBoundary, f3 = b.blockedSegment, e2 = d.fallback, d = d.children, g = /* @__PURE__ */ new Set();
              var h2 = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: g, errorDigest: null }, k = T(a, f3.chunks.length, h2, f3.formatContext, !1, !1);
              f3.children.push(k), f3.lastPushedText = !1;
              var m2 = T(a, 0, null, f3.formatContext, !1, !1);
              m2.parentFlushed = !0, b.blockedBoundary = h2, b.blockedSegment = m2;
              try {
                if (Jb(a, b, d), a.responseState.generateStaticMarkup || m2.lastPushedText && m2.textEmbedded && m2.chunks.push("<!-- -->"), m2.status = 1, X(h2, m2), h2.pendingTasks === 0)
                  break a;
              } catch (l) {
                m2.status = 4, h2.forceClientRender = !0, h2.errorDigest = U(a, l);
              } finally {
                b.blockedBoundary = c, b.blockedSegment = f3;
              }
              b = Db(a, e2, c, k, g, b.legacyContext, b.context, b.treeContext), a.pingedTasks.push(b);
            }
            return;
        }
        if (typeof c == "object" && c !== null)
          switch (c.$$typeof) {
            case Pa:
              if (d = Fb(a, b, c.render, d, f3), M !== 0) {
                c = b.treeContext, b.treeContext = ib(c, 1, 0);
                try {
                  W(a, b, d);
                } finally {
                  b.treeContext = c;
                }
              } else
                W(a, b, d);
              return;
            case Sa:
              c = c.type, d = Hb(c, d), Ib(a, b, c, d, f3);
              return;
            case Na:
              if (f3 = d.children, c = c._context, d = d.value, e2 = c._currentValue2, c._currentValue2 = d, g = D, D = d = { parent: g, depth: g === null ? 0 : g.depth + 1, context: c, parentValue: e2, value: d }, b.context = d, W(a, b, f3), a = D, a === null)
                throw Error("Tried to pop a Context at the root of the app. This is a bug in React.");
              d = a.parentValue, a.context._currentValue2 = d === Xa ? a.context._defaultValue : d, a = D = a.parent, b.context = a;
              return;
            case Oa:
              d = d.children, d = d(c._currentValue2), W(a, b, d);
              return;
            case Ta:
              f3 = c._init, c = f3(c._payload), d = Hb(c, d), Ib(a, b, c, d, void 0);
              return;
          }
        throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((c == null ? c : typeof c) + "."));
      }
    }
    function W(a, b, c) {
      if (b.node = c, typeof c == "object" && c !== null) {
        switch (c.$$typeof) {
          case Ia:
            Ib(a, b, c.type, c.props, c.ref);
            return;
          case Ja:
            throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case Ta:
            var d = c._init;
            c = d(c._payload), W(a, b, c);
            return;
        }
        if (ra(c)) {
          Kb(a, b, c);
          return;
        }
        if (c === null || typeof c != "object" ? d = null : (d = Ya && c[Ya] || c["@@iterator"], d = typeof d == "function" ? d : null), d && (d = d.call(c))) {
          if (c = d.next(), !c.done) {
            var f3 = [];
            do
              f3.push(c.value), c = d.next();
            while (!c.done);
            Kb(a, b, f3);
          }
          return;
        }
        throw a = Object.prototype.toString.call(c), Error("Objects are not valid as a React child (found: " + (a === "[object Object]" ? "object with keys {" + Object.keys(c).join(", ") + "}" : a) + "). If you meant to render a collection of children, use an array instead.");
      }
      typeof c == "string" ? (d = b.blockedSegment, d.lastPushedText = Ha(b.blockedSegment.chunks, c, a.responseState, d.lastPushedText)) : typeof c == "number" && (d = b.blockedSegment, d.lastPushedText = Ha(
        b.blockedSegment.chunks,
        "" + c,
        a.responseState,
        d.lastPushedText
      ));
    }
    function Kb(a, b, c) {
      for (var d = c.length, f3 = 0; f3 < d; f3++) {
        var e2 = b.treeContext;
        b.treeContext = ib(e2, d, f3);
        try {
          Jb(a, b, c[f3]);
        } finally {
          b.treeContext = e2;
        }
      }
    }
    function Jb(a, b, c) {
      var d = b.blockedSegment.formatContext, f3 = b.legacyContext, e2 = b.context;
      try {
        return W(a, b, c);
      } catch (k) {
        if (tb(), typeof k == "object" && k !== null && typeof k.then == "function") {
          c = k;
          var g = b.blockedSegment, h2 = T(a, g.chunks.length, null, g.formatContext, g.lastPushedText, !0);
          g.children.push(h2), g.lastPushedText = !1, a = Db(a, b.node, b.blockedBoundary, h2, b.abortSet, b.legacyContext, b.context, b.treeContext).ping, c.then(a, a), b.blockedSegment.formatContext = d, b.legacyContext = f3, b.context = e2, F2(e2);
        } else
          throw b.blockedSegment.formatContext = d, b.legacyContext = f3, b.context = e2, F2(e2), k;
      }
    }
    function Lb(a) {
      var b = a.blockedBoundary;
      a = a.blockedSegment, a.status = 3, Mb(this, b, a);
    }
    function Nb(a, b, c) {
      var d = a.blockedBoundary;
      a.blockedSegment.status = 3, d === null ? (b.allPendingTasks--, b.status !== 2 && (b.status = 2, b.destination !== null && b.destination.push(null))) : (d.pendingTasks--, d.forceClientRender || (d.forceClientRender = !0, d.errorDigest = b.onError(c === void 0 ? Error("The render was aborted by the server without a reason.") : c), d.parentFlushed && b.clientRenderedBoundaries.push(d)), d.fallbackAbortableTasks.forEach(function(a2) {
        return Nb(a2, b, c);
      }), d.fallbackAbortableTasks.clear(), b.allPendingTasks--, b.allPendingTasks === 0 && (a = b.onAllReady, a()));
    }
    function X(a, b) {
      if (b.chunks.length === 0 && b.children.length === 1 && b.children[0].boundary === null) {
        var c = b.children[0];
        c.id = b.id, c.parentFlushed = !0, c.status === 1 && X(a, c);
      } else
        a.completedSegments.push(b);
    }
    function Mb(a, b, c) {
      if (b === null) {
        if (c.parentFlushed) {
          if (a.completedRootSegment !== null)
            throw Error("There can only be one root segment. This is a bug in React.");
          a.completedRootSegment = c;
        }
        a.pendingRootTasks--, a.pendingRootTasks === 0 && (a.onShellError = S2, b = a.onShellReady, b());
      } else
        b.pendingTasks--, b.forceClientRender || (b.pendingTasks === 0 ? (c.parentFlushed && c.status === 1 && X(b, c), b.parentFlushed && a.completedBoundaries.push(b), b.fallbackAbortableTasks.forEach(Lb, a), b.fallbackAbortableTasks.clear()) : c.parentFlushed && c.status === 1 && (X(b, c), b.completedSegments.length === 1 && b.parentFlushed && a.partialBoundaries.push(b)));
      a.allPendingTasks--, a.allPendingTasks === 0 && (a = a.onAllReady, a());
    }
    function Eb(a) {
      if (a.status !== 2) {
        var b = D, c = Ab.current;
        Ab.current = zb;
        var d = R;
        R = a.responseState;
        try {
          var f3 = a.pingedTasks, e2;
          for (e2 = 0; e2 < f3.length; e2++) {
            var g = f3[e2], h2 = a, k = g.blockedSegment;
            if (k.status === 0) {
              F2(g.context);
              try {
                W(h2, g, g.node), h2.responseState.generateStaticMarkup || k.lastPushedText && k.textEmbedded && k.chunks.push("<!-- -->"), g.abortSet.delete(g), k.status = 1, Mb(h2, g.blockedBoundary, k);
              } catch (y) {
                if (tb(), typeof y == "object" && y !== null && typeof y.then == "function") {
                  var m2 = g.ping;
                  y.then(m2, m2);
                } else {
                  g.abortSet.delete(g), k.status = 4;
                  var l = g.blockedBoundary, p = y, B = U(h2, p);
                  if (l === null ? V(h2, p) : (l.pendingTasks--, l.forceClientRender || (l.forceClientRender = !0, l.errorDigest = B, l.parentFlushed && h2.clientRenderedBoundaries.push(l))), h2.allPendingTasks--, h2.allPendingTasks === 0) {
                    var C = h2.onAllReady;
                    C();
                  }
                }
              } finally {
              }
            }
          }
          f3.splice(0, e2), a.destination !== null && Ob(a, a.destination);
        } catch (y) {
          U(a, y), V(a, y);
        } finally {
          R = d, Ab.current = c, c === zb && F2(b);
        }
      }
    }
    function Y(a, b, c) {
      switch (c.parentFlushed = !0, c.status) {
        case 0:
          var d = c.id = a.nextSegmentId++;
          return c.lastPushedText = !1, c.textEmbedded = !1, a = a.responseState, b.push('<template id="'), b.push(a.placeholderPrefix), a = d.toString(16), b.push(a), b.push('"></template>');
        case 1:
          c.status = 2;
          var f3 = !0;
          d = c.chunks;
          var e2 = 0;
          c = c.children;
          for (var g = 0; g < c.length; g++) {
            for (f3 = c[g]; e2 < f3.index; e2++)
              b.push(d[e2]);
            f3 = Z2(a, b, f3);
          }
          for (; e2 < d.length - 1; e2++)
            b.push(d[e2]);
          return e2 < d.length && (f3 = b.push(d[e2])), f3;
        default:
          throw Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function Z2(a, b, c) {
      var d = c.boundary;
      if (d === null)
        return Y(a, b, c);
      if (d.parentFlushed = !0, d.forceClientRender)
        return a.responseState.generateStaticMarkup || (d = d.errorDigest, b.push("<!--$!-->"), b.push("<template"), d && (b.push(' data-dgst="'), d = u(d), b.push(d), b.push('"')), b.push("></template>")), Y(a, b, c), a = a.responseState.generateStaticMarkup ? !0 : b.push("<!--/$-->"), a;
      if (0 < d.pendingTasks) {
        d.rootSegmentID = a.nextSegmentId++, 0 < d.completedSegments.length && a.partialBoundaries.push(d);
        var f3 = a.responseState, e2 = f3.nextSuspenseID++;
        return f3 = f3.boundaryPrefix + e2.toString(16), d = d.id = f3, Aa(b, a.responseState, d), Y(a, b, c), b.push("<!--/$-->");
      }
      if (d.byteSize > a.progressiveChunkSize)
        return d.rootSegmentID = a.nextSegmentId++, a.completedBoundaries.push(d), Aa(b, a.responseState, d.id), Y(a, b, c), b.push("<!--/$-->");
      if (a.responseState.generateStaticMarkup || b.push("<!--$-->"), c = d.completedSegments, c.length !== 1)
        throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
      return Z2(a, b, c[0]), a = a.responseState.generateStaticMarkup ? !0 : b.push("<!--/$-->"), a;
    }
    function Pb(a, b, c) {
      return Ba(b, a.responseState, c.formatContext, c.id), Z2(a, b, c), Ca(b, c.formatContext);
    }
    function Qb(a, b, c) {
      for (var d = c.completedSegments, f3 = 0; f3 < d.length; f3++)
        Rb(a, b, c, d[f3]);
      if (d.length = 0, a = a.responseState, d = c.id, c = c.rootSegmentID, b.push(a.startInlineScript), a.sentCompleteBoundaryFunction ? b.push('$RC("') : (a.sentCompleteBoundaryFunction = !0, b.push('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("')), d === null)
        throw Error("An ID must have been assigned before we can complete the boundary.");
      return c = c.toString(16), b.push(d), b.push('","'), b.push(a.segmentPrefix), b.push(c), b.push('")</script>');
    }
    function Rb(a, b, c, d) {
      if (d.status === 2)
        return !0;
      var f3 = d.id;
      if (f3 === -1) {
        if ((d.id = c.rootSegmentID) === -1)
          throw Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return Pb(a, b, d);
      }
      return Pb(a, b, d), a = a.responseState, b.push(a.startInlineScript), a.sentCompleteSegmentFunction ? b.push('$RS("') : (a.sentCompleteSegmentFunction = !0, b.push('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("')), b.push(a.segmentPrefix), f3 = f3.toString(16), b.push(f3), b.push('","'), b.push(a.placeholderPrefix), b.push(f3), b.push('")</script>');
    }
    function Ob(a, b) {
      try {
        var c = a.completedRootSegment;
        if (c !== null && a.pendingRootTasks === 0) {
          Z2(a, b, c), a.completedRootSegment = null;
          var d = a.responseState.bootstrapChunks;
          for (c = 0; c < d.length - 1; c++)
            b.push(d[c]);
          c < d.length && b.push(d[c]);
        }
        var f3 = a.clientRenderedBoundaries, e2;
        for (e2 = 0; e2 < f3.length; e2++) {
          var g = f3[e2];
          d = b;
          var h2 = a.responseState, k = g.id, m2 = g.errorDigest, l = g.errorMessage, p = g.errorComponentStack;
          if (d.push(h2.startInlineScript), h2.sentClientRenderFunction ? d.push('$RX("') : (h2.sentClientRenderFunction = !0, d.push('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("')), k === null)
            throw Error("An ID must have been assigned before we can complete the boundary.");
          if (d.push(k), d.push('"'), m2 || l || p) {
            d.push(",");
            var B = Ea(m2 || "");
            d.push(B);
          }
          if (l || p) {
            d.push(",");
            var C = Ea(l || "");
            d.push(C);
          }
          if (p) {
            d.push(",");
            var y = Ea(p);
            d.push(y);
          }
          if (!d.push(")</script>")) {
            a.destination = null, e2++, f3.splice(0, e2);
            return;
          }
        }
        f3.splice(0, e2);
        var aa = a.completedBoundaries;
        for (e2 = 0; e2 < aa.length; e2++)
          if (!Qb(a, b, aa[e2])) {
            a.destination = null, e2++, aa.splice(0, e2);
            return;
          }
        aa.splice(0, e2);
        var ba = a.partialBoundaries;
        for (e2 = 0; e2 < ba.length; e2++) {
          var pb = ba[e2];
          a: {
            f3 = a, g = b;
            var ca = pb.completedSegments;
            for (h2 = 0; h2 < ca.length; h2++)
              if (!Rb(f3, g, pb, ca[h2])) {
                h2++, ca.splice(0, h2);
                var qb = !1;
                break a;
              }
            ca.splice(0, h2), qb = !0;
          }
          if (!qb) {
            a.destination = null, e2++, ba.splice(0, e2);
            return;
          }
        }
        ba.splice(0, e2);
        var da = a.completedBoundaries;
        for (e2 = 0; e2 < da.length; e2++)
          if (!Qb(a, b, da[e2])) {
            a.destination = null, e2++, da.splice(0, e2);
            return;
          }
        da.splice(0, e2);
      } finally {
        a.allPendingTasks === 0 && a.pingedTasks.length === 0 && a.clientRenderedBoundaries.length === 0 && a.completedBoundaries.length === 0 && b.push(null);
      }
    }
    function Sb(a, b) {
      if (a.status === 1)
        a.status = 2, b.destroy(a.fatalError);
      else if (a.status !== 2 && a.destination === null) {
        a.destination = b;
        try {
          Ob(a, b);
        } catch (c) {
          U(a, c), V(a, c);
        }
      }
    }
    function Tb(a, b) {
      try {
        var c = a.abortableTasks;
        c.forEach(function(c2) {
          return Nb(c2, a, b);
        }), c.clear(), a.destination !== null && Ob(a, a.destination);
      } catch (d) {
        U(a, d), V(a, d);
      }
    }
    function Ub() {
    }
    function Vb(a, b, c, d) {
      var f3 = !1, e2 = null, g = "", h2 = !1;
      if (a = Cb(a, Fa(c, b ? b.identifierPrefix : void 0), Ga(), 1 / 0, Ub, void 0, function() {
        h2 = !0;
      }, void 0, void 0), Eb(a), Tb(a, d), Sb(a, { push: function(a2) {
        return a2 !== null && (g += a2), !0;
      }, destroy: function(a2) {
        f3 = !0, e2 = a2;
      } }), f3)
        throw e2;
      if (!h2)
        throw Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
      return g;
    }
    function Wb(a, b) {
      a.prototype = Object.create(b.prototype), a.prototype.constructor = a, a.__proto__ = b;
    }
    var Xb = function(a) {
      function b() {
        var b2 = a.call(this, {}) || this;
        return b2.request = null, b2.startedFlowing = !1, b2;
      }
      Wb(b, a);
      var c = b.prototype;
      return c._destroy = function(a2, b2) {
        Tb(this.request), b2(a2);
      }, c._read = function() {
        this.startedFlowing && Sb(this.request, this);
      }, b;
    }(fa.Readable);
    function Yb() {
    }
    function Zb(a, b) {
      var c = new Xb(), d = Cb(a, Fa(!1, b ? b.identifierPrefix : void 0), Ga(), 1 / 0, Yb, function() {
        c.startedFlowing = !0, Sb(d, c);
      }, void 0, void 0);
      return c.request = d, Eb(d), c;
    }
    exports.renderToNodeStream = function(a, b) {
      return Zb(a, b);
    };
    exports.renderToStaticMarkup = function(a, b) {
      return Vb(a, b, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server');
    };
    exports.renderToStaticNodeStream = function(a, b) {
      return Zb(a, b);
    };
    exports.renderToString = function(a, b) {
      return Vb(a, b, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server');
    };
    exports.version = "18.2.0";
  }
});

// node_modules/react-dom/cjs/react-dom-server.node.production.min.js
var require_react_dom_server_node_production_min = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server.node.production.min.js"(exports) {
    "use strict";
    var aa = require("util"), ba = require_react(), k = null, l = 0, q = !0;
    function r2(a, b) {
      if (typeof b == "string") {
        if (b.length !== 0)
          if (2048 < 3 * b.length)
            0 < l && (t2(a, k.subarray(0, l)), k = new Uint8Array(2048), l = 0), t2(a, u.encode(b));
          else {
            var c = k;
            0 < l && (c = k.subarray(l)), c = u.encodeInto(b, c);
            var d = c.read;
            l += c.written, d < b.length && (t2(a, k), k = new Uint8Array(2048), l = u.encodeInto(b.slice(d), k).written), l === 2048 && (t2(a, k), k = new Uint8Array(2048), l = 0);
          }
      } else
        b.byteLength !== 0 && (2048 < b.byteLength ? (0 < l && (t2(a, k.subarray(0, l)), k = new Uint8Array(2048), l = 0), t2(a, b)) : (c = k.length - l, c < b.byteLength && (c === 0 ? t2(
          a,
          k
        ) : (k.set(b.subarray(0, c), l), l += c, t2(a, k), b = b.subarray(c)), k = new Uint8Array(2048), l = 0), k.set(b, l), l += b.byteLength, l === 2048 && (t2(a, k), k = new Uint8Array(2048), l = 0)));
    }
    function t2(a, b) {
      a = a.write(b), q = q && a;
    }
    function w(a, b) {
      return r2(a, b), q;
    }
    function ca(a) {
      k && 0 < l && a.write(k.subarray(0, l)), k = null, l = 0, q = !0;
    }
    var u = new aa.TextEncoder();
    function x2(a) {
      return u.encode(a);
    }
    var y = Object.prototype.hasOwnProperty, da = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, ea = {}, fa = {};
    function ha(a) {
      return y.call(fa, a) ? !0 : y.call(ea, a) ? !1 : da.test(a) ? fa[a] = !0 : (ea[a] = !0, !1);
    }
    function z(a, b, c, d, f3, e2, g) {
      this.acceptsBooleans = b === 2 || b === 3 || b === 4, this.attributeName = d, this.attributeNamespace = f3, this.mustUseProperty = c, this.propertyName = a, this.type = b, this.sanitizeURL = e2, this.removeEmptyString = g;
    }
    var A2 = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
      A2[a] = new z(a, 0, !1, a, null, !1, !1);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
      var b = a[0];
      A2[b] = new z(b, 1, !1, a[1], null, !1, !1);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
      A2[a] = new z(a, 2, !1, a.toLowerCase(), null, !1, !1);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
      A2[a] = new z(a, 2, !1, a, null, !1, !1);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
      A2[a] = new z(a, 3, !1, a.toLowerCase(), null, !1, !1);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a) {
      A2[a] = new z(a, 3, !0, a, null, !1, !1);
    });
    ["capture", "download"].forEach(function(a) {
      A2[a] = new z(a, 4, !1, a, null, !1, !1);
    });
    ["cols", "rows", "size", "span"].forEach(function(a) {
      A2[a] = new z(a, 6, !1, a, null, !1, !1);
    });
    ["rowSpan", "start"].forEach(function(a) {
      A2[a] = new z(a, 5, !1, a.toLowerCase(), null, !1, !1);
    });
    var ia = /[\-:]([a-z])/g;
    function ja(a) {
      return a[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
      var b = a.replace(
        ia,
        ja
      );
      A2[b] = new z(b, 1, !1, a, null, !1, !1);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
      var b = a.replace(ia, ja);
      A2[b] = new z(b, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
      var b = a.replace(ia, ja);
      A2[b] = new z(b, 1, !1, a, "http://www.w3.org/XML/1998/namespace", !1, !1);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a) {
      A2[a] = new z(a, 1, !1, a.toLowerCase(), null, !1, !1);
    });
    A2.xlinkHref = new z("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
    ["src", "href", "action", "formAction"].forEach(function(a) {
      A2[a] = new z(a, 1, !1, a.toLowerCase(), null, !0, !0);
    });
    var B = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    }, ka = ["Webkit", "ms", "Moz", "O"];
    Object.keys(B).forEach(function(a) {
      ka.forEach(function(b) {
        b = b + a.charAt(0).toUpperCase() + a.substring(1), B[b] = B[a];
      });
    });
    var la = /["'&<>]/;
    function F2(a) {
      if (typeof a == "boolean" || typeof a == "number")
        return "" + a;
      a = "" + a;
      var b = la.exec(a);
      if (b) {
        var c = "", d, f3 = 0;
        for (d = b.index; d < a.length; d++) {
          switch (a.charCodeAt(d)) {
            case 34:
              b = "&quot;";
              break;
            case 38:
              b = "&amp;";
              break;
            case 39:
              b = "&#x27;";
              break;
            case 60:
              b = "&lt;";
              break;
            case 62:
              b = "&gt;";
              break;
            default:
              continue;
          }
          f3 !== d && (c += a.substring(f3, d)), f3 = d + 1, c += b;
        }
        a = f3 !== d ? c + a.substring(f3, d) : c;
      }
      return a;
    }
    var ma = /([A-Z])/g, pa = /^ms-/, qa = Array.isArray, ra = x2("<script>"), sa = x2("</script>"), ta = x2('<script src="'), ua = x2('<script type="module" src="'), va = x2('" async=""></script>'), wa = /(<\/|<)(s)(cript)/gi;
    function xa(a, b, c, d) {
      return "" + b + (c === "s" ? "\\u0073" : "\\u0053") + d;
    }
    function G(a, b) {
      return { insertionMode: a, selectedValue: b };
    }
    function ya(a, b, c) {
      switch (b) {
        case "select":
          return G(1, c.value != null ? c.value : c.defaultValue);
        case "svg":
          return G(2, null);
        case "math":
          return G(3, null);
        case "foreignObject":
          return G(1, null);
        case "table":
          return G(4, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return G(5, null);
        case "colgroup":
          return G(7, null);
        case "tr":
          return G(6, null);
      }
      return 4 <= a.insertionMode || a.insertionMode === 0 ? G(1, null) : a;
    }
    var za = x2("<!-- -->");
    function Aa(a, b, c, d) {
      return b === "" ? d : (d && a.push(za), a.push(F2(b)), !0);
    }
    var Ba = /* @__PURE__ */ new Map(), Ca = x2(' style="'), Da = x2(":"), Ea = x2(";");
    function Fa(a, b, c) {
      if (typeof c != "object")
        throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      b = !0;
      for (var d in c)
        if (y.call(c, d)) {
          var f3 = c[d];
          if (f3 != null && typeof f3 != "boolean" && f3 !== "") {
            if (d.indexOf("--") === 0) {
              var e2 = F2(d);
              f3 = F2(("" + f3).trim());
            } else {
              e2 = d;
              var g = Ba.get(e2);
              g !== void 0 || (g = x2(F2(e2.replace(ma, "-$1").toLowerCase().replace(pa, "-ms-"))), Ba.set(e2, g)), e2 = g, f3 = typeof f3 == "number" ? f3 === 0 || y.call(
                B,
                d
              ) ? "" + f3 : f3 + "px" : F2(("" + f3).trim());
            }
            b ? (b = !1, a.push(Ca, e2, Da, f3)) : a.push(Ea, e2, Da, f3);
          }
        }
      b || a.push(H);
    }
    var I = x2(" "), J = x2('="'), H = x2('"'), Ga = x2('=""');
    function K(a, b, c, d) {
      switch (c) {
        case "style":
          Fa(a, b, d);
          return;
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (!(2 < c.length) || c[0] !== "o" && c[0] !== "O" || c[1] !== "n" && c[1] !== "N") {
        if (b = A2.hasOwnProperty(c) ? A2[c] : null, b !== null) {
          switch (typeof d) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!b.acceptsBooleans)
                return;
          }
          switch (c = b.attributeName, b.type) {
            case 3:
              d && a.push(I, c, Ga);
              break;
            case 4:
              d === !0 ? a.push(I, c, Ga) : d !== !1 && a.push(I, c, J, F2(d), H);
              break;
            case 5:
              isNaN(d) || a.push(I, c, J, F2(d), H);
              break;
            case 6:
              !isNaN(d) && 1 <= d && a.push(I, c, J, F2(d), H);
              break;
            default:
              b.sanitizeURL && (d = "" + d), a.push(I, c, J, F2(d), H);
          }
        } else if (ha(c)) {
          switch (typeof d) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (b = c.toLowerCase().slice(0, 5), b !== "data-" && b !== "aria-")
                return;
          }
          a.push(I, c, J, F2(d), H);
        }
      }
    }
    var L = x2(">"), Ha = x2("/>");
    function M(a, b, c) {
      if (b != null) {
        if (c != null)
          throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof b != "object" || !("__html" in b))
          throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        b = b.__html, b != null && a.push("" + b);
      }
    }
    function Ia(a) {
      var b = "";
      return ba.Children.forEach(a, function(a2) {
        a2 != null && (b += a2);
      }), b;
    }
    var Ja = x2(' selected=""');
    function Ka(a, b, c, d) {
      a.push(N(c));
      var f3 = c = null, e2;
      for (e2 in b)
        if (y.call(b, e2)) {
          var g = b[e2];
          if (g != null)
            switch (e2) {
              case "children":
                c = g;
                break;
              case "dangerouslySetInnerHTML":
                f3 = g;
                break;
              default:
                K(a, d, e2, g);
            }
        }
      return a.push(L), M(a, f3, c), typeof c == "string" ? (a.push(F2(c)), null) : c;
    }
    var La = x2(`
`), Ma = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, Na = /* @__PURE__ */ new Map();
    function N(a) {
      var b = Na.get(a);
      if (b === void 0) {
        if (!Ma.test(a))
          throw Error("Invalid tag: " + a);
        b = x2("<" + a), Na.set(a, b);
      }
      return b;
    }
    var Oa = x2("<!DOCTYPE html>");
    function Pa(a, b, c, d, f3) {
      switch (b) {
        case "select":
          a.push(N("select"));
          var e2 = null, g = null;
          for (p in c)
            if (y.call(c, p)) {
              var h2 = c[p];
              if (h2 != null)
                switch (p) {
                  case "children":
                    e2 = h2;
                    break;
                  case "dangerouslySetInnerHTML":
                    g = h2;
                    break;
                  case "defaultValue":
                  case "value":
                    break;
                  default:
                    K(a, d, p, h2);
                }
            }
          return a.push(L), M(a, g, e2), e2;
        case "option":
          g = f3.selectedValue, a.push(N("option"));
          var m2 = h2 = null, n = null, p = null;
          for (e2 in c)
            if (y.call(c, e2)) {
              var v = c[e2];
              if (v != null)
                switch (e2) {
                  case "children":
                    h2 = v;
                    break;
                  case "selected":
                    n = v;
                    break;
                  case "dangerouslySetInnerHTML":
                    p = v;
                    break;
                  case "value":
                    m2 = v;
                  default:
                    K(a, d, e2, v);
                }
            }
          if (g != null)
            if (c = m2 !== null ? "" + m2 : Ia(h2), qa(g)) {
              for (d = 0; d < g.length; d++)
                if ("" + g[d] === c) {
                  a.push(Ja);
                  break;
                }
            } else
              "" + g === c && a.push(Ja);
          else
            n && a.push(Ja);
          return a.push(L), M(a, p, h2), h2;
        case "textarea":
          a.push(N("textarea")), p = g = e2 = null;
          for (h2 in c)
            if (y.call(c, h2) && (m2 = c[h2], m2 != null))
              switch (h2) {
                case "children":
                  p = m2;
                  break;
                case "value":
                  e2 = m2;
                  break;
                case "defaultValue":
                  g = m2;
                  break;
                case "dangerouslySetInnerHTML":
                  throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                default:
                  K(a, d, h2, m2);
              }
          if (e2 === null && g !== null && (e2 = g), a.push(L), p != null) {
            if (e2 != null)
              throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (qa(p) && 1 < p.length)
              throw Error("<textarea> can only have at most one child.");
            e2 = "" + p;
          }
          return typeof e2 == "string" && e2[0] === `
` && a.push(La), e2 !== null && a.push(F2("" + e2)), null;
        case "input":
          a.push(N("input")), m2 = p = h2 = e2 = null;
          for (g in c)
            if (y.call(c, g) && (n = c[g], n != null))
              switch (g) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                case "defaultChecked":
                  m2 = n;
                  break;
                case "defaultValue":
                  h2 = n;
                  break;
                case "checked":
                  p = n;
                  break;
                case "value":
                  e2 = n;
                  break;
                default:
                  K(a, d, g, n);
              }
          return p !== null ? K(a, d, "checked", p) : m2 !== null && K(a, d, "checked", m2), e2 !== null ? K(a, d, "value", e2) : h2 !== null && K(a, d, "value", h2), a.push(Ha), null;
        case "menuitem":
          a.push(N("menuitem"));
          for (var C in c)
            if (y.call(c, C) && (e2 = c[C], e2 != null))
              switch (C) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
                default:
                  K(a, d, C, e2);
              }
          return a.push(L), null;
        case "title":
          a.push(N("title")), e2 = null;
          for (v in c)
            if (y.call(c, v) && (g = c[v], g != null))
              switch (v) {
                case "children":
                  e2 = g;
                  break;
                case "dangerouslySetInnerHTML":
                  throw Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
                default:
                  K(a, d, v, g);
              }
          return a.push(L), e2;
        case "listing":
        case "pre":
          a.push(N(b)), g = e2 = null;
          for (m2 in c)
            if (y.call(c, m2) && (h2 = c[m2], h2 != null))
              switch (m2) {
                case "children":
                  e2 = h2;
                  break;
                case "dangerouslySetInnerHTML":
                  g = h2;
                  break;
                default:
                  K(a, d, m2, h2);
              }
          if (a.push(L), g != null) {
            if (e2 != null)
              throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            if (typeof g != "object" || !("__html" in g))
              throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            c = g.__html, c != null && (typeof c == "string" && 0 < c.length && c[0] === `
` ? a.push(La, c) : a.push("" + c));
          }
          return typeof e2 == "string" && e2[0] === `
` && a.push(La), e2;
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          a.push(N(b));
          for (var D in c)
            if (y.call(c, D) && (e2 = c[D], e2 != null))
              switch (D) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(b + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                default:
                  K(a, d, D, e2);
              }
          return a.push(Ha), null;
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return Ka(a, c, b, d);
        case "html":
          return f3.insertionMode === 0 && a.push(Oa), Ka(
            a,
            c,
            b,
            d
          );
        default:
          if (b.indexOf("-") === -1 && typeof c.is != "string")
            return Ka(a, c, b, d);
          a.push(N(b)), g = e2 = null;
          for (n in c)
            if (y.call(c, n) && (h2 = c[n], h2 != null))
              switch (n) {
                case "children":
                  e2 = h2;
                  break;
                case "dangerouslySetInnerHTML":
                  g = h2;
                  break;
                case "style":
                  Fa(a, d, h2);
                  break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                  break;
                default:
                  ha(n) && typeof h2 != "function" && typeof h2 != "symbol" && a.push(I, n, J, F2(h2), H);
              }
          return a.push(L), M(a, g, e2), e2;
      }
    }
    var Qa = x2("</"), Ra = x2(">"), Sa = x2('<template id="'), Ta = x2('"></template>'), Ua = x2("<!--$-->"), Va = x2('<!--$?--><template id="'), Wa = x2('"></template>'), Xa = x2("<!--$!-->"), Ya = x2("<!--/$-->"), Za = x2("<template"), $a = x2('"'), ab = x2(' data-dgst="');
    x2(' data-msg="');
    x2(' data-stck="');
    var bb = x2("></template>");
    function cb(a, b, c) {
      if (r2(a, Va), c === null)
        throw Error("An ID must have been assigned before we can complete the boundary.");
      return r2(a, c), w(a, Wa);
    }
    var db = x2('<div hidden id="'), eb = x2('">'), fb = x2("</div>"), gb = x2('<svg aria-hidden="true" style="display:none" id="'), hb = x2('">'), ib = x2("</svg>"), jb = x2('<math aria-hidden="true" style="display:none" id="'), kb = x2('">'), lb = x2("</math>"), mb = x2('<table hidden id="'), nb = x2('">'), ob = x2("</table>"), pb = x2('<table hidden><tbody id="'), qb = x2('">'), rb = x2("</tbody></table>"), sb = x2('<table hidden><tr id="'), tb = x2('">'), ub = x2("</tr></table>"), vb = x2('<table hidden><colgroup id="'), wb = x2('">'), xb = x2("</colgroup></table>");
    function yb(a, b, c, d) {
      switch (c.insertionMode) {
        case 0:
        case 1:
          return r2(a, db), r2(a, b.segmentPrefix), r2(a, d.toString(16)), w(a, eb);
        case 2:
          return r2(a, gb), r2(a, b.segmentPrefix), r2(a, d.toString(16)), w(a, hb);
        case 3:
          return r2(a, jb), r2(a, b.segmentPrefix), r2(a, d.toString(16)), w(a, kb);
        case 4:
          return r2(a, mb), r2(a, b.segmentPrefix), r2(a, d.toString(16)), w(a, nb);
        case 5:
          return r2(a, pb), r2(a, b.segmentPrefix), r2(a, d.toString(16)), w(a, qb);
        case 6:
          return r2(a, sb), r2(a, b.segmentPrefix), r2(a, d.toString(16)), w(a, tb);
        case 7:
          return r2(a, vb), r2(
            a,
            b.segmentPrefix
          ), r2(a, d.toString(16)), w(a, wb);
        default:
          throw Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function zb(a, b) {
      switch (b.insertionMode) {
        case 0:
        case 1:
          return w(a, fb);
        case 2:
          return w(a, ib);
        case 3:
          return w(a, lb);
        case 4:
          return w(a, ob);
        case 5:
          return w(a, rb);
        case 6:
          return w(a, ub);
        case 7:
          return w(a, xb);
        default:
          throw Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var Ab = x2('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'), Bb = x2('$RS("'), Cb = x2('","'), Db = x2('")</script>'), Fb = x2('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'), Gb = x2('$RC("'), Hb = x2('","'), Ib = x2('")</script>'), Jb = x2('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'), Kb = x2('$RX("'), Lb = x2('"'), Mb = x2(")</script>"), Nb = x2(","), Ob = /[<\u2028\u2029]/g;
    function Pb(a) {
      return JSON.stringify(a).replace(Ob, function(a2) {
        switch (a2) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    var O = Object.assign, Qb = Symbol.for("react.element"), Rb = Symbol.for("react.portal"), Sb = Symbol.for("react.fragment"), Tb = Symbol.for("react.strict_mode"), Ub = Symbol.for("react.profiler"), Vb = Symbol.for("react.provider"), Wb = Symbol.for("react.context"), Xb = Symbol.for("react.forward_ref"), Yb = Symbol.for("react.suspense"), Zb = Symbol.for("react.suspense_list"), $b = Symbol.for("react.memo"), ac = Symbol.for("react.lazy"), bc = Symbol.for("react.scope"), cc = Symbol.for("react.debug_trace_mode"), dc = Symbol.for("react.legacy_hidden"), ec = Symbol.for("react.default_value"), fc = Symbol.iterator;
    function gc(a) {
      if (a == null)
        return null;
      if (typeof a == "function")
        return a.displayName || a.name || null;
      if (typeof a == "string")
        return a;
      switch (a) {
        case Sb:
          return "Fragment";
        case Rb:
          return "Portal";
        case Ub:
          return "Profiler";
        case Tb:
          return "StrictMode";
        case Yb:
          return "Suspense";
        case Zb:
          return "SuspenseList";
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case Wb:
            return (a.displayName || "Context") + ".Consumer";
          case Vb:
            return (a._context.displayName || "Context") + ".Provider";
          case Xb:
            var b = a.render;
            return a = a.displayName, a || (a = b.displayName || b.name || "", a = a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef"), a;
          case $b:
            return b = a.displayName || null, b !== null ? b : gc(a.type) || "Memo";
          case ac:
            b = a._payload, a = a._init;
            try {
              return gc(a(b));
            } catch {
            }
        }
      return null;
    }
    var hc = {};
    function ic(a, b) {
      if (a = a.contextTypes, !a)
        return hc;
      var c = {}, d;
      for (d in a)
        c[d] = b[d];
      return c;
    }
    var P = null;
    function Q(a, b) {
      if (a !== b) {
        a.context._currentValue = a.parentValue, a = a.parent;
        var c = b.parent;
        if (a === null) {
          if (c !== null)
            throw Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (c === null)
            throw Error("The stacks must reach the root at the same time. This is a bug in React.");
          Q(a, c);
        }
        b.context._currentValue = b.value;
      }
    }
    function jc(a) {
      a.context._currentValue = a.parentValue, a = a.parent, a !== null && jc(a);
    }
    function kc(a) {
      var b = a.parent;
      b !== null && kc(b), a.context._currentValue = a.value;
    }
    function lc(a, b) {
      if (a.context._currentValue = a.parentValue, a = a.parent, a === null)
        throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      a.depth === b.depth ? Q(a, b) : lc(a, b);
    }
    function mc(a, b) {
      var c = b.parent;
      if (c === null)
        throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      a.depth === c.depth ? Q(a, c) : mc(a, c), b.context._currentValue = b.value;
    }
    function nc(a) {
      var b = P;
      b !== a && (b === null ? kc(a) : a === null ? jc(b) : b.depth === a.depth ? Q(b, a) : b.depth > a.depth ? lc(b, a) : mc(b, a), P = a);
    }
    var oc = { isMounted: function() {
      return !1;
    }, enqueueSetState: function(a, b) {
      a = a._reactInternals, a.queue !== null && a.queue.push(b);
    }, enqueueReplaceState: function(a, b) {
      a = a._reactInternals, a.replace = !0, a.queue = [b];
    }, enqueueForceUpdate: function() {
    } };
    function pc(a, b, c, d) {
      var f3 = a.state !== void 0 ? a.state : null;
      a.updater = oc, a.props = c, a.state = f3;
      var e2 = { queue: [], replace: !1 };
      a._reactInternals = e2;
      var g = b.contextType;
      if (a.context = typeof g == "object" && g !== null ? g._currentValue : d, g = b.getDerivedStateFromProps, typeof g == "function" && (g = g(c, f3), f3 = g == null ? f3 : O({}, f3, g), a.state = f3), typeof b.getDerivedStateFromProps != "function" && typeof a.getSnapshotBeforeUpdate != "function" && (typeof a.UNSAFE_componentWillMount == "function" || typeof a.componentWillMount == "function"))
        if (b = a.state, typeof a.componentWillMount == "function" && a.componentWillMount(), typeof a.UNSAFE_componentWillMount == "function" && a.UNSAFE_componentWillMount(), b !== a.state && oc.enqueueReplaceState(a, a.state, null), e2.queue !== null && 0 < e2.queue.length)
          if (b = e2.queue, g = e2.replace, e2.queue = null, e2.replace = !1, g && b.length === 1)
            a.state = b[0];
          else {
            for (e2 = g ? b[0] : a.state, f3 = !0, g = g ? 1 : 0; g < b.length; g++) {
              var h2 = b[g];
              h2 = typeof h2 == "function" ? h2.call(a, e2, c, d) : h2, h2 != null && (f3 ? (f3 = !1, e2 = O({}, e2, h2)) : O(e2, h2));
            }
            a.state = e2;
          }
        else
          e2.queue = null;
    }
    var qc = { id: 1, overflow: "" };
    function rc(a, b, c) {
      var d = a.id;
      a = a.overflow;
      var f3 = 32 - sc(d) - 1;
      d &= ~(1 << f3), c += 1;
      var e2 = 32 - sc(b) + f3;
      if (30 < e2) {
        var g = f3 - f3 % 5;
        return e2 = (d & (1 << g) - 1).toString(32), d >>= g, f3 -= g, { id: 1 << 32 - sc(b) + f3 | c << f3 | d, overflow: e2 + a };
      }
      return { id: 1 << e2 | c << f3 | d, overflow: a };
    }
    var sc = Math.clz32 ? Math.clz32 : tc, uc = Math.log, vc = Math.LN2;
    function tc(a) {
      return a >>>= 0, a === 0 ? 32 : 31 - (uc(a) / vc | 0) | 0;
    }
    function wc(a, b) {
      return a === b && (a !== 0 || 1 / a === 1 / b) || a !== a && b !== b;
    }
    var xc = typeof Object.is == "function" ? Object.is : wc, R = null, yc = null, zc = null, S2 = null, T = !1, Ac = !1, U = 0, V = null, Bc = 0;
    function W() {
      if (R === null)
        throw Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return R;
    }
    function Cc() {
      if (0 < Bc)
        throw Error("Rendered more hooks than during the previous render");
      return { memoizedState: null, queue: null, next: null };
    }
    function Dc() {
      return S2 === null ? zc === null ? (T = !1, zc = S2 = Cc()) : (T = !0, S2 = zc) : S2.next === null ? (T = !1, S2 = S2.next = Cc()) : (T = !0, S2 = S2.next), S2;
    }
    function Ec() {
      yc = R = null, Ac = !1, zc = null, Bc = 0, S2 = V = null;
    }
    function Fc(a, b) {
      return typeof b == "function" ? b(a) : b;
    }
    function Gc(a, b, c) {
      if (R = W(), S2 = Dc(), T) {
        var d = S2.queue;
        if (b = d.dispatch, V !== null && (c = V.get(d), c !== void 0)) {
          V.delete(d), d = S2.memoizedState;
          do
            d = a(d, c.action), c = c.next;
          while (c !== null);
          return S2.memoizedState = d, [d, b];
        }
        return [S2.memoizedState, b];
      }
      return a = a === Fc ? typeof b == "function" ? b() : b : c !== void 0 ? c(b) : b, S2.memoizedState = a, a = S2.queue = { last: null, dispatch: null }, a = a.dispatch = Hc.bind(null, R, a), [S2.memoizedState, a];
    }
    function Ic(a, b) {
      if (R = W(), S2 = Dc(), b = b === void 0 ? null : b, S2 !== null) {
        var c = S2.memoizedState;
        if (c !== null && b !== null) {
          var d = c[1];
          a:
            if (d === null)
              d = !1;
            else {
              for (var f3 = 0; f3 < d.length && f3 < b.length; f3++)
                if (!xc(b[f3], d[f3])) {
                  d = !1;
                  break a;
                }
              d = !0;
            }
          if (d)
            return c[0];
        }
      }
      return a = a(), S2.memoizedState = [a, b], a;
    }
    function Hc(a, b, c) {
      if (25 <= Bc)
        throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (a === R)
        if (Ac = !0, a = { action: c, next: null }, V === null && (V = /* @__PURE__ */ new Map()), c = V.get(b), c === void 0)
          V.set(b, a);
        else {
          for (b = c; b.next !== null; )
            b = b.next;
          b.next = a;
        }
    }
    function Jc() {
      throw Error("startTransition cannot be called during server rendering.");
    }
    function Kc() {
    }
    var Mc = { readContext: function(a) {
      return a._currentValue;
    }, useContext: function(a) {
      return W(), a._currentValue;
    }, useMemo: Ic, useReducer: Gc, useRef: function(a) {
      R = W(), S2 = Dc();
      var b = S2.memoizedState;
      return b === null ? (a = { current: a }, S2.memoizedState = a) : b;
    }, useState: function(a) {
      return Gc(Fc, a);
    }, useInsertionEffect: Kc, useLayoutEffect: function() {
    }, useCallback: function(a, b) {
      return Ic(function() {
        return a;
      }, b);
    }, useImperativeHandle: Kc, useEffect: Kc, useDebugValue: Kc, useDeferredValue: function(a) {
      return W(), a;
    }, useTransition: function() {
      return W(), [!1, Jc];
    }, useId: function() {
      var a = yc.treeContext, b = a.overflow;
      a = a.id, a = (a & ~(1 << 32 - sc(a) - 1)).toString(32) + b;
      var c = Lc;
      if (c === null)
        throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      return b = U++, a = ":" + c.idPrefix + "R" + a, 0 < b && (a += "H" + b.toString(32)), a + ":";
    }, useMutableSource: function(a, b) {
      return W(), b(a._source);
    }, useSyncExternalStore: function(a, b, c) {
      if (c === void 0)
        throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return c();
    } }, Lc = null, Nc = ba.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
    function Oc(a) {
      return console.error(a), null;
    }
    function X() {
    }
    function Pc(a, b) {
      var c = a.pingedTasks;
      c.push(b), c.length === 1 && setImmediate(function() {
        return Qc(a);
      });
    }
    function Rc(a, b, c, d, f3, e2, g, h2) {
      a.allPendingTasks++, c === null ? a.pendingRootTasks++ : c.pendingTasks++;
      var m2 = { node: b, ping: function() {
        return Pc(a, m2);
      }, blockedBoundary: c, blockedSegment: d, abortSet: f3, legacyContext: e2, context: g, treeContext: h2 };
      return f3.add(m2), m2;
    }
    function Sc(a, b, c, d, f3, e2) {
      return { status: 0, id: -1, index: b, parentFlushed: !1, chunks: [], children: [], formatContext: d, boundary: c, lastPushedText: f3, textEmbedded: e2 };
    }
    function Y(a, b) {
      if (a = a.onError(b), a != null && typeof a != "string")
        throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof a + '" instead');
      return a;
    }
    function Tc(a, b) {
      var c = a.onShellError;
      c(b), c = a.onFatalError, c(b), a.destination !== null ? (a.status = 2, a.destination.destroy(b)) : (a.status = 1, a.fatalError = b);
    }
    function Uc(a, b, c, d, f3) {
      for (R = {}, yc = b, U = 0, a = c(d, f3); Ac; )
        Ac = !1, U = 0, Bc += 1, S2 = null, a = c(d, f3);
      return Ec(), a;
    }
    function Vc(a, b, c, d) {
      var f3 = c.render(), e2 = d.childContextTypes;
      if (e2 != null) {
        var g = b.legacyContext;
        if (typeof c.getChildContext != "function")
          d = g;
        else {
          c = c.getChildContext();
          for (var h2 in c)
            if (!(h2 in e2))
              throw Error((gc(d) || "Unknown") + '.getChildContext(): key "' + h2 + '" is not defined in childContextTypes.');
          d = O({}, g, c);
        }
        b.legacyContext = d, Z2(a, b, f3), b.legacyContext = g;
      } else
        Z2(a, b, f3);
    }
    function Wc(a, b) {
      if (a && a.defaultProps) {
        b = O({}, b), a = a.defaultProps;
        for (var c in a)
          b[c] === void 0 && (b[c] = a[c]);
        return b;
      }
      return b;
    }
    function Xc(a, b, c, d, f3) {
      if (typeof c == "function")
        if (c.prototype && c.prototype.isReactComponent) {
          f3 = ic(c, b.legacyContext);
          var e2 = c.contextType;
          e2 = new c(d, typeof e2 == "object" && e2 !== null ? e2._currentValue : f3), pc(e2, c, d, f3), Vc(a, b, e2, c);
        } else {
          e2 = ic(c, b.legacyContext), f3 = Uc(a, b, c, d, e2);
          var g = U !== 0;
          if (typeof f3 == "object" && f3 !== null && typeof f3.render == "function" && f3.$$typeof === void 0)
            pc(f3, c, d, e2), Vc(a, b, f3, c);
          else if (g) {
            d = b.treeContext, b.treeContext = rc(d, 1, 0);
            try {
              Z2(a, b, f3);
            } finally {
              b.treeContext = d;
            }
          } else
            Z2(a, b, f3);
        }
      else if (typeof c == "string") {
        switch (f3 = b.blockedSegment, e2 = Pa(f3.chunks, c, d, a.responseState, f3.formatContext), f3.lastPushedText = !1, g = f3.formatContext, f3.formatContext = ya(g, c, d), Yc(a, b, e2), f3.formatContext = g, c) {
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "input":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
            break;
          default:
            f3.chunks.push(Qa, c, Ra);
        }
        f3.lastPushedText = !1;
      } else {
        switch (c) {
          case dc:
          case cc:
          case Tb:
          case Ub:
          case Sb:
            Z2(a, b, d.children);
            return;
          case Zb:
            Z2(
              a,
              b,
              d.children
            );
            return;
          case bc:
            throw Error("ReactDOMServer does not yet support scope components.");
          case Yb:
            a: {
              c = b.blockedBoundary, f3 = b.blockedSegment, e2 = d.fallback, d = d.children, g = /* @__PURE__ */ new Set();
              var h2 = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: g, errorDigest: null }, m2 = Sc(a, f3.chunks.length, h2, f3.formatContext, !1, !1);
              f3.children.push(m2), f3.lastPushedText = !1;
              var n = Sc(a, 0, null, f3.formatContext, !1, !1);
              n.parentFlushed = !0, b.blockedBoundary = h2, b.blockedSegment = n;
              try {
                if (Yc(a, b, d), n.lastPushedText && n.textEmbedded && n.chunks.push(za), n.status = 1, Zc(h2, n), h2.pendingTasks === 0)
                  break a;
              } catch (p) {
                n.status = 4, h2.forceClientRender = !0, h2.errorDigest = Y(a, p);
              } finally {
                b.blockedBoundary = c, b.blockedSegment = f3;
              }
              b = Rc(a, e2, c, m2, g, b.legacyContext, b.context, b.treeContext), a.pingedTasks.push(b);
            }
            return;
        }
        if (typeof c == "object" && c !== null)
          switch (c.$$typeof) {
            case Xb:
              if (d = Uc(a, b, c.render, d, f3), U !== 0) {
                c = b.treeContext, b.treeContext = rc(c, 1, 0);
                try {
                  Z2(a, b, d);
                } finally {
                  b.treeContext = c;
                }
              } else
                Z2(
                  a,
                  b,
                  d
                );
              return;
            case $b:
              c = c.type, d = Wc(c, d), Xc(a, b, c, d, f3);
              return;
            case Vb:
              if (f3 = d.children, c = c._context, d = d.value, e2 = c._currentValue, c._currentValue = d, g = P, P = d = { parent: g, depth: g === null ? 0 : g.depth + 1, context: c, parentValue: e2, value: d }, b.context = d, Z2(a, b, f3), a = P, a === null)
                throw Error("Tried to pop a Context at the root of the app. This is a bug in React.");
              d = a.parentValue, a.context._currentValue = d === ec ? a.context._defaultValue : d, a = P = a.parent, b.context = a;
              return;
            case Wb:
              d = d.children, d = d(c._currentValue), Z2(a, b, d);
              return;
            case ac:
              f3 = c._init, c = f3(c._payload), d = Wc(c, d), Xc(a, b, c, d, void 0);
              return;
          }
        throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((c == null ? c : typeof c) + "."));
      }
    }
    function Z2(a, b, c) {
      if (b.node = c, typeof c == "object" && c !== null) {
        switch (c.$$typeof) {
          case Qb:
            Xc(a, b, c.type, c.props, c.ref);
            return;
          case Rb:
            throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case ac:
            var d = c._init;
            c = d(c._payload), Z2(a, b, c);
            return;
        }
        if (qa(c)) {
          $c(a, b, c);
          return;
        }
        if (c === null || typeof c != "object" ? d = null : (d = fc && c[fc] || c["@@iterator"], d = typeof d == "function" ? d : null), d && (d = d.call(c))) {
          if (c = d.next(), !c.done) {
            var f3 = [];
            do
              f3.push(c.value), c = d.next();
            while (!c.done);
            $c(a, b, f3);
          }
          return;
        }
        throw a = Object.prototype.toString.call(c), Error("Objects are not valid as a React child (found: " + (a === "[object Object]" ? "object with keys {" + Object.keys(c).join(", ") + "}" : a) + "). If you meant to render a collection of children, use an array instead.");
      }
      typeof c == "string" ? (d = b.blockedSegment, d.lastPushedText = Aa(b.blockedSegment.chunks, c, a.responseState, d.lastPushedText)) : typeof c == "number" && (d = b.blockedSegment, d.lastPushedText = Aa(
        b.blockedSegment.chunks,
        "" + c,
        a.responseState,
        d.lastPushedText
      ));
    }
    function $c(a, b, c) {
      for (var d = c.length, f3 = 0; f3 < d; f3++) {
        var e2 = b.treeContext;
        b.treeContext = rc(e2, d, f3);
        try {
          Yc(a, b, c[f3]);
        } finally {
          b.treeContext = e2;
        }
      }
    }
    function Yc(a, b, c) {
      var d = b.blockedSegment.formatContext, f3 = b.legacyContext, e2 = b.context;
      try {
        return Z2(a, b, c);
      } catch (m2) {
        if (Ec(), typeof m2 == "object" && m2 !== null && typeof m2.then == "function") {
          c = m2;
          var g = b.blockedSegment, h2 = Sc(a, g.chunks.length, null, g.formatContext, g.lastPushedText, !0);
          g.children.push(h2), g.lastPushedText = !1, a = Rc(a, b.node, b.blockedBoundary, h2, b.abortSet, b.legacyContext, b.context, b.treeContext).ping, c.then(a, a), b.blockedSegment.formatContext = d, b.legacyContext = f3, b.context = e2, nc(e2);
        } else
          throw b.blockedSegment.formatContext = d, b.legacyContext = f3, b.context = e2, nc(e2), m2;
      }
    }
    function ad(a) {
      var b = a.blockedBoundary;
      a = a.blockedSegment, a.status = 3, bd(this, b, a);
    }
    function cd(a, b, c) {
      var d = a.blockedBoundary;
      a.blockedSegment.status = 3, d === null ? (b.allPendingTasks--, b.status !== 2 && (b.status = 2, b.destination !== null && b.destination.end())) : (d.pendingTasks--, d.forceClientRender || (d.forceClientRender = !0, d.errorDigest = b.onError(c === void 0 ? Error("The render was aborted by the server without a reason.") : c), d.parentFlushed && b.clientRenderedBoundaries.push(d)), d.fallbackAbortableTasks.forEach(function(a2) {
        return cd(a2, b, c);
      }), d.fallbackAbortableTasks.clear(), b.allPendingTasks--, b.allPendingTasks === 0 && (a = b.onAllReady, a()));
    }
    function Zc(a, b) {
      if (b.chunks.length === 0 && b.children.length === 1 && b.children[0].boundary === null) {
        var c = b.children[0];
        c.id = b.id, c.parentFlushed = !0, c.status === 1 && Zc(a, c);
      } else
        a.completedSegments.push(b);
    }
    function bd(a, b, c) {
      if (b === null) {
        if (c.parentFlushed) {
          if (a.completedRootSegment !== null)
            throw Error("There can only be one root segment. This is a bug in React.");
          a.completedRootSegment = c;
        }
        a.pendingRootTasks--, a.pendingRootTasks === 0 && (a.onShellError = X, b = a.onShellReady, b());
      } else
        b.pendingTasks--, b.forceClientRender || (b.pendingTasks === 0 ? (c.parentFlushed && c.status === 1 && Zc(b, c), b.parentFlushed && a.completedBoundaries.push(b), b.fallbackAbortableTasks.forEach(ad, a), b.fallbackAbortableTasks.clear()) : c.parentFlushed && c.status === 1 && (Zc(b, c), b.completedSegments.length === 1 && b.parentFlushed && a.partialBoundaries.push(b)));
      a.allPendingTasks--, a.allPendingTasks === 0 && (a = a.onAllReady, a());
    }
    function Qc(a) {
      if (a.status !== 2) {
        var b = P, c = Nc.current;
        Nc.current = Mc;
        var d = Lc;
        Lc = a.responseState;
        try {
          var f3 = a.pingedTasks, e2;
          for (e2 = 0; e2 < f3.length; e2++) {
            var g = f3[e2], h2 = a, m2 = g.blockedSegment;
            if (m2.status === 0) {
              nc(g.context);
              try {
                Z2(h2, g, g.node), m2.lastPushedText && m2.textEmbedded && m2.chunks.push(za), g.abortSet.delete(g), m2.status = 1, bd(h2, g.blockedBoundary, m2);
              } catch (E) {
                if (Ec(), typeof E == "object" && E !== null && typeof E.then == "function") {
                  var n = g.ping;
                  E.then(n, n);
                } else {
                  g.abortSet.delete(g), m2.status = 4;
                  var p = g.blockedBoundary, v = E, C = Y(h2, v);
                  if (p === null ? Tc(h2, v) : (p.pendingTasks--, p.forceClientRender || (p.forceClientRender = !0, p.errorDigest = C, p.parentFlushed && h2.clientRenderedBoundaries.push(p))), h2.allPendingTasks--, h2.allPendingTasks === 0) {
                    var D = h2.onAllReady;
                    D();
                  }
                }
              } finally {
              }
            }
          }
          f3.splice(0, e2), a.destination !== null && dd(a, a.destination);
        } catch (E) {
          Y(a, E), Tc(a, E);
        } finally {
          Lc = d, Nc.current = c, c === Mc && nc(b);
        }
      }
    }
    function ed(a, b, c) {
      switch (c.parentFlushed = !0, c.status) {
        case 0:
          var d = c.id = a.nextSegmentId++;
          return c.lastPushedText = !1, c.textEmbedded = !1, a = a.responseState, r2(b, Sa), r2(b, a.placeholderPrefix), a = d.toString(16), r2(b, a), w(b, Ta);
        case 1:
          c.status = 2;
          var f3 = !0;
          d = c.chunks;
          var e2 = 0;
          c = c.children;
          for (var g = 0; g < c.length; g++) {
            for (f3 = c[g]; e2 < f3.index; e2++)
              r2(b, d[e2]);
            f3 = fd(a, b, f3);
          }
          for (; e2 < d.length - 1; e2++)
            r2(b, d[e2]);
          return e2 < d.length && (f3 = w(b, d[e2])), f3;
        default:
          throw Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function fd(a, b, c) {
      var d = c.boundary;
      if (d === null)
        return ed(a, b, c);
      if (d.parentFlushed = !0, d.forceClientRender)
        d = d.errorDigest, w(b, Xa), r2(b, Za), d && (r2(b, ab), r2(b, F2(d)), r2(b, $a)), w(b, bb), ed(a, b, c);
      else if (0 < d.pendingTasks) {
        d.rootSegmentID = a.nextSegmentId++, 0 < d.completedSegments.length && a.partialBoundaries.push(d);
        var f3 = a.responseState, e2 = f3.nextSuspenseID++;
        f3 = x2(f3.boundaryPrefix + e2.toString(16)), d = d.id = f3, cb(b, a.responseState, d), ed(a, b, c);
      } else if (d.byteSize > a.progressiveChunkSize)
        d.rootSegmentID = a.nextSegmentId++, a.completedBoundaries.push(d), cb(b, a.responseState, d.id), ed(a, b, c);
      else {
        if (w(b, Ua), c = d.completedSegments, c.length !== 1)
          throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        fd(a, b, c[0]);
      }
      return w(b, Ya);
    }
    function gd(a, b, c) {
      return yb(b, a.responseState, c.formatContext, c.id), fd(a, b, c), zb(b, c.formatContext);
    }
    function hd(a, b, c) {
      for (var d = c.completedSegments, f3 = 0; f3 < d.length; f3++)
        id(a, b, c, d[f3]);
      if (d.length = 0, a = a.responseState, d = c.id, c = c.rootSegmentID, r2(b, a.startInlineScript), a.sentCompleteBoundaryFunction ? r2(b, Gb) : (a.sentCompleteBoundaryFunction = !0, r2(b, Fb)), d === null)
        throw Error("An ID must have been assigned before we can complete the boundary.");
      return c = c.toString(16), r2(b, d), r2(b, Hb), r2(b, a.segmentPrefix), r2(b, c), w(b, Ib);
    }
    function id(a, b, c, d) {
      if (d.status === 2)
        return !0;
      var f3 = d.id;
      if (f3 === -1) {
        if ((d.id = c.rootSegmentID) === -1)
          throw Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return gd(a, b, d);
      }
      return gd(a, b, d), a = a.responseState, r2(b, a.startInlineScript), a.sentCompleteSegmentFunction ? r2(b, Bb) : (a.sentCompleteSegmentFunction = !0, r2(b, Ab)), r2(b, a.segmentPrefix), f3 = f3.toString(16), r2(b, f3), r2(b, Cb), r2(b, a.placeholderPrefix), r2(b, f3), w(b, Db);
    }
    function dd(a, b) {
      k = new Uint8Array(2048), l = 0, q = !0;
      try {
        var c = a.completedRootSegment;
        if (c !== null && a.pendingRootTasks === 0) {
          fd(a, b, c), a.completedRootSegment = null;
          var d = a.responseState.bootstrapChunks;
          for (c = 0; c < d.length - 1; c++)
            r2(b, d[c]);
          c < d.length && w(b, d[c]);
        }
        var f3 = a.clientRenderedBoundaries, e2;
        for (e2 = 0; e2 < f3.length; e2++) {
          var g = f3[e2];
          d = b;
          var h2 = a.responseState, m2 = g.id, n = g.errorDigest, p = g.errorMessage, v = g.errorComponentStack;
          if (r2(d, h2.startInlineScript), h2.sentClientRenderFunction ? r2(d, Kb) : (h2.sentClientRenderFunction = !0, r2(d, Jb)), m2 === null)
            throw Error("An ID must have been assigned before we can complete the boundary.");
          if (r2(d, m2), r2(d, Lb), (n || p || v) && (r2(d, Nb), r2(d, Pb(n || ""))), (p || v) && (r2(d, Nb), r2(d, Pb(p || ""))), v && (r2(d, Nb), r2(d, Pb(v))), !w(d, Mb)) {
            a.destination = null, e2++, f3.splice(0, e2);
            return;
          }
        }
        f3.splice(0, e2);
        var C = a.completedBoundaries;
        for (e2 = 0; e2 < C.length; e2++)
          if (!hd(a, b, C[e2])) {
            a.destination = null, e2++, C.splice(0, e2);
            return;
          }
        C.splice(0, e2), ca(b), k = new Uint8Array(2048), l = 0, q = !0;
        var D = a.partialBoundaries;
        for (e2 = 0; e2 < D.length; e2++) {
          var E = D[e2];
          a: {
            f3 = a, g = b;
            var na = E.completedSegments;
            for (h2 = 0; h2 < na.length; h2++)
              if (!id(f3, g, E, na[h2])) {
                h2++, na.splice(0, h2);
                var Eb = !1;
                break a;
              }
            na.splice(0, h2), Eb = !0;
          }
          if (!Eb) {
            a.destination = null, e2++, D.splice(0, e2);
            return;
          }
        }
        D.splice(0, e2);
        var oa = a.completedBoundaries;
        for (e2 = 0; e2 < oa.length; e2++)
          if (!hd(a, b, oa[e2])) {
            a.destination = null, e2++, oa.splice(0, e2);
            return;
          }
        oa.splice(0, e2);
      } finally {
        ca(b), typeof b.flush == "function" && b.flush(), a.allPendingTasks === 0 && a.pingedTasks.length === 0 && a.clientRenderedBoundaries.length === 0 && a.completedBoundaries.length === 0 && b.end();
      }
    }
    function jd(a) {
      setImmediate(function() {
        return Qc(a);
      });
    }
    function kd(a, b) {
      if (a.status === 1)
        a.status = 2, b.destroy(a.fatalError);
      else if (a.status !== 2 && a.destination === null) {
        a.destination = b;
        try {
          dd(a, b);
        } catch (c) {
          Y(a, c), Tc(a, c);
        }
      }
    }
    function ld(a, b) {
      try {
        var c = a.abortableTasks;
        c.forEach(function(c2) {
          return cd(c2, a, b);
        }), c.clear(), a.destination !== null && dd(a, a.destination);
      } catch (d) {
        Y(a, d), Tc(a, d);
      }
    }
    function md(a, b) {
      return function() {
        return kd(b, a);
      };
    }
    function nd(a, b) {
      return function() {
        return ld(a, b);
      };
    }
    function od(a, b) {
      var c = b ? b.identifierPrefix : void 0, d = b ? b.nonce : void 0, f3 = b ? b.bootstrapScriptContent : void 0, e2 = b ? b.bootstrapScripts : void 0, g = b ? b.bootstrapModules : void 0;
      c = c === void 0 ? "" : c, d = d === void 0 ? ra : x2('<script nonce="' + F2(d) + '">');
      var h2 = [];
      if (f3 !== void 0 && h2.push(d, ("" + f3).replace(wa, xa), sa), e2 !== void 0)
        for (f3 = 0; f3 < e2.length; f3++)
          h2.push(ta, F2(e2[f3]), va);
      if (g !== void 0)
        for (e2 = 0; e2 < g.length; e2++)
          h2.push(ua, F2(g[e2]), va);
      g = {
        bootstrapChunks: h2,
        startInlineScript: d,
        placeholderPrefix: x2(c + "P:"),
        segmentPrefix: x2(c + "S:"),
        boundaryPrefix: c + "B:",
        idPrefix: c,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      }, e2 = b ? b.namespaceURI : void 0, e2 = G(e2 === "http://www.w3.org/2000/svg" ? 2 : e2 === "http://www.w3.org/1998/Math/MathML" ? 3 : 0, null), f3 = b ? b.progressiveChunkSize : void 0, d = b ? b.onError : void 0, h2 = b ? b.onAllReady : void 0;
      var m2 = b ? b.onShellReady : void 0, n = b ? b.onShellError : void 0;
      return b = [], c = /* @__PURE__ */ new Set(), g = {
        destination: null,
        responseState: g,
        progressiveChunkSize: f3 === void 0 ? 12800 : f3,
        status: 0,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: c,
        pingedTasks: b,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: d === void 0 ? Oc : d,
        onAllReady: h2 === void 0 ? X : h2,
        onShellReady: m2 === void 0 ? X : m2,
        onShellError: n === void 0 ? X : n,
        onFatalError: X
      }, e2 = Sc(g, 0, null, e2, !1, !1), e2.parentFlushed = !0, a = Rc(g, a, null, e2, c, hc, null, qc), b.push(a), g;
    }
    exports.renderToPipeableStream = function(a, b) {
      var c = od(a, b), d = !1;
      return jd(c), { pipe: function(a2) {
        if (d)
          throw Error("React currently only supports piping to one writable stream.");
        return d = !0, kd(c, a2), a2.on("drain", md(a2, c)), a2.on("error", nd(c, Error("The destination stream errored while writing data."))), a2.on("close", nd(c, Error("The destination stream closed early."))), a2;
      }, abort: function(a2) {
        ld(c, a2);
      } };
    };
    exports.version = "18.2.0";
  }
});

// node_modules/react-dom/server.node.js
var require_server_node = __commonJS({
  "node_modules/react-dom/server.node.js"(exports) {
    "use strict";
    var l, s2;
    l = require_react_dom_server_legacy_node_production_min(), s2 = require_react_dom_server_node_production_min();
    exports.version = l.version;
    exports.renderToString = l.renderToString;
    exports.renderToStaticMarkup = l.renderToStaticMarkup;
    exports.renderToNodeStream = l.renderToNodeStream;
    exports.renderToStaticNodeStream = l.renderToStaticNodeStream;
    exports.renderToPipeableStream = s2.renderToPipeableStream;
  }
});

// node_modules/react/cjs/react-jsx-runtime.production.min.js
var require_react_jsx_runtime_production_min = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.production.min.js"(exports) {
    "use strict";
    var f3 = require_react(), k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m2 = Object.prototype.hasOwnProperty, n = f3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: !0, ref: !0, __self: !0, __source: !0 };
    function q(c, a, g) {
      var b, d = {}, e2 = null, h2 = null;
      g !== void 0 && (e2 = "" + g), a.key !== void 0 && (e2 = "" + a.key), a.ref !== void 0 && (h2 = a.ref);
      for (b in a)
        m2.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
      if (c && c.defaultProps)
        for (b in a = c.defaultProps, a)
          d[b] === void 0 && (d[b] = a[b]);
      return { $$typeof: k, type: c, key: e2, ref: h2, props: d, _owner: n.current };
    }
    exports.Fragment = l;
    exports.jsx = q;
    exports.jsxs = q;
  }
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "node_modules/react/jsx-runtime.js"(exports, module2) {
    "use strict";
    module2.exports = require_react_jsx_runtime_production_min();
  }
});

// node_modules/map-obj/index.js
var require_map_obj = __commonJS({
  "node_modules/map-obj/index.js"(exports, module2) {
    "use strict";
    var isObject2 = (value) => typeof value == "object" && value !== null, mapObjectSkip = Symbol("skip"), isObjectCustom = (value) => isObject2(value) && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date), mapObject2 = (object, mapper, options, isSeen = /* @__PURE__ */ new WeakMap()) => {
      if (options = {
        deep: !1,
        target: {},
        ...options
      }, isSeen.has(object))
        return isSeen.get(object);
      isSeen.set(object, options.target);
      let { target } = options;
      delete options.target;
      let mapArray = (array) => array.map((element) => isObjectCustom(element) ? mapObject2(element, mapper, options, isSeen) : element);
      if (Array.isArray(object))
        return mapArray(object);
      for (let [key, value] of Object.entries(object)) {
        let mapResult = mapper(key, value, object);
        if (mapResult === mapObjectSkip)
          continue;
        let [newKey, newValue, { shouldRecurse = !0 } = {}] = mapResult;
        newKey !== "__proto__" && (options.deep && shouldRecurse && isObjectCustom(newValue) && (newValue = Array.isArray(newValue) ? mapArray(newValue) : mapObject2(newValue, mapper, options, isSeen)), target[newKey] = newValue);
      }
      return target;
    };
    module2.exports = (object, mapper, options) => {
      if (!isObject2(object))
        throw new TypeError(`Expected an object, got \`${object}\` (${typeof object})`);
      return mapObject2(object, mapper, options);
    };
    module2.exports.mapObjectSkip = mapObjectSkip;
  }
});

// node_modules/lodash.merge/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.merge/index.js"(exports, module2) {
    var LARGE_ARRAY_SIZE = 200, HASH_UNDEFINED = "__lodash_hash_undefined__", HOT_COUNT = 800, HOT_SPAN = 16, MAX_SAFE_INTEGER = 9007199254740991, argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, reIsUint = /^(?:0|[1-9]\d*)$/, typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = !1;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global, freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), freeExports = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2, moduleExports = freeModule && freeModule.exports === freeExports, freeProcess = moduleExports && freeGlobal.process, nodeUtil = function() {
      try {
        var types3 = freeModule && freeModule.require && freeModule.require("util").types;
        return types3 || freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch {
      }
    }(), nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n, iteratee) {
      for (var index = -1, result = Array(n); ++index < n; )
        result[index] = iteratee(index);
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype, coreJsData = root["__core-js_shared__"], funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }(), nativeObjectToString = objectProto.toString, objectCtorString = funcToString.call(Object), reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    ), Buffer4 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, allocUnsafe = Buffer4 ? Buffer4.allocUnsafe : void 0, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0, defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        return func({}, "", {}), func;
      } catch {
      }
    }(), nativeIsBuffer = Buffer4 ? Buffer4.isBuffer : void 0, nativeMax = Math.max, nativeNow = Date.now, Map2 = getNative(root, "Map"), nativeCreate = getNative(Object, "create"), baseCreate = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject2(proto))
          return {};
        if (objectCreate)
          return objectCreate(proto);
        object.prototype = proto;
        var result = new object();
        return object.prototype = void 0, result;
      };
    }();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      for (this.clear(); ++index < length; ) {
        var entry2 = entries[index];
        this.set(entry2[0], entry2[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      return this.size -= result ? 1 : 0, result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      return this.size += this.has(key) ? 0 : 1, data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value, this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype.delete = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      for (this.clear(); ++index < length; ) {
        var entry2 = entries[index];
        this.set(entry2[0], entry2[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [], this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0)
        return !1;
      var lastIndex = data.length - 1;
      return index == lastIndex ? data.pop() : splice.call(data, index, 1), --this.size, !0;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? (++this.size, data.push([key, value])) : data[index][1] = value, this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype.delete = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      for (this.clear(); ++index < length; ) {
        var entry2 = entries[index];
        this.set(entry2[0], entry2[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0, this.__data__ = {
        hash: new Hash(),
        map: new (Map2 || ListCache)(),
        string: new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key).delete(key);
      return this.size -= result ? 1 : 0, result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      return data.set(key, value), this.size += data.size == size ? 0 : 1, this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype.delete = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache(), this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data.delete(key);
      return this.size = data.size, result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1)
          return pairs.push([key, value]), this.size = ++data.size, this;
        data = this.__data__ = new MapCache(pairs);
      }
      return data.set(key, value), this.size = data.size, this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype.delete = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value)
        (inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length))) && result.push(key);
      return result;
    }
    function assignMergeValue(object, key, value) {
      (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) && baseAssignValue(object, key, value);
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) && baseAssignValue(object, key, value);
    }
    function assocIndexOf(array, key) {
      for (var length = array.length; length--; )
        if (eq(array[length][0], key))
          return length;
      return -1;
    }
    function baseAssignValue(object, key, value) {
      key == "__proto__" && defineProperty ? defineProperty(object, key, {
        configurable: !0,
        enumerable: !0,
        value,
        writable: !0
      }) : object[key] = value;
    }
    var baseFor = createBaseFor();
    function baseGetTag(value) {
      return value == null ? value === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value))
        return !1;
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeysIn(object) {
      if (!isObject2(object))
        return nativeKeysIn(object);
      var isProto = isPrototype(object), result = [];
      for (var key in object)
        key == "constructor" && (isProto || !hasOwnProperty.call(object, key)) || result.push(key);
      return result;
    }
    function baseMerge(object, source, srcIndex, customizer, stack) {
      object !== source && baseFor(source, function(srcValue, key) {
        if (stack || (stack = new Stack()), isObject2(srcValue))
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          newValue === void 0 && (newValue = srcValue), assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0, isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue, isArr || isBuff || isTyped ? isArray(objValue) ? newValue = objValue : isArrayLikeObject(objValue) ? newValue = copyArray(objValue) : isBuff ? (isCommon = !1, newValue = cloneBuffer(srcValue, !0)) : isTyped ? (isCommon = !1, newValue = cloneTypedArray(srcValue, !0)) : newValue = [] : isPlainObject(srcValue) || isArguments(srcValue) ? (newValue = objValue, isArguments(objValue) ? newValue = toPlainObject(objValue) : (!isObject2(objValue) || isFunction(objValue)) && (newValue = initCloneObject(srcValue))) : isCommon = !1;
      }
      isCommon && (stack.set(srcValue, newValue), mergeFunc(newValue, srcValue, srcIndex, customizer, stack), stack.delete(srcValue)), assignMergeValue(object, key, newValue);
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    var baseSetToString = defineProperty ? function(func, string) {
      return defineProperty(func, "toString", {
        configurable: !0,
        enumerable: !1,
        value: constant(string),
        writable: !0
      });
    } : identity;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep)
        return buffer.slice();
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      return buffer.copy(result), result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      return new Uint8Array2(result).set(new Uint8Array2(arrayBuffer)), result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      for (array || (array = Array(length)); ++index < length; )
        array[index] = source[index];
      return array;
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      for (var index = -1, length = props.length; ++index < length; ) {
        var key = props[index], newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        newValue === void 0 && (newValue = source[key]), isNew ? baseAssignValue(object, key, newValue) : assignValue(object, key, newValue);
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        for (customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0, guard && isIterateeCall(sources[0], sources[1], guard) && (customizer = length < 3 ? void 0 : customizer, length = 1), object = Object(object); ++index < length; ) {
          var source = sources[index];
          source && assigner(object, source, index, customizer);
        }
        return object;
      });
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        for (var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length; length--; ) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === !1)
            break;
        }
        return object;
      };
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = !0;
      } catch {
      }
      var result = nativeObjectToString.call(value);
      return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]), result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function isIndex(value, length) {
      var type = typeof value;
      return length = length ?? MAX_SAFE_INTEGER, !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
    }
    function isIterateeCall(value, index, object) {
      if (!isObject2(object))
        return !1;
      var type = typeof index;
      return (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) ? eq(object[index], value) : !1;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null)
        for (var key in Object(object))
          result.push(key);
      return result;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function overRest(func, start, transform) {
      return start = nativeMax(start === void 0 ? func.length - 1 : start, 0), function() {
        for (var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length); ++index < length; )
          array[index] = args[start + index];
        index = -1;
        for (var otherArgs = Array(start + 1); ++index < start; )
          otherArgs[index] = args[index];
        return otherArgs[start] = transform(array), apply(func, this, otherArgs);
      };
    }
    function safeGet(object, key) {
      if (!(key === "constructor" && typeof object[key] == "function") && key != "__proto__")
        return object[key];
    }
    var setToString = shortOut(baseSetToString);
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        if (lastCalled = stamp, remaining > 0) {
          if (++count >= HOT_COUNT)
            return arguments[0];
        } else
          count = 0;
        return func.apply(void 0, arguments);
      };
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch {
        }
        try {
          return func + "";
        } catch {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    }, isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      if (!isObject2(value))
        return !1;
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag)
        return !1;
      var proto = getPrototype(value);
      if (proto === null)
        return !0;
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, !0) : baseKeysIn(object);
    }
    var merge2 = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    function constant(value) {
      return function() {
        return value;
      };
    }
    function identity(value) {
      return value;
    }
    function stubFalse() {
      return !1;
    }
    module2.exports = merge2;
  }
});

// node_modules/web-streams-polyfill/dist/ponyfill.es2018.js
var require_ponyfill_es2018 = __commonJS({
  "node_modules/web-streams-polyfill/dist/ponyfill.es2018.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports == "object" && typeof module2 < "u" ? factory(exports) : typeof define == "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis < "u" ? globalThis : global2 || self, factory(global2.WebStreamsPolyfill = {}));
    })(exports, function(exports2) {
      "use strict";
      let SymbolPolyfill = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol : (description) => `Symbol(${description})`;
      function noop2() {
      }
      function getGlobals() {
        if (typeof self < "u")
          return self;
        if (typeof window < "u")
          return window;
        if (typeof global < "u")
          return global;
      }
      let globals = getGlobals();
      function typeIsObject(x2) {
        return typeof x2 == "object" && x2 !== null || typeof x2 == "function";
      }
      let rethrowAssertionErrorRejection = noop2, originalPromise = Promise, originalPromiseThen = Promise.prototype.then, originalPromiseResolve = Promise.resolve.bind(originalPromise), originalPromiseReject = Promise.reject.bind(originalPromise);
      function newPromise(executor) {
        return new originalPromise(executor);
      }
      function promiseResolvedWith(value) {
        return originalPromiseResolve(value);
      }
      function promiseRejectedWith(reason) {
        return originalPromiseReject(reason);
      }
      function PerformPromiseThen(promise, onFulfilled, onRejected) {
        return originalPromiseThen.call(promise, onFulfilled, onRejected);
      }
      function uponPromise(promise, onFulfilled, onRejected) {
        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
      }
      function uponFulfillment(promise, onFulfilled) {
        uponPromise(promise, onFulfilled);
      }
      function uponRejection(promise, onRejected) {
        uponPromise(promise, void 0, onRejected);
      }
      function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
      }
      function setPromiseIsHandledToTrue(promise) {
        PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
      }
      let queueMicrotask = (() => {
        let globalQueueMicrotask = globals && globals.queueMicrotask;
        if (typeof globalQueueMicrotask == "function")
          return globalQueueMicrotask;
        let resolvedPromise = promiseResolvedWith(void 0);
        return (fn) => PerformPromiseThen(resolvedPromise, fn);
      })();
      function reflectCall(F2, V, args) {
        if (typeof F2 != "function")
          throw new TypeError("Argument is not a function");
        return Function.prototype.apply.call(F2, V, args);
      }
      function promiseCall(F2, V, args) {
        try {
          return promiseResolvedWith(reflectCall(F2, V, args));
        } catch (value) {
          return promiseRejectedWith(value);
        }
      }
      let QUEUE_MAX_ARRAY_SIZE = 16384;
      class SimpleQueue {
        constructor() {
          this._cursor = 0, this._size = 0, this._front = {
            _elements: [],
            _next: void 0
          }, this._back = this._front, this._cursor = 0, this._size = 0;
        }
        get length() {
          return this._size;
        }
        // For exception safety, this method is structured in order:
        // 1. Read state
        // 2. Calculate required state mutations
        // 3. Perform state mutations
        push(element) {
          let oldBack = this._back, newBack = oldBack;
          oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1 && (newBack = {
            _elements: [],
            _next: void 0
          }), oldBack._elements.push(element), newBack !== oldBack && (this._back = newBack, oldBack._next = newBack), ++this._size;
        }
        // Like push(), shift() follows the read -> calculate -> mutate pattern for
        // exception safety.
        shift() {
          let oldFront = this._front, newFront = oldFront, oldCursor = this._cursor, newCursor = oldCursor + 1, elements = oldFront._elements, element = elements[oldCursor];
          return newCursor === QUEUE_MAX_ARRAY_SIZE && (newFront = oldFront._next, newCursor = 0), --this._size, this._cursor = newCursor, oldFront !== newFront && (this._front = newFront), elements[oldCursor] = void 0, element;
        }
        // The tricky thing about forEach() is that it can be called
        // re-entrantly. The queue may be mutated inside the callback. It is easy to
        // see that push() within the callback has no negative effects since the end
        // of the queue is checked for on every iteration. If shift() is called
        // repeatedly within the callback then the next iteration may return an
        // element that has been removed. In this case the callback will be called
        // with undefined values until we either "catch up" with elements that still
        // exist or reach the back of the queue.
        forEach(callback) {
          let i2 = this._cursor, node = this._front, elements = node._elements;
          for (; (i2 !== elements.length || node._next !== void 0) && !(i2 === elements.length && (node = node._next, elements = node._elements, i2 = 0, elements.length === 0)); )
            callback(elements[i2]), ++i2;
        }
        // Return the element that would be returned if shift() was called now,
        // without modifying the queue.
        peek() {
          let front = this._front, cursor = this._cursor;
          return front._elements[cursor];
        }
      }
      function ReadableStreamReaderGenericInitialize(reader, stream) {
        reader._ownerReadableStream = stream, stream._reader = reader, stream._state === "readable" ? defaultReaderClosedPromiseInitialize(reader) : stream._state === "closed" ? defaultReaderClosedPromiseInitializeAsResolved(reader) : defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
      }
      function ReadableStreamReaderGenericCancel(reader, reason) {
        let stream = reader._ownerReadableStream;
        return ReadableStreamCancel(stream, reason);
      }
      function ReadableStreamReaderGenericRelease(reader) {
        reader._ownerReadableStream._state === "readable" ? defaultReaderClosedPromiseReject(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : defaultReaderClosedPromiseResetToRejected(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), reader._ownerReadableStream._reader = void 0, reader._ownerReadableStream = void 0;
      }
      function readerLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released reader");
      }
      function defaultReaderClosedPromiseInitialize(reader) {
        reader._closedPromise = newPromise((resolve, reject) => {
          reader._closedPromise_resolve = resolve, reader._closedPromise_reject = reject;
        });
      }
      function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
        defaultReaderClosedPromiseInitialize(reader), defaultReaderClosedPromiseReject(reader, reason);
      }
      function defaultReaderClosedPromiseInitializeAsResolved(reader) {
        defaultReaderClosedPromiseInitialize(reader), defaultReaderClosedPromiseResolve(reader);
      }
      function defaultReaderClosedPromiseReject(reader, reason) {
        reader._closedPromise_reject !== void 0 && (setPromiseIsHandledToTrue(reader._closedPromise), reader._closedPromise_reject(reason), reader._closedPromise_resolve = void 0, reader._closedPromise_reject = void 0);
      }
      function defaultReaderClosedPromiseResetToRejected(reader, reason) {
        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
      }
      function defaultReaderClosedPromiseResolve(reader) {
        reader._closedPromise_resolve !== void 0 && (reader._closedPromise_resolve(void 0), reader._closedPromise_resolve = void 0, reader._closedPromise_reject = void 0);
      }
      let AbortSteps = SymbolPolyfill("[[AbortSteps]]"), ErrorSteps = SymbolPolyfill("[[ErrorSteps]]"), CancelSteps = SymbolPolyfill("[[CancelSteps]]"), PullSteps = SymbolPolyfill("[[PullSteps]]"), NumberIsFinite = Number.isFinite || function(x2) {
        return typeof x2 == "number" && isFinite(x2);
      }, MathTrunc = Math.trunc || function(v) {
        return v < 0 ? Math.ceil(v) : Math.floor(v);
      };
      function isDictionary(x2) {
        return typeof x2 == "object" || typeof x2 == "function";
      }
      function assertDictionary(obj, context) {
        if (obj !== void 0 && !isDictionary(obj))
          throw new TypeError(`${context} is not an object.`);
      }
      function assertFunction(x2, context) {
        if (typeof x2 != "function")
          throw new TypeError(`${context} is not a function.`);
      }
      function isObject2(x2) {
        return typeof x2 == "object" && x2 !== null || typeof x2 == "function";
      }
      function assertObject(x2, context) {
        if (!isObject2(x2))
          throw new TypeError(`${context} is not an object.`);
      }
      function assertRequiredArgument(x2, position, context) {
        if (x2 === void 0)
          throw new TypeError(`Parameter ${position} is required in '${context}'.`);
      }
      function assertRequiredField(x2, field, context) {
        if (x2 === void 0)
          throw new TypeError(`${field} is required in '${context}'.`);
      }
      function convertUnrestrictedDouble(value) {
        return Number(value);
      }
      function censorNegativeZero(x2) {
        return x2 === 0 ? 0 : x2;
      }
      function integerPart(x2) {
        return censorNegativeZero(MathTrunc(x2));
      }
      function convertUnsignedLongLongWithEnforceRange(value, context) {
        let upperBound = Number.MAX_SAFE_INTEGER, x2 = Number(value);
        if (x2 = censorNegativeZero(x2), !NumberIsFinite(x2))
          throw new TypeError(`${context} is not a finite number`);
        if (x2 = integerPart(x2), x2 < 0 || x2 > upperBound)
          throw new TypeError(`${context} is outside the accepted range of 0 to ${upperBound}, inclusive`);
        return !NumberIsFinite(x2) || x2 === 0 ? 0 : x2;
      }
      function assertReadableStream(x2, context) {
        if (!IsReadableStream(x2))
          throw new TypeError(`${context} is not a ReadableStream.`);
      }
      function AcquireReadableStreamDefaultReader(stream) {
        return new ReadableStreamDefaultReader(stream);
      }
      function ReadableStreamAddReadRequest(stream, readRequest) {
        stream._reader._readRequests.push(readRequest);
      }
      function ReadableStreamFulfillReadRequest(stream, chunk, done) {
        let readRequest = stream._reader._readRequests.shift();
        done ? readRequest._closeSteps() : readRequest._chunkSteps(chunk);
      }
      function ReadableStreamGetNumReadRequests(stream) {
        return stream._reader._readRequests.length;
      }
      function ReadableStreamHasDefaultReader(stream) {
        let reader = stream._reader;
        return !(reader === void 0 || !IsReadableStreamDefaultReader(reader));
      }
      class ReadableStreamDefaultReader {
        constructor(stream) {
          if (assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader"), assertReadableStream(stream, "First parameter"), IsReadableStreamLocked(stream))
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          ReadableStreamReaderGenericInitialize(this, stream), this._readRequests = new SimpleQueue();
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed,
         * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
         */
        get closed() {
          return IsReadableStreamDefaultReader(this) ? this._closedPromise : promiseRejectedWith(defaultReaderBrandCheckException("closed"));
        }
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */
        cancel(reason = void 0) {
          return IsReadableStreamDefaultReader(this) ? this._ownerReadableStream === void 0 ? promiseRejectedWith(readerLockException("cancel")) : ReadableStreamReaderGenericCancel(this, reason) : promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
        }
        /**
         * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.
         *
         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
         */
        read() {
          if (!IsReadableStreamDefaultReader(this))
            return promiseRejectedWith(defaultReaderBrandCheckException("read"));
          if (this._ownerReadableStream === void 0)
            return promiseRejectedWith(readerLockException("read from"));
          let resolvePromise, rejectPromise, promise = newPromise((resolve, reject) => {
            resolvePromise = resolve, rejectPromise = reject;
          });
          return ReadableStreamDefaultReaderRead(this, {
            _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: !1 }),
            _closeSteps: () => resolvePromise({ value: void 0, done: !0 }),
            _errorSteps: (e2) => rejectPromise(e2)
          }), promise;
        }
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */
        releaseLock() {
          if (!IsReadableStreamDefaultReader(this))
            throw defaultReaderBrandCheckException("releaseLock");
          if (this._ownerReadableStream !== void 0) {
            if (this._readRequests.length > 0)
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            ReadableStreamReaderGenericRelease(this);
          }
        }
      }
      Object.defineProperties(ReadableStreamDefaultReader.prototype, {
        cancel: { enumerable: !0 },
        read: { enumerable: !0 },
        releaseLock: { enumerable: !0 },
        closed: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamDefaultReader",
        configurable: !0
      });
      function IsReadableStreamDefaultReader(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_readRequests") ? !1 : x2 instanceof ReadableStreamDefaultReader;
      }
      function ReadableStreamDefaultReaderRead(reader, readRequest) {
        let stream = reader._ownerReadableStream;
        stream._disturbed = !0, stream._state === "closed" ? readRequest._closeSteps() : stream._state === "errored" ? readRequest._errorSteps(stream._storedError) : stream._readableStreamController[PullSteps](readRequest);
      }
      function defaultReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
      }
      let AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
      }).prototype);
      class ReadableStreamAsyncIteratorImpl {
        constructor(reader, preventCancel) {
          this._ongoingPromise = void 0, this._isFinished = !1, this._reader = reader, this._preventCancel = preventCancel;
        }
        next() {
          let nextSteps = () => this._nextSteps();
          return this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps(), this._ongoingPromise;
        }
        return(value) {
          let returnSteps = () => this._returnSteps(value);
          return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
        }
        _nextSteps() {
          if (this._isFinished)
            return Promise.resolve({ value: void 0, done: !0 });
          let reader = this._reader;
          if (reader._ownerReadableStream === void 0)
            return promiseRejectedWith(readerLockException("iterate"));
          let resolvePromise, rejectPromise, promise = newPromise((resolve, reject) => {
            resolvePromise = resolve, rejectPromise = reject;
          });
          return ReadableStreamDefaultReaderRead(reader, {
            _chunkSteps: (chunk) => {
              this._ongoingPromise = void 0, queueMicrotask(() => resolvePromise({ value: chunk, done: !1 }));
            },
            _closeSteps: () => {
              this._ongoingPromise = void 0, this._isFinished = !0, ReadableStreamReaderGenericRelease(reader), resolvePromise({ value: void 0, done: !0 });
            },
            _errorSteps: (reason) => {
              this._ongoingPromise = void 0, this._isFinished = !0, ReadableStreamReaderGenericRelease(reader), rejectPromise(reason);
            }
          }), promise;
        }
        _returnSteps(value) {
          if (this._isFinished)
            return Promise.resolve({ value, done: !0 });
          this._isFinished = !0;
          let reader = this._reader;
          if (reader._ownerReadableStream === void 0)
            return promiseRejectedWith(readerLockException("finish iterating"));
          if (!this._preventCancel) {
            let result = ReadableStreamReaderGenericCancel(reader, value);
            return ReadableStreamReaderGenericRelease(reader), transformPromiseWith(result, () => ({ value, done: !0 }));
          }
          return ReadableStreamReaderGenericRelease(reader), promiseResolvedWith({ value, done: !0 });
        }
      }
      let ReadableStreamAsyncIteratorPrototype = {
        next() {
          return IsReadableStreamAsyncIterator(this) ? this._asyncIteratorImpl.next() : promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
        },
        return(value) {
          return IsReadableStreamAsyncIterator(this) ? this._asyncIteratorImpl.return(value) : promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
        }
      };
      AsyncIteratorPrototype !== void 0 && Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
      function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
        let reader = AcquireReadableStreamDefaultReader(stream), impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel), iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
        return iterator._asyncIteratorImpl = impl, iterator;
      }
      function IsReadableStreamAsyncIterator(x2) {
        if (!typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_asyncIteratorImpl"))
          return !1;
        try {
          return x2._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
        } catch {
          return !1;
        }
      }
      function streamAsyncIteratorBrandCheckException(name) {
        return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
      }
      let NumberIsNaN = Number.isNaN || function(x2) {
        return x2 !== x2;
      };
      function CreateArrayFromList(elements) {
        return elements.slice();
      }
      function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
      }
      function TransferArrayBuffer(O) {
        return O;
      }
      function IsDetachedBuffer(O) {
        return !1;
      }
      function ArrayBufferSlice(buffer, begin, end) {
        if (buffer.slice)
          return buffer.slice(begin, end);
        let length = end - begin, slice = new ArrayBuffer(length);
        return CopyDataBlockBytes(slice, 0, buffer, begin, length), slice;
      }
      function IsNonNegativeNumber(v) {
        return !(typeof v != "number" || NumberIsNaN(v) || v < 0);
      }
      function CloneAsUint8Array(O) {
        let buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
        return new Uint8Array(buffer);
      }
      function DequeueValue(container) {
        let pair = container._queue.shift();
        return container._queueTotalSize -= pair.size, container._queueTotalSize < 0 && (container._queueTotalSize = 0), pair.value;
      }
      function EnqueueValueWithSize(container, value, size) {
        if (!IsNonNegativeNumber(size) || size === 1 / 0)
          throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
        container._queue.push({ value, size }), container._queueTotalSize += size;
      }
      function PeekQueueValue(container) {
        return container._queue.peek().value;
      }
      function ResetQueue(container) {
        container._queue = new SimpleQueue(), container._queueTotalSize = 0;
      }
      class ReadableStreamBYOBRequest {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
         */
        get view() {
          if (!IsReadableStreamBYOBRequest(this))
            throw byobRequestBrandCheckException("view");
          return this._view;
        }
        respond(bytesWritten) {
          if (!IsReadableStreamBYOBRequest(this))
            throw byobRequestBrandCheckException("respond");
          if (assertRequiredArgument(bytesWritten, 1, "respond"), bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter"), this._associatedReadableByteStreamController === void 0)
            throw new TypeError("This BYOB request has been invalidated");
          IsDetachedBuffer(this._view.buffer), ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
        }
        respondWithNewView(view) {
          if (!IsReadableStreamBYOBRequest(this))
            throw byobRequestBrandCheckException("respondWithNewView");
          if (assertRequiredArgument(view, 1, "respondWithNewView"), !ArrayBuffer.isView(view))
            throw new TypeError("You can only respond with array buffer views");
          if (this._associatedReadableByteStreamController === void 0)
            throw new TypeError("This BYOB request has been invalidated");
          IsDetachedBuffer(view.buffer), ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
        }
      }
      Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
        respond: { enumerable: !0 },
        respondWithNewView: { enumerable: !0 },
        view: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamBYOBRequest",
        configurable: !0
      });
      class ReadableByteStreamController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the current BYOB pull request, or `null` if there isn't one.
         */
        get byobRequest() {
          if (!IsReadableByteStreamController(this))
            throw byteStreamControllerBrandCheckException("byobRequest");
          return ReadableByteStreamControllerGetBYOBRequest(this);
        }
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
         */
        get desiredSize() {
          if (!IsReadableByteStreamController(this))
            throw byteStreamControllerBrandCheckException("desiredSize");
          return ReadableByteStreamControllerGetDesiredSize(this);
        }
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */
        close() {
          if (!IsReadableByteStreamController(this))
            throw byteStreamControllerBrandCheckException("close");
          if (this._closeRequested)
            throw new TypeError("The stream has already been closed; do not close it again!");
          let state = this._controlledReadableByteStream._state;
          if (state !== "readable")
            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
          ReadableByteStreamControllerClose(this);
        }
        enqueue(chunk) {
          if (!IsReadableByteStreamController(this))
            throw byteStreamControllerBrandCheckException("enqueue");
          if (assertRequiredArgument(chunk, 1, "enqueue"), !ArrayBuffer.isView(chunk))
            throw new TypeError("chunk must be an array buffer view");
          if (chunk.byteLength === 0)
            throw new TypeError("chunk must have non-zero byteLength");
          if (chunk.buffer.byteLength === 0)
            throw new TypeError("chunk's buffer must have non-zero byteLength");
          if (this._closeRequested)
            throw new TypeError("stream is closed or draining");
          let state = this._controlledReadableByteStream._state;
          if (state !== "readable")
            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
          ReadableByteStreamControllerEnqueue(this, chunk);
        }
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */
        error(e2 = void 0) {
          if (!IsReadableByteStreamController(this))
            throw byteStreamControllerBrandCheckException("error");
          ReadableByteStreamControllerError(this, e2);
        }
        /** @internal */
        [CancelSteps](reason) {
          ReadableByteStreamControllerClearPendingPullIntos(this), ResetQueue(this);
          let result = this._cancelAlgorithm(reason);
          return ReadableByteStreamControllerClearAlgorithms(this), result;
        }
        /** @internal */
        [PullSteps](readRequest) {
          let stream = this._controlledReadableByteStream;
          if (this._queueTotalSize > 0) {
            let entry2 = this._queue.shift();
            this._queueTotalSize -= entry2.byteLength, ReadableByteStreamControllerHandleQueueDrain(this);
            let view = new Uint8Array(entry2.buffer, entry2.byteOffset, entry2.byteLength);
            readRequest._chunkSteps(view);
            return;
          }
          let autoAllocateChunkSize = this._autoAllocateChunkSize;
          if (autoAllocateChunkSize !== void 0) {
            let buffer;
            try {
              buffer = new ArrayBuffer(autoAllocateChunkSize);
            } catch (bufferE) {
              readRequest._errorSteps(bufferE);
              return;
            }
            let pullIntoDescriptor = {
              buffer,
              bufferByteLength: autoAllocateChunkSize,
              byteOffset: 0,
              byteLength: autoAllocateChunkSize,
              bytesFilled: 0,
              elementSize: 1,
              viewConstructor: Uint8Array,
              readerType: "default"
            };
            this._pendingPullIntos.push(pullIntoDescriptor);
          }
          ReadableStreamAddReadRequest(stream, readRequest), ReadableByteStreamControllerCallPullIfNeeded(this);
        }
      }
      Object.defineProperties(ReadableByteStreamController.prototype, {
        close: { enumerable: !0 },
        enqueue: { enumerable: !0 },
        error: { enumerable: !0 },
        byobRequest: { enumerable: !0 },
        desiredSize: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableByteStreamController",
        configurable: !0
      });
      function IsReadableByteStreamController(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_controlledReadableByteStream") ? !1 : x2 instanceof ReadableByteStreamController;
      }
      function IsReadableStreamBYOBRequest(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_associatedReadableByteStreamController") ? !1 : x2 instanceof ReadableStreamBYOBRequest;
      }
      function ReadableByteStreamControllerCallPullIfNeeded(controller) {
        if (!ReadableByteStreamControllerShouldCallPull(controller))
          return;
        if (controller._pulling) {
          controller._pullAgain = !0;
          return;
        }
        controller._pulling = !0;
        let pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
          controller._pulling = !1, controller._pullAgain && (controller._pullAgain = !1, ReadableByteStreamControllerCallPullIfNeeded(controller));
        }, (e2) => {
          ReadableByteStreamControllerError(controller, e2);
        });
      }
      function ReadableByteStreamControllerClearPendingPullIntos(controller) {
        ReadableByteStreamControllerInvalidateBYOBRequest(controller), controller._pendingPullIntos = new SimpleQueue();
      }
      function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
        let done = !1;
        stream._state === "closed" && (done = !0);
        let filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        pullIntoDescriptor.readerType === "default" ? ReadableStreamFulfillReadRequest(stream, filledView, done) : ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
      }
      function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
        let bytesFilled = pullIntoDescriptor.bytesFilled, elementSize = pullIntoDescriptor.elementSize;
        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
      }
      function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
        controller._queue.push({ buffer, byteOffset, byteLength }), controller._queueTotalSize += byteLength;
      }
      function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
        let elementSize = pullIntoDescriptor.elementSize, currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize, maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled), maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy, maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize, totalBytesToCopyRemaining = maxBytesToCopy, ready = !1;
        maxAlignedBytes > currentAlignedBytes && (totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled, ready = !0);
        let queue = controller._queue;
        for (; totalBytesToCopyRemaining > 0; ) {
          let headOfQueue = queue.peek(), bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength), destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy), headOfQueue.byteLength === bytesToCopy ? queue.shift() : (headOfQueue.byteOffset += bytesToCopy, headOfQueue.byteLength -= bytesToCopy), controller._queueTotalSize -= bytesToCopy, ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor), totalBytesToCopyRemaining -= bytesToCopy;
        }
        return ready;
      }
      function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
        pullIntoDescriptor.bytesFilled += size;
      }
      function ReadableByteStreamControllerHandleQueueDrain(controller) {
        controller._queueTotalSize === 0 && controller._closeRequested ? (ReadableByteStreamControllerClearAlgorithms(controller), ReadableStreamClose(controller._controlledReadableByteStream)) : ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
        controller._byobRequest !== null && (controller._byobRequest._associatedReadableByteStreamController = void 0, controller._byobRequest._view = null, controller._byobRequest = null);
      }
      function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
        for (; controller._pendingPullIntos.length > 0; ) {
          if (controller._queueTotalSize === 0)
            return;
          let pullIntoDescriptor = controller._pendingPullIntos.peek();
          ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) && (ReadableByteStreamControllerShiftPendingPullInto(controller), ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor));
        }
      }
      function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
        let stream = controller._controlledReadableByteStream, elementSize = 1;
        view.constructor !== DataView && (elementSize = view.constructor.BYTES_PER_ELEMENT);
        let ctor = view.constructor, buffer = view.buffer, pullIntoDescriptor = {
          buffer,
          bufferByteLength: buffer.byteLength,
          byteOffset: view.byteOffset,
          byteLength: view.byteLength,
          bytesFilled: 0,
          elementSize,
          viewConstructor: ctor,
          readerType: "byob"
        };
        if (controller._pendingPullIntos.length > 0) {
          controller._pendingPullIntos.push(pullIntoDescriptor), ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          return;
        }
        if (stream._state === "closed") {
          let emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
          readIntoRequest._closeSteps(emptyView);
          return;
        }
        if (controller._queueTotalSize > 0) {
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            let filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
            ReadableByteStreamControllerHandleQueueDrain(controller), readIntoRequest._chunkSteps(filledView);
            return;
          }
          if (controller._closeRequested) {
            let e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e2), readIntoRequest._errorSteps(e2);
            return;
          }
        }
        controller._pendingPullIntos.push(pullIntoDescriptor), ReadableStreamAddReadIntoRequest(stream, readIntoRequest), ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
        let stream = controller._controlledReadableByteStream;
        if (ReadableStreamHasBYOBReader(stream))
          for (; ReadableStreamGetNumReadIntoRequests(stream) > 0; ) {
            let pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
          }
      }
      function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
        if (ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor), pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize)
          return;
        ReadableByteStreamControllerShiftPendingPullInto(controller);
        let remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
        if (remainderSize > 0) {
          let end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled, remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
        }
        pullIntoDescriptor.bytesFilled -= remainderSize, ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor), ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
      }
      function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
        let firstDescriptor = controller._pendingPullIntos.peek();
        ReadableByteStreamControllerInvalidateBYOBRequest(controller), controller._controlledReadableByteStream._state === "closed" ? ReadableByteStreamControllerRespondInClosedState(controller) : ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor), ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerShiftPendingPullInto(controller) {
        return controller._pendingPullIntos.shift();
      }
      function ReadableByteStreamControllerShouldCallPull(controller) {
        let stream = controller._controlledReadableByteStream;
        return stream._state !== "readable" || controller._closeRequested || !controller._started ? !1 : !!(ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0 || ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0 || ReadableByteStreamControllerGetDesiredSize(controller) > 0);
      }
      function ReadableByteStreamControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0, controller._cancelAlgorithm = void 0;
      }
      function ReadableByteStreamControllerClose(controller) {
        let stream = controller._controlledReadableByteStream;
        if (!(controller._closeRequested || stream._state !== "readable")) {
          if (controller._queueTotalSize > 0) {
            controller._closeRequested = !0;
            return;
          }
          if (controller._pendingPullIntos.length > 0 && controller._pendingPullIntos.peek().bytesFilled > 0) {
            let e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
            throw ReadableByteStreamControllerError(controller, e2), e2;
          }
          ReadableByteStreamControllerClearAlgorithms(controller), ReadableStreamClose(stream);
        }
      }
      function ReadableByteStreamControllerEnqueue(controller, chunk) {
        let stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable")
          return;
        let buffer = chunk.buffer, byteOffset = chunk.byteOffset, byteLength = chunk.byteLength, transferredBuffer = buffer;
        if (controller._pendingPullIntos.length > 0) {
          let firstPendingPullInto = controller._pendingPullIntos.peek();
          IsDetachedBuffer(firstPendingPullInto.buffer), firstPendingPullInto.buffer = firstPendingPullInto.buffer;
        }
        if (ReadableByteStreamControllerInvalidateBYOBRequest(controller), ReadableStreamHasDefaultReader(stream))
          if (ReadableStreamGetNumReadRequests(stream) === 0)
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          else {
            controller._pendingPullIntos.length > 0 && ReadableByteStreamControllerShiftPendingPullInto(controller);
            let transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
            ReadableStreamFulfillReadRequest(stream, transferredView, !1);
          }
        else
          ReadableStreamHasBYOBReader(stream) ? (ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength), ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller)) : ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerError(controller, e2) {
        let stream = controller._controlledReadableByteStream;
        stream._state === "readable" && (ReadableByteStreamControllerClearPendingPullIntos(controller), ResetQueue(controller), ReadableByteStreamControllerClearAlgorithms(controller), ReadableStreamError(stream, e2));
      }
      function ReadableByteStreamControllerGetBYOBRequest(controller) {
        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
          let firstDescriptor = controller._pendingPullIntos.peek(), view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled), byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
          SetUpReadableStreamBYOBRequest(byobRequest, controller, view), controller._byobRequest = byobRequest;
        }
        return controller._byobRequest;
      }
      function ReadableByteStreamControllerGetDesiredSize(controller) {
        let state = controller._controlledReadableByteStream._state;
        return state === "errored" ? null : state === "closed" ? 0 : controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableByteStreamControllerRespond(controller, bytesWritten) {
        let firstDescriptor = controller._pendingPullIntos.peek();
        if (controller._controlledReadableByteStream._state === "closed") {
          if (bytesWritten !== 0)
            throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
        } else {
          if (bytesWritten === 0)
            throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
          if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength)
            throw new RangeError("bytesWritten out of range");
        }
        firstDescriptor.buffer = firstDescriptor.buffer, ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
      }
      function ReadableByteStreamControllerRespondWithNewView(controller, view) {
        let firstDescriptor = controller._pendingPullIntos.peek();
        if (controller._controlledReadableByteStream._state === "closed") {
          if (view.byteLength !== 0)
            throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
        } else if (view.byteLength === 0)
          throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset)
          throw new RangeError("The region specified by view does not match byobRequest");
        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength)
          throw new RangeError("The buffer of view has different capacity than byobRequest");
        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength)
          throw new RangeError("The region specified by view is larger than byobRequest");
        let viewByteLength = view.byteLength;
        firstDescriptor.buffer = view.buffer, ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
      }
      function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
        controller._controlledReadableByteStream = stream, controller._pullAgain = !1, controller._pulling = !1, controller._byobRequest = null, controller._queue = controller._queueTotalSize = void 0, ResetQueue(controller), controller._closeRequested = !1, controller._started = !1, controller._strategyHWM = highWaterMark, controller._pullAlgorithm = pullAlgorithm, controller._cancelAlgorithm = cancelAlgorithm, controller._autoAllocateChunkSize = autoAllocateChunkSize, controller._pendingPullIntos = new SimpleQueue(), stream._readableStreamController = controller;
        let startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
          controller._started = !0, ReadableByteStreamControllerCallPullIfNeeded(controller);
        }, (r2) => {
          ReadableByteStreamControllerError(controller, r2);
        });
      }
      function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
        let controller = Object.create(ReadableByteStreamController.prototype), startAlgorithm = () => {
        }, pullAlgorithm = () => promiseResolvedWith(void 0), cancelAlgorithm = () => promiseResolvedWith(void 0);
        underlyingByteSource.start !== void 0 && (startAlgorithm = () => underlyingByteSource.start(controller)), underlyingByteSource.pull !== void 0 && (pullAlgorithm = () => underlyingByteSource.pull(controller)), underlyingByteSource.cancel !== void 0 && (cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason));
        let autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
        if (autoAllocateChunkSize === 0)
          throw new TypeError("autoAllocateChunkSize must be greater than 0");
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
      }
      function SetUpReadableStreamBYOBRequest(request, controller, view) {
        request._associatedReadableByteStreamController = controller, request._view = view;
      }
      function byobRequestBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
      }
      function byteStreamControllerBrandCheckException(name) {
        return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
      }
      function AcquireReadableStreamBYOBReader(stream) {
        return new ReadableStreamBYOBReader(stream);
      }
      function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
        stream._reader._readIntoRequests.push(readIntoRequest);
      }
      function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
        let readIntoRequest = stream._reader._readIntoRequests.shift();
        done ? readIntoRequest._closeSteps(chunk) : readIntoRequest._chunkSteps(chunk);
      }
      function ReadableStreamGetNumReadIntoRequests(stream) {
        return stream._reader._readIntoRequests.length;
      }
      function ReadableStreamHasBYOBReader(stream) {
        let reader = stream._reader;
        return !(reader === void 0 || !IsReadableStreamBYOBReader(reader));
      }
      class ReadableStreamBYOBReader {
        constructor(stream) {
          if (assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader"), assertReadableStream(stream, "First parameter"), IsReadableStreamLocked(stream))
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          if (!IsReadableByteStreamController(stream._readableStreamController))
            throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
          ReadableStreamReaderGenericInitialize(this, stream), this._readIntoRequests = new SimpleQueue();
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the reader's lock is released before the stream finishes closing.
         */
        get closed() {
          return IsReadableStreamBYOBReader(this) ? this._closedPromise : promiseRejectedWith(byobReaderBrandCheckException("closed"));
        }
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */
        cancel(reason = void 0) {
          return IsReadableStreamBYOBReader(this) ? this._ownerReadableStream === void 0 ? promiseRejectedWith(readerLockException("cancel")) : ReadableStreamReaderGenericCancel(this, reason) : promiseRejectedWith(byobReaderBrandCheckException("cancel"));
        }
        /**
         * Attempts to reads bytes into view, and returns a promise resolved with the result.
         *
         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
         */
        read(view) {
          if (!IsReadableStreamBYOBReader(this))
            return promiseRejectedWith(byobReaderBrandCheckException("read"));
          if (!ArrayBuffer.isView(view))
            return promiseRejectedWith(new TypeError("view must be an array buffer view"));
          if (view.byteLength === 0)
            return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
          if (view.buffer.byteLength === 0)
            return promiseRejectedWith(new TypeError("view's buffer must have non-zero byteLength"));
          if (IsDetachedBuffer(view.buffer), this._ownerReadableStream === void 0)
            return promiseRejectedWith(readerLockException("read from"));
          let resolvePromise, rejectPromise, promise = newPromise((resolve, reject) => {
            resolvePromise = resolve, rejectPromise = reject;
          });
          return ReadableStreamBYOBReaderRead(this, view, {
            _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: !1 }),
            _closeSteps: (chunk) => resolvePromise({ value: chunk, done: !0 }),
            _errorSteps: (e2) => rejectPromise(e2)
          }), promise;
        }
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */
        releaseLock() {
          if (!IsReadableStreamBYOBReader(this))
            throw byobReaderBrandCheckException("releaseLock");
          if (this._ownerReadableStream !== void 0) {
            if (this._readIntoRequests.length > 0)
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            ReadableStreamReaderGenericRelease(this);
          }
        }
      }
      Object.defineProperties(ReadableStreamBYOBReader.prototype, {
        cancel: { enumerable: !0 },
        read: { enumerable: !0 },
        releaseLock: { enumerable: !0 },
        closed: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamBYOBReader",
        configurable: !0
      });
      function IsReadableStreamBYOBReader(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_readIntoRequests") ? !1 : x2 instanceof ReadableStreamBYOBReader;
      }
      function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
        let stream = reader._ownerReadableStream;
        stream._disturbed = !0, stream._state === "errored" ? readIntoRequest._errorSteps(stream._storedError) : ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
      }
      function byobReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
      }
      function ExtractHighWaterMark(strategy, defaultHWM) {
        let { highWaterMark } = strategy;
        if (highWaterMark === void 0)
          return defaultHWM;
        if (NumberIsNaN(highWaterMark) || highWaterMark < 0)
          throw new RangeError("Invalid highWaterMark");
        return highWaterMark;
      }
      function ExtractSizeAlgorithm(strategy) {
        let { size } = strategy;
        return size || (() => 1);
      }
      function convertQueuingStrategy(init, context) {
        assertDictionary(init, context);
        let highWaterMark = init == null ? void 0 : init.highWaterMark, size = init == null ? void 0 : init.size;
        return {
          highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
          size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
        };
      }
      function convertQueuingStrategySize(fn, context) {
        return assertFunction(fn, context), (chunk) => convertUnrestrictedDouble(fn(chunk));
      }
      function convertUnderlyingSink(original, context) {
        assertDictionary(original, context);
        let abort = original == null ? void 0 : original.abort, close = original == null ? void 0 : original.close, start = original == null ? void 0 : original.start, type = original == null ? void 0 : original.type, write = original == null ? void 0 : original.write;
        return {
          abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
          close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
          start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
          write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
          type
        };
      }
      function convertUnderlyingSinkAbortCallback(fn, original, context) {
        return assertFunction(fn, context), (reason) => promiseCall(fn, original, [reason]);
      }
      function convertUnderlyingSinkCloseCallback(fn, original, context) {
        return assertFunction(fn, context), () => promiseCall(fn, original, []);
      }
      function convertUnderlyingSinkStartCallback(fn, original, context) {
        return assertFunction(fn, context), (controller) => reflectCall(fn, original, [controller]);
      }
      function convertUnderlyingSinkWriteCallback(fn, original, context) {
        return assertFunction(fn, context), (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
      }
      function assertWritableStream(x2, context) {
        if (!IsWritableStream(x2))
          throw new TypeError(`${context} is not a WritableStream.`);
      }
      function isAbortSignal2(value) {
        if (typeof value != "object" || value === null)
          return !1;
        try {
          return typeof value.aborted == "boolean";
        } catch {
          return !1;
        }
      }
      let supportsAbortController = typeof AbortController == "function";
      function createAbortController() {
        if (supportsAbortController)
          return new AbortController();
      }
      class WritableStream {
        constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
          rawUnderlyingSink === void 0 ? rawUnderlyingSink = null : assertObject(rawUnderlyingSink, "First parameter");
          let strategy = convertQueuingStrategy(rawStrategy, "Second parameter"), underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
          if (InitializeWritableStream(this), underlyingSink.type !== void 0)
            throw new RangeError("Invalid type is specified");
          let sizeAlgorithm = ExtractSizeAlgorithm(strategy), highWaterMark = ExtractHighWaterMark(strategy, 1);
          SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
        }
        /**
         * Returns whether or not the writable stream is locked to a writer.
         */
        get locked() {
          if (!IsWritableStream(this))
            throw streamBrandCheckException$2("locked");
          return IsWritableStreamLocked(this);
        }
        /**
         * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be
         * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort
         * mechanism of the underlying sink.
         *
         * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled
         * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel
         * the stream) if the stream is currently locked.
         */
        abort(reason = void 0) {
          return IsWritableStream(this) ? IsWritableStreamLocked(this) ? promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer")) : WritableStreamAbort(this, reason) : promiseRejectedWith(streamBrandCheckException$2("abort"));
        }
        /**
         * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its
         * close behavior. During this time any further attempts to write will fail (without erroring the stream).
         *
         * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream
         * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with
         * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.
         */
        close() {
          return IsWritableStream(this) ? IsWritableStreamLocked(this) ? promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer")) : WritableStreamCloseQueuedOrInFlight(this) ? promiseRejectedWith(new TypeError("Cannot close an already-closing stream")) : WritableStreamClose(this) : promiseRejectedWith(streamBrandCheckException$2("close"));
        }
        /**
         * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream
         * is locked, no other writer can be acquired until this one is released.
         *
         * This functionality is especially useful for creating abstractions that desire the ability to write to a stream
         * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at
         * the same time, which would cause the resulting written data to be unpredictable and probably useless.
         */
        getWriter() {
          if (!IsWritableStream(this))
            throw streamBrandCheckException$2("getWriter");
          return AcquireWritableStreamDefaultWriter(this);
        }
      }
      Object.defineProperties(WritableStream.prototype, {
        abort: { enumerable: !0 },
        close: { enumerable: !0 },
        getWriter: { enumerable: !0 },
        locked: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
        value: "WritableStream",
        configurable: !0
      });
      function AcquireWritableStreamDefaultWriter(stream) {
        return new WritableStreamDefaultWriter(stream);
      }
      function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        let stream = Object.create(WritableStream.prototype);
        InitializeWritableStream(stream);
        let controller = Object.create(WritableStreamDefaultController.prototype);
        return SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm), stream;
      }
      function InitializeWritableStream(stream) {
        stream._state = "writable", stream._storedError = void 0, stream._writer = void 0, stream._writableStreamController = void 0, stream._writeRequests = new SimpleQueue(), stream._inFlightWriteRequest = void 0, stream._closeRequest = void 0, stream._inFlightCloseRequest = void 0, stream._pendingAbortRequest = void 0, stream._backpressure = !1;
      }
      function IsWritableStream(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_writableStreamController") ? !1 : x2 instanceof WritableStream;
      }
      function IsWritableStreamLocked(stream) {
        return stream._writer !== void 0;
      }
      function WritableStreamAbort(stream, reason) {
        var _a4;
        if (stream._state === "closed" || stream._state === "errored")
          return promiseResolvedWith(void 0);
        stream._writableStreamController._abortReason = reason, (_a4 = stream._writableStreamController._abortController) === null || _a4 === void 0 || _a4.abort();
        let state = stream._state;
        if (state === "closed" || state === "errored")
          return promiseResolvedWith(void 0);
        if (stream._pendingAbortRequest !== void 0)
          return stream._pendingAbortRequest._promise;
        let wasAlreadyErroring = !1;
        state === "erroring" && (wasAlreadyErroring = !0, reason = void 0);
        let promise = newPromise((resolve, reject) => {
          stream._pendingAbortRequest = {
            _promise: void 0,
            _resolve: resolve,
            _reject: reject,
            _reason: reason,
            _wasAlreadyErroring: wasAlreadyErroring
          };
        });
        return stream._pendingAbortRequest._promise = promise, wasAlreadyErroring || WritableStreamStartErroring(stream, reason), promise;
      }
      function WritableStreamClose(stream) {
        let state = stream._state;
        if (state === "closed" || state === "errored")
          return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
        let promise = newPromise((resolve, reject) => {
          let closeRequest = {
            _resolve: resolve,
            _reject: reject
          };
          stream._closeRequest = closeRequest;
        }), writer = stream._writer;
        return writer !== void 0 && stream._backpressure && state === "writable" && defaultWriterReadyPromiseResolve(writer), WritableStreamDefaultControllerClose(stream._writableStreamController), promise;
      }
      function WritableStreamAddWriteRequest(stream) {
        return newPromise((resolve, reject) => {
          let writeRequest = {
            _resolve: resolve,
            _reject: reject
          };
          stream._writeRequests.push(writeRequest);
        });
      }
      function WritableStreamDealWithRejection(stream, error) {
        if (stream._state === "writable") {
          WritableStreamStartErroring(stream, error);
          return;
        }
        WritableStreamFinishErroring(stream);
      }
      function WritableStreamStartErroring(stream, reason) {
        let controller = stream._writableStreamController;
        stream._state = "erroring", stream._storedError = reason;
        let writer = stream._writer;
        writer !== void 0 && WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason), !WritableStreamHasOperationMarkedInFlight(stream) && controller._started && WritableStreamFinishErroring(stream);
      }
      function WritableStreamFinishErroring(stream) {
        stream._state = "errored", stream._writableStreamController[ErrorSteps]();
        let storedError = stream._storedError;
        if (stream._writeRequests.forEach((writeRequest) => {
          writeRequest._reject(storedError);
        }), stream._writeRequests = new SimpleQueue(), stream._pendingAbortRequest === void 0) {
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        let abortRequest = stream._pendingAbortRequest;
        if (stream._pendingAbortRequest = void 0, abortRequest._wasAlreadyErroring) {
          abortRequest._reject(storedError), WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        let promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
        uponPromise(promise, () => {
          abortRequest._resolve(), WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        }, (reason) => {
          abortRequest._reject(reason), WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        });
      }
      function WritableStreamFinishInFlightWrite(stream) {
        stream._inFlightWriteRequest._resolve(void 0), stream._inFlightWriteRequest = void 0;
      }
      function WritableStreamFinishInFlightWriteWithError(stream, error) {
        stream._inFlightWriteRequest._reject(error), stream._inFlightWriteRequest = void 0, WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamFinishInFlightClose(stream) {
        stream._inFlightCloseRequest._resolve(void 0), stream._inFlightCloseRequest = void 0, stream._state === "erroring" && (stream._storedError = void 0, stream._pendingAbortRequest !== void 0 && (stream._pendingAbortRequest._resolve(), stream._pendingAbortRequest = void 0)), stream._state = "closed";
        let writer = stream._writer;
        writer !== void 0 && defaultWriterClosedPromiseResolve(writer);
      }
      function WritableStreamFinishInFlightCloseWithError(stream, error) {
        stream._inFlightCloseRequest._reject(error), stream._inFlightCloseRequest = void 0, stream._pendingAbortRequest !== void 0 && (stream._pendingAbortRequest._reject(error), stream._pendingAbortRequest = void 0), WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamCloseQueuedOrInFlight(stream) {
        return !(stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0);
      }
      function WritableStreamHasOperationMarkedInFlight(stream) {
        return !(stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0);
      }
      function WritableStreamMarkCloseRequestInFlight(stream) {
        stream._inFlightCloseRequest = stream._closeRequest, stream._closeRequest = void 0;
      }
      function WritableStreamMarkFirstWriteRequestInFlight(stream) {
        stream._inFlightWriteRequest = stream._writeRequests.shift();
      }
      function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
        stream._closeRequest !== void 0 && (stream._closeRequest._reject(stream._storedError), stream._closeRequest = void 0);
        let writer = stream._writer;
        writer !== void 0 && defaultWriterClosedPromiseReject(writer, stream._storedError);
      }
      function WritableStreamUpdateBackpressure(stream, backpressure) {
        let writer = stream._writer;
        writer !== void 0 && backpressure !== stream._backpressure && (backpressure ? defaultWriterReadyPromiseReset(writer) : defaultWriterReadyPromiseResolve(writer)), stream._backpressure = backpressure;
      }
      class WritableStreamDefaultWriter {
        constructor(stream) {
          if (assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter"), assertWritableStream(stream, "First parameter"), IsWritableStreamLocked(stream))
            throw new TypeError("This stream has already been locked for exclusive writing by another writer");
          this._ownerWritableStream = stream, stream._writer = this;
          let state = stream._state;
          if (state === "writable")
            !WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure ? defaultWriterReadyPromiseInitialize(this) : defaultWriterReadyPromiseInitializeAsResolved(this), defaultWriterClosedPromiseInitialize(this);
          else if (state === "erroring")
            defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError), defaultWriterClosedPromiseInitialize(this);
          else if (state === "closed")
            defaultWriterReadyPromiseInitializeAsResolved(this), defaultWriterClosedPromiseInitializeAsResolved(this);
          else {
            let storedError = stream._storedError;
            defaultWriterReadyPromiseInitializeAsRejected(this, storedError), defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
          }
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the writers lock is released before the stream finishes closing.
         */
        get closed() {
          return IsWritableStreamDefaultWriter(this) ? this._closedPromise : promiseRejectedWith(defaultWriterBrandCheckException("closed"));
        }
        /**
         * Returns the desired size to fill the streams internal queue. It can be negative, if the queue is over-full.
         * A producer can use this information to determine the right amount of data to write.
         *
         * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
         * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
         * the writers lock is released.
         */
        get desiredSize() {
          if (!IsWritableStreamDefaultWriter(this))
            throw defaultWriterBrandCheckException("desiredSize");
          if (this._ownerWritableStream === void 0)
            throw defaultWriterLockException("desiredSize");
          return WritableStreamDefaultWriterGetDesiredSize(this);
        }
        /**
         * Returns a promise that will be fulfilled when the desired size to fill the streams internal queue transitions
         * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
         * back to zero or below, the getter will return a new promise that stays pending until the next transition.
         *
         * If the stream becomes errored or aborted, or the writers lock is released, the returned promise will become
         * rejected.
         */
        get ready() {
          return IsWritableStreamDefaultWriter(this) ? this._readyPromise : promiseRejectedWith(defaultWriterBrandCheckException("ready"));
        }
        /**
         * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.
         */
        abort(reason = void 0) {
          return IsWritableStreamDefaultWriter(this) ? this._ownerWritableStream === void 0 ? promiseRejectedWith(defaultWriterLockException("abort")) : WritableStreamDefaultWriterAbort(this, reason) : promiseRejectedWith(defaultWriterBrandCheckException("abort"));
        }
        /**
         * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.
         */
        close() {
          if (!IsWritableStreamDefaultWriter(this))
            return promiseRejectedWith(defaultWriterBrandCheckException("close"));
          let stream = this._ownerWritableStream;
          return stream === void 0 ? promiseRejectedWith(defaultWriterLockException("close")) : WritableStreamCloseQueuedOrInFlight(stream) ? promiseRejectedWith(new TypeError("Cannot close an already-closing stream")) : WritableStreamDefaultWriterClose(this);
        }
        /**
         * Releases the writers lock on the corresponding stream. After the lock is released, the writer is no longer active.
         * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from
         * now on; otherwise, the writer will appear closed.
         *
         * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the
         * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).
         * Its not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents
         * other producers from writing in an interleaved manner.
         */
        releaseLock() {
          if (!IsWritableStreamDefaultWriter(this))
            throw defaultWriterBrandCheckException("releaseLock");
          this._ownerWritableStream !== void 0 && WritableStreamDefaultWriterRelease(this);
        }
        write(chunk = void 0) {
          return IsWritableStreamDefaultWriter(this) ? this._ownerWritableStream === void 0 ? promiseRejectedWith(defaultWriterLockException("write to")) : WritableStreamDefaultWriterWrite(this, chunk) : promiseRejectedWith(defaultWriterBrandCheckException("write"));
        }
      }
      Object.defineProperties(WritableStreamDefaultWriter.prototype, {
        abort: { enumerable: !0 },
        close: { enumerable: !0 },
        releaseLock: { enumerable: !0 },
        write: { enumerable: !0 },
        closed: { enumerable: !0 },
        desiredSize: { enumerable: !0 },
        ready: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
        value: "WritableStreamDefaultWriter",
        configurable: !0
      });
      function IsWritableStreamDefaultWriter(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_ownerWritableStream") ? !1 : x2 instanceof WritableStreamDefaultWriter;
      }
      function WritableStreamDefaultWriterAbort(writer, reason) {
        let stream = writer._ownerWritableStream;
        return WritableStreamAbort(stream, reason);
      }
      function WritableStreamDefaultWriterClose(writer) {
        let stream = writer._ownerWritableStream;
        return WritableStreamClose(stream);
      }
      function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
        let stream = writer._ownerWritableStream, state = stream._state;
        return WritableStreamCloseQueuedOrInFlight(stream) || state === "closed" ? promiseResolvedWith(void 0) : state === "errored" ? promiseRejectedWith(stream._storedError) : WritableStreamDefaultWriterClose(writer);
      }
      function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
        writer._closedPromiseState === "pending" ? defaultWriterClosedPromiseReject(writer, error) : defaultWriterClosedPromiseResetToRejected(writer, error);
      }
      function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
        writer._readyPromiseState === "pending" ? defaultWriterReadyPromiseReject(writer, error) : defaultWriterReadyPromiseResetToRejected(writer, error);
      }
      function WritableStreamDefaultWriterGetDesiredSize(writer) {
        let stream = writer._ownerWritableStream, state = stream._state;
        return state === "errored" || state === "erroring" ? null : state === "closed" ? 0 : WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
      }
      function WritableStreamDefaultWriterRelease(writer) {
        let stream = writer._ownerWritableStream, releasedError = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError), WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError), stream._writer = void 0, writer._ownerWritableStream = void 0;
      }
      function WritableStreamDefaultWriterWrite(writer, chunk) {
        let stream = writer._ownerWritableStream, controller = stream._writableStreamController, chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
        if (stream !== writer._ownerWritableStream)
          return promiseRejectedWith(defaultWriterLockException("write to"));
        let state = stream._state;
        if (state === "errored")
          return promiseRejectedWith(stream._storedError);
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed")
          return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
        if (state === "erroring")
          return promiseRejectedWith(stream._storedError);
        let promise = WritableStreamAddWriteRequest(stream);
        return WritableStreamDefaultControllerWrite(controller, chunk, chunkSize), promise;
      }
      let closeSentinel = {};
      class WritableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
         *
         * @deprecated
         *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
         *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
         */
        get abortReason() {
          if (!IsWritableStreamDefaultController(this))
            throw defaultControllerBrandCheckException$2("abortReason");
          return this._abortReason;
        }
        /**
         * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
         */
        get signal() {
          if (!IsWritableStreamDefaultController(this))
            throw defaultControllerBrandCheckException$2("signal");
          if (this._abortController === void 0)
            throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
          return this._abortController.signal;
        }
        /**
         * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.
         *
         * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying
         * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the
         * normal lifecycle of interactions with the underlying sink.
         */
        error(e2 = void 0) {
          if (!IsWritableStreamDefaultController(this))
            throw defaultControllerBrandCheckException$2("error");
          this._controlledWritableStream._state === "writable" && WritableStreamDefaultControllerError(this, e2);
        }
        /** @internal */
        [AbortSteps](reason) {
          let result = this._abortAlgorithm(reason);
          return WritableStreamDefaultControllerClearAlgorithms(this), result;
        }
        /** @internal */
        [ErrorSteps]() {
          ResetQueue(this);
        }
      }
      Object.defineProperties(WritableStreamDefaultController.prototype, {
        abortReason: { enumerable: !0 },
        signal: { enumerable: !0 },
        error: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
        value: "WritableStreamDefaultController",
        configurable: !0
      });
      function IsWritableStreamDefaultController(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_controlledWritableStream") ? !1 : x2 instanceof WritableStreamDefaultController;
      }
      function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledWritableStream = stream, stream._writableStreamController = controller, controller._queue = void 0, controller._queueTotalSize = void 0, ResetQueue(controller), controller._abortReason = void 0, controller._abortController = createAbortController(), controller._started = !1, controller._strategySizeAlgorithm = sizeAlgorithm, controller._strategyHWM = highWaterMark, controller._writeAlgorithm = writeAlgorithm, controller._closeAlgorithm = closeAlgorithm, controller._abortAlgorithm = abortAlgorithm;
        let backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
        let startResult = startAlgorithm(), startPromise = promiseResolvedWith(startResult);
        uponPromise(startPromise, () => {
          controller._started = !0, WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, (r2) => {
          controller._started = !0, WritableStreamDealWithRejection(stream, r2);
        });
      }
      function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
        let controller = Object.create(WritableStreamDefaultController.prototype), startAlgorithm = () => {
        }, writeAlgorithm = () => promiseResolvedWith(void 0), closeAlgorithm = () => promiseResolvedWith(void 0), abortAlgorithm = () => promiseResolvedWith(void 0);
        underlyingSink.start !== void 0 && (startAlgorithm = () => underlyingSink.start(controller)), underlyingSink.write !== void 0 && (writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller)), underlyingSink.close !== void 0 && (closeAlgorithm = () => underlyingSink.close()), underlyingSink.abort !== void 0 && (abortAlgorithm = (reason) => underlyingSink.abort(reason)), SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function WritableStreamDefaultControllerClearAlgorithms(controller) {
        controller._writeAlgorithm = void 0, controller._closeAlgorithm = void 0, controller._abortAlgorithm = void 0, controller._strategySizeAlgorithm = void 0;
      }
      function WritableStreamDefaultControllerClose(controller) {
        EnqueueValueWithSize(controller, closeSentinel, 0), WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
        try {
          return controller._strategySizeAlgorithm(chunk);
        } catch (chunkSizeE) {
          return WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE), 1;
        }
      }
      function WritableStreamDefaultControllerGetDesiredSize(controller) {
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
        try {
          EnqueueValueWithSize(controller, chunk, chunkSize);
        } catch (enqueueE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
          return;
        }
        let stream = controller._controlledWritableStream;
        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
          let backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
        let stream = controller._controlledWritableStream;
        if (!controller._started || stream._inFlightWriteRequest !== void 0)
          return;
        if (stream._state === "erroring") {
          WritableStreamFinishErroring(stream);
          return;
        }
        if (controller._queue.length === 0)
          return;
        let value = PeekQueueValue(controller);
        value === closeSentinel ? WritableStreamDefaultControllerProcessClose(controller) : WritableStreamDefaultControllerProcessWrite(controller, value);
      }
      function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
        controller._controlledWritableStream._state === "writable" && WritableStreamDefaultControllerError(controller, error);
      }
      function WritableStreamDefaultControllerProcessClose(controller) {
        let stream = controller._controlledWritableStream;
        WritableStreamMarkCloseRequestInFlight(stream), DequeueValue(controller);
        let sinkClosePromise = controller._closeAlgorithm();
        WritableStreamDefaultControllerClearAlgorithms(controller), uponPromise(sinkClosePromise, () => {
          WritableStreamFinishInFlightClose(stream);
        }, (reason) => {
          WritableStreamFinishInFlightCloseWithError(stream, reason);
        });
      }
      function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
        let stream = controller._controlledWritableStream;
        WritableStreamMarkFirstWriteRequestInFlight(stream);
        let sinkWritePromise = controller._writeAlgorithm(chunk);
        uponPromise(sinkWritePromise, () => {
          WritableStreamFinishInFlightWrite(stream);
          let state = stream._state;
          if (DequeueValue(controller), !WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
            let backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, (reason) => {
          stream._state === "writable" && WritableStreamDefaultControllerClearAlgorithms(controller), WritableStreamFinishInFlightWriteWithError(stream, reason);
        });
      }
      function WritableStreamDefaultControllerGetBackpressure(controller) {
        return WritableStreamDefaultControllerGetDesiredSize(controller) <= 0;
      }
      function WritableStreamDefaultControllerError(controller, error) {
        let stream = controller._controlledWritableStream;
        WritableStreamDefaultControllerClearAlgorithms(controller), WritableStreamStartErroring(stream, error);
      }
      function streamBrandCheckException$2(name) {
        return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
      }
      function defaultControllerBrandCheckException$2(name) {
        return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
      }
      function defaultWriterBrandCheckException(name) {
        return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
      }
      function defaultWriterLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released writer");
      }
      function defaultWriterClosedPromiseInitialize(writer) {
        writer._closedPromise = newPromise((resolve, reject) => {
          writer._closedPromise_resolve = resolve, writer._closedPromise_reject = reject, writer._closedPromiseState = "pending";
        });
      }
      function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
        defaultWriterClosedPromiseInitialize(writer), defaultWriterClosedPromiseReject(writer, reason);
      }
      function defaultWriterClosedPromiseInitializeAsResolved(writer) {
        defaultWriterClosedPromiseInitialize(writer), defaultWriterClosedPromiseResolve(writer);
      }
      function defaultWriterClosedPromiseReject(writer, reason) {
        writer._closedPromise_reject !== void 0 && (setPromiseIsHandledToTrue(writer._closedPromise), writer._closedPromise_reject(reason), writer._closedPromise_resolve = void 0, writer._closedPromise_reject = void 0, writer._closedPromiseState = "rejected");
      }
      function defaultWriterClosedPromiseResetToRejected(writer, reason) {
        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterClosedPromiseResolve(writer) {
        writer._closedPromise_resolve !== void 0 && (writer._closedPromise_resolve(void 0), writer._closedPromise_resolve = void 0, writer._closedPromise_reject = void 0, writer._closedPromiseState = "resolved");
      }
      function defaultWriterReadyPromiseInitialize(writer) {
        writer._readyPromise = newPromise((resolve, reject) => {
          writer._readyPromise_resolve = resolve, writer._readyPromise_reject = reject;
        }), writer._readyPromiseState = "pending";
      }
      function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
        defaultWriterReadyPromiseInitialize(writer), defaultWriterReadyPromiseReject(writer, reason);
      }
      function defaultWriterReadyPromiseInitializeAsResolved(writer) {
        defaultWriterReadyPromiseInitialize(writer), defaultWriterReadyPromiseResolve(writer);
      }
      function defaultWriterReadyPromiseReject(writer, reason) {
        writer._readyPromise_reject !== void 0 && (setPromiseIsHandledToTrue(writer._readyPromise), writer._readyPromise_reject(reason), writer._readyPromise_resolve = void 0, writer._readyPromise_reject = void 0, writer._readyPromiseState = "rejected");
      }
      function defaultWriterReadyPromiseReset(writer) {
        defaultWriterReadyPromiseInitialize(writer);
      }
      function defaultWriterReadyPromiseResetToRejected(writer, reason) {
        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterReadyPromiseResolve(writer) {
        writer._readyPromise_resolve !== void 0 && (writer._readyPromise_resolve(void 0), writer._readyPromise_resolve = void 0, writer._readyPromise_reject = void 0, writer._readyPromiseState = "fulfilled");
      }
      let NativeDOMException = typeof DOMException < "u" ? DOMException : void 0;
      function isDOMExceptionConstructor(ctor) {
        if (!(typeof ctor == "function" || typeof ctor == "object"))
          return !1;
        try {
          return new ctor(), !0;
        } catch {
          return !1;
        }
      }
      function createDOMExceptionPolyfill() {
        let ctor = function(message, name) {
          this.message = message || "", this.name = name || "Error", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
        };
        return ctor.prototype = Object.create(Error.prototype), Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: !0, configurable: !0 }), ctor;
      }
      let DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
      function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
        let reader = AcquireReadableStreamDefaultReader(source), writer = AcquireWritableStreamDefaultWriter(dest);
        source._disturbed = !0;
        let shuttingDown = !1, currentWrite = promiseResolvedWith(void 0);
        return newPromise((resolve, reject) => {
          let abortAlgorithm;
          if (signal !== void 0) {
            if (abortAlgorithm = () => {
              let error = new DOMException$1("Aborted", "AbortError"), actions = [];
              preventAbort || actions.push(() => dest._state === "writable" ? WritableStreamAbort(dest, error) : promiseResolvedWith(void 0)), preventCancel || actions.push(() => source._state === "readable" ? ReadableStreamCancel(source, error) : promiseResolvedWith(void 0)), shutdownWithAction(() => Promise.all(actions.map((action3) => action3())), !0, error);
            }, signal.aborted) {
              abortAlgorithm();
              return;
            }
            signal.addEventListener("abort", abortAlgorithm);
          }
          function pipeLoop() {
            return newPromise((resolveLoop, rejectLoop) => {
              function next(done) {
                done ? resolveLoop() : PerformPromiseThen(pipeStep(), next, rejectLoop);
              }
              next(!1);
            });
          }
          function pipeStep() {
            return shuttingDown ? promiseResolvedWith(!0) : PerformPromiseThen(writer._readyPromise, () => newPromise((resolveRead, rejectRead) => {
              ReadableStreamDefaultReaderRead(reader, {
                _chunkSteps: (chunk) => {
                  currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop2), resolveRead(!1);
                },
                _closeSteps: () => resolveRead(!0),
                _errorSteps: rejectRead
              });
            }));
          }
          if (isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
            preventAbort ? shutdown(!0, storedError) : shutdownWithAction(() => WritableStreamAbort(dest, storedError), !0, storedError);
          }), isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
            preventCancel ? shutdown(!0, storedError) : shutdownWithAction(() => ReadableStreamCancel(source, storedError), !0, storedError);
          }), isOrBecomesClosed(source, reader._closedPromise, () => {
            preventClose ? shutdown() : shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
          }), WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
            let destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
            preventCancel ? shutdown(!0, destClosed) : shutdownWithAction(() => ReadableStreamCancel(source, destClosed), !0, destClosed);
          }
          setPromiseIsHandledToTrue(pipeLoop());
          function waitForWritesToFinish() {
            let oldCurrentWrite = currentWrite;
            return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
          }
          function isOrBecomesErrored(stream, promise, action3) {
            stream._state === "errored" ? action3(stream._storedError) : uponRejection(promise, action3);
          }
          function isOrBecomesClosed(stream, promise, action3) {
            stream._state === "closed" ? action3() : uponFulfillment(promise, action3);
          }
          function shutdownWithAction(action3, originalIsError, originalError) {
            if (shuttingDown)
              return;
            shuttingDown = !0, dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest) ? uponFulfillment(waitForWritesToFinish(), doTheRest) : doTheRest();
            function doTheRest() {
              uponPromise(action3(), () => finalize(originalIsError, originalError), (newError) => finalize(!0, newError));
            }
          }
          function shutdown(isError, error) {
            shuttingDown || (shuttingDown = !0, dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest) ? uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error)) : finalize(isError, error));
          }
          function finalize(isError, error) {
            WritableStreamDefaultWriterRelease(writer), ReadableStreamReaderGenericRelease(reader), signal !== void 0 && signal.removeEventListener("abort", abortAlgorithm), isError ? reject(error) : resolve(void 0);
          }
        });
      }
      class ReadableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
         */
        get desiredSize() {
          if (!IsReadableStreamDefaultController(this))
            throw defaultControllerBrandCheckException$1("desiredSize");
          return ReadableStreamDefaultControllerGetDesiredSize(this);
        }
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */
        close() {
          if (!IsReadableStreamDefaultController(this))
            throw defaultControllerBrandCheckException$1("close");
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this))
            throw new TypeError("The stream is not in a state that permits close");
          ReadableStreamDefaultControllerClose(this);
        }
        enqueue(chunk = void 0) {
          if (!IsReadableStreamDefaultController(this))
            throw defaultControllerBrandCheckException$1("enqueue");
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this))
            throw new TypeError("The stream is not in a state that permits enqueue");
          return ReadableStreamDefaultControllerEnqueue(this, chunk);
        }
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */
        error(e2 = void 0) {
          if (!IsReadableStreamDefaultController(this))
            throw defaultControllerBrandCheckException$1("error");
          ReadableStreamDefaultControllerError(this, e2);
        }
        /** @internal */
        [CancelSteps](reason) {
          ResetQueue(this);
          let result = this._cancelAlgorithm(reason);
          return ReadableStreamDefaultControllerClearAlgorithms(this), result;
        }
        /** @internal */
        [PullSteps](readRequest) {
          let stream = this._controlledReadableStream;
          if (this._queue.length > 0) {
            let chunk = DequeueValue(this);
            this._closeRequested && this._queue.length === 0 ? (ReadableStreamDefaultControllerClearAlgorithms(this), ReadableStreamClose(stream)) : ReadableStreamDefaultControllerCallPullIfNeeded(this), readRequest._chunkSteps(chunk);
          } else
            ReadableStreamAddReadRequest(stream, readRequest), ReadableStreamDefaultControllerCallPullIfNeeded(this);
        }
      }
      Object.defineProperties(ReadableStreamDefaultController.prototype, {
        close: { enumerable: !0 },
        enqueue: { enumerable: !0 },
        error: { enumerable: !0 },
        desiredSize: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamDefaultController",
        configurable: !0
      });
      function IsReadableStreamDefaultController(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_controlledReadableStream") ? !1 : x2 instanceof ReadableStreamDefaultController;
      }
      function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
        if (!ReadableStreamDefaultControllerShouldCallPull(controller))
          return;
        if (controller._pulling) {
          controller._pullAgain = !0;
          return;
        }
        controller._pulling = !0;
        let pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
          controller._pulling = !1, controller._pullAgain && (controller._pullAgain = !1, ReadableStreamDefaultControllerCallPullIfNeeded(controller));
        }, (e2) => {
          ReadableStreamDefaultControllerError(controller, e2);
        });
      }
      function ReadableStreamDefaultControllerShouldCallPull(controller) {
        let stream = controller._controlledReadableStream;
        return !ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) || !controller._started ? !1 : !!(IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0 || ReadableStreamDefaultControllerGetDesiredSize(controller) > 0);
      }
      function ReadableStreamDefaultControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0, controller._cancelAlgorithm = void 0, controller._strategySizeAlgorithm = void 0;
      }
      function ReadableStreamDefaultControllerClose(controller) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller))
          return;
        let stream = controller._controlledReadableStream;
        controller._closeRequested = !0, controller._queue.length === 0 && (ReadableStreamDefaultControllerClearAlgorithms(controller), ReadableStreamClose(stream));
      }
      function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller))
          return;
        let stream = controller._controlledReadableStream;
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0)
          ReadableStreamFulfillReadRequest(stream, chunk, !1);
        else {
          let chunkSize;
          try {
            chunkSize = controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            throw ReadableStreamDefaultControllerError(controller, chunkSizeE), chunkSizeE;
          }
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            throw ReadableStreamDefaultControllerError(controller, enqueueE), enqueueE;
          }
        }
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
      }
      function ReadableStreamDefaultControllerError(controller, e2) {
        let stream = controller._controlledReadableStream;
        stream._state === "readable" && (ResetQueue(controller), ReadableStreamDefaultControllerClearAlgorithms(controller), ReadableStreamError(stream, e2));
      }
      function ReadableStreamDefaultControllerGetDesiredSize(controller) {
        let state = controller._controlledReadableStream._state;
        return state === "errored" ? null : state === "closed" ? 0 : controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableStreamDefaultControllerHasBackpressure(controller) {
        return !ReadableStreamDefaultControllerShouldCallPull(controller);
      }
      function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
        let state = controller._controlledReadableStream._state;
        return !controller._closeRequested && state === "readable";
      }
      function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledReadableStream = stream, controller._queue = void 0, controller._queueTotalSize = void 0, ResetQueue(controller), controller._started = !1, controller._closeRequested = !1, controller._pullAgain = !1, controller._pulling = !1, controller._strategySizeAlgorithm = sizeAlgorithm, controller._strategyHWM = highWaterMark, controller._pullAlgorithm = pullAlgorithm, controller._cancelAlgorithm = cancelAlgorithm, stream._readableStreamController = controller;
        let startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
          controller._started = !0, ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }, (r2) => {
          ReadableStreamDefaultControllerError(controller, r2);
        });
      }
      function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
        let controller = Object.create(ReadableStreamDefaultController.prototype), startAlgorithm = () => {
        }, pullAlgorithm = () => promiseResolvedWith(void 0), cancelAlgorithm = () => promiseResolvedWith(void 0);
        underlyingSource.start !== void 0 && (startAlgorithm = () => underlyingSource.start(controller)), underlyingSource.pull !== void 0 && (pullAlgorithm = () => underlyingSource.pull(controller)), underlyingSource.cancel !== void 0 && (cancelAlgorithm = (reason) => underlyingSource.cancel(reason)), SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function defaultControllerBrandCheckException$1(name) {
        return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
      }
      function ReadableStreamTee(stream, cloneForBranch2) {
        return IsReadableByteStreamController(stream._readableStreamController) ? ReadableByteStreamTee(stream) : ReadableStreamDefaultTee(stream);
      }
      function ReadableStreamDefaultTee(stream, cloneForBranch2) {
        let reader = AcquireReadableStreamDefaultReader(stream), reading = !1, readAgain = !1, canceled1 = !1, canceled2 = !1, reason1, reason2, branch1, branch2, resolveCancelPromise, cancelPromise = newPromise((resolve) => {
          resolveCancelPromise = resolve;
        });
        function pullAlgorithm() {
          return reading ? (readAgain = !0, promiseResolvedWith(void 0)) : (reading = !0, ReadableStreamDefaultReaderRead(reader, {
            _chunkSteps: (chunk) => {
              queueMicrotask(() => {
                readAgain = !1;
                let chunk1 = chunk, chunk2 = chunk;
                canceled1 || ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1), canceled2 || ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2), reading = !1, readAgain && pullAlgorithm();
              });
            },
            _closeSteps: () => {
              reading = !1, canceled1 || ReadableStreamDefaultControllerClose(branch1._readableStreamController), canceled2 || ReadableStreamDefaultControllerClose(branch2._readableStreamController), (!canceled1 || !canceled2) && resolveCancelPromise(void 0);
            },
            _errorSteps: () => {
              reading = !1;
            }
          }), promiseResolvedWith(void 0));
        }
        function cancel1Algorithm(reason) {
          if (canceled1 = !0, reason1 = reason, canceled2) {
            let compositeReason = CreateArrayFromList([reason1, reason2]), cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          if (canceled2 = !0, reason2 = reason, canceled1) {
            let compositeReason = CreateArrayFromList([reason1, reason2]), cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
        }
        return branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm), branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm), uponRejection(reader._closedPromise, (r2) => {
          ReadableStreamDefaultControllerError(branch1._readableStreamController, r2), ReadableStreamDefaultControllerError(branch2._readableStreamController, r2), (!canceled1 || !canceled2) && resolveCancelPromise(void 0);
        }), [branch1, branch2];
      }
      function ReadableByteStreamTee(stream) {
        let reader = AcquireReadableStreamDefaultReader(stream), reading = !1, readAgainForBranch1 = !1, readAgainForBranch2 = !1, canceled1 = !1, canceled2 = !1, reason1, reason2, branch1, branch2, resolveCancelPromise, cancelPromise = newPromise((resolve) => {
          resolveCancelPromise = resolve;
        });
        function forwardReaderError(thisReader) {
          uponRejection(thisReader._closedPromise, (r2) => {
            thisReader === reader && (ReadableByteStreamControllerError(branch1._readableStreamController, r2), ReadableByteStreamControllerError(branch2._readableStreamController, r2), (!canceled1 || !canceled2) && resolveCancelPromise(void 0));
          });
        }
        function pullWithDefaultReader() {
          IsReadableStreamBYOBReader(reader) && (ReadableStreamReaderGenericRelease(reader), reader = AcquireReadableStreamDefaultReader(stream), forwardReaderError(reader)), ReadableStreamDefaultReaderRead(reader, {
            _chunkSteps: (chunk) => {
              queueMicrotask(() => {
                readAgainForBranch1 = !1, readAgainForBranch2 = !1;
                let chunk1 = chunk, chunk2 = chunk;
                if (!canceled1 && !canceled2)
                  try {
                    chunk2 = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(branch1._readableStreamController, cloneE), ReadableByteStreamControllerError(branch2._readableStreamController, cloneE), resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                canceled1 || ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1), canceled2 || ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2), reading = !1, readAgainForBranch1 ? pull1Algorithm() : readAgainForBranch2 && pull2Algorithm();
              });
            },
            _closeSteps: () => {
              reading = !1, canceled1 || ReadableByteStreamControllerClose(branch1._readableStreamController), canceled2 || ReadableByteStreamControllerClose(branch2._readableStreamController), branch1._readableStreamController._pendingPullIntos.length > 0 && ReadableByteStreamControllerRespond(branch1._readableStreamController, 0), branch2._readableStreamController._pendingPullIntos.length > 0 && ReadableByteStreamControllerRespond(branch2._readableStreamController, 0), (!canceled1 || !canceled2) && resolveCancelPromise(void 0);
            },
            _errorSteps: () => {
              reading = !1;
            }
          });
        }
        function pullWithBYOBReader(view, forBranch2) {
          IsReadableStreamDefaultReader(reader) && (ReadableStreamReaderGenericRelease(reader), reader = AcquireReadableStreamBYOBReader(stream), forwardReaderError(reader));
          let byobBranch = forBranch2 ? branch2 : branch1, otherBranch = forBranch2 ? branch1 : branch2;
          ReadableStreamBYOBReaderRead(reader, view, {
            _chunkSteps: (chunk) => {
              queueMicrotask(() => {
                readAgainForBranch1 = !1, readAgainForBranch2 = !1;
                let byobCanceled = forBranch2 ? canceled2 : canceled1;
                if (forBranch2 ? canceled1 : canceled2)
                  byobCanceled || ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                else {
                  let clonedChunk;
                  try {
                    clonedChunk = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE), ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE), resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                  byobCanceled || ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk), ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                }
                reading = !1, readAgainForBranch1 ? pull1Algorithm() : readAgainForBranch2 && pull2Algorithm();
              });
            },
            _closeSteps: (chunk) => {
              reading = !1;
              let byobCanceled = forBranch2 ? canceled2 : canceled1, otherCanceled = forBranch2 ? canceled1 : canceled2;
              byobCanceled || ReadableByteStreamControllerClose(byobBranch._readableStreamController), otherCanceled || ReadableByteStreamControllerClose(otherBranch._readableStreamController), chunk !== void 0 && (byobCanceled || ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk), !otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0 && ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0)), (!byobCanceled || !otherCanceled) && resolveCancelPromise(void 0);
            },
            _errorSteps: () => {
              reading = !1;
            }
          });
        }
        function pull1Algorithm() {
          if (reading)
            return readAgainForBranch1 = !0, promiseResolvedWith(void 0);
          reading = !0;
          let byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
          return byobRequest === null ? pullWithDefaultReader() : pullWithBYOBReader(byobRequest._view, !1), promiseResolvedWith(void 0);
        }
        function pull2Algorithm() {
          if (reading)
            return readAgainForBranch2 = !0, promiseResolvedWith(void 0);
          reading = !0;
          let byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
          return byobRequest === null ? pullWithDefaultReader() : pullWithBYOBReader(byobRequest._view, !0), promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          if (canceled1 = !0, reason1 = reason, canceled2) {
            let compositeReason = CreateArrayFromList([reason1, reason2]), cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          if (canceled2 = !0, reason2 = reason, canceled1) {
            let compositeReason = CreateArrayFromList([reason1, reason2]), cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
        }
        return branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm), branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm), forwardReaderError(reader), [branch1, branch2];
      }
      function convertUnderlyingDefaultOrByteSource(source, context) {
        assertDictionary(source, context);
        let original = source, autoAllocateChunkSize = original == null ? void 0 : original.autoAllocateChunkSize, cancel = original == null ? void 0 : original.cancel, pull = original == null ? void 0 : original.pull, start = original == null ? void 0 : original.start, type = original == null ? void 0 : original.type;
        return {
          autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
          cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
          pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
          start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
          type: type === void 0 ? void 0 : convertReadableStreamType(type, `${context} has member 'type' that`)
        };
      }
      function convertUnderlyingSourceCancelCallback(fn, original, context) {
        return assertFunction(fn, context), (reason) => promiseCall(fn, original, [reason]);
      }
      function convertUnderlyingSourcePullCallback(fn, original, context) {
        return assertFunction(fn, context), (controller) => promiseCall(fn, original, [controller]);
      }
      function convertUnderlyingSourceStartCallback(fn, original, context) {
        return assertFunction(fn, context), (controller) => reflectCall(fn, original, [controller]);
      }
      function convertReadableStreamType(type, context) {
        if (type = `${type}`, type !== "bytes")
          throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
        return type;
      }
      function convertReaderOptions(options, context) {
        assertDictionary(options, context);
        let mode = options == null ? void 0 : options.mode;
        return {
          mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
        };
      }
      function convertReadableStreamReaderMode(mode, context) {
        if (mode = `${mode}`, mode !== "byob")
          throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
        return mode;
      }
      function convertIteratorOptions(options, context) {
        assertDictionary(options, context);
        let preventCancel = options == null ? void 0 : options.preventCancel;
        return { preventCancel: Boolean(preventCancel) };
      }
      function convertPipeOptions(options, context) {
        assertDictionary(options, context);
        let preventAbort = options == null ? void 0 : options.preventAbort, preventCancel = options == null ? void 0 : options.preventCancel, preventClose = options == null ? void 0 : options.preventClose, signal = options == null ? void 0 : options.signal;
        return signal !== void 0 && assertAbortSignal(signal, `${context} has member 'signal' that`), {
          preventAbort: Boolean(preventAbort),
          preventCancel: Boolean(preventCancel),
          preventClose: Boolean(preventClose),
          signal
        };
      }
      function assertAbortSignal(signal, context) {
        if (!isAbortSignal2(signal))
          throw new TypeError(`${context} is not an AbortSignal.`);
      }
      function convertReadableWritablePair(pair, context) {
        assertDictionary(pair, context);
        let readable = pair == null ? void 0 : pair.readable;
        assertRequiredField(readable, "readable", "ReadableWritablePair"), assertReadableStream(readable, `${context} has member 'readable' that`);
        let writable = pair == null ? void 0 : pair.writable;
        return assertRequiredField(writable, "writable", "ReadableWritablePair"), assertWritableStream(writable, `${context} has member 'writable' that`), { readable, writable };
      }
      class ReadableStream2 {
        constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
          rawUnderlyingSource === void 0 ? rawUnderlyingSource = null : assertObject(rawUnderlyingSource, "First parameter");
          let strategy = convertQueuingStrategy(rawStrategy, "Second parameter"), underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
          if (InitializeReadableStream(this), underlyingSource.type === "bytes") {
            if (strategy.size !== void 0)
              throw new RangeError("The strategy for a byte stream cannot have a size function");
            let highWaterMark = ExtractHighWaterMark(strategy, 0);
            SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
          } else {
            let sizeAlgorithm = ExtractSizeAlgorithm(strategy), highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
          }
        }
        /**
         * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
         */
        get locked() {
          if (!IsReadableStream(this))
            throw streamBrandCheckException$1("locked");
          return IsReadableStreamLocked(this);
        }
        /**
         * Cancels the stream, signaling a loss of interest in the stream by a consumer.
         *
         * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}
         * method, which might or might not use it.
         */
        cancel(reason = void 0) {
          return IsReadableStream(this) ? IsReadableStreamLocked(this) ? promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader")) : ReadableStreamCancel(this, reason) : promiseRejectedWith(streamBrandCheckException$1("cancel"));
        }
        getReader(rawOptions = void 0) {
          if (!IsReadableStream(this))
            throw streamBrandCheckException$1("getReader");
          return convertReaderOptions(rawOptions, "First parameter").mode === void 0 ? AcquireReadableStreamDefaultReader(this) : AcquireReadableStreamBYOBReader(this);
        }
        pipeThrough(rawTransform, rawOptions = {}) {
          if (!IsReadableStream(this))
            throw streamBrandCheckException$1("pipeThrough");
          assertRequiredArgument(rawTransform, 1, "pipeThrough");
          let transform = convertReadableWritablePair(rawTransform, "First parameter"), options = convertPipeOptions(rawOptions, "Second parameter");
          if (IsReadableStreamLocked(this))
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
          if (IsWritableStreamLocked(transform.writable))
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
          let promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
          return setPromiseIsHandledToTrue(promise), transform.readable;
        }
        pipeTo(destination, rawOptions = {}) {
          if (!IsReadableStream(this))
            return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
          if (destination === void 0)
            return promiseRejectedWith("Parameter 1 is required in 'pipeTo'.");
          if (!IsWritableStream(destination))
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
          let options;
          try {
            options = convertPipeOptions(rawOptions, "Second parameter");
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          return IsReadableStreamLocked(this) ? promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")) : IsWritableStreamLocked(destination) ? promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")) : ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
        }
        /**
         * Tees this readable stream, returning a two-element array containing the two resulting branches as
         * new {@link ReadableStream} instances.
         *
         * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.
         * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be
         * propagated to the stream's underlying source.
         *
         * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,
         * this could allow interference between the two branches.
         */
        tee() {
          if (!IsReadableStream(this))
            throw streamBrandCheckException$1("tee");
          let branches = ReadableStreamTee(this);
          return CreateArrayFromList(branches);
        }
        values(rawOptions = void 0) {
          if (!IsReadableStream(this))
            throw streamBrandCheckException$1("values");
          let options = convertIteratorOptions(rawOptions, "First parameter");
          return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
        }
      }
      Object.defineProperties(ReadableStream2.prototype, {
        cancel: { enumerable: !0 },
        getReader: { enumerable: !0 },
        pipeThrough: { enumerable: !0 },
        pipeTo: { enumerable: !0 },
        tee: { enumerable: !0 },
        values: { enumerable: !0 },
        locked: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStream",
        configurable: !0
      }), typeof SymbolPolyfill.asyncIterator == "symbol" && Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
        value: ReadableStream2.prototype.values,
        writable: !0,
        configurable: !0
      });
      function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        let stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        let controller = Object.create(ReadableStreamDefaultController.prototype);
        return SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm), stream;
      }
      function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
        let stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        let controller = Object.create(ReadableByteStreamController.prototype);
        return SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0), stream;
      }
      function InitializeReadableStream(stream) {
        stream._state = "readable", stream._reader = void 0, stream._storedError = void 0, stream._disturbed = !1;
      }
      function IsReadableStream(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_readableStreamController") ? !1 : x2 instanceof ReadableStream2;
      }
      function IsReadableStreamLocked(stream) {
        return stream._reader !== void 0;
      }
      function ReadableStreamCancel(stream, reason) {
        if (stream._disturbed = !0, stream._state === "closed")
          return promiseResolvedWith(void 0);
        if (stream._state === "errored")
          return promiseRejectedWith(stream._storedError);
        ReadableStreamClose(stream);
        let reader = stream._reader;
        reader !== void 0 && IsReadableStreamBYOBReader(reader) && (reader._readIntoRequests.forEach((readIntoRequest) => {
          readIntoRequest._closeSteps(void 0);
        }), reader._readIntoRequests = new SimpleQueue());
        let sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
        return transformPromiseWith(sourceCancelPromise, noop2);
      }
      function ReadableStreamClose(stream) {
        stream._state = "closed";
        let reader = stream._reader;
        reader !== void 0 && (defaultReaderClosedPromiseResolve(reader), IsReadableStreamDefaultReader(reader) && (reader._readRequests.forEach((readRequest) => {
          readRequest._closeSteps();
        }), reader._readRequests = new SimpleQueue()));
      }
      function ReadableStreamError(stream, e2) {
        stream._state = "errored", stream._storedError = e2;
        let reader = stream._reader;
        reader !== void 0 && (defaultReaderClosedPromiseReject(reader, e2), IsReadableStreamDefaultReader(reader) ? (reader._readRequests.forEach((readRequest) => {
          readRequest._errorSteps(e2);
        }), reader._readRequests = new SimpleQueue()) : (reader._readIntoRequests.forEach((readIntoRequest) => {
          readIntoRequest._errorSteps(e2);
        }), reader._readIntoRequests = new SimpleQueue()));
      }
      function streamBrandCheckException$1(name) {
        return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
      }
      function convertQueuingStrategyInit(init, context) {
        assertDictionary(init, context);
        let highWaterMark = init == null ? void 0 : init.highWaterMark;
        return assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit"), {
          highWaterMark: convertUnrestrictedDouble(highWaterMark)
        };
      }
      let byteLengthSizeFunction = (chunk) => chunk.byteLength;
      try {
        Object.defineProperty(byteLengthSizeFunction, "name", {
          value: "size",
          configurable: !0
        });
      } catch {
      }
      class ByteLengthQueuingStrategy {
        constructor(options) {
          assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy"), options = convertQueuingStrategyInit(options, "First parameter"), this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        /**
         * Returns the high water mark provided to the constructor.
         */
        get highWaterMark() {
          if (!IsByteLengthQueuingStrategy(this))
            throw byteLengthBrandCheckException("highWaterMark");
          return this._byteLengthQueuingStrategyHighWaterMark;
        }
        /**
         * Measures the size of `chunk` by returning the value of its `byteLength` property.
         */
        get size() {
          if (!IsByteLengthQueuingStrategy(this))
            throw byteLengthBrandCheckException("size");
          return byteLengthSizeFunction;
        }
      }
      Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
        highWaterMark: { enumerable: !0 },
        size: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
        value: "ByteLengthQueuingStrategy",
        configurable: !0
      });
      function byteLengthBrandCheckException(name) {
        return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
      }
      function IsByteLengthQueuingStrategy(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_byteLengthQueuingStrategyHighWaterMark") ? !1 : x2 instanceof ByteLengthQueuingStrategy;
      }
      let countSizeFunction = () => 1;
      try {
        Object.defineProperty(countSizeFunction, "name", {
          value: "size",
          configurable: !0
        });
      } catch {
      }
      class CountQueuingStrategy {
        constructor(options) {
          assertRequiredArgument(options, 1, "CountQueuingStrategy"), options = convertQueuingStrategyInit(options, "First parameter"), this._countQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        /**
         * Returns the high water mark provided to the constructor.
         */
        get highWaterMark() {
          if (!IsCountQueuingStrategy(this))
            throw countBrandCheckException("highWaterMark");
          return this._countQueuingStrategyHighWaterMark;
        }
        /**
         * Measures the size of `chunk` by always returning 1.
         * This ensures that the total queue size is a count of the number of chunks in the queue.
         */
        get size() {
          if (!IsCountQueuingStrategy(this))
            throw countBrandCheckException("size");
          return countSizeFunction;
        }
      }
      Object.defineProperties(CountQueuingStrategy.prototype, {
        highWaterMark: { enumerable: !0 },
        size: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
        value: "CountQueuingStrategy",
        configurable: !0
      });
      function countBrandCheckException(name) {
        return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
      }
      function IsCountQueuingStrategy(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_countQueuingStrategyHighWaterMark") ? !1 : x2 instanceof CountQueuingStrategy;
      }
      function convertTransformer(original, context) {
        assertDictionary(original, context);
        let flush = original == null ? void 0 : original.flush, readableType = original == null ? void 0 : original.readableType, start = original == null ? void 0 : original.start, transform = original == null ? void 0 : original.transform, writableType = original == null ? void 0 : original.writableType;
        return {
          flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
          readableType,
          start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
          transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
          writableType
        };
      }
      function convertTransformerFlushCallback(fn, original, context) {
        return assertFunction(fn, context), (controller) => promiseCall(fn, original, [controller]);
      }
      function convertTransformerStartCallback(fn, original, context) {
        return assertFunction(fn, context), (controller) => reflectCall(fn, original, [controller]);
      }
      function convertTransformerTransformCallback(fn, original, context) {
        return assertFunction(fn, context), (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
      }
      class TransformStream {
        constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
          rawTransformer === void 0 && (rawTransformer = null);
          let writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter"), readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter"), transformer = convertTransformer(rawTransformer, "First parameter");
          if (transformer.readableType !== void 0)
            throw new RangeError("Invalid readableType specified");
          if (transformer.writableType !== void 0)
            throw new RangeError("Invalid writableType specified");
          let readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0), readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy), writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1), writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy), startPromise_resolve, startPromise = newPromise((resolve) => {
            startPromise_resolve = resolve;
          });
          InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm), SetUpTransformStreamDefaultControllerFromTransformer(this, transformer), transformer.start !== void 0 ? startPromise_resolve(transformer.start(this._transformStreamController)) : startPromise_resolve(void 0);
        }
        /**
         * The readable side of the transform stream.
         */
        get readable() {
          if (!IsTransformStream(this))
            throw streamBrandCheckException("readable");
          return this._readable;
        }
        /**
         * The writable side of the transform stream.
         */
        get writable() {
          if (!IsTransformStream(this))
            throw streamBrandCheckException("writable");
          return this._writable;
        }
      }
      Object.defineProperties(TransformStream.prototype, {
        readable: { enumerable: !0 },
        writable: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
        value: "TransformStream",
        configurable: !0
      });
      function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
        function startAlgorithm() {
          return startPromise;
        }
        function writeAlgorithm(chunk) {
          return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
        }
        function abortAlgorithm(reason) {
          return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
        }
        function closeAlgorithm() {
          return TransformStreamDefaultSinkCloseAlgorithm(stream);
        }
        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
        function pullAlgorithm() {
          return TransformStreamDefaultSourcePullAlgorithm(stream);
        }
        function cancelAlgorithm(reason) {
          return TransformStreamErrorWritableAndUnblockWrite(stream, reason), promiseResolvedWith(void 0);
        }
        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm), stream._backpressure = void 0, stream._backpressureChangePromise = void 0, stream._backpressureChangePromise_resolve = void 0, TransformStreamSetBackpressure(stream, !0), stream._transformStreamController = void 0;
      }
      function IsTransformStream(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_transformStreamController") ? !1 : x2 instanceof TransformStream;
      }
      function TransformStreamError(stream, e2) {
        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e2), TransformStreamErrorWritableAndUnblockWrite(stream, e2);
      }
      function TransformStreamErrorWritableAndUnblockWrite(stream, e2) {
        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController), WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e2), stream._backpressure && TransformStreamSetBackpressure(stream, !1);
      }
      function TransformStreamSetBackpressure(stream, backpressure) {
        stream._backpressureChangePromise !== void 0 && stream._backpressureChangePromise_resolve(), stream._backpressureChangePromise = newPromise((resolve) => {
          stream._backpressureChangePromise_resolve = resolve;
        }), stream._backpressure = backpressure;
      }
      class TransformStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the desired size to fill the readable sides internal queue. It can be negative, if the queue is over-full.
         */
        get desiredSize() {
          if (!IsTransformStreamDefaultController(this))
            throw defaultControllerBrandCheckException("desiredSize");
          let readableController = this._controlledTransformStream._readable._readableStreamController;
          return ReadableStreamDefaultControllerGetDesiredSize(readableController);
        }
        enqueue(chunk = void 0) {
          if (!IsTransformStreamDefaultController(this))
            throw defaultControllerBrandCheckException("enqueue");
          TransformStreamDefaultControllerEnqueue(this, chunk);
        }
        /**
         * Errors both the readable side and the writable side of the controlled transform stream, making all future
         * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.
         */
        error(reason = void 0) {
          if (!IsTransformStreamDefaultController(this))
            throw defaultControllerBrandCheckException("error");
          TransformStreamDefaultControllerError(this, reason);
        }
        /**
         * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the
         * transformer only needs to consume a portion of the chunks written to the writable side.
         */
        terminate() {
          if (!IsTransformStreamDefaultController(this))
            throw defaultControllerBrandCheckException("terminate");
          TransformStreamDefaultControllerTerminate(this);
        }
      }
      Object.defineProperties(TransformStreamDefaultController.prototype, {
        enqueue: { enumerable: !0 },
        error: { enumerable: !0 },
        terminate: { enumerable: !0 },
        desiredSize: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
        value: "TransformStreamDefaultController",
        configurable: !0
      });
      function IsTransformStreamDefaultController(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_controlledTransformStream") ? !1 : x2 instanceof TransformStreamDefaultController;
      }
      function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
        controller._controlledTransformStream = stream, stream._transformStreamController = controller, controller._transformAlgorithm = transformAlgorithm, controller._flushAlgorithm = flushAlgorithm;
      }
      function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
        let controller = Object.create(TransformStreamDefaultController.prototype), transformAlgorithm = (chunk) => {
          try {
            return TransformStreamDefaultControllerEnqueue(controller, chunk), promiseResolvedWith(void 0);
          } catch (transformResultE) {
            return promiseRejectedWith(transformResultE);
          }
        }, flushAlgorithm = () => promiseResolvedWith(void 0);
        transformer.transform !== void 0 && (transformAlgorithm = (chunk) => transformer.transform(chunk, controller)), transformer.flush !== void 0 && (flushAlgorithm = () => transformer.flush(controller)), SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
      }
      function TransformStreamDefaultControllerClearAlgorithms(controller) {
        controller._transformAlgorithm = void 0, controller._flushAlgorithm = void 0;
      }
      function TransformStreamDefaultControllerEnqueue(controller, chunk) {
        let stream = controller._controlledTransformStream, readableController = stream._readable._readableStreamController;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController))
          throw new TypeError("Readable side is not in a state that permits enqueue");
        try {
          ReadableStreamDefaultControllerEnqueue(readableController, chunk);
        } catch (e2) {
          throw TransformStreamErrorWritableAndUnblockWrite(stream, e2), stream._readable._storedError;
        }
        ReadableStreamDefaultControllerHasBackpressure(readableController) !== stream._backpressure && TransformStreamSetBackpressure(stream, !0);
      }
      function TransformStreamDefaultControllerError(controller, e2) {
        TransformStreamError(controller._controlledTransformStream, e2);
      }
      function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
        let transformPromise = controller._transformAlgorithm(chunk);
        return transformPromiseWith(transformPromise, void 0, (r2) => {
          throw TransformStreamError(controller._controlledTransformStream, r2), r2;
        });
      }
      function TransformStreamDefaultControllerTerminate(controller) {
        let stream = controller._controlledTransformStream, readableController = stream._readable._readableStreamController;
        ReadableStreamDefaultControllerClose(readableController);
        let error = new TypeError("TransformStream terminated");
        TransformStreamErrorWritableAndUnblockWrite(stream, error);
      }
      function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
        let controller = stream._transformStreamController;
        if (stream._backpressure) {
          let backpressureChangePromise = stream._backpressureChangePromise;
          return transformPromiseWith(backpressureChangePromise, () => {
            let writable = stream._writable;
            if (writable._state === "erroring")
              throw writable._storedError;
            return TransformStreamDefaultControllerPerformTransform(controller, chunk);
          });
        }
        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
      }
      function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
        return TransformStreamError(stream, reason), promiseResolvedWith(void 0);
      }
      function TransformStreamDefaultSinkCloseAlgorithm(stream) {
        let readable = stream._readable, controller = stream._transformStreamController, flushPromise = controller._flushAlgorithm();
        return TransformStreamDefaultControllerClearAlgorithms(controller), transformPromiseWith(flushPromise, () => {
          if (readable._state === "errored")
            throw readable._storedError;
          ReadableStreamDefaultControllerClose(readable._readableStreamController);
        }, (r2) => {
          throw TransformStreamError(stream, r2), readable._storedError;
        });
      }
      function TransformStreamDefaultSourcePullAlgorithm(stream) {
        return TransformStreamSetBackpressure(stream, !1), stream._backpressureChangePromise;
      }
      function defaultControllerBrandCheckException(name) {
        return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
      }
      function streamBrandCheckException(name) {
        return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
      }
      exports2.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy, exports2.CountQueuingStrategy = CountQueuingStrategy, exports2.ReadableByteStreamController = ReadableByteStreamController, exports2.ReadableStream = ReadableStream2, exports2.ReadableStreamBYOBReader = ReadableStreamBYOBReader, exports2.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest, exports2.ReadableStreamDefaultController = ReadableStreamDefaultController, exports2.ReadableStreamDefaultReader = ReadableStreamDefaultReader, exports2.TransformStream = TransformStream, exports2.TransformStreamDefaultController = TransformStreamDefaultController, exports2.WritableStream = WritableStream, exports2.WritableStreamDefaultController = WritableStreamDefaultController, exports2.WritableStreamDefaultWriter = WritableStreamDefaultWriter, Object.defineProperty(exports2, "__esModule", { value: !0 });
    });
  }
});

// node_modules/fetch-blob/streams.cjs
var require_streams = __commonJS({
  "node_modules/fetch-blob/streams.cjs"() {
    if (!globalThis.ReadableStream)
      try {
        let process2 = require("node:process"), { emitWarning } = process2;
        try {
          process2.emitWarning = () => {
          }, Object.assign(globalThis, require("node:stream/web")), process2.emitWarning = emitWarning;
        } catch (error) {
          throw process2.emitWarning = emitWarning, error;
        }
      } catch {
        Object.assign(globalThis, require_ponyfill_es2018());
      }
    try {
      let { Blob: Blob3 } = require("buffer");
      Blob3 && !Blob3.prototype.stream && (Blob3.prototype.stream = function(params) {
        let position = 0, blob = this;
        return new ReadableStream({
          type: "bytes",
          async pull(ctrl) {
            let buffer = await blob.slice(position, Math.min(blob.size, position + 65536)).arrayBuffer();
            position += buffer.byteLength, ctrl.enqueue(new Uint8Array(buffer)), position === blob.size && ctrl.close();
          }
        });
      });
    } catch {
    }
  }
});

// node_modules/fetch-blob/index.js
async function* toIterator(parts, clone2 = !0) {
  for (let part of parts)
    if ("stream" in part)
      yield* (
        /** @type {AsyncIterableIterator<Uint8Array>} */
        part.stream()
      );
    else if (ArrayBuffer.isView(part))
      if (clone2) {
        let position = part.byteOffset, end = part.byteOffset + part.byteLength;
        for (; position !== end; ) {
          let size = Math.min(end - position, POOL_SIZE), chunk = part.buffer.slice(position, position + size);
          position += chunk.byteLength, yield new Uint8Array(chunk);
        }
      } else
        yield part;
    else {
      let position = 0, b = (
        /** @type {Blob} */
        part
      );
      for (; position !== b.size; ) {
        let buffer = await b.slice(position, Math.min(b.size, position + POOL_SIZE)).arrayBuffer();
        position += buffer.byteLength, yield new Uint8Array(buffer);
      }
    }
}
var import_streams, POOL_SIZE, _parts, _type, _size, _endings, _a, _Blob, Blob2, fetch_blob_default, init_fetch_blob = __esm({
  "node_modules/fetch-blob/index.js"() {
    import_streams = __toESM(require_streams(), 1);
    POOL_SIZE = 65536;
    _Blob = (_a = class {
      /**
       * The Blob() constructor returns a new Blob object. The content
       * of the blob consists of the concatenation of the values given
       * in the parameter array.
       *
       * @param {*} blobParts
       * @param {{ type?: string, endings?: string }} [options]
       */
      constructor(blobParts = [], options = {}) {
        /** @type {Array.<(Blob|Uint8Array)>} */
        __privateAdd(this, _parts, []);
        __privateAdd(this, _type, "");
        __privateAdd(this, _size, 0);
        __privateAdd(this, _endings, "transparent");
        if (typeof blobParts != "object" || blobParts === null)
          throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
        if (typeof blobParts[Symbol.iterator] != "function")
          throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
        if (typeof options != "object" && typeof options != "function")
          throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        options === null && (options = {});
        let encoder = new TextEncoder();
        for (let element of blobParts) {
          let part;
          ArrayBuffer.isView(element) ? part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength)) : element instanceof ArrayBuffer ? part = new Uint8Array(element.slice(0)) : element instanceof _a ? part = element : part = encoder.encode(`${element}`), __privateSet(this, _size, __privateGet(this, _size) + (ArrayBuffer.isView(part) ? part.byteLength : part.size)), __privateGet(this, _parts).push(part);
        }
        __privateSet(this, _endings, `${options.endings === void 0 ? "transparent" : options.endings}`);
        let type = options.type === void 0 ? "" : String(options.type);
        __privateSet(this, _type, /^[\x20-\x7E]*$/.test(type) ? type : "");
      }
      /**
       * The Blob interface's size property returns the
       * size of the Blob in bytes.
       */
      get size() {
        return __privateGet(this, _size);
      }
      /**
       * The type property of a Blob object returns the MIME type of the file.
       */
      get type() {
        return __privateGet(this, _type);
      }
      /**
       * The text() method in the Blob interface returns a Promise
       * that resolves with a string containing the contents of
       * the blob, interpreted as UTF-8.
       *
       * @return {Promise<string>}
       */
      async text() {
        let decoder = new TextDecoder(), str = "";
        for await (let part of toIterator(__privateGet(this, _parts), !1))
          str += decoder.decode(part, { stream: !0 });
        return str += decoder.decode(), str;
      }
      /**
       * The arrayBuffer() method in the Blob interface returns a
       * Promise that resolves with the contents of the blob as
       * binary data contained in an ArrayBuffer.
       *
       * @return {Promise<ArrayBuffer>}
       */
      async arrayBuffer() {
        let data = new Uint8Array(this.size), offset = 0;
        for await (let chunk of toIterator(__privateGet(this, _parts), !1))
          data.set(chunk, offset), offset += chunk.length;
        return data.buffer;
      }
      stream() {
        let it = toIterator(__privateGet(this, _parts), !0);
        return new globalThis.ReadableStream({
          // @ts-ignore
          type: "bytes",
          async pull(ctrl) {
            let chunk = await it.next();
            chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
          },
          async cancel() {
            await it.return();
          }
        });
      }
      /**
       * The Blob interface's slice() method creates and returns a
       * new Blob object which contains data from a subset of the
       * blob on which it's called.
       *
       * @param {number} [start]
       * @param {number} [end]
       * @param {string} [type]
       */
      slice(start = 0, end = this.size, type = "") {
        let { size } = this, relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size), relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size), span = Math.max(relativeEnd - relativeStart, 0), parts = __privateGet(this, _parts), blobParts = [], added = 0;
        for (let part of parts) {
          if (added >= span)
            break;
          let size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart)
            relativeStart -= size2, relativeEnd -= size2;
          else {
            let chunk;
            ArrayBuffer.isView(part) ? (chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd)), added += chunk.byteLength) : (chunk = part.slice(relativeStart, Math.min(size2, relativeEnd)), added += chunk.size), relativeEnd -= size2, blobParts.push(chunk), relativeStart = 0;
          }
        }
        let blob = new _a([], { type: String(type).toLowerCase() });
        return __privateSet(blob, _size, span), __privateSet(blob, _parts, blobParts), blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object == "object" && typeof object.constructor == "function" && (typeof object.stream == "function" || typeof object.arrayBuffer == "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    }, _parts = new WeakMap(), _type = new WeakMap(), _size = new WeakMap(), _endings = new WeakMap(), _a);
    Object.defineProperties(_Blob.prototype, {
      size: { enumerable: !0 },
      type: { enumerable: !0 },
      slice: { enumerable: !0 }
    });
    Blob2 = _Blob, fetch_blob_default = Blob2;
  }
});

// node_modules/fetch-blob/file.js
var _lastModified, _name, _a2, _File, File3, file_default, init_file = __esm({
  "node_modules/fetch-blob/file.js"() {
    init_fetch_blob();
    _File = (_a2 = class extends fetch_blob_default {
      /**
       * @param {*[]} fileBits
       * @param {string} fileName
       * @param {{lastModified?: number, type?: string}} options
       */
      // @ts-ignore
      constructor(fileBits, fileName, options = {}) {
        if (arguments.length < 2)
          throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
        super(fileBits, options);
        __privateAdd(this, _lastModified, 0);
        __privateAdd(this, _name, "");
        options === null && (options = {});
        let lastModified = options.lastModified === void 0 ? Date.now() : Number(options.lastModified);
        Number.isNaN(lastModified) || __privateSet(this, _lastModified, lastModified), __privateSet(this, _name, String(fileName));
      }
      get name() {
        return __privateGet(this, _name);
      }
      get lastModified() {
        return __privateGet(this, _lastModified);
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
      static [Symbol.hasInstance](object) {
        return !!object && object instanceof fetch_blob_default && /^(File)$/.test(object[Symbol.toStringTag]);
      }
    }, _lastModified = new WeakMap(), _name = new WeakMap(), _a2), File3 = _File, file_default = File3;
  }
});

// node_modules/formdata-polyfill/esm.min.js
function formDataToBlob(F2, B = fetch_blob_default) {
  var b = `${r()}${r()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), c = [], p = `--${b}\r
Content-Disposition: form-data; name="`;
  return F2.forEach((v, n) => typeof v == "string" ? c.push(p + e(n) + `"\r
\r
${v.replace(/\r(?!\n)|(?<!\r)\n/g, `\r
`)}\r
`) : c.push(p + e(n) + `"; filename="${e(v.name, 1)}"\r
Content-Type: ${v.type || "application/octet-stream"}\r
\r
`, v, `\r
`)), c.push(`--${b}--`), new B(c, { type: "multipart/form-data; boundary=" + b });
}
var t, i, h, r, m, f, e, x, _d, _a3, FormData2, init_esm_min = __esm({
  "node_modules/formdata-polyfill/esm.min.js"() {
    init_fetch_blob();
    init_file();
    ({ toStringTag: t, iterator: i, hasInstance: h } = Symbol), r = Math.random, m = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(","), f = (a, b, c) => (a += "", /^(Blob|File)$/.test(b && b[t]) ? [(c = c !== void 0 ? c + "" : b[t] == "File" ? b.name : "blob", a), b.name !== c || b[t] == "blob" ? new file_default([b], c, b) : b] : [a, b + ""]), e = (c, f3) => (f3 ? c : c.replace(/\r?\n|\r/g, `\r
`)).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), x = (n, a, e2) => {
      if (a.length < e2)
        throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e2} arguments required, but only ${a.length} present.`);
    }, FormData2 = (_a3 = class {
      constructor(...a) {
        __privateAdd(this, _d, []);
        if (a.length)
          throw new TypeError("Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.");
      }
      get [t]() {
        return "FormData";
      }
      [i]() {
        return this.entries();
      }
      static [h](o) {
        return o && typeof o == "object" && o[t] === "FormData" && !m.some((m2) => typeof o[m2] != "function");
      }
      append(...a) {
        x("append", arguments, 2), __privateGet(this, _d).push(f(...a));
      }
      delete(a) {
        x("delete", arguments, 1), a += "", __privateSet(this, _d, __privateGet(this, _d).filter(([b]) => b !== a));
      }
      get(a) {
        x("get", arguments, 1), a += "";
        for (var b = __privateGet(this, _d), l = b.length, c = 0; c < l; c++)
          if (b[c][0] === a)
            return b[c][1];
        return null;
      }
      getAll(a, b) {
        return x("getAll", arguments, 1), b = [], a += "", __privateGet(this, _d).forEach((c) => c[0] === a && b.push(c[1])), b;
      }
      has(a) {
        return x("has", arguments, 1), a += "", __privateGet(this, _d).some((b) => b[0] === a);
      }
      forEach(a, b) {
        x("forEach", arguments, 1);
        for (var [c, d] of this)
          a.call(b, d, c, this);
      }
      set(...a) {
        x("set", arguments, 2);
        var b = [], c = !0;
        a = f(...a), __privateGet(this, _d).forEach((d) => {
          d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);
        }), c && b.push(a), __privateSet(this, _d, b);
      }
      *entries() {
        yield* __privateGet(this, _d);
      }
      *keys() {
        for (var [a] of this)
          yield a;
      }
      *values() {
        for (var [, a] of this)
          yield a;
      }
    }, _d = new WeakMap(), _a3);
  }
});

// node_modules/node-domexception/index.js
var require_node_domexception = __commonJS({
  "node_modules/node-domexception/index.js"(exports, module2) {
    if (!globalThis.DOMException)
      try {
        let { MessageChannel } = require("worker_threads"), port = new MessageChannel().port1, ab = new ArrayBuffer();
        port.postMessage(ab, [ab, ab]);
      } catch (err) {
        err.constructor.name === "DOMException" && (globalThis.DOMException = err.constructor);
      }
    module2.exports = globalThis.DOMException;
  }
});

// node_modules/fetch-blob/from.js
var import_node_fs, import_node_domexception, stat, _path, _start, _BlobDataItem, BlobDataItem, init_from = __esm({
  "node_modules/fetch-blob/from.js"() {
    import_node_fs = require("node:fs"), import_node_domexception = __toESM(require_node_domexception(), 1);
    init_file();
    init_fetch_blob();
    ({ stat } = import_node_fs.promises), _BlobDataItem = class {
      constructor(options) {
        __privateAdd(this, _path, void 0);
        __privateAdd(this, _start, void 0);
        __privateSet(this, _path, options.path), __privateSet(this, _start, options.start), this.size = options.size, this.lastModified = options.lastModified;
      }
      /**
       * Slicing arguments is first validated and formatted
       * to not be out of range by Blob.prototype.slice
       */
      slice(start, end) {
        return new _BlobDataItem({
          path: __privateGet(this, _path),
          lastModified: this.lastModified,
          size: end - start,
          start: __privateGet(this, _start) + start
        });
      }
      async *stream() {
        let { mtimeMs } = await stat(__privateGet(this, _path));
        if (mtimeMs > this.lastModified)
          throw new import_node_domexception.default("The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.", "NotReadableError");
        yield* (0, import_node_fs.createReadStream)(__privateGet(this, _path), {
          start: __privateGet(this, _start),
          end: __privateGet(this, _start) + this.size - 1
        });
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
    }, BlobDataItem = _BlobDataItem;
    _path = new WeakMap(), _start = new WeakMap();
  }
});

// node_modules/node-fetch/src/utils/multipart-parser.js
var multipart_parser_exports = {};
__export(multipart_parser_exports, {
  toFormData: () => toFormData
});
function _fileName(headerValue) {
  let m2 = headerValue.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
  if (!m2)
    return;
  let match = m2[2] || m2[3] || "", filename = match.slice(match.lastIndexOf("\\") + 1);
  return filename = filename.replace(/%22/g, '"'), filename = filename.replace(/&#(\d{4});/g, (m3, code) => String.fromCharCode(code)), filename;
}
async function toFormData(Body2, ct) {
  if (!/multipart/i.test(ct))
    throw new TypeError("Failed to fetch");
  let m2 = ct.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
  if (!m2)
    throw new TypeError("no or bad content-type header, no multipart boundary");
  let parser = new MultipartParser(m2[1] || m2[2]), headerField, headerValue, entryValue, entryName, contentType, filename, entryChunks = [], formData = new FormData2(), onPartData = (ui8a) => {
    entryValue += decoder.decode(ui8a, { stream: !0 });
  }, appendToFile = (ui8a) => {
    entryChunks.push(ui8a);
  }, appendFileToFormData = () => {
    let file = new file_default(entryChunks, filename, { type: contentType });
    formData.append(entryName, file);
  }, appendEntryToFormData = () => {
    formData.append(entryName, entryValue);
  }, decoder = new TextDecoder("utf-8");
  decoder.decode(), parser.onPartBegin = function() {
    parser.onPartData = onPartData, parser.onPartEnd = appendEntryToFormData, headerField = "", headerValue = "", entryValue = "", entryName = "", contentType = "", filename = null, entryChunks.length = 0;
  }, parser.onHeaderField = function(ui8a) {
    headerField += decoder.decode(ui8a, { stream: !0 });
  }, parser.onHeaderValue = function(ui8a) {
    headerValue += decoder.decode(ui8a, { stream: !0 });
  }, parser.onHeaderEnd = function() {
    if (headerValue += decoder.decode(), headerField = headerField.toLowerCase(), headerField === "content-disposition") {
      let m3 = headerValue.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);
      m3 && (entryName = m3[2] || m3[3] || ""), filename = _fileName(headerValue), filename && (parser.onPartData = appendToFile, parser.onPartEnd = appendFileToFormData);
    } else
      headerField === "content-type" && (contentType = headerValue);
    headerValue = "", headerField = "";
  };
  for await (let chunk of Body2)
    parser.write(chunk);
  return parser.end(), formData;
}
var s, S, f2, F, LF, CR, SPACE, HYPHEN, COLON, A, Z, lower, noop, MultipartParser, init_multipart_parser = __esm({
  "node_modules/node-fetch/src/utils/multipart-parser.js"() {
    init_from();
    init_esm_min();
    s = 0, S = {
      START_BOUNDARY: s++,
      HEADER_FIELD_START: s++,
      HEADER_FIELD: s++,
      HEADER_VALUE_START: s++,
      HEADER_VALUE: s++,
      HEADER_VALUE_ALMOST_DONE: s++,
      HEADERS_ALMOST_DONE: s++,
      PART_DATA_START: s++,
      PART_DATA: s++,
      END: s++
    }, f2 = 1, F = {
      PART_BOUNDARY: f2,
      LAST_BOUNDARY: f2 *= 2
    }, LF = 10, CR = 13, SPACE = 32, HYPHEN = 45, COLON = 58, A = 97, Z = 122, lower = (c) => c | 32, noop = () => {
    }, MultipartParser = class {
      /**
       * @param {string} boundary
       */
      constructor(boundary) {
        this.index = 0, this.flags = 0, this.onHeaderEnd = noop, this.onHeaderField = noop, this.onHeadersEnd = noop, this.onHeaderValue = noop, this.onPartBegin = noop, this.onPartData = noop, this.onPartEnd = noop, this.boundaryChars = {}, boundary = `\r
--` + boundary;
        let ui8a = new Uint8Array(boundary.length);
        for (let i2 = 0; i2 < boundary.length; i2++)
          ui8a[i2] = boundary.charCodeAt(i2), this.boundaryChars[ui8a[i2]] = !0;
        this.boundary = ui8a, this.lookbehind = new Uint8Array(this.boundary.length + 8), this.state = S.START_BOUNDARY;
      }
      /**
       * @param {Uint8Array} data
       */
      write(data) {
        let i2 = 0, length_ = data.length, previousIndex = this.index, { lookbehind, boundary, boundaryChars, index, state, flags: flags2 } = this, boundaryLength = this.boundary.length, boundaryEnd = boundaryLength - 1, bufferLength = data.length, c, cl, mark = (name) => {
          this[name + "Mark"] = i2;
        }, clear = (name) => {
          delete this[name + "Mark"];
        }, callback = (callbackSymbol, start, end, ui8a) => {
          (start === void 0 || start !== end) && this[callbackSymbol](ui8a && ui8a.subarray(start, end));
        }, dataCallback = (name, clear2) => {
          let markSymbol = name + "Mark";
          markSymbol in this && (clear2 ? (callback(name, this[markSymbol], i2, data), delete this[markSymbol]) : (callback(name, this[markSymbol], data.length, data), this[markSymbol] = 0));
        };
        for (i2 = 0; i2 < length_; i2++)
          switch (c = data[i2], state) {
            case S.START_BOUNDARY:
              if (index === boundary.length - 2) {
                if (c === HYPHEN)
                  flags2 |= F.LAST_BOUNDARY;
                else if (c !== CR)
                  return;
                index++;
                break;
              } else if (index - 1 === boundary.length - 2) {
                if (flags2 & F.LAST_BOUNDARY && c === HYPHEN)
                  state = S.END, flags2 = 0;
                else if (!(flags2 & F.LAST_BOUNDARY) && c === LF)
                  index = 0, callback("onPartBegin"), state = S.HEADER_FIELD_START;
                else
                  return;
                break;
              }
              c !== boundary[index + 2] && (index = -2), c === boundary[index + 2] && index++;
              break;
            case S.HEADER_FIELD_START:
              state = S.HEADER_FIELD, mark("onHeaderField"), index = 0;
            case S.HEADER_FIELD:
              if (c === CR) {
                clear("onHeaderField"), state = S.HEADERS_ALMOST_DONE;
                break;
              }
              if (index++, c === HYPHEN)
                break;
              if (c === COLON) {
                if (index === 1)
                  return;
                dataCallback("onHeaderField", !0), state = S.HEADER_VALUE_START;
                break;
              }
              if (cl = lower(c), cl < A || cl > Z)
                return;
              break;
            case S.HEADER_VALUE_START:
              if (c === SPACE)
                break;
              mark("onHeaderValue"), state = S.HEADER_VALUE;
            case S.HEADER_VALUE:
              c === CR && (dataCallback("onHeaderValue", !0), callback("onHeaderEnd"), state = S.HEADER_VALUE_ALMOST_DONE);
              break;
            case S.HEADER_VALUE_ALMOST_DONE:
              if (c !== LF)
                return;
              state = S.HEADER_FIELD_START;
              break;
            case S.HEADERS_ALMOST_DONE:
              if (c !== LF)
                return;
              callback("onHeadersEnd"), state = S.PART_DATA_START;
              break;
            case S.PART_DATA_START:
              state = S.PART_DATA, mark("onPartData");
            case S.PART_DATA:
              if (previousIndex = index, index === 0) {
                for (i2 += boundaryEnd; i2 < bufferLength && !(data[i2] in boundaryChars); )
                  i2 += boundaryLength;
                i2 -= boundaryEnd, c = data[i2];
              }
              if (index < boundary.length)
                boundary[index] === c ? (index === 0 && dataCallback("onPartData", !0), index++) : index = 0;
              else if (index === boundary.length)
                index++, c === CR ? flags2 |= F.PART_BOUNDARY : c === HYPHEN ? flags2 |= F.LAST_BOUNDARY : index = 0;
              else if (index - 1 === boundary.length)
                if (flags2 & F.PART_BOUNDARY) {
                  if (index = 0, c === LF) {
                    flags2 &= ~F.PART_BOUNDARY, callback("onPartEnd"), callback("onPartBegin"), state = S.HEADER_FIELD_START;
                    break;
                  }
                } else
                  flags2 & F.LAST_BOUNDARY && c === HYPHEN ? (callback("onPartEnd"), state = S.END, flags2 = 0) : index = 0;
              if (index > 0)
                lookbehind[index - 1] = c;
              else if (previousIndex > 0) {
                let _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);
                callback("onPartData", 0, previousIndex, _lookbehind), previousIndex = 0, mark("onPartData"), i2--;
              }
              break;
            case S.END:
              break;
            default:
              throw new Error(`Unexpected state entered: ${state}`);
          }
        dataCallback("onHeaderField"), dataCallback("onHeaderValue"), dataCallback("onPartData"), this.index = index, this.state = state, this.flags = flags2;
      }
      end() {
        if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length)
          this.onPartEnd();
        else if (this.state !== S.END)
          throw new Error("MultipartParser.end(): stream ended unexpectedly");
      }
    };
  }
});

// node_modules/lodash.capitalize/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.capitalize/index.js"(exports, module2) {
    var INFINITY = 1 / 0, symbolTag = "[object Symbol]", rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23", rsComboSymbolsRange = "\\u20d0-\\u20f0", rsVarRange = "\\ufe0e\\ufe0f", rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")", reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g"), reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]"), freeGlobal = typeof global == "object" && global && global.Object === Object && global, freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")();
    function asciiToArray(string) {
      return string.split("");
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    var objectProto = Object.prototype, objectToString = objectProto.toString, Symbol2 = root.Symbol, symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseSlice(array, start, end) {
      var index = -1, length = array.length;
      start < 0 && (start = -start > length ? 0 : length + start), end = end > length ? length : end, end < 0 && (end += length), length = start > end ? 0 : end - start >>> 0, start >>>= 0;
      for (var result = Array(length); ++index < length; )
        result[index] = array[index + start];
      return result;
    }
    function baseToString(value) {
      if (typeof value == "string")
        return value;
      if (isSymbol(value))
        return symbolToString ? symbolToString.call(value) : "";
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castSlice(array, start, end) {
      var length = array.length;
      return end = end === void 0 ? length : end, !start && end >= length ? array : baseSlice(array, start, end);
    }
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);
        var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0, chr = strSymbols ? strSymbols[0] : string.charAt(0), trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function capitalize2(string) {
      return upperFirst(toString(string).toLowerCase());
    }
    var upperFirst = createCaseFirst("toUpperCase");
    module2.exports = capitalize2;
  }
});

// node_modules/lodash.kebabcase/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.kebabcase/index.js"(exports, module2) {
    var INFINITY = 1 / 0, symbolTag = "[object Symbol]", reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23", rsComboSymbolsRange = "\\u20d0-\\u20f0", rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange, rsApos = "['\u2019]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d", rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")", rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, reApos = RegExp(rsApos, "g"), reComboMark = RegExp(rsCombo, "g"), reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
      rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
      rsUpper + "+" + rsOptUpperContr,
      rsDigits,
      rsEmoji
    ].join("|"), "g"), reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, deburredLetters = {
      // Latin-1 Supplement block.
      \u00C0: "A",
      \u00C1: "A",
      \u00C2: "A",
      \u00C3: "A",
      \u00C4: "A",
      \u00C5: "A",
      \u00E0: "a",
      \u00E1: "a",
      \u00E2: "a",
      \u00E3: "a",
      \u00E4: "a",
      \u00E5: "a",
      \u00C7: "C",
      \u00E7: "c",
      \u00D0: "D",
      \u00F0: "d",
      \u00C8: "E",
      \u00C9: "E",
      \u00CA: "E",
      \u00CB: "E",
      \u00E8: "e",
      \u00E9: "e",
      \u00EA: "e",
      \u00EB: "e",
      \u00CC: "I",
      \u00CD: "I",
      \u00CE: "I",
      \u00CF: "I",
      \u00EC: "i",
      \u00ED: "i",
      \u00EE: "i",
      \u00EF: "i",
      \u00D1: "N",
      \u00F1: "n",
      \u00D2: "O",
      \u00D3: "O",
      \u00D4: "O",
      \u00D5: "O",
      \u00D6: "O",
      \u00D8: "O",
      \u00F2: "o",
      \u00F3: "o",
      \u00F4: "o",
      \u00F5: "o",
      \u00F6: "o",
      \u00F8: "o",
      \u00D9: "U",
      \u00DA: "U",
      \u00DB: "U",
      \u00DC: "U",
      \u00F9: "u",
      \u00FA: "u",
      \u00FB: "u",
      \u00FC: "u",
      \u00DD: "Y",
      \u00FD: "y",
      \u00FF: "y",
      \u00C6: "Ae",
      \u00E6: "ae",
      \u00DE: "Th",
      \u00FE: "th",
      \u00DF: "ss",
      // Latin Extended-A block.
      \u0100: "A",
      \u0102: "A",
      \u0104: "A",
      \u0101: "a",
      \u0103: "a",
      \u0105: "a",
      \u0106: "C",
      \u0108: "C",
      \u010A: "C",
      \u010C: "C",
      \u0107: "c",
      \u0109: "c",
      \u010B: "c",
      \u010D: "c",
      \u010E: "D",
      \u0110: "D",
      \u010F: "d",
      \u0111: "d",
      \u0112: "E",
      \u0114: "E",
      \u0116: "E",
      \u0118: "E",
      \u011A: "E",
      \u0113: "e",
      \u0115: "e",
      \u0117: "e",
      \u0119: "e",
      \u011B: "e",
      \u011C: "G",
      \u011E: "G",
      \u0120: "G",
      \u0122: "G",
      \u011D: "g",
      \u011F: "g",
      \u0121: "g",
      \u0123: "g",
      \u0124: "H",
      \u0126: "H",
      \u0125: "h",
      \u0127: "h",
      \u0128: "I",
      \u012A: "I",
      \u012C: "I",
      \u012E: "I",
      \u0130: "I",
      \u0129: "i",
      \u012B: "i",
      \u012D: "i",
      \u012F: "i",
      \u0131: "i",
      \u0134: "J",
      \u0135: "j",
      \u0136: "K",
      \u0137: "k",
      \u0138: "k",
      \u0139: "L",
      \u013B: "L",
      \u013D: "L",
      \u013F: "L",
      \u0141: "L",
      \u013A: "l",
      \u013C: "l",
      \u013E: "l",
      \u0140: "l",
      \u0142: "l",
      \u0143: "N",
      \u0145: "N",
      \u0147: "N",
      \u014A: "N",
      \u0144: "n",
      \u0146: "n",
      \u0148: "n",
      \u014B: "n",
      \u014C: "O",
      \u014E: "O",
      \u0150: "O",
      \u014D: "o",
      \u014F: "o",
      \u0151: "o",
      \u0154: "R",
      \u0156: "R",
      \u0158: "R",
      \u0155: "r",
      \u0157: "r",
      \u0159: "r",
      \u015A: "S",
      \u015C: "S",
      \u015E: "S",
      \u0160: "S",
      \u015B: "s",
      \u015D: "s",
      \u015F: "s",
      \u0161: "s",
      \u0162: "T",
      \u0164: "T",
      \u0166: "T",
      \u0163: "t",
      \u0165: "t",
      \u0167: "t",
      \u0168: "U",
      \u016A: "U",
      \u016C: "U",
      \u016E: "U",
      \u0170: "U",
      \u0172: "U",
      \u0169: "u",
      \u016B: "u",
      \u016D: "u",
      \u016F: "u",
      \u0171: "u",
      \u0173: "u",
      \u0174: "W",
      \u0175: "w",
      \u0176: "Y",
      \u0177: "y",
      \u0178: "Y",
      \u0179: "Z",
      \u017B: "Z",
      \u017D: "Z",
      \u017A: "z",
      \u017C: "z",
      \u017E: "z",
      \u0132: "IJ",
      \u0133: "ij",
      \u0152: "Oe",
      \u0153: "oe",
      \u0149: "'n",
      \u017F: "ss"
    }, freeGlobal = typeof global == "object" && global && global.Object === Object && global, freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")();
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      for (initAccum && length && (accumulator = array[++index]); ++index < length; )
        accumulator = iteratee(accumulator, array[index], index, array);
      return accumulator;
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? void 0 : object[key];
      };
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var objectProto = Object.prototype, objectToString = objectProto.toString, Symbol2 = root.Symbol, symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string")
        return value;
      if (isSymbol(value))
        return symbolToString ? symbolToString.call(value) : "";
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
      };
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function deburr(string) {
      return string = toString(string), string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    var kebabCase2 = createCompounder(function(result, word, index) {
      return result + (index ? "-" : "") + word.toLowerCase();
    });
    function words(string, pattern, guard) {
      return string = toString(string), pattern = guard ? void 0 : pattern, pattern === void 0 ? hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string) : string.match(pattern) || [];
    }
    module2.exports = kebabCase2;
  }
});

// <stdin>
var stdin_exports = {};
__export(stdin_exports, {
  assets: () => assets_manifest_default,
  assetsBuildDirectory: () => assetsBuildDirectory,
  entry: () => entry,
  future: () => future,
  publicPath: () => publicPath,
  routes: () => routes
});
module.exports = __toCommonJS(stdin_exports);

// app/entry.server.tsx
var entry_server_exports = {};
__export(entry_server_exports, {
  default: () => handleRequest
});
var import_node_stream = require("node:stream"), import_node = __toESM(require_dist2()), import_react = __toESM(require_dist3());

// node_modules/isbot/index.mjs
function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
  return _classApplyDescriptorGet(receiver, descriptor);
}
function _classPrivateFieldSet(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
  return _classApplyDescriptorSet(receiver, descriptor, value), value;
}
function _classExtractFieldDescriptor(receiver, privateMap, action3) {
  if (!privateMap.has(receiver))
    throw new TypeError("attempted to " + action3 + " private field on non-instance");
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet(receiver, descriptor) {
  return descriptor.get ? descriptor.get.call(receiver) : descriptor.value;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
  if (descriptor.set)
    descriptor.set.call(receiver, value);
  else {
    if (!descriptor.writable)
      throw new TypeError("attempted to set read only private field");
    descriptor.value = value;
  }
}
function _classPrivateMethodGet(receiver, privateSet, fn) {
  if (!privateSet.has(receiver))
    throw new TypeError("attempted to get private field on non-instance");
  return fn;
}
function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj))
    throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classPrivateFieldInitSpec(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap), privateMap.set(obj, value);
}
function _classPrivateMethodInitSpec(obj, privateSet) {
  _checkPrivateRedeclaration(obj, privateSet), privateSet.add(obj);
}
var list = [
  " daum[ /]",
  " deusu/",
  "(?:^| )site",
  "@[a-z]",
  "\\(at\\)[a-z]",
  "\\(github\\.com/",
  "\\[at\\][a-z]",
  "^12345",
  "^<",
  "^[\\w \\.\\-\\(\\)]+(/v?\\d+(\\.\\d+)?(\\.\\d{1,10})?)?$",
  "^[^ ]{50,}$",
  "^active",
  "^ad muncher",
  "^anglesharp/",
  "^anonymous",
  "^avsdevicesdk/",
  "^axios/",
  "^bidtellect/",
  "^biglotron",
  "^btwebclient/",
  "^castro",
  "^clamav[ /]",
  "^client/",
  "^cobweb/",
  "^coccoc",
  "^custom",
  "^ddg[_-]android",
  "^discourse",
  "^dispatch/\\d",
  "^downcast/",
  "^duckduckgo",
  "^facebook",
  "^fdm[ /]\\d",
  "^getright/",
  "^gozilla/",
  "^hatena",
  "^hobbit",
  "^hotzonu",
  "^hwcdn/",
  "^jeode/",
  "^jetty/",
  "^jigsaw",
  "^linkdex",
  "^lwp[-: ]",
  "^metauri",
  "^microsoft bits",
  "^movabletype",
  "^mozilla/\\d\\.\\d \\(compatible;?\\)$",
  "^mozilla/\\d\\.\\d \\w*$",
  "^navermailapp",
  "^netsurf",
  "^offline explorer",
  "^php",
  "^postman",
  "^postrank",
  "^python",
  "^read",
  "^reed",
  "^restsharp/",
  "^snapchat",
  "^space bison",
  "^svn",
  "^swcd ",
  "^taringa",
  "^test certificate info",
  "^thumbor/",
  "^tumblr/",
  "^user-agent:mozilla",
  "^valid",
  "^venus/fedoraplanet",
  "^w3c",
  "^webbandit/",
  "^webcopier",
  "^wget",
  "^whatsapp",
  "^xenu link sleuth",
  "^yahoo",
  "^yandex",
  "^zdm/\\d",
  "^zoom marketplace/",
  "^{{.*}}$",
  "adbeat\\.com",
  "appinsights",
  "archive",
  "ask jeeves/teoma",
  "bit\\.ly/",
  "bluecoat drtr",
  "bot",
  "browsex",
  "burpcollaborator",
  "capture",
  "catch",
  "check",
  "chrome-lighthouse",
  "chromeframe",
  "cloud",
  "crawl",
  "cryptoapi",
  "dareboost",
  "datanyze",
  "dataprovider",
  "dejaclick",
  "dmbrowser",
  "download",
  "evc-batch/",
  "feed",
  "firephp",
  "freesafeip",
  "ghost",
  "gomezagent",
  "google",
  "headlesschrome/",
  "http",
  "httrack",
  "hubspot marketing grader",
  "hydra",
  "ibisbrowser",
  "images",
  "iplabel",
  "ips-agent",
  "java",
  "library",
  "mail\\.ru/",
  "manager",
  "monitor",
  "morningscore/",
  "neustar wpm",
  "news",
  "nutch",
  "offbyone",
  "optimize",
  "pageburst",
  "pagespeed",
  "perl",
  "phantom",
  "pingdom",
  "powermarks",
  "preview",
  "proxy",
  "ptst[ /]\\d",
  "reader",
  "rexx;",
  "rigor",
  "rss",
  "scan",
  "scrape",
  "search",
  "serp ?reputation ?management",
  "server",
  "sogou",
  "sparkler/",
  "speedcurve",
  "spider",
  "statuscake",
  "stumbleupon\\.com",
  "supercleaner",
  "synapse",
  "synthetic",
  "taginspector/",
  "torrent",
  "tracemyfile",
  "transcoder",
  "trendsmapresolver",
  "twingly recon",
  "url",
  "virtuoso",
  "wappalyzer",
  "webglance",
  "webkit2png",
  "websitemetadataretriever",
  "whatcms/",
  "wordpress",
  "zgrab"
];
function amend(list2) {
  try {
    new RegExp("(?<! cu)bot").test("dangerbot");
  } catch {
    return list2;
  }
  return [
    // Addresses: Cubot device
    ["bot", "(?<! cu)bot"],
    // Addresses: Android webview
    ["google", "(?<! (?:channel/|google/))google(?!(app|/google| pixel))"],
    // Addresses: libhttp browser
    ["http", "(?<!(?:lib))http"],
    // Addresses: java based browsers
    ["java", "java(?!;)"],
    // Addresses: Yandex Search App
    ["search", "(?<! ya(?:yandex)?)search"]
  ].forEach((_ref) => {
    let [search, replace] = _ref, index = list2.lastIndexOf(search);
    ~index && list2.splice(index, 1, replace);
  }), list2;
}
amend(list);
var flags = "i", _list = /* @__PURE__ */ new WeakMap(), _pattern = /* @__PURE__ */ new WeakMap(), _update = /* @__PURE__ */ new WeakSet(), _index = /* @__PURE__ */ new WeakSet(), Isbot = class {
  constructor(patterns) {
    return _classPrivateMethodInitSpec(this, _index), _classPrivateMethodInitSpec(this, _update), _classPrivateFieldInitSpec(this, _list, {
      writable: !0,
      value: void 0
    }), _classPrivateFieldInitSpec(this, _pattern, {
      writable: !0,
      value: void 0
    }), _classPrivateFieldSet(this, _list, patterns || list.slice()), _classPrivateMethodGet(this, _update, _update2).call(this), Object.defineProperties((ua) => this.test(ua), Object.entries(Object.getOwnPropertyDescriptors(Isbot.prototype)).reduce((accumulator, _ref) => {
      let [prop, descriptor] = _ref;
      return typeof descriptor.value == "function" && Object.assign(accumulator, {
        [prop]: {
          value: this[prop].bind(this)
        }
      }), typeof descriptor.get == "function" && Object.assign(accumulator, {
        [prop]: {
          get: () => this[prop]
        }
      }), accumulator;
    }, {}));
  }
  /**
   * Get a clone of the pattern
   * @type RegExp
   */
  get pattern() {
    return new RegExp(_classPrivateFieldGet(this, _pattern));
  }
  /**
   * Match given string against out pattern
   * @param  {string} ua User Agent string
   * @returns {boolean}
   */
  test(ua) {
    return Boolean(ua) && _classPrivateFieldGet(this, _pattern).test(ua);
  }
  /**
   * Get the match for strings' known crawler pattern
   * @param  {string} ua User Agent string
   * @returns {string|null}
   */
  find() {
    let match = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "").match(_classPrivateFieldGet(this, _pattern));
    return match && match[0];
  }
  /**
   * Get the patterns that match user agent string if any
   * @param  {string} ua User Agent string
   * @returns {string[]}
   */
  matches() {
    let ua = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return _classPrivateFieldGet(this, _list).filter((entry2) => new RegExp(entry2, flags).test(ua));
  }
  /**
   * Clear all patterns that match user agent
   * @param  {string} ua User Agent string
   * @returns {void}
   */
  clear() {
    let ua = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    this.exclude(this.matches(ua));
  }
  /**
   * Extent patterns for known crawlers
   * @param  {string[]} filters
   * @returns {void}
   */
  extend() {
    let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    [].push.apply(_classPrivateFieldGet(this, _list), filters.filter((rule) => _classPrivateMethodGet(this, _index, _index2).call(this, rule) === -1).map((filter) => filter.toLowerCase())), _classPrivateMethodGet(this, _update, _update2).call(this);
  }
  /**
   * Exclude patterns from bot pattern rule
   * @param  {string[]} filters
   * @returns {void}
   */
  exclude() {
    let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], {
      length
    } = filters;
    for (; length--; ) {
      let index = _classPrivateMethodGet(this, _index, _index2).call(this, filters[length]);
      index > -1 && _classPrivateFieldGet(this, _list).splice(index, 1);
    }
    _classPrivateMethodGet(this, _update, _update2).call(this);
  }
  /**
   * Create a new Isbot instance using given list or self's list
   * @param  {string[]} [list]
   * @returns {Isbot}
   */
  spawn(list2) {
    return new Isbot(list2 || _classPrivateFieldGet(this, _list));
  }
};
function _update2() {
  _classPrivateFieldSet(this, _pattern, new RegExp(_classPrivateFieldGet(this, _list).join("|"), flags));
}
function _index2(rule) {
  return _classPrivateFieldGet(this, _list).indexOf(rule.toLowerCase());
}
var isbot = new Isbot();

// app/entry.server.tsx
var import_server = __toESM(require_server_node()), import_jsx_runtime = __toESM(require_jsx_runtime()), ABORT_DELAY = 5e3;
function handleRequest(request, responseStatusCode, responseHeaders, remixContext) {
  return isbot(request.headers.get("user-agent")) ? handleBotRequest(
    request,
    responseStatusCode,
    responseHeaders,
    remixContext
  ) : handleBrowserRequest(
    request,
    responseStatusCode,
    responseHeaders,
    remixContext
  );
}
function handleBotRequest(request, responseStatusCode, responseHeaders, remixContext) {
  return new Promise((resolve, reject) => {
    let { pipe, abort } = (0, import_server.renderToPipeableStream)(
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        import_react.RemixServer,
        {
          context: remixContext,
          url: request.url,
          abortDelay: ABORT_DELAY
        }
      ),
      {
        onAllReady() {
          let body = new import_node_stream.PassThrough();
          responseHeaders.set("Content-Type", "text/html"), resolve(
            new import_node.Response(body, {
              headers: responseHeaders,
              status: responseStatusCode
            })
          ), pipe(body);
        },
        onShellError(error) {
          reject(error);
        },
        onError(error) {
          responseStatusCode = 500, console.error(error);
        }
      }
    );
    setTimeout(abort, ABORT_DELAY);
  });
}
function handleBrowserRequest(request, responseStatusCode, responseHeaders, remixContext) {
  return new Promise((resolve, reject) => {
    let { pipe, abort } = (0, import_server.renderToPipeableStream)(
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        import_react.RemixServer,
        {
          context: remixContext,
          url: request.url,
          abortDelay: ABORT_DELAY
        }
      ),
      {
        onShellReady() {
          let body = new import_node_stream.PassThrough();
          responseHeaders.set("Content-Type", "text/html"), resolve(
            new import_node.Response(body, {
              headers: responseHeaders,
              status: responseStatusCode
            })
          ), pipe(body);
        },
        onShellError(error) {
          reject(error);
        },
        onError(error) {
          console.error(error), responseStatusCode = 500;
        }
      }
    );
    setTimeout(abort, ABORT_DELAY);
  });
}

// app/root.tsx
var root_exports = {};
__export(root_exports, {
  ErrorBoundary: () => ErrorBoundary,
  action: () => action,
  default: () => App,
  links: () => links
});
var import_react2 = __toESM(require_dist3()), import_node2 = __toESM(require_dist2());

// app/styles/app.css
var app_default = "/build/_assets/app-HCUYGGXP.css";

// app/root.tsx
var import_jsx_runtime2 = __toESM(require_jsx_runtime()), links = () => [{ rel: "stylesheet", href: app_default }];
function ErrorBoundary() {
  let error = (0, import_react2.useRouteError)();
  return (0, import_react2.isRouteErrorResponse)(error) ? /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("h1", { children: "Something went wrong!" }),
    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("p", { className: "text-[1px]", children: error.data })
  ] }) : error instanceof Error ? /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("h1", { children: "Something went wrong!" }),
    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("p", { className: "text-[1px]", children: error.message })
  ] }) : /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("h1", { children: "Something went wrong!" }) });
}
async function action({ request }) {
  let query = (await request.formData()).get("search-query");
  return (0, import_node2.redirect)(`/products/${query}`);
}
function App() {
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("html", { lang: "en", children: [
    /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("head", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("meta", { charSet: "utf-8" }),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("meta", { name: "viewport", content: "width=device-width,initial-scale=1" }),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_react2.Links, {}),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("title", { children: "Store Page" })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("body", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_react2.Outlet, {}),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_react2.Scripts, {}),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_react2.LiveReload, {})
    ] })
  ] });
}

// app/routes/products.$searchTerm.tsx
var products_searchTerm_exports = {};
__export(products_searchTerm_exports, {
  action: () => action2,
  default: () => MainRoute,
  loader: () => loader
});
var import_node3 = __toESM(require_dist2());

// app/components/appbar.tsx
var import_react3 = __toESM(require_dist3()), import_react4 = __toESM(require_react());

// app/icons/bdt-icon-logo-oldstack.tsx
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
function BdtIconAppLogoOldstack(attrs) {
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(
    "svg",
    {
      width: "137",
      height: "49",
      viewBox: "0 0 137 49",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...attrs,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M67.7799 42.684L132.817 48.2925L136.615 5.60852L71.578 0L48 19.4729L67.7799 42.684ZM132.539 9.18631L129.409 44.3523L125.918 44.0513L129.046 8.88627L132.539 9.18631ZM58.4302 18.5359C58.8776 19.0591 59.0954 19.7406 59.0343 20.4263C58.9733 21.1121 58.6385 21.7443 58.1057 22.1803C56.9901 23.098 55.3458 22.9562 54.4037 21.8612C53.9561 21.338 53.7381 20.6565 53.7991 19.9707C53.8601 19.2848 54.1948 18.6525 54.7276 18.2164C55.8433 17.2977 57.4887 17.4395 58.4307 18.5355L58.4302 18.5359Z",
            fill: "#F44945"
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M99.9508 11.9648V8.28765C98.7007 7.66368 96.9659 7.30255 95.3831 7.30273C92.7643 7.30273 90.6631 8.51754 90.6631 11.0131C90.6631 13.7182 93.1948 14.3724 94.7814 14.7824C95.5055 14.9695 96.0328 15.1058 96.0328 15.3629C96.0328 15.5928 95.8986 15.757 95.0148 15.757C93.8474 15.757 92.2797 15.2976 90.779 14.3617V18.2525C92.0963 18.9744 93.6974 19.352 95.5149 19.352C98.3162 19.352 100.601 18.5472 100.601 15.4612C100.601 12.8401 98.2122 12.2338 96.6262 11.8313C95.8381 11.6313 95.2482 11.4816 95.2482 11.16C95.2482 10.9479 95.4316 10.8322 95.9486 10.8322C97.1991 10.8157 98.7334 11.2753 99.9508 11.9648ZM74.8846 7.58008C77.5685 7.58008 79.0538 8.46726 79.0538 10.4861C79.0538 11.6025 78.7034 12.4397 77.4362 12.948C78.9036 13.3922 79.5208 14.3762 79.5208 15.7387C79.5208 18.3486 77.386 19.0705 74.7511 19.0705H68.5977V7.58008H74.8846ZM74.1342 10.6661H73.0328V12.0449H74.1336C74.3914 12.0594 74.6364 11.9315 74.7718 11.7117C74.9055 11.4934 74.9055 11.2186 74.7718 11.0004C74.6364 10.7807 74.3916 10.6528 74.134 10.6672L74.1342 10.6661ZM74.3176 14.4747H73.033V15.9521H74.3172C74.589 15.9605 74.8441 15.8218 74.9849 15.5892C75.1236 15.3581 75.1236 15.0694 74.9849 14.8384C74.8443 14.6057 74.5892 14.4668 74.3174 14.4749L74.3176 14.4747ZM89.6279 7.58008V10.8634H84.8908V11.8485H88.9599V14.7706H84.8908V15.7557H89.7269V19.0713H80.4551V7.58008H89.6279ZM111.358 7.58045V11.3565H108.357V19.0716H103.921V11.3561H100.919V7.58008H111.359L111.358 7.58045ZM79.9545 26.8377C79.9545 23.4557 78.1194 21.0918 73.9176 21.0918H68.5977V32.5835H73.9176C78.1201 32.5835 79.9545 30.2196 79.9545 26.8377ZM73.033 24.7035H73.751C74.718 24.7035 75.3843 25.1797 75.3843 26.8377C75.3843 28.4956 74.7172 28.9719 73.7501 28.9719H73.033V24.7035ZM90.1613 21.0902V24.3735H85.4254V25.3586H89.4944V28.2808H85.4254V29.2657H90.2613V32.5818H80.9893V21.0898H90.1613V21.0902ZM94.8138 21.0918L90.6279 32.5833H95.1146L95.4983 31.2701H98.8982L99.2819 32.5833H103.769L99.5832 21.0918H94.8138ZM98.0488 28.3149H96.3312L96.8486 26.5421C97.0083 25.9771 97.1253 25.4009 97.1986 24.8184C97.272 25.4009 97.3891 25.9771 97.549 26.5421L98.0488 28.3149ZM108.806 21.0906V28.8057H113.542V32.5818H104.37V21.0898H108.806V21.0906ZM123.481 21.7976C122.231 21.1738 120.497 20.8125 118.912 20.8125L118.913 20.8129C116.294 20.8129 114.193 22.0277 114.193 24.523C114.193 27.2279 116.725 27.8821 118.312 28.2922C119.036 28.4793 119.563 28.6156 119.563 28.8729C119.563 29.1027 119.429 29.2669 118.545 29.2669C117.378 29.2669 115.811 28.8075 114.309 27.8716V31.7626C115.627 32.4843 117.228 32.8619 119.046 32.8619C121.847 32.8619 124.132 32.0573 124.132 28.9713C124.132 26.3499 121.743 25.7436 120.157 25.3412C119.369 25.1412 118.779 24.9916 118.779 24.6702C118.779 24.4579 118.962 24.3422 119.479 24.3422C120.73 24.3257 122.264 24.7855 123.481 25.4748V21.7976Z",
            fill: "white"
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M101.79 35.498C104.029 35.498 105.166 36.8954 105.166 38.6834C105.166 40.4715 104.03 41.8686 101.79 41.8686C99.5495 41.8686 98.4209 40.4715 98.4209 38.6834C98.4209 36.8954 99.55 35.498 101.79 35.498ZM101.79 37.5812C101.216 37.5812 100.838 37.9545 100.838 38.6834C100.838 39.4124 101.217 39.7857 101.79 39.7857C102.372 39.7857 102.751 39.4122 102.751 38.6834C102.751 37.9547 102.372 37.5812 101.79 37.5812ZM98.3242 37.6435V35.6465H92.8057V37.6435H94.3922V41.7229H96.7372V37.6435H98.3242ZM90.7773 40.793C90.7773 41.5217 91.3069 41.869 91.9065 41.869C92.5147 41.869 93.0428 41.5219 93.0428 40.793C93.0428 40.064 92.5138 39.7168 91.9065 39.7168C91.3064 39.7168 90.7773 40.0642 90.7773 40.793ZM111.699 38.6843C111.699 36.8965 110.729 35.6465 108.508 35.6465H105.695V41.7222H108.508C110.729 41.7222 111.699 40.4722 111.699 38.6843ZM108.04 37.556H108.419L108.419 37.5545C108.931 37.5545 109.283 37.8053 109.283 38.6836C109.283 39.5619 108.931 39.8127 108.419 39.8127H108.04V37.556ZM111.488 41.7222L113.701 35.6465H116.223L118.436 41.7222H116.065L115.861 41.0277H114.063L113.859 41.7222H111.488ZM114.504 39.4655H115.412L115.147 38.5279C115.063 38.2293 115.001 37.9246 114.962 37.6167C114.923 37.9246 114.862 38.2293 114.777 38.5279L114.504 39.4655ZM119.442 39.6476V41.7222H121.77V39.6476L124.079 35.6465H121.434L120.606 37.7816L119.786 35.6465H117.141L119.442 39.6476Z",
            fill: "#FBE000"
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("path", { d: "M57.2308 19.3845H0V21.2307H57.2308V19.3845Z", fill: "white" })
      ]
    }
  );
}

// app/utils/app-bar-menu-items.ts
var app_bar_menu_items_default = [
  {
    title: "Electronics",
    href: "/electronics"
  },
  {
    title: "Appliances",
    href: "/appliances"
  },
  {
    title: "Automotive",
    href: "/automotive"
  },
  {
    title: "Software",
    href: "/software"
  },
  {
    title: "Home & Kitchen",
    href: "/home-kitchen"
  }
];

// app/components/appbar.tsx
var import_jsx_runtime4 = __toESM(require_jsx_runtime()), Appbar = () => /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("header", { className: "contents", children: /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("nav", { className: "border-gray-200 bg-[#333333] sticky top-0 z-50", children: [
  /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("div", { className: "flex items-center justify-between mx-auto ", children: [
    /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(BdtIconAppLogoOldstack, {}),
    /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(
      import_react3.Form,
      {
        className: "flex justify-center mx-auto tablet:hidden min-w-[50%]",
        method: "post",
        action: "/",
        reloadDocument: !0,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
            "input",
            {
              type: "text",
              "aria-label": "Search-input",
              name: "search-query",
              className: "w-full p-1 outline-none placeholder:text-sm pl-3 text-[#7b7b7b]",
              placeholder: "Search deals",
              defaultValue: ""
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
            "button",
            {
              className: "bg-red-500 uppercase text-white not-italic font-normal text-sm px-5",
              "aria-label": "Search-button",
              type: "submit",
              children: "Search"
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(
      "button",
      {
        className: "hidden tablet:flex flex-col justify-between w-6 h-4 cursor-pointer bg-transparent mr-3",
        "aria-label": "open-mobile-menu",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("span", { className: "block w-full h-0.5 bg-white" }),
          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("span", { className: "block w-full h-0.5 bg-white" }),
          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("span", { className: "block w-full h-0.5 bg-white" })
        ]
      }
    )
  ] }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("div", { className: "flex flex-row w-full justify-between px-20 py-2 tablet:hidden sticky top-12 z-50 bg-white drop-shadow-md", children: [
    app_bar_menu_items_default.map(({ title, href }, i2) => /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(import_react4.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("a", { href: `/${href}`, className: "font-light text-sm", "aria-label": "categories", children: title }) }, `${title}-${i2}`)),
    /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("a", { href: "/categories", className: "font-light text-sm", "aria-label": "categories", children: "See All" })
  ] })
] }) }), appbar_default = Appbar;

// app/components/content.tsx
var import_react7 = __toESM(require_react()), import_react8 = __toESM(require_dist3());

// app/utils/products-filter.ts
var filtersMapType = {
  byBrand: (products, filterValues) => filterValues.length ? products.filter((p) => filterValues.includes(p.brandName || "")) : products,
  byFixedPrice: (products, filterValues) => filterValues.length ? products.filter((p) => !p.auction && filterValues.includes("fixed")) : products,
  byDiscounted: (products, filterValues) => filterValues.length ? products.filter((p) => p.discount && filterValues.includes("discounted")) : products,
  byStore: (products, filterValues) => filterValues.length ? products.filter((p) => filterValues.includes(p.shop)) : products,
  byCondition: (products, filterValues) => filterValues.length ? products.filter((p) => filterValues.includes(p.condition)) : products,
  byShipping: (products, filterValues) => filterValues.length ? products.filter((p) => filterValues.includes("shipping") && p.freeShipping) : products
}, getProductsByFilters = (products, filters) => {
  if (!products.length)
    return [];
  if (!filters)
    return products;
  let filtersKeys = Object.keys(filters), iter = (filteredProducts, filterBy) => {
    if (filterBy.length === 0)
      return filteredProducts;
    let [currentFilterKey, ...restFilterKeys] = filterBy, updatedList = filtersMapType[currentFilterKey](
      filteredProducts,
      filters[currentFilterKey]
    );
    return iter(updatedList, restFilterKeys);
  };
  return iter(products, filtersKeys);
}, getBrandFilterValues = (products) => [...new Set(products.map((p) => p.brandName).filter((p) => p))], getConditionFilterValues = (products) => [...new Set(products.map((p) => p.condition).filter((p) => p))], getStoreFilterValues = (products) => [...new Set(products.map((p) => p.shop).filter((p) => p))];

// app/utils/currency-formatter.ts
var currency_formatter_default = new Intl.NumberFormat("en", { style: "currency", currency: "USD" });

// app/icons/bdt-icon-free-shipping.tsx
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
function BdtIconShipping({ fill, ...attrs }) {
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", ...attrs, children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
    "path",
    {
      fill,
      fillRule: "nonzero",
      d: "M15.975 6a1 1 0 011 1l-.002.068-.064.925h1.324a2 2 0 011.991 2.19l-.467 4.905a1 1 0 01-.995.906l-1.174-.001c.05.157.076.325.076.5 0 .83-.592 1.5-1.323 1.5-.73 0-1.323-.67-1.323-1.5 0-.17.025-.336.072-.489H8.77c.047.153.072.318.072.49 0 .828-.592 1.5-1.323 1.5-.73 0-1.323-.672-1.323-1.5 0-.172.025-.337.072-.49H5a1 1 0 01-1-1l.003-.078.195-1.552a.5.5 0 01.996.035l-.003.09L5 15.005l2.367-.001a1.181 1.181 0 01.306 0h7.756l.027-.348L15.975 7H6.939a.5.5 0 01-.09-.992L6.94 6h9.036zm.91 2.993l-.428 5.675-.022.324 2.327.002.095-1.008h-.014a.5.5 0 01.09-.992l.019-.001.095-1h-1.114a.5.5 0 010-1h1.209l.087-.905.004-.094A1 1 0 0018.35 9l-.117-.006-1.348-.001zm-6.952 1a.5.5 0 110 1h-5a.5.5 0 110-1h5zm0-2a.5.5 0 010 1h-3a.5.5 0 110-1h3z"
    }
  ) }) });
}

// app/components/desktop-filter.tsx
var import_react5 = __toESM(require_dist3()), import_react6 = __toESM(require_react());

// app/components/filter-row.tsx
var import_jsx_runtime6 = __toESM(require_jsx_runtime()), FilterRow = ({ title, filterBy, isChecked, value, onSubmit }) => /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("fieldset", { className: "flex flex-row justify-between items-center", children: [
  /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("label", { className: "text-sm font-normal capitalize text-[#7b7b7b] w-full", children: title }),
  /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
    "input",
    {
      name: filterBy,
      id: value,
      className: "text-white rounded-sm cursor-pointer ml-auto w-3 h-3 focus:ring-1 focus:ring-blue-300",
      value,
      type: "checkbox",
      checked: isChecked,
      onChange: onSubmit,
      "aria-label": `${title}-${value}`
    }
  )
] }), filter_row_default = FilterRow;

// app/components/desktop-filter.tsx
var import_jsx_runtime7 = __toESM(require_jsx_runtime()), DesktopFilter = () => {
  var _a4, _b, _c;
  let { products } = (0, import_react5.useLoaderData)(), submit = (0, import_react5.useSubmit)(), toggle = (0, import_react5.useFetcher)(), data = (0, import_react5.useActionData)(), brandNames = getBrandFilterValues(products), storeNames = getStoreFilterValues(products), conditions = getConditionFilterValues(products), isFixedPriceChecked = data != null && data.filters ? (_a4 = data == null ? void 0 : data.filters) == null ? void 0 : _a4.byFixedPrice.includes("fixed") : !1, isDiscountChecked = data != null && data.filters ? (_b = data == null ? void 0 : data.filters) == null ? void 0 : _b.byDiscounted.includes("discounted") : !1, handleOnChange = (e2) => {
    e2.preventDefault(), submit(e2.target.form);
  };
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(
    "div",
    {
      className: "tablet:hidden sticky min-w-[245px] drop-shadow-lg h-[100] bg-white px-5 py-8",
      "aria-label": "filters",
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(toggle.Form, { method: "post", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { className: "flex flex-row justify-between ", children: [
          /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("h1", { className: "text-[15px]", children: "Filter by" }),
          /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
            "button",
            {
              className: "underline font-light text-[15px] text-[#7b7b7b]",
              onClick: handleOnChange,
              "aria-label": "clear-all",
              children: "Clear all"
            }
          )
        ] }) }),
        /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(import_react5.Form, { method: "post", className: "flex flex-col gap-10 mt-10", children: [
          /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { className: "flex flex-col gap-5", children: [
            /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("h1", { className: "text-[#7b7b7b] text-[15px]", children: "Pricing" }),
            /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
              filter_row_default,
              {
                title: "Fixed",
                value: "fixed",
                isChecked: isFixedPriceChecked,
                filterBy: "byFixedPrice",
                onSubmit: handleOnChange
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
              filter_row_default,
              {
                title: "Discounted Products",
                value: "discounted",
                isChecked: isDiscountChecked,
                filterBy: "byDiscounted",
                onSubmit: handleOnChange
              }
            )
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { className: "flex flex-col gap-5", children: [
            /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("h1", { className: "text-[#7b7b7b] text-[15px]", children: "Store" }),
            storeNames.map((store, i2) => {
              var _a5;
              return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(import_react6.default.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
                filter_row_default,
                {
                  title: store,
                  value: store,
                  isChecked: data != null && data.filters ? (_a5 = data == null ? void 0 : data.filters) == null ? void 0 : _a5.byStore.includes(store) : !1,
                  filterBy: "byStore",
                  onSubmit: handleOnChange
                }
              ) }, `${store}-${i2}`);
            })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { className: "flex flex-col gap-5", children: [
            /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("h1", { className: "text-[#7b7b7b] text-[15px]", children: "Condition" }),
            conditions.map((condition, i2) => {
              var _a5;
              return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(import_react6.default.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
                filter_row_default,
                {
                  title: condition,
                  value: condition,
                  isChecked: data != null && data.filters ? (_a5 = data == null ? void 0 : data.filters) == null ? void 0 : _a5.byCondition.includes(condition) : !1,
                  filterBy: "byCondition",
                  onSubmit: handleOnChange
                }
              ) }, `${condition}-${i2}`);
            })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { className: "flex flex-col gap-5", children: [
            /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("h1", { className: "text-[#7b7b7b] text-[15px]", children: "Brand" }),
            brandNames.map((brand, i2) => {
              var _a5;
              return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(import_react6.default.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
                filter_row_default,
                {
                  title: brand,
                  value: brand,
                  isChecked: data != null && data.filters ? (_a5 = data == null ? void 0 : data.filters) == null ? void 0 : _a5.byBrand.includes(brand) : !1,
                  filterBy: "byBrand",
                  onSubmit: handleOnChange
                }
              ) }, `${brand}-${i2}`);
            })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { className: "flex flex-col gap-5", children: [
            /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("h1", { className: "text-[#7b7b7b] text-[15px]", children: "Other" }),
            /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
              filter_row_default,
              {
                title: "Free Shipping",
                value: "shipping",
                isChecked: data != null && data.filters ? (_c = data == null ? void 0 : data.filters) == null ? void 0 : _c.byShipping.includes("shipping") : !1,
                filterBy: "byShipping",
                onSubmit: handleOnChange
              }
            )
          ] })
        ] })
      ]
    }
  );
}, desktop_filter_default = DesktopFilter;

// app/components/content.tsx
var import_jsx_runtime8 = __toESM(require_jsx_runtime()), Content = () => {
  let { products, metadata } = (0, import_react8.useLoaderData)(), data = (0, import_react8.useActionData)(), filteredProducts = getProductsByFilters(products.slice(0, 35), data == null ? void 0 : data.filters);
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex flex-row", children: [
    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(desktop_filter_default, {}),
    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "w-full h-full px-6", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex flex-col justify-center mt-4 mb-4", children: [
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "overflow-visible", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex flex-col gap-4 mt-5", children: [
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "flex flex-row text-[13px] leading-normal text-gray-400 ml-[-4px]", children: metadata.breadcrumbs.map((crump, i2) => /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
          "a",
          {
            className: 'after:content-["/"] last:after:content-[""] capitalize',
            href: crump.path,
            children: [
              "\xA0\xA0",
              `${crump.title}`,
              "\xA0\xA0"
            ]
          },
          i2
        )) }),
        /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex flex-row", children: [
          /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex flex-row gap-5 sm:gap-3 sm:flex-col pr-9 mobile:pr-0", children: [
            /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("p", { className: "text-2xl capitalize", children: [
              "Best ",
              metadata.query,
              " deals in the united states"
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("span", { className: "flex leading-none text-base font-light text-[#686868] items-center", children: [
              filteredProducts.length,
              " deals found"
            ] })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "ml-auto" })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "border-b-[1px] sm:hidden" }),
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { className: "text-[13px] font-light mobile:hidden", children: metadata == null ? void 0 : metadata.queryInfoTop })
      ] }) }),
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "grid mobile:grid-cols-2 tablet:grid-cols-3 desktop:grid-cols-3 xl-desktop:grid-cols-4 gap-5 mt-9", children: filteredProducts.map((p, i2) => /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(import_react7.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
        "a",
        {
          "aria-label": "product-card",
          href: p.redirectLinkTo,
          rel: "noreferrer",
          target: "_blank",
          className: " flex overflow-hidden relative flex-col justify-between rounded-sm cursor-pointer drop-shadow-md bg-white",
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "pb-8", children: p.merchantLogo && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
              "img",
              {
                className: "h-5 absolute right-3 top-3 mobile:hidden",
                src: p.merchantLogo,
                alt: p.title
              }
            ) }),
            p.discount && /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "absolute top-16 left-[-12px] flex rotate-[-45deg] items-center justify-center w-32 h-8 origin-left whitespace-no-wrap bg-red-500 text-white", children: [
              Math.ceil(p.discount),
              "% OFF"
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "p-3 flex justify-center items-center h-32 w-32 mx-auto", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
              "img",
              {
                className: "mx-auto object-scale-down h-32 w-32",
                src: p.image,
                alt: p.title
              }
            ) }),
            /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "h-32 p-3", children: [
              /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "text-center block overflow-hidden whitespace-no-wrap w-full text-ellipsis ...", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { className: "line-clamp-1", children: p.title }) }),
              /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "text-center capitalize mb-2", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { children: p.condition }) }),
              /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "border-b-[1px] mx-[-30px]" }),
              /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "line-through text-center text-red-500 mt-6", children: p.oldPrice && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { children: currency_formatter_default.format(p.oldPrice) }) })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex flex-row justify-center tablet:hidden", children: [
              /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(BdtIconShipping, { fill: "#595959" }),
              /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { className: "text-[#595959] text-[15px] font-normal uppercase", children: "Free shipping" })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "mobile:flex flex-row justify-center hidden", children: p.merchantLogo && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("img", { className: "h-5", src: p.merchantLogo, alt: p.title }) }),
            /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "p-3", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
              "button",
              {
                className: " p-0 bg-[#61c200] hover:bg-[#52a102] uppercase text-white font-normal sm:text-sm py-2 px-4 w-full",
                "aria-label": "product-cta",
                children: "View Deal"
              }
            ) }) })
          ]
        }
      ) }, `${p.title}-${i2}`)) })
    ] }) })
  ] });
}, content_default = Content;

// app/components/footer.tsx
var import_react9 = __toESM(require_react());

// app/icons/bdt-icon-logo-footer.tsx
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
function BdtIconAppLogoFooter(attrs) {
  return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "40", height: "24", viewBox: "0 0 40 24", ...attrs, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("g", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("g", { fill: "#FFF", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("path", { d: "M19.292 0c1.14 0 2.39.258 3.29.703v2.623c-.876-.492-1.982-.82-2.882-.808-.373 0-.505.083-.505.234 0 .691 3.856.27 3.856 3.069 0 2.202-1.646 2.776-3.664 2.776-1.309 0-2.462-.27-3.41-.784V5.037c1.08.667 2.21.995 3.05.995.637 0 .733-.117.733-.281 0-.586-3.867-.293-3.867-3.104 0-1.78 1.513-2.647 3.4-2.647zM4.528.199c1.933 0 3.003.633 3.003 2.073 0 .797-.252 1.394-1.165 1.757 1.057.317 1.502 1.019 1.502 1.991 0 1.862-1.538 2.377-3.436 2.377H0V.2h4.528zm10.62 0v2.343h-3.412v.703h2.93v2.084h-2.93v.703h3.483v2.366H8.54V.199h6.607zm15.651 0v2.694h-2.162v5.505h-3.195V2.893H23.28V.199h7.52zM4.12 5.119h-.924v1.053h.925a.544.544 0 00.48-.259c.1-.164.1-.37 0-.535a.544.544 0 00-.48-.26zM3.989 2.4h-.793v.984h.792c.186.01.363-.081.46-.238a.482.482 0 000-.508.508.508 0 00-.46-.237V2.4zM36.24 9.966c1.141 0 2.39.258 3.291.703v2.624c-.876-.492-1.981-.82-2.882-.808-.373 0-.505.082-.505.234 0 .69 3.856.269 3.856 3.068 0 2.202-1.646 2.776-3.664 2.776-1.309 0-2.462-.269-3.411-.784v-2.776c1.081.668 2.21.995 3.05.995.638 0 .734-.117.734-.28 0-.586-3.868-.294-3.868-3.104 0-1.717 1.408-2.585 3.2-2.644l.199-.004zm-32.408.2c3.026 0 4.348 1.686 4.348 4.099 0 2.413-1.321 4.1-4.348 4.1H0v-8.2h3.832zm11.7-.001v2.343H12.12v.703h2.931v2.085h-2.93v.702h3.482v2.366H8.925v-8.199h6.606zm6.786 0l3.014 8.2h-3.231l-.277-.938h-2.449l-.276.937h-3.232l3.015-8.199h3.436zm6.643 0v5.505h3.411v2.694h-6.606v-8.2h3.195zm-25.25 2.577h-.516v3.046h.516c.697 0 1.177-.34 1.177-1.523 0-1.183-.48-1.523-1.176-1.523zm16.89.082a8.28 8.28 0 01-.253 1.23l-.373 1.265h1.237l-.36-1.265a8.28 8.28 0 01-.252-1.23z" }) }),
    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
      "path",
      {
        fill: "#FFC31E",
        d: "M16.789 22.464c.437 0 .818.248.818.768s-.38.768-.818.768c-.432 0-.814-.248-.814-.768s.381-.768.814-.768zm7.118-3.01c1.613 0 2.432.998 2.432 2.273 0 1.276-.818 2.273-2.432 2.273-1.613 0-2.426-.997-2.426-2.273 0-1.275.813-2.272 2.426-2.272zm-2.496.106v1.425h-1.143v2.91H18.58v-2.91h-1.142V19.56h3.974zm7.335 0c1.6 0 2.299.892 2.299 2.167 0 1.276-.699 2.168-2.299 2.168h-2.025V19.56h2.025zm5.557 0l1.594 4.335h-1.708l-.146-.496h-1.296l-.146.496h-1.708l1.594-4.335h1.816zm2.566 0l.59 1.523.597-1.523h1.906l-1.664 2.855v1.48H36.62v-1.48l-1.657-2.855h1.905zm-8.186 1.361v.001h-.273v1.61h.273c.368 0 .622-.178.622-.805s-.254-.806-.622-.806zm-4.776.02c-.413 0-.685.266-.685.786s.273.787.685.787c.42 0 .692-.267.692-.787s-.273-.786-.692-.786zm9.488.025c-.028.22-.072.437-.133.65l-.197.669h.654l-.19-.67a4.375 4.375 0 01-.134-.65z"
      }
    )
  ] }) }) });
}

// app/utils/footer-navigation.ts
var footer_navigation_default = [
  {
    title: "General",
    menuItems: [
      {
        title: "Home",
        href: "/"
      },
      {
        title: "Privacy",
        href: "/privacy"
      },
      {
        title: "Terms & Conditions",
        href: "/terms"
      },
      { title: "Contact Us", href: "/contact-us" }
    ]
  },
  {
    title: "Popular searches",
    menuItems: [
      {
        title: "Oculus Quest 2",
        href: "/oculus-quest-2"
      },
      {
        title: "Airpod Pro",
        href: "/airpod-pro"
      },
      {
        title: "Ember Wave",
        href: "/ember-wave"
      },
      {
        title: "Dyson Airwrap Complete",
        href: "/dyson-airwrap-complete"
      },
      {
        title: "Uniden R7",
        href: "/uniden-r-7"
      },
      {
        title: "Nintendo Switch",
        href: "/nintendo-switch"
      },
      {
        title: "Laptop",
        href: "/laptop"
      }
    ]
  },
  {
    title: "Categories",
    menuItems: [
      {
        title: "Electronics",
        href: "/electronics"
      },
      {
        title: "Appliances",
        href: "/appliances"
      },
      {
        title: "Automotive",
        href: "/automotive"
      },
      {
        title: "Software",
        href: "/software"
      },
      {
        title: "Home & Kitchen",
        href: "/home-kitchen"
      }
    ]
  },
  {
    title: "International sites",
    menuItems: [
      {
        title: "France",
        href: "//fr.bestdeals.today"
      },
      {
        title: "Australia",
        href: "//au.bestdeals.today"
      },
      {
        title: "Spain",
        href: "//es.bestdeals.today"
      },
      {
        title: "Japan",
        href: "//jp.bestdeals.today"
      },
      {
        title: "Italy",
        href: "//it.bestdeals.today"
      },
      {
        title: "Germany",
        href: "//de.bestdeals.today"
      },
      {
        title: "Canada",
        href: "//ca.bestdeals.today"
      },
      {
        title: "Singapore",
        href: "//sg.bestdeals.today"
      },
      {
        title: "United Kingdom",
        href: "//uk.bestdeals.today"
      },
      {
        title: "Mexico",
        href: "//mx.bestdeals.today"
      },
      {
        title: "India",
        href: "//in.bestdeals.today"
      }
    ]
  }
];

// app/components/footer.tsx
var import_jsx_runtime10 = __toESM(require_jsx_runtime()), Footer = () => /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("footer", { className: "px-[24px] bg-[#333333]", children: /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)("div", { className: "max-w-[1400px] py-[40px] mx-auto text-white", children: [
  /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)("div", { className: "tablet:text-center tablet:items-center tablet:flex-col tablet:justify-center flex items-start justify-between text-left", children: [
    /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("a", { href: "/", className: "mt-5 tablet:mb-10", children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(BdtIconAppLogoFooter, { width: 104, height: 62 }) }),
    footer_navigation_default.map((item, i2) => /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)("div", { className: "p-5", children: [
      /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("h4", { className: "mb-4 text-white font-bold uppercase", children: item.title }),
      /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)("ul", { children: [
        item.menuItems.map((menuItem, index) => /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(import_react9.default.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("a", { href: menuItem.href, className: "block text-white font-light my-2 text-sm", children: menuItem.title }) }, `${menuItem}-${index}`)),
        item.title === "Categories" && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(import_react9.default.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("a", { href: "/categories", children: "See All" }) }, item.menuItems.length)
      ] })
    ] }, `${item}-${i2}`))
  ] }),
  /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("div", { className: "mt-6 pt-6 border-t-[0.01em] border-solid border-gray-400 tablet:items-center text-center text-[12px]", children: /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)("div", { className: "flex tablet:flex-col-reverse flex-row justify-between", children: [
    /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("div", { className: "", children: "Amazon, Amazon Prime, the Amazon logo and Amazon Prime logo are trademarks of Amazon.com, Inc. or its affiliates" }),
    /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)("div", { className: "justify-between mb-2", children: [
      "Bestdeals.today\xA0\xA9 ",
      (/* @__PURE__ */ new Date()).getFullYear(),
      " All Rights Reserved"
    ] })
  ] }) })
] }) }), footer_default = Footer;

// node_modules/camelcase-keys/index.js
var import_map_obj = __toESM(require_map_obj(), 1);

// node_modules/camelcase/index.js
var UPPERCASE = /[\p{Lu}]/u, LOWERCASE = /[\p{Ll}]/u, LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu, IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u, SEPARATORS = /[_.\- ]+/, LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source), SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu"), NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu"), preserveCamelCase = (string, toLowerCase, toUpperCase, preserveConsecutiveUppercase2) => {
  let isLastCharLower = !1, isLastCharUpper = !1, isLastLastCharUpper = !1, isLastLastCharPreserved = !1;
  for (let index = 0; index < string.length; index++) {
    let character = string[index];
    isLastLastCharPreserved = index > 2 ? string[index - 3] === "-" : !0, isLastCharLower && UPPERCASE.test(character) ? (string = string.slice(0, index) + "-" + string.slice(index), isLastCharLower = !1, isLastLastCharUpper = isLastCharUpper, isLastCharUpper = !0, index++) : isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character) && (!isLastLastCharPreserved || preserveConsecutiveUppercase2) ? (string = string.slice(0, index - 1) + "-" + string.slice(index - 1), isLastLastCharUpper = isLastCharUpper, isLastCharUpper = !1, isLastCharLower = !0) : (isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character, isLastLastCharUpper = isLastCharUpper, isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character);
  }
  return string;
}, preserveConsecutiveUppercase = (input, toLowerCase) => (LEADING_CAPITAL.lastIndex = 0, input.replace(LEADING_CAPITAL, (m1) => toLowerCase(m1))), postProcess = (input, toUpperCase) => (SEPARATORS_AND_IDENTIFIER.lastIndex = 0, NUMBERS_AND_IDENTIFIER.lastIndex = 0, input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier)).replace(NUMBERS_AND_IDENTIFIER, (m2) => toUpperCase(m2)));
function camelCase(input, options) {
  if (!(typeof input == "string" || Array.isArray(input)))
    throw new TypeError("Expected the input to be `string | string[]`");
  if (options = {
    pascalCase: !1,
    preserveConsecutiveUppercase: !1,
    ...options
  }, Array.isArray(input) ? input = input.map((x2) => x2.trim()).filter((x2) => x2.length).join("-") : input = input.trim(), input.length === 0)
    return "";
  let toLowerCase = options.locale === !1 ? (string) => string.toLowerCase() : (string) => string.toLocaleLowerCase(options.locale), toUpperCase = options.locale === !1 ? (string) => string.toUpperCase() : (string) => string.toLocaleUpperCase(options.locale);
  return input.length === 1 ? SEPARATORS.test(input) ? "" : options.pascalCase ? toUpperCase(input) : toLowerCase(input) : (input !== toLowerCase(input) && (input = preserveCamelCase(input, toLowerCase, toUpperCase, options.preserveConsecutiveUppercase)), input = input.replace(LEADING_SEPARATORS, ""), input = options.preserveConsecutiveUppercase ? preserveConsecutiveUppercase(input, toLowerCase) : toLowerCase(input), options.pascalCase && (input = toUpperCase(input.charAt(0)) + input.slice(1)), postProcess(input, toUpperCase));
}

// node_modules/quick-lru/index.js
var QuickLRU = class extends Map {
  constructor(options = {}) {
    if (super(), !(options.maxSize && options.maxSize > 0))
      throw new TypeError("`maxSize` must be a number greater than 0");
    if (typeof options.maxAge == "number" && options.maxAge === 0)
      throw new TypeError("`maxAge` must be a number greater than 0");
    this.maxSize = options.maxSize, this.maxAge = options.maxAge || Number.POSITIVE_INFINITY, this.onEviction = options.onEviction, this.cache = /* @__PURE__ */ new Map(), this.oldCache = /* @__PURE__ */ new Map(), this._size = 0;
  }
  // TODO: Use private class methods when targeting Node.js 16.
  _emitEvictions(cache2) {
    if (typeof this.onEviction == "function")
      for (let [key, item] of cache2)
        this.onEviction(key, item.value);
  }
  _deleteIfExpired(key, item) {
    return typeof item.expiry == "number" && item.expiry <= Date.now() ? (typeof this.onEviction == "function" && this.onEviction(key, item.value), this.delete(key)) : !1;
  }
  _getOrDeleteIfExpired(key, item) {
    if (this._deleteIfExpired(key, item) === !1)
      return item.value;
  }
  _getItemValue(key, item) {
    return item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;
  }
  _peek(key, cache2) {
    let item = cache2.get(key);
    return this._getItemValue(key, item);
  }
  _set(key, value) {
    this.cache.set(key, value), this._size++, this._size >= this.maxSize && (this._size = 0, this._emitEvictions(this.oldCache), this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map());
  }
  _moveToRecent(key, item) {
    this.oldCache.delete(key), this._set(key, item);
  }
  *_entriesAscending() {
    for (let item of this.oldCache) {
      let [key, value] = item;
      this.cache.has(key) || this._deleteIfExpired(key, value) === !1 && (yield item);
    }
    for (let item of this.cache) {
      let [key, value] = item;
      this._deleteIfExpired(key, value) === !1 && (yield item);
    }
  }
  get(key) {
    if (this.cache.has(key)) {
      let item = this.cache.get(key);
      return this._getItemValue(key, item);
    }
    if (this.oldCache.has(key)) {
      let item = this.oldCache.get(key);
      if (this._deleteIfExpired(key, item) === !1)
        return this._moveToRecent(key, item), item.value;
    }
  }
  set(key, value, { maxAge = this.maxAge } = {}) {
    let expiry = typeof maxAge == "number" && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : void 0;
    this.cache.has(key) ? this.cache.set(key, {
      value,
      expiry
    }) : this._set(key, { value, expiry });
  }
  has(key) {
    return this.cache.has(key) ? !this._deleteIfExpired(key, this.cache.get(key)) : this.oldCache.has(key) ? !this._deleteIfExpired(key, this.oldCache.get(key)) : !1;
  }
  peek(key) {
    if (this.cache.has(key))
      return this._peek(key, this.cache);
    if (this.oldCache.has(key))
      return this._peek(key, this.oldCache);
  }
  delete(key) {
    let deleted = this.cache.delete(key);
    return deleted && this._size--, this.oldCache.delete(key) || deleted;
  }
  clear() {
    this.cache.clear(), this.oldCache.clear(), this._size = 0;
  }
  resize(newSize) {
    if (!(newSize && newSize > 0))
      throw new TypeError("`maxSize` must be a number greater than 0");
    let items = [...this._entriesAscending()], removeCount = items.length - newSize;
    removeCount < 0 ? (this.cache = new Map(items), this.oldCache = /* @__PURE__ */ new Map(), this._size = items.length) : (removeCount > 0 && this._emitEvictions(items.slice(0, removeCount)), this.oldCache = new Map(items.slice(removeCount)), this.cache = /* @__PURE__ */ new Map(), this._size = 0), this.maxSize = newSize;
  }
  *keys() {
    for (let [key] of this)
      yield key;
  }
  *values() {
    for (let [, value] of this)
      yield value;
  }
  *[Symbol.iterator]() {
    for (let item of this.cache) {
      let [key, value] = item;
      this._deleteIfExpired(key, value) === !1 && (yield [key, value.value]);
    }
    for (let item of this.oldCache) {
      let [key, value] = item;
      this.cache.has(key) || this._deleteIfExpired(key, value) === !1 && (yield [key, value.value]);
    }
  }
  *entriesDescending() {
    let items = [...this.cache];
    for (let i2 = items.length - 1; i2 >= 0; --i2) {
      let item = items[i2], [key, value] = item;
      this._deleteIfExpired(key, value) === !1 && (yield [key, value.value]);
    }
    items = [...this.oldCache];
    for (let i2 = items.length - 1; i2 >= 0; --i2) {
      let item = items[i2], [key, value] = item;
      this.cache.has(key) || this._deleteIfExpired(key, value) === !1 && (yield [key, value.value]);
    }
  }
  *entriesAscending() {
    for (let [key, value] of this._entriesAscending())
      yield [key, value.value];
  }
  get size() {
    if (!this._size)
      return this.oldCache.size;
    let oldCacheSize = 0;
    for (let key of this.oldCache.keys())
      this.cache.has(key) || oldCacheSize++;
    return Math.min(this._size + oldCacheSize, this.maxSize);
  }
  entries() {
    return this.entriesAscending();
  }
  forEach(callbackFunction, thisArgument = this) {
    for (let [key, value] of this.entriesAscending())
      callbackFunction.call(thisArgument, value, key, this);
  }
  get [Symbol.toStringTag]() {
    return JSON.stringify([...this.entriesAscending()]);
  }
};

// node_modules/camelcase-keys/index.js
var has = (array, key) => array.some((element) => typeof element == "string" ? element === key : (element.lastIndex = 0, element.test(key))), cache = new QuickLRU({ maxSize: 1e5 }), isObject = (value) => typeof value == "object" && value !== null && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date), camelCaseConvert = (input, options) => {
  if (!isObject(input))
    return input;
  options = {
    deep: !1,
    pascalCase: !1,
    ...options
  };
  let { exclude, pascalCase, stopPaths, deep } = options, stopPathsSet = new Set(stopPaths), makeMapper = (parentPath) => (key, value) => {
    if (deep && isObject(value)) {
      let path = parentPath === void 0 ? key : `${parentPath}.${key}`;
      stopPathsSet.has(path) || (value = (0, import_map_obj.default)(value, makeMapper(path)));
    }
    if (!(exclude && has(exclude, key))) {
      let cacheKey = pascalCase ? `${key}_` : key;
      if (cache.has(cacheKey))
        key = cache.get(cacheKey);
      else {
        let returnValue = camelCase(key, { pascalCase, locale: !1 });
        key.length < 100 && cache.set(cacheKey, returnValue), key = returnValue;
      }
    }
    return [key, value];
  };
  return (0, import_map_obj.default)(input, makeMapper(void 0));
};
function camelcaseKeys(input, options) {
  return Array.isArray(input) ? Object.keys(input).map((key) => camelCaseConvert(input[key], options)) : camelCaseConvert(input, options);
}

// node_modules/@roundforest/http-commons/src/http-commons.js
var import_lodash = __toESM(require_lodash(), 1);

// node_modules/@roundforest/functional-commons/src/functional-commons.js
function memo(syncCreationFunction) {
  let cacheMap = /* @__PURE__ */ new Map();
  return (...args) => {
    let key = JSON.stringify(args), cachedValue = cacheMap.get(key);
    if (cachedValue)
      return cachedValue;
    let newValue = syncCreationFunction(...args);
    if (typeof /** @type {any} */
    newValue.then == "function")
      throw new Error("your function returned a promise. Maybe you want to use cacheFunctionAsync?");
    return cacheMap.set(key, newValue), newValue;
  };
}
function makeError(error, properties) {
  return typeof error == "string" && (error = new Error(error)), properties ? Object.assign(error, properties) : error;
}

// node_modules/@roundforest/promise-commons/src/promise-commons.js
function delay(ms) {
  return new Promise((res) => setTimeout(res, ms));
}
var resolveSymbol = Symbol("resolve-promise"), rejectSymbol = Symbol("reject-promise");

// node_modules/@roundforest/http-commons/src/http-commons.js
function makeClient(fetcher2, requestIdGetterSymbol2) {
  async function throwErrorFromBadStatus2(response) {
    var _a4, _b;
    let body = await response.text().catch(() => "failed to get body of error");
    throw makeError(`Response ${response.status} returned from ${response.url}, body: ${body}`, {
      code: "ERR_X_STATUS_CODE_NOT_OK",
      status: response.status,
      statusText: response.statusText,
      // @ts-expect-error
      headers: ((_b = (_a4 = response == null ? void 0 : response.headers) == null ? void 0 : _a4.raw) == null ? void 0 : _b.call(_a4)) ?? response.headers,
      body
    });
  }
  async function fetchAsJson2(url, init, jsonReviver) {
    let response = await fetcher2(url, (0, import_lodash.default)({ headers: { Accept: "application/json" } }, init));
    return response.ok || await throwErrorFromBadStatus2(response), jsonReviver ? await JSON.parse(await response.text(), jsonReviver) : await response.json();
  }
  async function fetchAsText2(url, init) {
    let response = await fetcher2(url, init);
    return response.ok || await throwErrorFromBadStatus2(response), await response.text();
  }
  async function fetchAsTextWithJsonBody2(url, json3, init) {
    let response = await fetcher2(
      url,
      // @ts-expect-error
      (0, import_lodash.default)(
        { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(json3) },
        init || {}
      )
    );
    return response.ok || await throwErrorFromBadStatus2(response), await response.text();
  }
  async function fetchAsBuffer2(url, init) {
    let response = await /** @type {nodeFetch}*/
    fetcher2(url, init);
    return response.ok || await throwErrorFromBadStatus2(response), await response.buffer();
  }
  async function fetchAsBufferWithJsonBody2(url, json3, init) {
    let response = await /** @type {nodeFetch}*/
    fetcher2(
      url,
      (0, import_lodash.default)(
        { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(json3) },
        init || {}
      )
    );
    return response.ok || await throwErrorFromBadStatus2(response), await response.buffer();
  }
  async function fetchAsJsonWithJsonBody2(url, json3, init, jsonReviver) {
    let response = await fetcher2(
      url,
      // @ts-expect-error
      (0, import_lodash.default)(
        {
          method: "POST",
          headers: { "Content-Type": "application/json", Accept: "application/json" },
          body: JSON.stringify(json3)
        },
        init || {}
      )
    );
    return response.ok || await throwErrorFromBadStatus2(response), jsonReviver ? JSON.parse(await response.text(), jsonReviver) : await response.json();
  }
  async function retryFetch2(f3, { retries = 2, sleepTime = 100, backoff = 1.1, idempotent = !0 } = {}) {
    for (let retry = 0; retry <= retries; retry++) {
      if (retry === retries)
        return await f3(retry);
      try {
        return await f3(retry);
      } catch (err) {
        if (!(CONNECTION_ERROR_CODES.has(err.code) || CONNECTION_ERROR_CODES.has(err.type))) {
          if (err.code === "ERR_X_STATUS_CODE_NOT_OK") {
            if (err.status >= 300 && err.status < 500)
              throw err;
          } else if (!idempotent)
            throw err;
        }
        await delay(sleepTime * backoff ** retry);
      }
    }
  }
  function setGlobalRequestIdGetter2(requestIdGetter) {
    if (globalThis[requestIdGetterSymbol2] != null)
      throw new Error("you are not allowed to change global request id getter");
    globalThis[requestIdGetterSymbol2] = requestIdGetter;
  }
  let CONNECTION_ERROR_CODES = /* @__PURE__ */ new Set([
    "ENOTFOUND",
    "ECONNREFUSED",
    "ETIMEDOUT",
    "EHOSTUNREACH",
    "ECONNRESET",
    "request-timeout"
  ]);
  return {
    throwErrorFromBadStatus: throwErrorFromBadStatus2,
    fetchAsJson: fetchAsJson2,
    fetchAsText: fetchAsText2,
    fetchAsTextWithJsonBody: fetchAsTextWithJsonBody2,
    fetchAsBuffer: fetchAsBuffer2,
    fetchAsBufferWithJsonBody: fetchAsBufferWithJsonBody2,
    fetchAsJsonWithJsonBody: fetchAsJsonWithJsonBody2,
    setGlobalRequestIdGetter: setGlobalRequestIdGetter2,
    retryFetch: retryFetch2,
    fetch: fetcher2
  };
}

// node_modules/node-fetch/src/index.js
var import_node_http2 = __toESM(require("node:http"), 1), import_node_https = __toESM(require("node:https"), 1), import_node_zlib = __toESM(require("node:zlib"), 1), import_node_stream3 = __toESM(require("node:stream"), 1), import_node_buffer2 = require("node:buffer");

// node_modules/node-fetch/node_modules/data-uri-to-buffer/dist/index.js
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri))
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  uri = uri.replace(/\r?\n/g, "");
  let firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4)
    throw new TypeError("malformed data: URI");
  let meta = uri.substring(5, firstComma).split(";"), charset = "", base64 = !1, type = meta[0] || "text/plain", typeFull = type;
  for (let i2 = 1; i2 < meta.length; i2++)
    meta[i2] === "base64" ? base64 = !0 : meta[i2] && (typeFull += `;${meta[i2]}`, meta[i2].indexOf("charset=") === 0 && (charset = meta[i2].substring(8)));
  !meta[0] && !charset.length && (typeFull += ";charset=US-ASCII", charset = "US-ASCII");
  let encoding = base64 ? "base64" : "ascii", data = unescape(uri.substring(firstComma + 1)), buffer = Buffer.from(data, encoding);
  return buffer.type = type, buffer.typeFull = typeFull, buffer.charset = charset, buffer;
}
var dist_default = dataUriToBuffer;

// node_modules/node-fetch/src/body.js
var import_node_stream2 = __toESM(require("node:stream"), 1), import_node_util = require("node:util"), import_node_buffer = require("node:buffer");
init_fetch_blob();
init_esm_min();

// node_modules/node-fetch/src/errors/base.js
var FetchBaseError = class extends Error {
  constructor(message, type) {
    super(message), Error.captureStackTrace(this, this.constructor), this.type = type;
  }
  get name() {
    return this.constructor.name;
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
};

// node_modules/node-fetch/src/errors/fetch-error.js
var FetchError = class extends FetchBaseError {
  /**
   * @param  {string} message -      Error message for human
   * @param  {string} [type] -        Error type for machine
   * @param  {SystemError} [systemError] - For Node.js system error
   */
  constructor(message, type, systemError) {
    super(message, type), systemError && (this.code = this.errno = systemError.code, this.erroredSysCall = systemError.syscall);
  }
};

// node_modules/node-fetch/src/utils/is.js
var NAME = Symbol.toStringTag, isURLSearchParameters = (object) => typeof object == "object" && typeof object.append == "function" && typeof object.delete == "function" && typeof object.get == "function" && typeof object.getAll == "function" && typeof object.has == "function" && typeof object.set == "function" && typeof object.sort == "function" && object[NAME] === "URLSearchParams", isBlob = (object) => object && typeof object == "object" && typeof object.arrayBuffer == "function" && typeof object.type == "string" && typeof object.stream == "function" && typeof object.constructor == "function" && /^(Blob|File)$/.test(object[NAME]), isAbortSignal = (object) => typeof object == "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget"), isDomainOrSubdomain = (destination, original) => {
  let orig = new URL(original).hostname, dest = new URL(destination).hostname;
  return orig === dest || orig.endsWith(`.${dest}`);
}, isSameProtocol = (destination, original) => {
  let orig = new URL(original).protocol, dest = new URL(destination).protocol;
  return orig === dest;
};

// node_modules/node-fetch/src/body.js
var pipeline = (0, import_node_util.promisify)(import_node_stream2.default.pipeline), INTERNALS = Symbol("Body internals"), Body = class {
  constructor(body, {
    size = 0
  } = {}) {
    let boundary = null;
    body === null ? body = null : isURLSearchParameters(body) ? body = import_node_buffer.Buffer.from(body.toString()) : isBlob(body) || import_node_buffer.Buffer.isBuffer(body) || (import_node_util.types.isAnyArrayBuffer(body) ? body = import_node_buffer.Buffer.from(body) : ArrayBuffer.isView(body) ? body = import_node_buffer.Buffer.from(body.buffer, body.byteOffset, body.byteLength) : body instanceof import_node_stream2.default || (body instanceof FormData2 ? (body = formDataToBlob(body), boundary = body.type.split("=")[1]) : body = import_node_buffer.Buffer.from(String(body))));
    let stream = body;
    import_node_buffer.Buffer.isBuffer(body) ? stream = import_node_stream2.default.Readable.from(body) : isBlob(body) && (stream = import_node_stream2.default.Readable.from(body.stream())), this[INTERNALS] = {
      body,
      stream,
      boundary,
      disturbed: !1,
      error: null
    }, this.size = size, body instanceof import_node_stream2.default && body.on("error", (error_) => {
      let error = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
      this[INTERNALS].error = error;
    });
  }
  get body() {
    return this[INTERNALS].stream;
  }
  get bodyUsed() {
    return this[INTERNALS].disturbed;
  }
  /**
   * Decode response as ArrayBuffer
   *
   * @return  Promise
   */
  async arrayBuffer() {
    let { buffer, byteOffset, byteLength } = await consumeBody(this);
    return buffer.slice(byteOffset, byteOffset + byteLength);
  }
  async formData() {
    let ct = this.headers.get("content-type");
    if (ct.startsWith("application/x-www-form-urlencoded")) {
      let formData = new FormData2(), parameters = new URLSearchParams(await this.text());
      for (let [name, value] of parameters)
        formData.append(name, value);
      return formData;
    }
    let { toFormData: toFormData2 } = await Promise.resolve().then(() => (init_multipart_parser(), multipart_parser_exports));
    return toFormData2(this.body, ct);
  }
  /**
   * Return raw response as Blob
   *
   * @return Promise
   */
  async blob() {
    let ct = this.headers && this.headers.get("content-type") || this[INTERNALS].body && this[INTERNALS].body.type || "", buf = await this.arrayBuffer();
    return new fetch_blob_default([buf], {
      type: ct
    });
  }
  /**
   * Decode response as json
   *
   * @return  Promise
   */
  async json() {
    let text = await this.text();
    return JSON.parse(text);
  }
  /**
   * Decode response as text
   *
   * @return  Promise
   */
  async text() {
    let buffer = await consumeBody(this);
    return new TextDecoder().decode(buffer);
  }
  /**
   * Decode response as buffer (non-spec api)
   *
   * @return  Promise
   */
  buffer() {
    return consumeBody(this);
  }
};
Body.prototype.buffer = (0, import_node_util.deprecate)(Body.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer");
Object.defineProperties(Body.prototype, {
  body: { enumerable: !0 },
  bodyUsed: { enumerable: !0 },
  arrayBuffer: { enumerable: !0 },
  blob: { enumerable: !0 },
  json: { enumerable: !0 },
  text: { enumerable: !0 },
  data: { get: (0, import_node_util.deprecate)(
    () => {
    },
    "data doesn't exist, use json(), text(), arrayBuffer(), or body instead",
    "https://github.com/node-fetch/node-fetch/issues/1000 (response)"
  ) }
});
async function consumeBody(data) {
  if (data[INTERNALS].disturbed)
    throw new TypeError(`body used already for: ${data.url}`);
  if (data[INTERNALS].disturbed = !0, data[INTERNALS].error)
    throw data[INTERNALS].error;
  let { body } = data;
  if (body === null)
    return import_node_buffer.Buffer.alloc(0);
  if (!(body instanceof import_node_stream2.default))
    return import_node_buffer.Buffer.alloc(0);
  let accum = [], accumBytes = 0;
  try {
    for await (let chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        let error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        throw body.destroy(error), error;
      }
      accumBytes += chunk.length, accum.push(chunk);
    }
  } catch (error) {
    throw error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, "system", error);
  }
  if (body.readableEnded === !0 || body._readableState.ended === !0)
    try {
      return accum.every((c) => typeof c == "string") ? import_node_buffer.Buffer.from(accum.join("")) : import_node_buffer.Buffer.concat(accum, accumBytes);
    } catch (error) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, "system", error);
    }
  else
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
}
var clone = (instance, highWaterMark) => {
  let p1, p2, { body } = instance[INTERNALS];
  if (instance.bodyUsed)
    throw new Error("cannot clone body after it is used");
  return body instanceof import_node_stream2.default && typeof body.getBoundary != "function" && (p1 = new import_node_stream2.PassThrough({ highWaterMark }), p2 = new import_node_stream2.PassThrough({ highWaterMark }), body.pipe(p1), body.pipe(p2), instance[INTERNALS].stream = p1, body = p2), body;
}, getNonSpecFormDataBoundary = (0, import_node_util.deprecate)(
  (body) => body.getBoundary(),
  "form-data doesn't follow the spec and requires special treatment. Use alternative package",
  "https://github.com/node-fetch/node-fetch/issues/1167"
), extractContentType = (body, request) => body === null ? null : typeof body == "string" ? "text/plain;charset=UTF-8" : isURLSearchParameters(body) ? "application/x-www-form-urlencoded;charset=UTF-8" : isBlob(body) ? body.type || null : import_node_buffer.Buffer.isBuffer(body) || import_node_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body) ? null : body instanceof FormData2 ? `multipart/form-data; boundary=${request[INTERNALS].boundary}` : body && typeof body.getBoundary == "function" ? `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}` : body instanceof import_node_stream2.default ? null : "text/plain;charset=UTF-8", getTotalBytes = (request) => {
  let { body } = request[INTERNALS];
  return body === null ? 0 : isBlob(body) ? body.size : import_node_buffer.Buffer.isBuffer(body) ? body.length : body && typeof body.getLengthSync == "function" && body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
}, writeToStream = async (dest, { body }) => {
  body === null ? dest.end() : await pipeline(body, dest);
};

// node_modules/node-fetch/src/headers.js
var import_node_util2 = require("node:util"), import_node_http = __toESM(require("node:http"), 1), validateHeaderName = typeof import_node_http.default.validateHeaderName == "function" ? import_node_http.default.validateHeaderName : (name) => {
  if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
    let error = new TypeError(`Header name must be a valid HTTP token [${name}]`);
    throw Object.defineProperty(error, "code", { value: "ERR_INVALID_HTTP_TOKEN" }), error;
  }
}, validateHeaderValue = typeof import_node_http.default.validateHeaderValue == "function" ? import_node_http.default.validateHeaderValue : (name, value) => {
  if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
    let error = new TypeError(`Invalid character in header content ["${name}"]`);
    throw Object.defineProperty(error, "code", { value: "ERR_INVALID_CHAR" }), error;
  }
}, Headers2 = class extends URLSearchParams {
  /**
   * Headers class
   *
   * @constructor
   * @param {HeadersInit} [init] - Response headers
   */
  constructor(init) {
    let result = [];
    if (init instanceof Headers2) {
      let raw = init.raw();
      for (let [name, values] of Object.entries(raw))
        result.push(...values.map((value) => [name, value]));
    } else if (init != null)
      if (typeof init == "object" && !import_node_util2.types.isBoxedPrimitive(init)) {
        let method = init[Symbol.iterator];
        if (method == null)
          result.push(...Object.entries(init));
        else {
          if (typeof method != "function")
            throw new TypeError("Header pairs must be iterable");
          result = [...init].map((pair) => {
            if (typeof pair != "object" || import_node_util2.types.isBoxedPrimitive(pair))
              throw new TypeError("Each header pair must be an iterable object");
            return [...pair];
          }).map((pair) => {
            if (pair.length !== 2)
              throw new TypeError("Each header pair must be a name/value tuple");
            return [...pair];
          });
        }
      } else
        throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
    return result = result.length > 0 ? result.map(([name, value]) => (validateHeaderName(name), validateHeaderValue(name, String(value)), [String(name).toLowerCase(), String(value)])) : void 0, super(result), new Proxy(this, {
      get(target, p, receiver) {
        switch (p) {
          case "append":
          case "set":
            return (name, value) => (validateHeaderName(name), validateHeaderValue(name, String(value)), URLSearchParams.prototype[p].call(
              target,
              String(name).toLowerCase(),
              String(value)
            ));
          case "delete":
          case "has":
          case "getAll":
            return (name) => (validateHeaderName(name), URLSearchParams.prototype[p].call(
              target,
              String(name).toLowerCase()
            ));
          case "keys":
            return () => (target.sort(), new Set(URLSearchParams.prototype.keys.call(target)).keys());
          default:
            return Reflect.get(target, p, receiver);
        }
      }
    });
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  toString() {
    return Object.prototype.toString.call(this);
  }
  get(name) {
    let values = this.getAll(name);
    if (values.length === 0)
      return null;
    let value = values.join(", ");
    return /^content-encoding$/i.test(name) && (value = value.toLowerCase()), value;
  }
  forEach(callback, thisArg = void 0) {
    for (let name of this.keys())
      Reflect.apply(callback, thisArg, [this.get(name), name, this]);
  }
  *values() {
    for (let name of this.keys())
      yield this.get(name);
  }
  /**
   * @type {() => IterableIterator<[string, string]>}
   */
  *entries() {
    for (let name of this.keys())
      yield [name, this.get(name)];
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Node-fetch non-spec method
   * returning all headers and their values as array
   * @returns {Record<string, string[]>}
   */
  raw() {
    return [...this.keys()].reduce((result, key) => (result[key] = this.getAll(key), result), {});
  }
  /**
   * For better console.log(headers) and also to convert Headers into Node.js Request compatible format
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return [...this.keys()].reduce((result, key) => {
      let values = this.getAll(key);
      return key === "host" ? result[key] = values[0] : result[key] = values.length > 1 ? values : values[0], result;
    }, {});
  }
};
Object.defineProperties(
  Headers2.prototype,
  ["get", "entries", "forEach", "values"].reduce((result, property) => (result[property] = { enumerable: !0 }, result), {})
);
function fromRawHeaders(headers = []) {
  return new Headers2(
    headers.reduce((result, value, index, array) => (index % 2 === 0 && result.push(array.slice(index, index + 2)), result), []).filter(([name, value]) => {
      try {
        return validateHeaderName(name), validateHeaderValue(name, String(value)), !0;
      } catch {
        return !1;
      }
    })
  );
}

// node_modules/node-fetch/src/utils/is-redirect.js
var redirectStatus = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]), isRedirect = (code) => redirectStatus.has(code);

// node_modules/node-fetch/src/response.js
var INTERNALS2 = Symbol("Response internals"), Response3 = class extends Body {
  constructor(body = null, options = {}) {
    super(body, options);
    let status = options.status != null ? options.status : 200, headers = new Headers2(options.headers);
    if (body !== null && !headers.has("Content-Type")) {
      let contentType = extractContentType(body, this);
      contentType && headers.append("Content-Type", contentType);
    }
    this[INTERNALS2] = {
      type: "default",
      url: options.url,
      status,
      statusText: options.statusText || "",
      headers,
      counter: options.counter,
      highWaterMark: options.highWaterMark
    };
  }
  get type() {
    return this[INTERNALS2].type;
  }
  get url() {
    return this[INTERNALS2].url || "";
  }
  get status() {
    return this[INTERNALS2].status;
  }
  /**
   * Convenience property representing if the request ended normally
   */
  get ok() {
    return this[INTERNALS2].status >= 200 && this[INTERNALS2].status < 300;
  }
  get redirected() {
    return this[INTERNALS2].counter > 0;
  }
  get statusText() {
    return this[INTERNALS2].statusText;
  }
  get headers() {
    return this[INTERNALS2].headers;
  }
  get highWaterMark() {
    return this[INTERNALS2].highWaterMark;
  }
  /**
   * Clone this response
   *
   * @return  Response
   */
  clone() {
    return new Response3(clone(this, this.highWaterMark), {
      type: this.type,
      url: this.url,
      status: this.status,
      statusText: this.statusText,
      headers: this.headers,
      ok: this.ok,
      redirected: this.redirected,
      size: this.size,
      highWaterMark: this.highWaterMark
    });
  }
  /**
   * @param {string} url    The URL that the new response is to originate from.
   * @param {number} status An optional status code for the response (e.g., 302.)
   * @returns {Response}    A Response object.
   */
  static redirect(url, status = 302) {
    if (!isRedirect(status))
      throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
    return new Response3(null, {
      headers: {
        location: new URL(url).toString()
      },
      status
    });
  }
  static error() {
    let response = new Response3(null, { status: 0, statusText: "" });
    return response[INTERNALS2].type = "error", response;
  }
  static json(data = void 0, init = {}) {
    let body = JSON.stringify(data);
    if (body === void 0)
      throw new TypeError("data is not JSON serializable");
    let headers = new Headers2(init && init.headers);
    return headers.has("content-type") || headers.set("content-type", "application/json"), new Response3(body, {
      ...init,
      headers
    });
  }
  get [Symbol.toStringTag]() {
    return "Response";
  }
};
Object.defineProperties(Response3.prototype, {
  type: { enumerable: !0 },
  url: { enumerable: !0 },
  status: { enumerable: !0 },
  ok: { enumerable: !0 },
  redirected: { enumerable: !0 },
  statusText: { enumerable: !0 },
  headers: { enumerable: !0 },
  clone: { enumerable: !0 }
});

// node_modules/node-fetch/src/request.js
var import_node_url = require("node:url"), import_node_util3 = require("node:util");

// node_modules/node-fetch/src/utils/get-search.js
var getSearch = (parsedURL) => {
  if (parsedURL.search)
    return parsedURL.search;
  let lastOffset = parsedURL.href.length - 1, hash = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
  return parsedURL.href[lastOffset - hash.length] === "?" ? "?" : "";
};

// node_modules/node-fetch/src/utils/referrer.js
var import_node_net = require("node:net");
function stripURLForUseAsAReferrer(url, originOnly = !1) {
  return url == null || (url = new URL(url), /^(about|blob|data):$/.test(url.protocol)) ? "no-referrer" : (url.username = "", url.password = "", url.hash = "", originOnly && (url.pathname = "", url.search = ""), url);
}
var ReferrerPolicy = /* @__PURE__ */ new Set([
  "",
  "no-referrer",
  "no-referrer-when-downgrade",
  "same-origin",
  "origin",
  "strict-origin",
  "origin-when-cross-origin",
  "strict-origin-when-cross-origin",
  "unsafe-url"
]), DEFAULT_REFERRER_POLICY = "strict-origin-when-cross-origin";
function validateReferrerPolicy(referrerPolicy) {
  if (!ReferrerPolicy.has(referrerPolicy))
    throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
  return referrerPolicy;
}
function isOriginPotentiallyTrustworthy(url) {
  if (/^(http|ws)s:$/.test(url.protocol))
    return !0;
  let hostIp = url.host.replace(/(^\[)|(]$)/g, ""), hostIPVersion = (0, import_node_net.isIP)(hostIp);
  return hostIPVersion === 4 && /^127\./.test(hostIp) || hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp) ? !0 : url.host === "localhost" || url.host.endsWith(".localhost") ? !1 : url.protocol === "file:";
}
function isUrlPotentiallyTrustworthy(url) {
  return /^about:(blank|srcdoc)$/.test(url) || url.protocol === "data:" || /^(blob|filesystem):$/.test(url.protocol) ? !0 : isOriginPotentiallyTrustworthy(url);
}
function determineRequestsReferrer(request, { referrerURLCallback, referrerOriginCallback } = {}) {
  if (request.referrer === "no-referrer" || request.referrerPolicy === "")
    return null;
  let policy = request.referrerPolicy;
  if (request.referrer === "about:client")
    return "no-referrer";
  let referrerSource = request.referrer, referrerURL = stripURLForUseAsAReferrer(referrerSource), referrerOrigin = stripURLForUseAsAReferrer(referrerSource, !0);
  referrerURL.toString().length > 4096 && (referrerURL = referrerOrigin), referrerURLCallback && (referrerURL = referrerURLCallback(referrerURL)), referrerOriginCallback && (referrerOrigin = referrerOriginCallback(referrerOrigin));
  let currentURL = new URL(request.url);
  switch (policy) {
    case "no-referrer":
      return "no-referrer";
    case "origin":
      return referrerOrigin;
    case "unsafe-url":
      return referrerURL;
    case "strict-origin":
      return isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL) ? "no-referrer" : referrerOrigin.toString();
    case "strict-origin-when-cross-origin":
      return referrerURL.origin === currentURL.origin ? referrerURL : isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL) ? "no-referrer" : referrerOrigin;
    case "same-origin":
      return referrerURL.origin === currentURL.origin ? referrerURL : "no-referrer";
    case "origin-when-cross-origin":
      return referrerURL.origin === currentURL.origin ? referrerURL : referrerOrigin;
    case "no-referrer-when-downgrade":
      return isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL) ? "no-referrer" : referrerURL;
    default:
      throw new TypeError(`Invalid referrerPolicy: ${policy}`);
  }
}
function parseReferrerPolicyFromHeader(headers) {
  let policyTokens = (headers.get("referrer-policy") || "").split(/[,\s]+/), policy = "";
  for (let token of policyTokens)
    token && ReferrerPolicy.has(token) && (policy = token);
  return policy;
}

// node_modules/node-fetch/src/request.js
var INTERNALS3 = Symbol("Request internals"), isRequest = (object) => typeof object == "object" && typeof object[INTERNALS3] == "object", doBadDataWarn = (0, import_node_util3.deprecate)(
  () => {
  },
  ".data is not a valid RequestInit property, use .body instead",
  "https://github.com/node-fetch/node-fetch/issues/1000 (request)"
), Request2 = class extends Body {
  constructor(input, init = {}) {
    let parsedURL;
    if (isRequest(input) ? parsedURL = new URL(input.url) : (parsedURL = new URL(input), input = {}), parsedURL.username !== "" || parsedURL.password !== "")
      throw new TypeError(`${parsedURL} is an url with embedded credentials.`);
    let method = init.method || input.method || "GET";
    if (/^(delete|get|head|options|post|put)$/i.test(method) && (method = method.toUpperCase()), !isRequest(init) && "data" in init && doBadDataWarn(), (init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD"))
      throw new TypeError("Request with GET/HEAD method cannot have body");
    let inputBody = init.body ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
    super(inputBody, {
      size: init.size || input.size || 0
    });
    let headers = new Headers2(init.headers || input.headers || {});
    if (inputBody !== null && !headers.has("Content-Type")) {
      let contentType = extractContentType(inputBody, this);
      contentType && headers.set("Content-Type", contentType);
    }
    let signal = isRequest(input) ? input.signal : null;
    if ("signal" in init && (signal = init.signal), signal != null && !isAbortSignal(signal))
      throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
    let referrer = init.referrer == null ? input.referrer : init.referrer;
    if (referrer === "")
      referrer = "no-referrer";
    else if (referrer) {
      let parsedReferrer = new URL(referrer);
      referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? "client" : parsedReferrer;
    } else
      referrer = void 0;
    this[INTERNALS3] = {
      method,
      redirect: init.redirect || input.redirect || "follow",
      headers,
      parsedURL,
      signal,
      referrer
    }, this.follow = init.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init.follow, this.compress = init.compress === void 0 ? input.compress === void 0 ? !0 : input.compress : init.compress, this.counter = init.counter || input.counter || 0, this.agent = init.agent || input.agent, this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384, this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || !1, this.referrerPolicy = init.referrerPolicy || input.referrerPolicy || "";
  }
  /** @returns {string} */
  get method() {
    return this[INTERNALS3].method;
  }
  /** @returns {string} */
  get url() {
    return (0, import_node_url.format)(this[INTERNALS3].parsedURL);
  }
  /** @returns {Headers} */
  get headers() {
    return this[INTERNALS3].headers;
  }
  get redirect() {
    return this[INTERNALS3].redirect;
  }
  /** @returns {AbortSignal} */
  get signal() {
    return this[INTERNALS3].signal;
  }
  // https://fetch.spec.whatwg.org/#dom-request-referrer
  get referrer() {
    if (this[INTERNALS3].referrer === "no-referrer")
      return "";
    if (this[INTERNALS3].referrer === "client")
      return "about:client";
    if (this[INTERNALS3].referrer)
      return this[INTERNALS3].referrer.toString();
  }
  get referrerPolicy() {
    return this[INTERNALS3].referrerPolicy;
  }
  set referrerPolicy(referrerPolicy) {
    this[INTERNALS3].referrerPolicy = validateReferrerPolicy(referrerPolicy);
  }
  /**
   * Clone this request
   *
   * @return  Request
   */
  clone() {
    return new Request2(this);
  }
  get [Symbol.toStringTag]() {
    return "Request";
  }
};
Object.defineProperties(Request2.prototype, {
  method: { enumerable: !0 },
  url: { enumerable: !0 },
  headers: { enumerable: !0 },
  redirect: { enumerable: !0 },
  clone: { enumerable: !0 },
  signal: { enumerable: !0 },
  referrer: { enumerable: !0 },
  referrerPolicy: { enumerable: !0 }
});
var getNodeRequestOptions = (request) => {
  let { parsedURL } = request[INTERNALS3], headers = new Headers2(request[INTERNALS3].headers);
  headers.has("Accept") || headers.set("Accept", "*/*");
  let contentLengthValue = null;
  if (request.body === null && /^(post|put)$/i.test(request.method) && (contentLengthValue = "0"), request.body !== null) {
    let totalBytes = getTotalBytes(request);
    typeof totalBytes == "number" && !Number.isNaN(totalBytes) && (contentLengthValue = String(totalBytes));
  }
  contentLengthValue && headers.set("Content-Length", contentLengthValue), request.referrerPolicy === "" && (request.referrerPolicy = DEFAULT_REFERRER_POLICY), request.referrer && request.referrer !== "no-referrer" ? request[INTERNALS3].referrer = determineRequestsReferrer(request) : request[INTERNALS3].referrer = "no-referrer", request[INTERNALS3].referrer instanceof URL && headers.set("Referer", request.referrer), headers.has("User-Agent") || headers.set("User-Agent", "node-fetch"), request.compress && !headers.has("Accept-Encoding") && headers.set("Accept-Encoding", "gzip, deflate, br");
  let { agent } = request;
  typeof agent == "function" && (agent = agent(parsedURL)), !headers.has("Connection") && !agent && headers.set("Connection", "close");
  let search = getSearch(parsedURL), options = {
    // Overwrite search to retain trailing ? (issue #776)
    path: parsedURL.pathname + search,
    // The following options are not expressed in the URL
    method: request.method,
    headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
    insecureHTTPParser: request.insecureHTTPParser,
    agent
  };
  return {
    /** @type {URL} */
    parsedURL,
    options
  };
};

// node_modules/node-fetch/src/errors/abort-error.js
var AbortError = class extends FetchBaseError {
  constructor(message, type = "aborted") {
    super(message, type);
  }
};

// node_modules/node-fetch/src/index.js
init_esm_min();
init_from();
var supportedSchemas = /* @__PURE__ */ new Set(["data:", "http:", "https:"]);
async function fetch2(url, options_) {
  return new Promise((resolve, reject) => {
    let request = new Request2(url, options_), { parsedURL, options } = getNodeRequestOptions(request);
    if (!supportedSchemas.has(parsedURL.protocol))
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`);
    if (parsedURL.protocol === "data:") {
      let data = dist_default(request.url), response2 = new Response3(data, { headers: { "Content-Type": data.typeFull } });
      resolve(response2);
      return;
    }
    let send = (parsedURL.protocol === "https:" ? import_node_https.default : import_node_http2.default).request, { signal } = request, response = null, abort = () => {
      let error = new AbortError("The operation was aborted.");
      reject(error), request.body && request.body instanceof import_node_stream3.default.Readable && request.body.destroy(error), !(!response || !response.body) && response.body.emit("error", error);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    let abortAndFinalize = () => {
      abort(), finalize();
    }, request_ = send(parsedURL.toString(), options);
    signal && signal.addEventListener("abort", abortAndFinalize);
    let finalize = () => {
      request_.abort(), signal && signal.removeEventListener("abort", abortAndFinalize);
    };
    request_.on("error", (error) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${error.message}`, "system", error)), finalize();
    }), fixResponseChunkedTransferBadEnding(request_, (error) => {
      response && response.body && response.body.destroy(error);
    }), process.version < "v14" && request_.on("socket", (s2) => {
      let endedWithEventsCount;
      s2.prependListener("end", () => {
        endedWithEventsCount = s2._eventsCount;
      }), s2.prependListener("close", (hadError) => {
        if (response && endedWithEventsCount < s2._eventsCount && !hadError) {
          let error = new Error("Premature close");
          error.code = "ERR_STREAM_PREMATURE_CLOSE", response.body.emit("error", error);
        }
      });
    }), request_.on("response", (response_) => {
      request_.setTimeout(0);
      let headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        let location = headers.get("Location"), locationURL = null;
        try {
          locationURL = location === null ? null : new URL(location, request.url);
        } catch {
          if (request.redirect !== "manual") {
            reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect")), finalize();
            return;
          }
        }
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect")), finalize();
            return;
          case "manual":
            break;
          case "follow": {
            if (locationURL === null)
              break;
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect")), finalize();
              return;
            }
            let requestOptions = {
              headers: new Headers2(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: clone(request),
              signal: request.signal,
              size: request.size,
              referrer: request.referrer,
              referrerPolicy: request.referrerPolicy
            };
            if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL))
              for (let name of ["authorization", "www-authenticate", "cookie", "cookie2"])
                requestOptions.headers.delete(name);
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_node_stream3.default.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect")), finalize();
              return;
            }
            (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") && (requestOptions.method = "GET", requestOptions.body = void 0, requestOptions.headers.delete("content-length"));
            let responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);
            responseReferrerPolicy && (requestOptions.referrerPolicy = responseReferrerPolicy), resolve(fetch2(new Request2(locationURL, requestOptions))), finalize();
            return;
          }
          default:
            return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
        }
      }
      signal && response_.once("end", () => {
        signal.removeEventListener("abort", abortAndFinalize);
      });
      let body = (0, import_node_stream3.pipeline)(response_, new import_node_stream3.PassThrough(), (error) => {
        error && reject(error);
      });
      process.version < "v12.10" && response_.on("aborted", abortAndFinalize);
      let responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      }, codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response3(body, responseOptions), resolve(response);
        return;
      }
      let zlibOptions = {
        flush: import_node_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_node_zlib.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_node_stream3.pipeline)(body, import_node_zlib.default.createGunzip(zlibOptions), (error) => {
          error && reject(error);
        }), response = new Response3(body, responseOptions), resolve(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        let raw = (0, import_node_stream3.pipeline)(response_, new import_node_stream3.PassThrough(), (error) => {
          error && reject(error);
        });
        raw.once("data", (chunk) => {
          (chunk[0] & 15) === 8 ? body = (0, import_node_stream3.pipeline)(body, import_node_zlib.default.createInflate(), (error) => {
            error && reject(error);
          }) : body = (0, import_node_stream3.pipeline)(body, import_node_zlib.default.createInflateRaw(), (error) => {
            error && reject(error);
          }), response = new Response3(body, responseOptions), resolve(response);
        }), raw.once("end", () => {
          response || (response = new Response3(body, responseOptions), resolve(response));
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_node_stream3.pipeline)(body, import_node_zlib.default.createBrotliDecompress(), (error) => {
          error && reject(error);
        }), response = new Response3(body, responseOptions), resolve(response);
        return;
      }
      response = new Response3(body, responseOptions), resolve(response);
    }), writeToStream(request_, request).catch(reject);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  let LAST_CHUNK = import_node_buffer2.Buffer.from(`0\r
\r
`), isChunkedTransfer = !1, properLastChunkReceived = !1, previousChunk;
  request.on("response", (response) => {
    let { headers } = response;
    isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
  }), request.on("socket", (socket) => {
    let onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        let error = new Error("Premature close");
        error.code = "ERR_STREAM_PREMATURE_CLOSE", errorCallback(error);
      }
    }, onData = (buf) => {
      properLastChunkReceived = import_node_buffer2.Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0, !properLastChunkReceived && previousChunk && (properLastChunkReceived = import_node_buffer2.Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && import_node_buffer2.Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0), previousChunk = buf;
    };
    socket.prependListener("close", onSocketClose), socket.on("data", onData), request.on("close", () => {
      socket.removeListener("close", onSocketClose), socket.removeListener("data", onData);
    });
  });
}

// node_modules/@roundforest/http-commons/src/node.index.js
var import_https = require("https"), import_http = require("http"), requestIdGetterSymbol = Symbol("request-id-getter"), defaultAgent = memo(
  /**@param {string} protocol*/
  (protocol) => protocol === "http:" ? new import_http.Agent(SOCKET_OPTIONS) : new import_https.Agent(SOCKET_OPTIONS)
), HTTP_FETCH_SOCKET_TIMEOUT = parseInt(
  process.env.HTTP_FETCH_SOCKET_TIMEOUT || `${5 * 60 * 1e3}`,
  10
), SOCKET_OPTIONS = { keepAlive: !0, timeout: HTTP_FETCH_SOCKET_TIMEOUT };
async function fetcher(url, init) {
  var _a4;
  let requestId = (init == null ? void 0 : init.requestId) ?? ((_a4 = globalThis[requestIdGetterSymbol]) == null ? void 0 : _a4.call(globalThis));
  return await fetch2(url.toString(), {
    //@ts-expect-error
    agent: defaultAgent((url == null ? void 0 : url.protocol) ?? new URL(url).protocol),
    ...requestId != null ? {
      ...init,
      headers: {
        "x-request-id": requestId,
        ...init == null ? void 0 : init.headers
      }
    } : init
  });
}
var client = makeClient(fetcher, requestIdGetterSymbol), {
  throwErrorFromBadStatus,
  fetchAsJson,
  fetchAsText,
  fetchAsTextWithJsonBody,
  fetchAsBuffer,
  fetchAsBufferWithJsonBody,
  fetchAsJsonWithJsonBody,
  setGlobalRequestIdGetter,
  retryFetch,
  fetch: fetch3
} = client;

// node_modules/@roundforest/url-commons/src/url-commons.js
function addQueryParamsToUrl(url, queryParams, options) {
  typeof url == "string" && (url = new URL(url));
  for (let [queryParam, value] of Object.entries(queryParams))
    value != null && (Array.isArray(value) ? value.forEach((valueItem) => {
      let queryParamKey = (options == null ? void 0 : options.style) === "RoR" ? `${queryParam}[]` : queryParam;
      return (
        /** @type {URL} */
        url.searchParams.append(queryParamKey, valueItem)
      );
    }) : url.searchParams.set(queryParam, value));
  return url;
}
function buildUrl(url, baseUrl, queryParams, options) {
  baseUrl != null && typeof baseUrl == "string" && (baseUrl = new URL(baseUrl));
  let finalUrl = new URL(url, baseUrl);
  return queryParams ? addQueryParamsToUrl(finalUrl, queryParams, options) : finalUrl;
}

// node_modules/@roundforest/text-transforms-commons/src/unslug.js
var splitByTokensRules = {
  "all-in-number": /[a-z0-9]+-in-\d+/,
  // ex: all-in-1, 5-in-1
  "letter-word": /^[a-z]-[a-z]+/,
  // ex: E-reader, k-cup
  "non-word": /^non-[a-z]+/,
  // ex: non-smart, non-slip
  "number-number": /\d+-\d+/,
  // ex: 5-1 converted,
  "number-letters": /\d+-[a-zA-Z]+/,
  // 4-way switch
  "split-dashes": /[^\s:-]+/
}, SPLIT_BY_TOKENS = new RegExp(
  `(${Object.values(splitByTokensRules).map((x2) => x2.source).join("|")}|.)`,
  "g"
);

// node_modules/@roundforest/text-transforms-commons/src/slug-to-text.js
var import_lodash2 = __toESM(require_lodash2(), 1), import_lodash3 = __toESM(require_lodash3(), 1);
function slugToText(slug, { capitalize: shouldCapitalize = !0, urlDecode } = {}) {
  let result = urlDecode ? decodeURIComponent(slug).replaceAll(`
`, " ") : slug;
  return result.startsWith("/") && (result = result.slice(1)), result = result.replace(/_|-|%20/g, " "), shouldCapitalize && (result = (0, import_lodash2.default)(result)), result;
}

// node_modules/@roundforest/bdt-locale-commons/src/bdt-locale-commons.js
function mapHostHeaderToLocaleParams(hostHeader) {
  let defaultResult = { locale: "en", language: "en-US", currencyCode: "USD" };
  if (!hostHeader)
    return defaultResult;
  let locale = hostHeader.split(".")[0];
  switch (locale.endsWith("2") && (locale = locale.slice(0, -1)), locale) {
    case "au":
      return { locale, language: "en-AU", currencyCode: "AUD" };
    case "ca":
      return { locale, language: "en-CA", currencyCode: "CAD" };
    case "de":
      return { locale, language: "de-DE", currencyCode: "EUR" };
    case "es":
      return { locale, language: "es-ES", currencyCode: "EUR" };
    case "fr":
      return { locale, language: "fr-FR", currencyCode: "EUR" };
    case "in":
      return { locale, language: "en-IN", currencyCode: "INR" };
    case "it":
      return { locale, language: "it-IT", currencyCode: "EUR" };
    case "nl":
      return { locale, language: "nl-NL", currencyCode: "EUR" };
    case "sg":
      return { locale: "sg", language: "en-SG", currencyCode: "SGD" };
    case "uk":
      return { locale: "uk", language: "en-GB", currencyCode: "GBP" };
    case "jp":
      return { locale, language: "ja-JA", currencyCode: "JPY" };
    case "tt":
      return { locale: "uk", language: "en-GB", currencyCode: "GBP" };
    default:
      return defaultResult;
  }
}

// node_modules/@roundforest/bdt-client/lib/commons/random-number.js
var randomNumber = () => Math.round(Math.random() * 1e16);

// node_modules/@roundforest/bdt-client/lib/modify-base-url-based-on-host-header.js
function modifyBaseUrlBasedOnHostHeader(baseUrl, hostHeader) {
  let {
    locale
  } = mapHostHeaderToLocaleParams(hostHeader), localedBaseUrl = new URL(baseUrl), hostnameSegments = localedBaseUrl.hostname.split(".");
  if (hostnameSegments[1] !== "bestdeals")
    return baseUrl;
  let normalizedLocale = locale === "en" ? "www" : locale;
  return localedBaseUrl.hostname = [normalizedLocale, ...hostnameSegments.slice(1)].join("."), localedBaseUrl.href;
}

// node_modules/@roundforest/bdt-client/lib/bdt-client.js
function extractTrafficFromCookieValue(rawTrafficString) {
  if (!rawTrafficString)
    return;
  let trafficString = decodeURIComponent(rawTrafficString);
  try {
    return JSON.parse(trafficString);
  } catch {
    return {
      raw: trafficString
    };
  }
}
function makeClient2(baseUrl) {
  return {
    submitContactForm,
    registerEmail,
    getProductsAndMetadata,
    getPageTypeData,
    getManualDeals,
    trackRequest,
    getAllCategories,
    TEST_clear: () => {
    }
  };
  async function submitContactForm(data) {
    return await fetchAsJsonWithJsonBody(buildUrl("./contact", baseUrl), data, {
      redirect: "error"
    });
  }
  async function registerEmail(data) {
    let dataForApi = {
      email: data.email,
      app_id: data.appId,
      user_id: data.userId,
      subscription_location: data.subscriptionLocation
    };
    return await fetchAsJsonWithJsonBody(buildUrl("./collect_email", baseUrl), {
      subscription: dataForApi
    });
  }
  async function getProductsAndMetadata(search, userAgent, {
    pageQueryParameters
  } = {
    pageQueryParameters: void 0
  }) {
    let headers = userAgent ? {
      "user-agent": userAgent
    } : void 0, apiUrl = buildUrl("./products", baseUrl, {
      search,
      ...pageQueryParameters || {}
    }), {
      metadata,
      products
    } = await fetchAsJson(apiUrl, {
      headers
    }), normalizedProducts = camelcaseKeys(products);
    return {
      metadata: camelcaseKeys(metadata),
      products: normalizedProducts.map((product) => {
        let randomClickId = randomNumber();
        return {
          ...product,
          redirectLinkTo: product.redirectLinkTo.replace("rf_client_click_id=000000000", `rf_client_click_id=${randomClickId}`),
          clickId: randomClickId
        };
      }),
      TEST_apiUrl: apiUrl.href
    };
  }
  async function getPageTypeData(commonBdtParameters, search) {
    let localedBaseUrl = modifyBaseUrlBasedOnHostHeader(baseUrl, commonBdtParameters.hostHeader), slugAsText = slugToText(search, {
      capitalize: !1
    }), {
      page_type,
      popular_categories,
      subcategories,
      banner
    } = await fetchAsJson(buildUrl("./page_type", localedBaseUrl, {
      search: slugAsText
    }), {
      headers: generateCommonHeaders(commonBdtParameters, baseUrl.toString())
    }), popularCategories = normalizePageTypeCategories(popular_categories || []), normalizedSubcategories = normalizePageTypeCategories(subcategories || []);
    return {
      banner,
      pageType: page_type,
      popularCategories,
      subcategories: normalizedSubcategories
    };
  }
  async function getManualDeals({
    location,
    positions,
    l1Taxonomy
  }) {
    let response = await fetchAsJson(buildUrl("./manual_deals", baseUrl, {
      location,
      positions,
      l1Taxonomy: l1Taxonomy ?? void 0
    }, {
      style: "RoR"
    }));
    return {
      topDeals: getManualDealsByPositionOrUndefined(positions, "Top Deals", response),
      topOffers: getManualDealsByPositionOrUndefined(positions, "Top Offers", response),
      popups: getManualDealsByPositionOrUndefined(positions, "Popups", response),
      banners: getManualDealsByPositionOrUndefined(positions, "Banners", response),
      coupons: getManualDealsByPositionOrUndefined(positions, "Coupons", response),
      offers: getManualDealsByPositionOrUndefined(positions, "Offers", response)
    };
  }
  async function trackRequest(commonBdtParameters, cookieSetter) {
    let {
      locale
    } = mapHostHeaderToLocaleParams(commonBdtParameters.hostHeader), trackRequestResponse = await fetch3(buildUrl("./track_request", baseUrl, {
      locale
    }), {
      headers: {
        "Content-Type": "application/json",
        ...generateCommonHeaders(commonBdtParameters, baseUrl.toString())
      },
      method: "POST",
      body: JSON.stringify({
        ab_tests: commonBdtParameters.abTests
      })
    });
    trackRequestResponse.ok || await throwErrorFromBadStatus(trackRequestResponse);
    let trackRequestCookies = trackRequestResponse.headers.raw()["set-cookie"], {
      bdtSession,
      traffic
    } = extractTrackingValuesFromCookies(trackRequestCookies);
    return cookieSetter && (traffic && cookieSetter("traffic", decodeURIComponent(traffic)), bdtSession && cookieSetter("_noam-stucco_session", decodeURIComponent(bdtSession))), {
      traffic: extractTrafficFromCookieValue(traffic),
      trackRequestCookies
    };
  }
  function getAllCategories(commonBdtParameters) {
    let {
      locale
    } = mapHostHeaderToLocaleParams(commonBdtParameters.hostHeader);
    return fetchAsJson(buildUrl("./categories", baseUrl, {
      locale
    }), {
      headers: generateCommonHeaders(commonBdtParameters, baseUrl.toString())
    });
  }
}
function normalizePageTypeCategories(categories) {
  return categories.map(({
    title,
    url,
    img,
    image
  }) => ({
    title,
    url,
    image: image || img
  }));
}
function normalizeManualDeal(manualDeal) {
  let manualDealItems = manualDeal == null ? void 0 : manualDeal.items.map((deal) => ({
    ...deal,
    clickId: randomNumber()
  }));
  return {
    duration: (manualDeal == null ? void 0 : manualDeal.duration) || 0,
    items: camelcaseKeys(manualDealItems || [])
  };
}
function getManualDealsByPositionOrUndefined(positions, positionKey, response) {
  return positions.includes(positionKey) ? normalizeManualDeal(response[positionKey]) : void 0;
}
function generateCommonHeaders({
  userAgent,
  userId,
  sessionId,
  pageId,
  requestPath,
  bdtSession,
  traffic
}, baseUrl) {
  return {
    ...userAgent ? {
      "user-agent": userAgent
    } : {},
    ...requestPath ? {
      referer: new URL(requestPath, baseUrl).href
    } : {},
    cookie: [userId ? `user_id=${userId}` : void 0, sessionId ? `page_group_id=${sessionId}` : void 0, pageId ? `page_load_id=${pageId}` : void 0, bdtSession ? `_noam-stucco_session=${bdtSession}` : void 0, traffic ? `traffic=${traffic}` : void 0].filter((x2) => !!x2).join("; ")
  };
}
function extractTrackingValuesFromCookies(cookies) {
  let trafficCookieString = cookies.find((cookieString) => cookieString.includes("traffic")), bdtSessionCookieString = cookies.find((cookieString) => cookieString.includes("_noam-stucco_session"));
  return {
    traffic: trafficCookieString ? extractValueFromCookieString(trafficCookieString) : void 0,
    bdtSession: bdtSessionCookieString ? extractValueFromCookieString(bdtSessionCookieString) : void 0
  };
}
function extractValueFromCookieString(cookieString) {
  return cookieString.split(";")[0].split("=")[1];
}

// node_modules/@roundforest/bdt-client/lib/fixtures/products-and-metadata.db.js
var mockData = {
  products: [{
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B07ZLRGJ94",
    title: "Video Games: The Movie V",
    truncatedTitle: "Video Games: The Movie",
    publicItemId: "B07ZLRGJ94",
    source: "amazon",
    categoryId: "2649512011",
    merchantId: null,
    total_new: 1,
    total_used: 0,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: null,
    condition: "new",
    price: 3.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTDEWDhwK_-U64YhfH4F6kO4pgpoWdv3WSypzeN4vtwPU.jpg",
    image: "https://m.media-amazon.com/images/I/61C5IggSY6L._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNjFDNUlnZ1NZNkwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.png",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDdaTFJHSjk0P1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=379172815-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B07ZLRGJ94-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=TW92aWVzICYgVFYgfCBNb3ZpZXM=&rf_from_api=true",
    position: 0,
    productCode: "amazon-us-B07ZLRGJ94-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_323951062782",
    title: "Super Smash Bros. Ultimate - Nintendo Switch (long german word tiiiiiiiiiiooooooooooOOOOOOOOOOXXXXXMMMMMMMMMiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiitl)",
    truncatedTitle: "Super Smash Bros. Ultimate - Nintendo Switch",
    publicItemId: "323951062782",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-18T00:40:36.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 42.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qV6u4CEUXZ3NWqfcmSJ8a3f_JW_9QKCF5pio3N55EvnOc-6wCVoY6XBgerGqMahhnr.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/-LIAAOSw3tddqQoG/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTAwMFgxMDAw/z/-LIAAOSw3tddqQoG/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy8tTElBQU9TdzN0ZGRxUW9HL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzMyMzk1MTA2Mjc4Mj9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=585204701-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-323951062782-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 1,
    productCode: "ebay-us-323951062782-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "nfl shop_new_15930515418",
    title: "Madden NFL 21 Xbox One Video Game",
    truncatedTitle: "Madden NFL 21 Xbox One Video Game",
    publicItemId: "15930515418",
    source: "bizrate.com",
    categoryId: "15010100",
    merchantId: 134939,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "nfl shop",
    expiring: null,
    auction: !1,
    brandName: "cokem",
    condition: "new",
    price: 59.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OHtFjQNBJd07nqH1lZMlQ-3Hn_wZnvjpNtoU-BloU6u1wbwhNMlit22tmOOVjZjQxu-iFyplXFfigCKTawPFrZy-HknCfOPLcpLMOo5YPzYJILT0xoZ7ysv55V-8eG9OK_aicW8IsIl6Hx9Lz5XfZxcv3s6Z2_5ZUadRB3-6tGaFcaQ3Nt2ONQqc6HAvegEJTG5EzHX2AqdQ2PdouVsNlb43UmDGQeAo8I1XEnANYqDG4ATZCiXcqPJAmmYa9jXw8y5lA5jisbJLPGwkT_xOsR0.jpeg",
    image: "https://d8.cnnx.io/image/obj/15930515418;sq=160;p=0;t=ooPwmM0WTWKfBARaVBY6aLR-KO_2YGOplhsmTkaQZE_U6xArW8SWSo630ymYVndlorncelIwZFk4gv0v61LeOOCLDF8JDsjY2mywNxF8Lrd7isRR9TlcrZUVzPCj1Uf_jdNQ4OwCxfJ-TmMEjsd2TdM=",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9kOC5jbm54LmlvL2ltYWdlL29iai8xNTkzMDUxNTQxODtzcT0xNjA7cD0wO3Q9b29Qd21NMFdUV0tmQkFSYVZCWTZhTFItS09fMllHT3BsaHNtVGthUVpFX1U2eEFyVzhTV1NvNjMweW1ZVm5kbG9ybmNlbEl3WkZrNGd2MHY2MUxlT09DTERGOEpEc2pZMm15d054RjhMcmQ3aXNSUjlUbGNyWlVWelBDajFVZl9qZE5RNE93Q3hmSi1UbU1FanNkMlRkTT0=",
    merchantLogo: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OGvyFA7sMtl4X-Sr3Ka1xUHi88nU-5n6yvV6bUlBxDMGXtS8TAV75yHD7vpq8nUKmw.gif",
    merchantLogoUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OGvyFA7sMtl4X-Sr3Ka1xUHi88nU-5n6yvV6bUlBxDMGXtS8TAV75yHD7vpq8nUKmw.gif",
    svgMerchantLogo: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OGvyFA7sMtl4X-Sr3Ka1xUHi88nU-5n6yvV6bUlBxDMGXtS8TAV75yHD7vpq8nUKmw.gif",
    originalMerchantLogo: "https://s9.cnnx.io/merchant/little/134939.gif",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly9yZC5iaXpyYXRlLmNvbS9yZD90PWh0dHBzJTNBJTJGJTJGd3d3Lm5mbHNob3AuY29tJTJGbWFkZGVuX25mbF8yMV94Ym94X29uZV92aWRlb19nYW1lJTJGdC00NzE1MTM4OCUyQm8tODA1MCUyQmQtOTA2MTQzODI4JTJCZi00MDcyMjg0JTJCei05LTIyMjY5MDQxMTMlM0Z1dG1fbWVkaXVtJTNEY3NlJTI2X3MlM0RhazE5NDRuZmwtc2hvcHppbGxhJTI2c2t1JTNEMTQyNzM5MDQmbWlkPTEzNDkzOSZjYXRfaWQ9MTUwMTAxMDAmYXRvbT0xMDAwMDM0NTMmcHJvZF9pZD0mb2lkPTE1OTMwNTE1NDE4JnBvcz0xJmJfaWQ9MTgmYmlkX3R5cGU9MTAmYmFtdD00OGNkOTIwMmRiMTk1ZTliJmNvYnJhbmQ9MSZwcHI9MjU5ZmFkZGFjMWVkZDFlMCZhZl9zaWQ9NzImbXBpZD0xNDI3MzkwNCZrZXl3b3JkPXZpZGVvJTIwZ2FtZXMmYT04YmRiNzg5MDQ2OTEyYWMzOTY2YWQyY2IzNDgwYWFkYyZkdj0xNGU3ODdjMDU4YzQ5NDE5M2ZiYzRlN2NjZWZkZjE1OWFjNzhkMzNiOWRmYzlkZTkmcmY9YWYxJmFmX2Fzc2V0dHlwZV9pZD0xMCZhZl9jcmVhdGl2ZV9pZD0yOTc1JmFmX2lkPTYwODEwNSZhZl9wbGFjZW1lbnRfaWQ9MiZwbGFjZW1lbnRJZD0x&click_id=415526353-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=bizrate.com&rf_product_code=bizrate.com-us-15930515418-new&rf_account=bizrate_us&rf_position=0&rf_merchant_name=NFL Shop&rf_merchant_id=134939&rf_c=&rf_from_api=true",
    position: 2,
    productCode: "bizrate.com-us-15930515418-new",
    account: "bizrate_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !0
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B096WZFCHR",
    title: "Marvel\u2019s Guardians of the Galaxy - PlayStation 5",
    truncatedTitle: "Marvel\u2019s Guardians of the Galaxy - PlayStation 5",
    publicItemId: "B096WZFCHR",
    source: "amazon",
    categoryId: "20972797011",
    merchantId: null,
    total_new: 23,
    total_used: 3,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: "Square Enix",
    condition: "new",
    price: 59.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTt4acKuHTT_UIyQCVb6Aa1DxqmA9X8wv6575Su9os9N0.jpg",
    image: "https://m.media-amazon.com/images/I/51fbu9jCezL._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNTFmYnU5akNlekwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/amazon-logo-543924fcbf756b453bf9414716467e3ef1e615637f49b7ba0b75461a839bb6ed.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/amazon-logo-b105fcd1d1470059ab7cea0edf9309ebc7d878039365215b947426e4f60e139d.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDk2V1pGQ0hSP1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=059477658-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B096WZFCHR-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=VmlkZW8gR2FtZXMgfCBQbGF5U3RhdGlvbiA1IHwgR2FtZXM=&rf_from_api=true",
    position: 3,
    productCode: "amazon-us-B096WZFCHR-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_used_B096WZFCHR",
    title: "Marvel\u2019s Guardians of the Galaxy - PlayStation 5",
    truncatedTitle: "Marvel\u2019s Guardians of the Galaxy - PlayStation 5",
    publicItemId: "B096WZFCHR",
    source: "amazon",
    categoryId: "20972797011",
    merchantId: null,
    total_new: 23,
    total_used: 3,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: "Square Enix",
    condition: "used",
    price: 52.79,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTt4acKuHTT_UIyQCVb6Aa1DxqmA9X8wv6575Su9os9N0.jpg",
    image: "https://m.media-amazon.com/images/I/51fbu9jCezL._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNTFmYnU5akNlekwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/amazon-logo-543924fcbf756b453bf9414716467e3ef1e615637f49b7ba0b75461a839bb6ed.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/amazon-logo-b105fcd1d1470059ab7cea0edf9309ebc7d878039365215b947426e4f60e139d.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDk2V1pGQ0hSP1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=705698613-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B096WZFCHR-used&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=VmlkZW8gR2FtZXMgfCBQbGF5U3RhdGlvbiA1IHwgR2FtZXM=&rf_from_api=true",
    position: 4,
    productCode: "amazon-us-B096WZFCHR-used",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_373082166982",
    title: "NINTENDO WII GAME LOT YOU PICK CHOOSE BUY 2 GET 1 50% OFF ALL GAMES PLAY TESTED!",
    truncatedTitle: "NINTENDO WII GAME LOT YOU PICK CHOOSE BUY 2 GET 1 50% OFF ALL GAMES PLAY...",
    publicItemId: "373082166982",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-13T02:03:41.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 1.97,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qV47OjNh9L7K9-958FXr7G8vqbYhqk_gnSVSbJmTFWI4_gHGjhH91IJi7v9dZ1pTup.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/DMQAAOSwvKBeww1Y/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTA1M1gxNTEx/z/DMQAAOSwvKBeww1Y/$_12.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9ETVFBQU9Td3ZLQmV3dzFZL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzM3MzA4MjE2Njk4Mj9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=203484469-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-373082166982-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 5,
    productCode: "ebay-us-373082166982-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "focus camera_new_17540256060",
    title: "Sony Watch Dogs 2 Video Game for Playstation 4",
    truncatedTitle: "Sony Watch Dogs 2 Video Game for Playstation 4",
    publicItemId: "17540256060",
    source: "bizrate.com",
    categoryId: "15010100",
    merchantId: 94705,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "focus camera",
    expiring: null,
    auction: !1,
    brandName: "Sony",
    condition: "new",
    price: 79.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLoqq0P-bB3rUQBimQQs1Q_Eh4qa9tfMCnTa2z5rNcHqYcje8_h0wOln80GAIKsK65q-wTm1p8Y16ar82K-7XsWp5q0-KKuJ9pgTiY3pu6GI33u41X_BVspgPfBZ36zKqO-Y4SVEicJk8meQtx2UqDCK4LA4U0PNdXj-XSNK37J7Xl_ZHScTMKhxbcU4Jrr2H1B2ywPEocCF4SntkFjrnY_WiS1As_C_4vdBt1LOs_5m.jpeg",
    image: "https://d10.cnnx.io/image/obj/17540256060;sq=160;p=0;t=ooPwmM0WTWKaBQ8NCV4zeSNCmBIMGjoDHVr-0SePLLAozh94mpq9wByav-1lFXIwmDh7OLoeSAMiNKcXepMrOe3ogHmVCrT2pMCnHFtS-w==",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9kMTAuY25ueC5pby9pbWFnZS9vYmovMTc1NDAyNTYwNjA7c3E9MTYwO3A9MDt0PW9vUHdtTTBXVFdLYUJROE5DVjR6ZVNOQ21CSU1Ham9ESFZyLTBTZVBMTEFvemg5NG1wcTl3Qnlhdi0xbEZYSXdtRGg3T0xvZVNBTWlOS2NYZXBNck9lM29nSG1WQ3JUMnBNQ25IRnRTLXc9PQ==",
    merchantLogo: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OMWRTpUpTFkVct9O84hCvu0646SEhhdweo6Sy2lTcM70MR7f4qlLKHYEoRoimJQ67g.gif",
    merchantLogoUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OMWRTpUpTFkVct9O84hCvu0646SEhhdweo6Sy2lTcM70MR7f4qlLKHYEoRoimJQ67g.gif",
    svgMerchantLogo: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OMWRTpUpTFkVct9O84hCvu0646SEhhdweo6Sy2lTcM70MR7f4qlLKHYEoRoimJQ67g.gif",
    originalMerchantLogo: "https://s10.cnnx.io/merchant/little/94705.gif",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly9yZC5iaXpyYXRlLmNvbS9yZD90PWh0dHBzJTNBJTJGJTJGd3d3LmZvY3VzY2FtZXJhLmNvbSUyRndhdGNoLWRvZ3MtMi1mb3ItcGxheXN0YXRpb24tNC5odG1sJTNGdXRtX3NvdXJjZSUzRGNvbm5leGl0eSUyNmNueGNsaWQlM0RTWl9SRURJUkVDVF9JRCUyNnN6cmVkaXJlY3RpZCUzRFNaX1JFRElSRUNUX0lEJm1pZD05NDcwNSZjYXRfaWQ9MTUwMTAxMDAmYXRvbT0xMDAwMDM0NTMmcHJvZF9pZD0mb2lkPTE3NTQwMjU2MDYwJnBvcz0xJmJfaWQ9MTgmYmlkX3R5cGU9OCZiYW10PTQ4Y2Q5MjAyZGIxOTVlOWImY29icmFuZD0xJnBwcj1jMDBmMmRlOTljZjM1ZTIyJmFmX3NpZD03MiZtcGlkPTAyMjg4JmJyYW5kSWQ9MzkwJmtleXdvcmQ9dmlkZW8lMjBnYW1lcyZhPTY3ODc3YjQyNzBiNzE2MzMyMWE1Y2I3NDZhOTNhM2NiJmR2PWE5MzliZDA2NjE5MWUwNWEyZjYwYzdmMTRmNzY5NmM1NmFiNTM3ZmFhYTgxOWZmNyZyZj1hZjEmYWZfYXNzZXR0eXBlX2lkPTEwJmFmX2NyZWF0aXZlX2lkPTI5NzUmYWZfaWQ9NjA4MTA1JmFmX3BsYWNlbWVudF9pZD0yJnBsYWNlbWVudElkPTE=&click_id=853383909-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=bizrate.com&rf_product_code=bizrate.com-us-17540256060-new&rf_account=bizrate_us&rf_position=0&rf_merchant_name=Focus Camera&rf_merchant_id=94705&rf_c=&rf_from_api=true",
    position: 6,
    productCode: "bizrate.com-us-17540256060-new",
    account: "bizrate_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B00EJQUZVK",
    title: "The Ultimate History of Video Games: From Pong to Pokemon: The Story Behind the Craze that Touched Our Lives and Changed the World",
    truncatedTitle: "The Ultimate History of Video Games: From Pong to Pokemon: The Story...",
    publicItemId: "B00EJQUZVK",
    source: "amazon",
    categoryId: "87",
    merchantId: null,
    total_new: 1,
    total_used: 0,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: null,
    condition: "new",
    price: 29.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGT5CO3IdK8mnB5mL9YOksxr5dLr-nGpox-Wa3VyF1rysM.jpg",
    image: "https://m.media-amazon.com/images/I/61GCaxr3r3L._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNjFHQ2F4cjNyM0wuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/amazon-logo-543924fcbf756b453bf9414716467e3ef1e615637f49b7ba0b75461a839bb6ed.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/amazon-logo-b105fcd1d1470059ab7cea0edf9309ebc7d878039365215b947426e4f60e139d.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDBFSlFVWlZLP1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=377060277-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B00EJQUZVK-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=Qm9va3MgfCBDb21wdXRlcnMgJiBUZWNobm9sb2d5IHwgR2FtZXMgJiBTdHJhdGVneSBHdWlkZXM=&rf_from_api=true",
    position: 7,
    productCode: "amazon-us-B00EJQUZVK-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_used_B098KVCFM8",
    title: "FIFA 22 - PlayStation 4",
    truncatedTitle: "FIFA 22 - PlayStation 4",
    publicItemId: "B098KVCFM8",
    source: "amazon",
    categoryId: "6427831011",
    merchantId: null,
    total_new: 21,
    total_used: 1,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: "Electronic Arts",
    condition: "used",
    price: 36.79,
    oldPrice: 59.99,
    discount: 38,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTNM8vDrJd9nReYzsNPk2SIpXHcJXkOkdbCBsjqIb8xS8.jpg",
    image: "https://m.media-amazon.com/images/I/41-I2ULMO1L._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNDEtSTJVTE1PMUwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/amazon-logo-543924fcbf756b453bf9414716467e3ef1e615637f49b7ba0b75461a839bb6ed.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/amazon-logo-b105fcd1d1470059ab7cea0edf9309ebc7d878039365215b947426e4f60e139d.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDk4S1ZDRk04P1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=830256134-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B098KVCFM8-used&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=VmlkZW8gR2FtZXMgfCBQbGF5U3RhdGlvbiA0IHwgR2FtZXM=&rf_from_api=true",
    position: 8,
    productCode: "amazon-us-B098KVCFM8-used",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_193657316256",
    title: "Mario Kart 8 Deluxe - Nintendo Switch",
    truncatedTitle: "Mario Kart 8 Deluxe - Nintendo Switch",
    publicItemId: "193657316256",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-10T23:28:47.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 36.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qV4vrXDb6U_t3FIurxTR0kVjpWcR_rNExQ1b4hEONrISEVs_4I_6uem6W7I8OE80yv.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/msgAAOSwfBFblpsK/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTAwMFgxMDAw/z/msgAAOSwfBFblpsK/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9tc2dBQU9Td2ZCRmJscHNLL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzE5MzY1NzMxNjI1Nj9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=565843717-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-193657316256-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 9,
    productCode: "ebay-us-193657316256-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B098KVCFM8",
    title: "FIFA 22 - PlayStation 4",
    truncatedTitle: "FIFA 22 - PlayStation 4",
    publicItemId: "B098KVCFM8",
    source: "amazon",
    categoryId: "6427831011",
    merchantId: null,
    total_new: 21,
    total_used: 1,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: "Electronic Arts",
    condition: "new",
    price: 39.99,
    oldPrice: 59.99,
    discount: 33,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTNM8vDrJd9nReYzsNPk2SIpXHcJXkOkdbCBsjqIb8xS8.jpg",
    image: "https://m.media-amazon.com/images/I/41-I2ULMO1L._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNDEtSTJVTE1PMUwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/amazon-logo-543924fcbf756b453bf9414716467e3ef1e615637f49b7ba0b75461a839bb6ed.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/amazon-logo-b105fcd1d1470059ab7cea0edf9309ebc7d878039365215b947426e4f60e139d.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDk4S1ZDRk04P1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=459159361-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B098KVCFM8-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=VmlkZW8gR2FtZXMgfCBQbGF5U3RhdGlvbiA0IHwgR2FtZXM=&rf_from_api=true",
    position: 10,
    productCode: "amazon-us-B098KVCFM8-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B07RGFF98S",
    title: "Nintendo Switch 32GB Console Video Games w/ 32GB Memory Card | Neon Red/Neon Blue Joy-Con | 1080p Resolution | 802.11ac WiFi | HDMI | Surround Sound | IR Motion Camera",
    truncatedTitle: "Nintendo Switch 32GB Console Video Games w/ 32GB Memory Card | Neon Red...",
    publicItemId: "B07RGFF98S",
    source: "amazon",
    categoryId: "16329781011",
    merchantId: null,
    total_new: 53,
    total_used: 2,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: "Nintendo",
    condition: "new",
    price: 395,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTYnCAagXefZKMGa7Ay8JgLrFDB_Cqpm-8erhWTNKwd84.jpg",
    image: "https://m.media-amazon.com/images/I/417kf2GJBuL._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNDE3a2YyR0pCdUwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/amazon-logo-543924fcbf756b453bf9414716467e3ef1e615637f49b7ba0b75461a839bb6ed.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/amazon-logo-b105fcd1d1470059ab7cea0edf9309ebc7d878039365215b947426e4f60e139d.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDdSR0ZGOThTP1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=007488442-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B07RGFF98S-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=VmlkZW8gR2FtZXMgfCBOaW50ZW5kbyBTd2l0Y2ggfCBBY2Nlc3NvcmllcyB8IENvbnRyb2xsZXJz&rf_from_api=true",
    position: 11,
    productCode: "amazon-us-B07RGFF98S-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_324436850948",
    title: "Luigi's Mansion 3 - Nintendo Switch",
    truncatedTitle: "Luigi's Mansion 3 - Nintendo Switch",
    publicItemId: "324436850948",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-30T19:35:41.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 52.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVEhmTNZOlKagipmfnzsumZqLV3GxWpOiG_n8m7FGyH6pCLIdBRQxQGPhp1hTeszqZ.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/1JwAAOSwihtd6YnT/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTAwMFgxMDAw/z/1JwAAOSwihtd6YnT/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy8xSndBQU9Td2lodGQ2WW5UL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzMyNDQzNjg1MDk0OD9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=139027653-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-324436850948-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 12,
    productCode: "ebay-us-324436850948-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_used_B07RGFF98S",
    title: "Nintendo Switch 32GB Console Video Games w/ 32GB Memory Card | Neon Red/Neon Blue Joy-Con | 1080p Resolution | 802.11ac WiFi | HDMI | Surround Sound | IR Motion Camera",
    truncatedTitle: "Nintendo Switch 32GB Console Video Games w/ 32GB Memory Card | Neon Red...",
    publicItemId: "B07RGFF98S",
    source: "amazon",
    categoryId: "16329781011",
    merchantId: null,
    total_new: 53,
    total_used: 2,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: "Nintendo",
    condition: "used",
    price: 365,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTYnCAagXefZKMGa7Ay8JgLrFDB_Cqpm-8erhWTNKwd84.jpg",
    image: "https://m.media-amazon.com/images/I/417kf2GJBuL._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNDE3a2YyR0pCdUwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/amazon-logo-543924fcbf756b453bf9414716467e3ef1e615637f49b7ba0b75461a839bb6ed.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/amazon-logo-b105fcd1d1470059ab7cea0edf9309ebc7d878039365215b947426e4f60e139d.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDdSR0ZGOThTP1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=294158344-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B07RGFF98S-used&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=VmlkZW8gR2FtZXMgfCBOaW50ZW5kbyBTd2l0Y2ggfCBBY2Nlc3NvcmllcyB8IENvbnRyb2xsZXJz&rf_from_api=true",
    position: 13,
    productCode: "amazon-us-B07RGFF98S-used",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B08Y6HCHP8",
    title: "Pok\xE9mon Brilliant Diamond - Nintendo Switch",
    truncatedTitle: "Pok\xE9mon Brilliant Diamond - Nintendo Switch",
    publicItemId: "B08Y6HCHP8",
    source: "amazon",
    categoryId: "16227133011",
    merchantId: null,
    total_new: 1,
    total_used: 0,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: "Nintendo",
    condition: "new",
    price: 59.88,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTmYhkjnJiHtwvf9T6RTozR21nNILumlfexgEkcV1UsnM.jpg",
    image: "https://m.media-amazon.com/images/I/51lgw9CRKbL._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNTFsZ3c5Q1JLYkwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/amazon-logo-543924fcbf756b453bf9414716467e3ef1e615637f49b7ba0b75461a839bb6ed.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/amazon-logo-b105fcd1d1470059ab7cea0edf9309ebc7d878039365215b947426e4f60e139d.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDhZNkhDSFA4P1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=555526169-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B08Y6HCHP8-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=VmlkZW8gR2FtZXMgfCBOaW50ZW5kbyBTd2l0Y2ggfCBHYW1lcw==&rf_from_api=true",
    position: 14,
    productCode: "amazon-us-B08Y6HCHP8-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_203102862760",
    title: "Super Mario Odyssey Standard Edition - Nintendo Switch",
    truncatedTitle: "Super Mario Odyssey Standard Edition - Nintendo Switch",
    publicItemId: "203102862760",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-11T00:16:35.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 38.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVgEeEpBRJHjoGcN8F7lskrbfNdbBCXUk3zpjMGUL_6sAiEKquaPTJ1Fon0VtQtUYv.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/N14AAOSw7FJblrC7/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTAwMFgxMDAw/z/N14AAOSw7FJblrC7/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9OMTRBQU9TdzdGSmJsckM3L3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzIwMzEwMjg2Mjc2MD9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=455887876-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-203102862760-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 15,
    productCode: "ebay-us-203102862760-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B01N5A8HEC",
    title: "Troll Face Quest Video Games",
    truncatedTitle: "Troll Face Quest Video Games",
    publicItemId: "B01N5A8HEC",
    source: "amazon",
    categoryId: "9408533011",
    merchantId: null,
    total_new: 1,
    total_used: 0,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: "SPIL GAMES",
    condition: "new",
    price: 0,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTdzy6pRQjIsMP3JkQ3iH1v-_gaW74JqHNclvsMQAOtdg.png",
    image: "https://m.media-amazon.com/images/I/719Kay7BjQL._SL500_.png",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNzE5S2F5N0JqUUwuX1NMNTAwXy5wbmc=",
    merchantLogo: "https://www.bestdeals.today/assets/amazon-logo-543924fcbf756b453bf9414716467e3ef1e615637f49b7ba0b75461a839bb6ed.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/amazon-logo-b105fcd1d1470059ab7cea0edf9309ebc7d878039365215b947426e4f60e139d.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDFONUE4SEVDP1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=810354787-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B01N5A8HEC-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=QXBwcyAmIEdhbWVzIHwgR2FtZXMgfCBCcmFpbiAmIFB1enpsZQ==&rf_from_api=true",
    position: 16,
    productCode: "amazon-us-B01N5A8HEC-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_284512457426",
    title: "Mario Party Superstars - Nintendo Switch",
    truncatedTitle: "Mario Party Superstars - Nintendo Switch",
    publicItemId: "284512457426",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-01T19:39:18.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 52.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVASUXdbIJDx6_mNDxrts5sv57UH7yiqBeOfPhjtxnzgtdzXYK6NggytOs2209juxZ.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/z~UAAOSwBMhhgEIC/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTUwMFg5MjY=/z/z~UAAOSwBMhhgEIC/$_12.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy96flVBQU9Td0JNaGhnRUlDL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzI4NDUxMjQ1NzQyNj9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=879440820-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-284512457426-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 17,
    productCode: "ebay-us-284512457426-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_202639034313",
    title: "Super Mario Bros. 3 - Nintendo NES Game Authentic",
    truncatedTitle: "Super Mario Bros. 3 - Nintendo NES Game Authentic",
    publicItemId: "202639034313",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-29T13:00:44.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 16.49,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 2.95,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVhk_Tt7CwT1FPIVLLg30qhdLLhIIPmcGOqucYT4RpUBXAot5fxzYcy9TG7Gv9ZEJu.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/fPQAAOSw~xVgbyMC/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTYwMFgxNDY3/z/fPQAAOSw~xVgbyMC/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9mUFFBQU9Td354VmdieU1DL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzIwMjYzOTAzNDMxMz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=648381428-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-202639034313-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 18,
    productCode: "ebay-us-202639034313-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_193657439637",
    title: "Animal Crossing: New Horizons - Nintendo Switch",
    truncatedTitle: "Animal Crossing: New Horizons - Nintendo Switch",
    publicItemId: "193657439637",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-11T02:04:50.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 50.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVq8HxkRVSWc1p3URiKCQr9z1FVJ5ENOYgudGrOQPzDS-cLb3IC4p8uevFGcY0GZUa.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/-vQAAOSwbPBeyKh1/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTAwMFg2MTg=/z/-vQAAOSwbPBeyKh1/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy8tdlFBQU9Td2JQQmV5S2gxL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzE5MzY1NzQzOTYzNz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=570090975-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-193657439637-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 19,
    productCode: "ebay-us-193657439637-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_164093307854",
    title: "Halo games (Microsoft Xbox 360) Tested",
    truncatedTitle: "Halo games (Microsoft Xbox 360) Tested",
    publicItemId: "164093307854",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-23T02:39:05.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 13.47,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 4.25,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVOUZ8zZObRXTnxKJhE321lFj0s8LVQfMNXMYz45hyNywEVsBtXmDyfnozy9hW32T8.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/AKMAAOSw4qNeUeAx/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9BS01BQU9TdzRxTmVVZUF4L3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzE2NDA5MzMwNzg1ND9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=795109873-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-164093307854-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 20,
    productCode: "ebay-us-164093307854-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_284469027330",
    title: "Metroid Dread - Nintendo Switch",
    truncatedTitle: "Metroid Dread - Nintendo Switch",
    publicItemId: "284469027330",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-28T21:41:24.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 54.95,
    oldPrice: 59.99,
    discount: 8,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVKQgpJ1VgVwCgbkCEgdKYJ_tiaFjPXEeui7dTu__Xraho-lmQbSCMyi9Wlgm0Zge_.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/4~wAAOSwphhhexu8/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy80fndBQU9Td3BoaGhleHU4L3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzI4NDQ2OTAyNzMzMD9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=165358476-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-284469027330-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 21,
    productCode: "ebay-us-284469027330-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_373241969167",
    title: "NINTENDO WII GAME LOT YOU PICK CHOOSE BUY 2 GET 1 50% OFF GAMES PLAY TESTED LOT2",
    truncatedTitle: "NINTENDO WII GAME LOT YOU PICK CHOOSE BUY 2 GET 1 50% OFF GAMES PLAY...",
    publicItemId: "373241969167",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-29T01:24:35.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 26.77,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVN4mojV2yIImjI5jke2DFJPHE6QWU2kVGqYalAkSOphFaaGFKaK9x-QShDRoeXy-y.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/EE0AAOSwFZhfjK5~/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9FRTBBQU9Td0ZaaGZqSzV+L3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzM3MzI0MTk2OTE2Nz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=269954237-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-373241969167-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 22,
    productCode: "ebay-us-373241969167-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_203293128997",
    title: "Super Mario 3D World + Bowsers Fury - Nintendo Switch, Nintendo Switch Lite",
    truncatedTitle: "Super Mario 3D World + Bowsers Fury - Nintendo Switch, Nintendo Switch Lite",
    publicItemId: "203293128997",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-01T18:10:29.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 51.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVAqOLmhaS-Tr2yMbYLTr1OOPyT1iNhtG9Bs2SWt5vE0KEeUS05Sddw8xHANjHOo08.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/5h0AAOSwf-5gPS4X/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTAwMFg2MTg=/z/5h0AAOSwf-5gPS4X/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy81aDBBQU9Td2YtNWdQUzRYL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzIwMzI5MzEyODk5Nz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=414297857-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-203293128997-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 23,
    productCode: "ebay-us-203293128997-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_392926103491",
    title: "Random Steam Game Key",
    truncatedTitle: "Random Steam Game Key",
    publicItemId: "392926103491",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-30T20:02:33.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 0.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVJjnSPRKunti0A_KPFpxEbmnFmubYehZ1g9s8qpypl8TJN2q9ZHHkc0tik0BPRrvb.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/OoYAAOSwjWRe~RS-/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9Pb1lBQU9Td2pXUmV+UlMtL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzM5MjkyNjEwMzQ5MT9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=008828760-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-392926103491-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 24,
    productCode: "ebay-us-392926103491-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_234277415927",
    title: "The Legend of Zelda: Skyward Sword HD - Nintendo Switch - In Stock Ready To Ship",
    truncatedTitle: "The Legend of Zelda: Skyward Sword HD - Nintendo Switch - In Stock Ready...",
    publicItemId: "234277415927",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-08T22:58:33.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 41,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVST6fUuul2H5FfAS3o5noyp7McriLmjyEsvgx4CCeHQbpw70Gp6DetEEgGyeI1eK3.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/lsgAAOSwWt9g1ahx/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9sc2dBQU9Td1d0OWcxYWh4L3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzIzNDI3NzQxNTkyNz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=011639376-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-234277415927-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 25,
    productCode: "ebay-us-234277415927-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_353260498302",
    title: "America/NA Genshin Impact Diluc Hu Tao Eula Zhongli Xiao Baal Ayaka Kazuha Venti",
    truncatedTitle: "America/NA Genshin Impact Diluc Hu Tao Eula Zhongli Xiao Baal Ayaka...",
    publicItemId: "353260498302",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-02T17:32:07.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 1.49,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qV2kB9LFSMw5cHH4_hGYBwo62B2ZfjimNj3watX6JlFQg4DY6xUv3pRvrV3OWMVoDL.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/IOkAAOSw40lhef3j/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9JT2tBQU9TdzQwbGhlZjNqL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzM1MzI2MDQ5ODMwMj9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=665197178-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-353260498302-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 26,
    productCode: "ebay-us-353260498302-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_403262883483",
    title: "GAMESTOP Shiny Zacian and Zamazenta BOTH (2) CODES - Pok\xE9mon Sword & Shield",
    truncatedTitle: "GAMESTOP Shiny Zacian and Zamazenta BOTH (2) CODES - Pok\xE9mon Sword & Shield",
    publicItemId: "403262883483",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-28T23:00:33.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 3.4,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVomIKzmHHtGUnzGX536nsRcGKlaOhwnxOglQMI4h4GlQ651t409MUXF8-k2yaW5rg.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/uaIAAOSw1x5hhbba/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy91YUlBQU9TdzF4NWhoYmJhL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzQwMzI2Mjg4MzQ4Mz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=045761077-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-403262883483-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 27,
    productCode: "ebay-us-403262883483-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_372840325578",
    title: "Nintendo Wii Games! You Choose from Large Selection! $7.95 Each! Buy 2 Get 1 50%",
    truncatedTitle: "Nintendo Wii Games! You Choose from Large Selection! $7.95 Each! Buy...",
    publicItemId: "372840325578",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-13T20:16:50.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 7.95,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 3.95,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVeBY6b1K4jqgtNTprB8Ps-PyTvrIn-aQ0bCI7eF9ByXtBmdgsEnCz1ruJJKK9lEUv.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/ENUAAOSwjY5de-qK/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTIwMFgxNjAw/z/ENUAAOSwjY5de-qK/$_12.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9FTlVBQU9Td2pZNWRlLXFLL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzM3Mjg0MDMyNTU3OD9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=402940196-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-372840325578-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 28,
    productCode: "ebay-us-372840325578-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_333855526527",
    title: "1X Random Steam Key [REGION FREE]",
    truncatedTitle: "1X Random Steam Key [REGION FREE]",
    publicItemId: "333855526527",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-12T18:54:45.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 0.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVm2-f-wnCYkWDNTUQx2eaCVRQLgjhAccN3RdnzewmFGS52xp_0SL3HlhYVAIyCL5x.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/OI8AAOSwAfVf~e75/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/NTAwWDUwMA==/z/OI8AAOSwAfVf~e75/$_12.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9PSThBQU9Td0FmVmZ+ZTc1L3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzMzMzg1NTUyNjUyNz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=049898507-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-333855526527-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 29,
    productCode: "ebay-us-333855526527-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_373342188901",
    title: "NINTENDO WII GAME LOT YOU PICK CHOOSE BUY 2 GET 1 50% OFF GAMES PLAY TESTED LOT3",
    truncatedTitle: "NINTENDO WII GAME LOT YOU PICK CHOOSE BUY 2 GET 1 50% OFF GAMES PLAY...",
    publicItemId: "373342188901",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-16T03:25:04.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 18.77,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qV7cp6OS-O6ofEFwEPqjjgnOZEPidy811huO0eG4_eatGRSgnjjayPUF1G29H8mLWD.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/UwQAAOSwgPtfsa2t/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9Vd1FBQU9Td2dQdGZzYTJ0L3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzM3MzM0MjE4ODkwMT9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=168956157-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-373342188901-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 30,
    productCode: "ebay-us-373342188901-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_192873974855",
    title: "Super Mario Bros. 2 - Nintendo NES Game Authentic",
    truncatedTitle: "Super Mario Bros. 2 - Nintendo NES Game Authentic",
    publicItemId: "192873974855",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-29T13:21:05.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 19.79,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 2.95,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVr7l_uMdVmDgN_7cqCvaj528zM57PntBUB7S6Gj_OfbZkFioQ9M0gl1sa3msVZR69.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/1zIAAOSwIxNf9eKI/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTYwMFgxNDI2/z/1zIAAOSwIxNf9eKI/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy8xeklBQU9Td0l4TmY5ZUtJL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzE5Mjg3Mzk3NDg1NT9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=036002691-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-192873974855-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 31,
    productCode: "ebay-us-192873974855-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_165170704956",
    title: "Nintendo Switch Games NEW SEALED Fun You Pick & Choose Video Games Lot Kids",
    truncatedTitle: "Nintendo Switch Games NEW SEALED Fun You Pick & Choose Video Games Lot Kids",
    publicItemId: "165170704956",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-06T21:22:46.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 44.91,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVmwBXM1381NCsFv2I2si-2_JPfHzInQHtAoe-Q_jL0CDym42gjJcUcpDNYtH1kaYb.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/Z6kAAOSwo0lhhvhB/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9aNmtBQU9Td28wbGhodmhCL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzE2NTE3MDcwNDk1Nj9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=528910424-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-165170704956-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 32,
    productCode: "ebay-us-165170704956-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_124994322339",
    title: "Animal Crossing Treasure Island | Version 2.0 | Unlimited Trips - free friends",
    truncatedTitle: "Animal Crossing Treasure Island | Version 2.0 | Unlimited Trips - free...",
    publicItemId: "124994322339",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-08T17:48:23.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 10,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVL_Pc0z8nrOR6fLoAw3wACP0I4EBsaY5Ji4n_rC5NG8i93ult734mT1txShfA9RVE.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/o5MAAOSwJ9BhiWGp/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9vNU1BQU9Td0o5QmhpV0dwL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzEyNDk5NDMyMjMzOT9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=100853898-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-124994322339-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 33,
    productCode: "ebay-us-124994322339-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_185115334649",
    title: "Minecraft (Nintendo Switch) Includes Super Mario Mash-Up + Case and Cartridge",
    truncatedTitle: "Minecraft (Nintendo Switch) Includes Super Mario Mash-Up + Case and...",
    publicItemId: "185115334649",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-18T21:10:28.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 29.98,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVF8kh642mfnsLp67Kl6wkWvwDzhVOrBNfR4M8ypBCCeo2oV8O1abLlkK56s51Mu55.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/Sj4AAOSwY~FhbeJS/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTUwMFgxNTAw/z/Sj4AAOSwY~FhbeJS/$_12.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9TajRBQU9Td1l+RmhiZUpTL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzE4NTExNTMzNDY0OT9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=074277027-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-185115334649-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 34,
    productCode: "ebay-us-185115334649-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_193844437919",
    title: "Nintendo Switch Games to Choose From (Or Blank Case)",
    truncatedTitle: "Nintendo Switch Games to Choose From (Or Blank Case)",
    publicItemId: "193844437919",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-10T21:34:58.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 44.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 3.45,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVpVQU_T-Gl0WAoat1TRIF3wKahQQJBsMXlMBJVfBVz4luiyQEYoOEfLWolCkJZrx7.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/qZcAAOSwy0Nf-2uH/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9xWmNBQU9Td3kwTmYtMnVIL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzE5Mzg0NDQzNzkxOT9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=115777774-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-193844437919-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 35,
    productCode: "ebay-us-193844437919-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_133923636655",
    title: "Shiny Zacian & Zamazenta GAMESTOP EVENT BOTH [2] CODES! Pokemon Sword and Shield",
    truncatedTitle: "Shiny Zacian & Zamazenta GAMESTOP EVENT BOTH [2] CODES! Pokemon Sword...",
    publicItemId: "133923636655",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-03T19:44:11.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 3.4,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVUfU3gF3PZz0vEeJFoQCUPFttGEB6nvYTFTRGL_m8PlAhQvYidYvf8ropYUQm0b2T.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/UbIAAOSwRGBhiA-F/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/NTI0WDU5Mw==/z/UbIAAOSwRGBhiA-F/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9VYklBQU9Td1JHQmhpQS1GL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzEzMzkyMzYzNjY1NT9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=309992456-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-133923636655-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 36,
    productCode: "ebay-us-133923636655-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_194376553053",
    title: "NINTENDO SWITCH GAMES LOT | BRAND NEW FACTORY SEALED | PICK & CHOOSE YOUR TITLE",
    truncatedTitle: "NINTENDO SWITCH GAMES LOT | BRAND NEW FACTORY SEALED | PICK & CHOOSE...",
    publicItemId: "194376553053",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-19T20:04:28.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 15.95,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVzgKhTOif-l2UJ4cPwM6Kz07b7TcbmgpJcsH5hKaknBDnhIbRLz6YmWl7a3AkMoGv.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/7KoAAOSwHeZhR4ac/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/OTQyWDE2MDA=/z/7KoAAOSwHeZhR4ac/$_12.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy83S29BQU9Td0hlWmhSNGFjL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzE5NDM3NjU1MzA1Mz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=200558594-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-194376553053-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 37,
    productCode: "ebay-us-194376553053-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_174967042821",
    title: "The Legend of Zelda: Phantom Hourglass (DS, 2007), Tested,US Version Hot Gift",
    truncatedTitle: "The Legend of Zelda: Phantom Hourglass (DS, 2007), Tested,US Version Hot...",
    publicItemId: "174967042821",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-06T14:41:35.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 14.55,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVMeFRjKnB0dXDu5aL-uSwC8xj4brDx83innuxMqepUxzjLQ8CSmBKfxKZlJKGTTBc.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/DhMAAOSwlophXbWF/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTYwMFgxNjAw/z/DhMAAOSwlophXbWF/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9EaE1BQU9Td2xvcGhYYldGL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzE3NDk2NzA0MjgyMT9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=251956442-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-174967042821-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 38,
    productCode: "ebay-us-174967042821-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_165171623112",
    title: "Nintendo Switch Games Complete Fun You Pick & Choose Video Games Lot Kids",
    truncatedTitle: "Nintendo Switch Games Complete Fun You Pick & Choose Video Games Lot Kids",
    publicItemId: "165171623112",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-07T15:38:08.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 10.91,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qV8sVUJ1-d_lgzgXBrZ09ltNXMB2pCQywZgDKlXnNxWSMoGOFXfaeBTscKCkpSXpQS.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/UAsAAOSwe95hh~Ca/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTIwMFgxNjAw/z/UAsAAOSwe95hh~Ca/$_12.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9VQXNBQU9Td2U5NWhofkNhL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzE2NTE3MTYyMzExMj9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=607746749-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-165171623112-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 39,
    productCode: "ebay-us-165171623112-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_353756562210",
    title: "Call of Duty: Vanguard (PS4 / PlayStation 4) BRAND NEW ",
    truncatedTitle: "Call of Duty: Vanguard (PS4 / PlayStation 4) BRAND NEW ",
    publicItemId: "353756562210",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-04T14:46:21.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 63.95,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVTiOEyvTEYEN-8MKc-BygcLY1JRxgZh6_Pw3AjY1mXfPOIEJqVxPvB1D5CsgTzqXR.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/HcwAAOSwbbNhhASy/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTYwMFgxMjAw/z/HcwAAOSwbbNhhASy/$_12.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9IY3dBQU9Td2JiTmhoQVN5L3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzM1Mzc1NjU2MjIxMD9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=410362581-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-353756562210-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 40,
    productCode: "ebay-us-353756562210-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_274806861917",
    title: "Buy 2 Get 3rd 50% Off!! Nintendo Wii Game Lot Pick & Choose!",
    truncatedTitle: "Buy 2 Get 3rd 50% Off!! Nintendo Wii Game Lot Pick & Choose!",
    publicItemId: "274806861917",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-22T17:31:51.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 7.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVaSTpalXuyK-dzSyN6X9_o4H9wPFAHpPeli2tHTUCNz6QPpONQfxkkPwIC1zdStn1.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/cHoAAOSwsRRgIcfp/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTYwMFgxMjAw/z/cHoAAOSwsRRgIcfp/$_12.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9jSG9BQU9Td3NSUmdJY2ZwL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzI3NDgwNjg2MTkxNz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=468501593-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-274806861917-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 41,
    productCode: "ebay-us-274806861917-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_194391097035",
    title: "Super 64 Retro Video Game 340 In 1 Cartridge - N64 Consoles ED64 Plus 16GB Card",
    truncatedTitle: "Super 64 Retro Video Game 340 In 1 Cartridge - N64 Consoles ED64 Plus...",
    publicItemId: "194391097035",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-25T17:28:54.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 64.95,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVUJEq12Dq99nOs9Km2oNr-_lTvQ_SWMgxKAwz7ebqBmUFmXSrADmrtNTUZZGmSrzl.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/JwwAAOSwBPhhT1Ay/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTYwMFgxMjAw/z/JwwAAOSwBPhhT1Ay/$_12.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9Kd3dBQU9Td0JQaGhUMUF5L3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzE5NDM5MTA5NzAzNT9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=661573027-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-194391097035-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 42,
    productCode: "ebay-us-194391097035-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_283884785065",
    title: "Minecraft - Nintendo Switch Includes Super Mario Mash-Up",
    truncatedTitle: "Minecraft - Nintendo Switch Includes Super Mario Mash-Up",
    publicItemId: "283884785065",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-20T16:06:22.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 31.95,
    oldPrice: 59.99,
    discount: 46,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qV4A7gf9GFBnNaLBkmwQyZexRA-fsR3Wb2vR3hRdYDqpo48G9m5JSAhNS7K94jHPW4.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/HBAAAOSwhjxhcI24/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9IQkFBQU9Td2hqeGhjSTI0L3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzI4Mzg4NDc4NTA2NT9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=557777212-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-283884785065-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 43,
    productCode: "ebay-us-283884785065-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_363203340563",
    title: "XBOX 360 Games - Xbox 360 Lot! Great Selection!! Low Prices & Shipping!!! ",
    truncatedTitle: "XBOX 360 Games - Xbox 360 Lot! Great Selection!! Low Prices & Shipping!!! ",
    publicItemId: "363203340563",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-01T16:37:55.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 34,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 3.5,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVqMz2AcjX81DmjUgMoOO-QHFDJb6JxBbaNwjz7533905Fqe7x2t74jrfOmdXE0Ots.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/gd4AAOSwFwlgX4BL/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9nZDRBQU9Td0Z3bGdYNEJML3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzM2MzIwMzM0MDU2Mz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=068227146-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-363203340563-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 44,
    productCode: "ebay-us-363203340563-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_203658230553",
    title: "Nintendo GameCube Black Label Games You Pick & Choose Video Game Lot - B",
    truncatedTitle: "Nintendo GameCube Black Label Games You Pick & Choose Video Game Lot - B",
    publicItemId: "203658230553",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-19T23:08:02.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 3.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 4.75,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVAVI4aXsE0dOQjlVw6e8Ta5FTAS7FG1-EEvi-aHSru_6Z1UGV5e89_qo-K7UpkoDk.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/OMkAAOSw~p1hb0EU/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTQ0M1gxNjAw/z/OMkAAOSw~p1hb0EU/$_12.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9PTWtBQU9Td35wMWhiMEVVL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzIwMzY1ODIzMDU1Mz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=843024559-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-203658230553-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 45,
    productCode: "ebay-us-203658230553-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_185140934923",
    title: "Mario Kart 64 Video Game Cartridge Console For Nintendo N64 Mario party 1 2 3",
    truncatedTitle: "Mario Kart 64 Video Game Cartridge Console For Nintendo N64 Mario party...",
    publicItemId: "185140934923",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-02T10:13:57.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 23.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVODhDyoqAZCbp-Yqwj4MEPkdSsYjspiptB4oMFaFjV31e6H966FcUp-Wc4CesT9Kk.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/HzwAAOSw2XRhgQ-C/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTAwMFgxMDAw/z/HzwAAOSw2XRhgQ-C/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9IendBQU9TdzJYUmhnUS1DL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzE4NTE0MDkzNDkyMz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=394123732-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-185140934923-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 46,
    productCode: "ebay-us-185140934923-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_373656621871",
    title: "Wii Play Wii Game",
    truncatedTitle: "Wii Play Wii Game",
    publicItemId: "373656621871",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-21T21:20:37.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 4.47,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 2.95,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVKPqd3lbyXzGzaRUJpRV3tuzuSNThFPlJhI1twiRJutXdg8SnOQnprAHunc2Q4Awb.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/0NAAAOSwqvVg-Iv~/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/ODk4WDY0MA==/z/0NAAAOSwqvVg-Iv~/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy8wTkFBQU9Td3F2VmctSXZ+L3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzM3MzY1NjYyMTg3MT9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=158928547-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-373656621871-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 47,
    productCode: "ebay-us-373656621871-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_403286467967",
    title: "Treasure Island for Animal Crossing New Horizon V 2.0 (1Hrs Unlimited Trips) \uFFFC",
    truncatedTitle: "Treasure Island for Animal Crossing New Horizon V 2.0 (1Hrs Unlimited...",
    publicItemId: "403286467967",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-09T18:26:43.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 30,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVKGOplqOnnA-XHUMW48XIc70P6uTL02jCDtsDkv8-Vqc5n9THbgvTP2oG_Z3OuxSG.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/lmkAAOSwPzthigOe/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTI4MFgxMjgw/z/lmkAAOSwPzthigOe/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9sbWtBQU9Td1B6dGhpZ09lL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzQwMzI4NjQ2Nzk2Nz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=614198923-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-403286467967-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 48,
    productCode: "ebay-us-403286467967-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_373497929502",
    title: "NINTENDO WII DISNEY SING IT GAME MICROPHONE BUY2 GET1 50% OFF BUILD YOUR BUNDLE ",
    truncatedTitle: "NINTENDO WII DISNEY SING IT GAME MICROPHONE BUY2 GET1 50% OFF BUILD YOUR...",
    publicItemId: "373497929502",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-14T16:45:45.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 3.98,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVOaXVQkB4T8VaYGWt-g0vkNGm0rpDRXocojSGRg6FYM4UxiEWBLRVW4kcwKfiLp43.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/WEMAAOSwaRFgTUw6/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTAyNVgxMDcz/z/WEMAAOSwaRFgTUw6/$_12.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9XRU1BQU9Td2FSRmdUVXc2L3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzM3MzQ5NzkyOTUwMj9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=831188278-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-373497929502-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 49,
    productCode: "ebay-us-373497929502-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_255220857763",
    title: "Pokemon Shining Pearl - Nintendo Switch",
    truncatedTitle: "Pokemon Shining Pearl - Nintendo Switch",
    publicItemId: "255220857763",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-10T06:11:06.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 59.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVHb5Ca9ppER67TA67Tr9lL83hvSc321JHHb04wA2r7ESm-IB3SxIdPMIY4sxfb45l.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/W~sAAOSwQvdhi2HU/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTYwMFg3NDA=/z/W~sAAOSwQvdhi2HU/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9XfnNBQU9Td1F2ZGhpMkhVL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzI1NTIyMDg1Nzc2Mz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=300983841-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-255220857763-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 50,
    productCode: "ebay-us-255220857763-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_234275739364",
    title: "Lots of Xbox 360 games!!",
    truncatedTitle: "Lots of Xbox 360 games!!",
    publicItemId: "234275739364",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-07T22:02:14.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 6.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 1,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVNMLJwC_jWfHJqk4NlrjemhmRpOlr0aYdfgfJyZIm5YSM6bOSeyPxZ-wxunkrvvkm.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/4bcAAOSwlLdhiDmh/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy80YmNBQU9Td2xMZGhpRG1oL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzIzNDI3NTczOTM2ND9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=660911291-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-234275739364-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 51,
    productCode: "ebay-us-234275739364-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_264357193616",
    title: "God of War PS4 [Factory Refurbished]",
    truncatedTitle: "God of War PS4 [Factory Refurbished]",
    publicItemId: "264357193616",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-10T18:51:06.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 11.51,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVpbAUa9puxGfyagBWy0xUQ5QozttC15nfxhywsoYzcqfgkhzo9ziJuh9bYsI8KrKL.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/5G0AAOSwM5Rc~qaf/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTUwMFgxNTAw/z/5G0AAOSwM5Rc~qaf/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy81RzBBQU9Td001UmN+cWFmL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzI2NDM1NzE5MzYxNj9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=368606623-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-264357193616-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 52,
    productCode: "ebay-us-264357193616-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_194189865184",
    title: "Metal Gear Solid HD Collection - PS3 - Brand New | Factory Sealed",
    truncatedTitle: "Metal Gear Solid HD Collection - PS3 - Brand New | Factory Sealed",
    publicItemId: "194189865184",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-06T20:02:38.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 24.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qV8ZADqjwF5dGqykZPAusCQE0ij31FSxyjKlnHVgBlRbeuHSdMocODXveL86UVuryJ.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/arYAAOSw1iZgwRIC/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTYwMFgxMjgw/z/arYAAOSw1iZgwRIC/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9hcllBQU9TdzFpWmd3UklDL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzE5NDE4OTg2NTE4ND9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=014615487-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-194189865184-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 53,
    productCode: "ebay-us-194189865184-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B07ZLRGJ94",
    title: "1Video Games: The Movie V",
    truncatedTitle: "1Video Games: The Movie",
    publicItemId: "B07ZLRGJ94",
    source: "amazon",
    categoryId: "2649512011",
    merchantId: null,
    total_new: 1,
    total_used: 0,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: null,
    condition: "new",
    price: 3.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTDEWDhwK_-U64YhfH4F6kO4pgpoWdv3WSypzeN4vtwPU.jpg",
    image: "https://m.media-amazon.com/images/I/61C5IggSY6L._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNjFDNUlnZ1NZNkwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.png",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDdaTFJHSjk0P1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=379172815-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B07ZLRGJ94-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=TW92aWVzICYgVFYgfCBNb3ZpZXM=&rf_from_api=true",
    position: 54,
    productCode: "amazon-us-B07ZLRGJ94-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B07ZLRGJ94",
    title: "2Video Games: The Movie V",
    truncatedTitle: "2Video Games: The Movie",
    publicItemId: "B07ZLRGJ94",
    source: "amazon",
    categoryId: "2649512011",
    merchantId: null,
    total_new: 1,
    total_used: 0,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: null,
    condition: "new",
    price: 3.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTDEWDhwK_-U64YhfH4F6kO4pgpoWdv3WSypzeN4vtwPU.jpg",
    image: "https://m.media-amazon.com/images/I/61C5IggSY6L._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNjFDNUlnZ1NZNkwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.png",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDdaTFJHSjk0P1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=379172815-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B07ZLRGJ94-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=TW92aWVzICYgVFYgfCBNb3ZpZXM=&rf_from_api=true",
    position: 55,
    productCode: "amazon-us-B07ZLRGJ94-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B07ZLRGJ94",
    title: "3Video Games: The Movie V",
    truncatedTitle: "3Video Games: The Movie",
    publicItemId: "B07ZLRGJ94",
    source: "amazon",
    categoryId: "2649512011",
    merchantId: null,
    total_new: 1,
    total_used: 0,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: null,
    condition: "new",
    price: 3.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTDEWDhwK_-U64YhfH4F6kO4pgpoWdv3WSypzeN4vtwPU.jpg",
    image: "https://m.media-amazon.com/images/I/61C5IggSY6L._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNjFDNUlnZ1NZNkwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.png",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDdaTFJHSjk0P1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=379172815-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B07ZLRGJ94-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=TW92aWVzICYgVFYgfCBNb3ZpZXM=&rf_from_api=true",
    position: 56,
    productCode: "amazon-us-B07ZLRGJ94-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B07ZLRGJ94",
    title: "4Video Games: The Movie V",
    truncatedTitle: "4Video Games: The Movie",
    publicItemId: "B07ZLRGJ94",
    source: "amazon",
    categoryId: "2649512011",
    merchantId: null,
    total_new: 1,
    total_used: 0,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: null,
    condition: "new",
    price: 3.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTDEWDhwK_-U64YhfH4F6kO4pgpoWdv3WSypzeN4vtwPU.jpg",
    image: "https://m.media-amazon.com/images/I/61C5IggSY6L._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNjFDNUlnZ1NZNkwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.png",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDdaTFJHSjk0P1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=379172815-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B07ZLRGJ94-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=TW92aWVzICYgVFYgfCBNb3ZpZXM=&rf_from_api=true",
    position: 57,
    productCode: "amazon-us-B07ZLRGJ94-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B07ZLRGJ94",
    title: "5Video Games: The Movie V",
    truncatedTitle: "5Video Games: The Movie",
    publicItemId: "B07ZLRGJ94",
    source: "amazon",
    categoryId: "2649512011",
    merchantId: null,
    total_new: 1,
    total_used: 0,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: null,
    condition: "new",
    price: 3.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTDEWDhwK_-U64YhfH4F6kO4pgpoWdv3WSypzeN4vtwPU.jpg",
    image: "https://m.media-amazon.com/images/I/61C5IggSY6L._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNjFDNUlnZ1NZNkwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.png",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDdaTFJHSjk0P1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=379172815-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B07ZLRGJ94-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=TW92aWVzICYgVFYgfCBNb3ZpZXM=&rf_from_api=true",
    position: 58,
    productCode: "amazon-us-B07ZLRGJ94-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B07ZLRGJ94",
    title: "6Video Games: The Movie V",
    truncatedTitle: "6Video Games: The Movie",
    publicItemId: "B07ZLRGJ94",
    source: "amazon",
    categoryId: "2649512011",
    merchantId: null,
    total_new: 1,
    total_used: 0,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: null,
    condition: "new",
    price: 3.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTDEWDhwK_-U64YhfH4F6kO4pgpoWdv3WSypzeN4vtwPU.jpg",
    image: "https://m.media-amazon.com/images/I/61C5IggSY6L._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNjFDNUlnZ1NZNkwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.png",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDdaTFJHSjk0P1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=379172815-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B07ZLRGJ94-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=TW92aWVzICYgVFYgfCBNb3ZpZXM=&rf_from_api=true",
    position: 59,
    productCode: "amazon-us-B07ZLRGJ94-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B07ZLRGJ94",
    title: "7Video Games: The Movie V",
    truncatedTitle: "7Video Games: The Movie",
    publicItemId: "B07ZLRGJ94",
    source: "amazon",
    categoryId: "2649512011",
    merchantId: null,
    total_new: 1,
    total_used: 0,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: null,
    condition: "new",
    price: 3.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTDEWDhwK_-U64YhfH4F6kO4pgpoWdv3WSypzeN4vtwPU.jpg",
    image: "https://m.media-amazon.com/images/I/61C5IggSY6L._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNjFDNUlnZ1NZNkwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.png",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDdaTFJHSjk0P1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=379172815-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B07ZLRGJ94-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=TW92aWVzICYgVFYgfCBNb3ZpZXM=&rf_from_api=true",
    position: 60,
    productCode: "amazon-us-B07ZLRGJ94-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B07ZLRGJ94",
    title: "8Video Games: The Movie V",
    truncatedTitle: "8Video Games: The Movie",
    publicItemId: "B07ZLRGJ94",
    source: "amazon",
    categoryId: "2649512011",
    merchantId: null,
    total_new: 1,
    total_used: 0,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: null,
    condition: "new",
    price: 3.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTDEWDhwK_-U64YhfH4F6kO4pgpoWdv3WSypzeN4vtwPU.jpg",
    image: "https://m.media-amazon.com/images/I/61C5IggSY6L._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNjFDNUlnZ1NZNkwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.png",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDdaTFJHSjk0P1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=379172815-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B07ZLRGJ94-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=TW92aWVzICYgVFYgfCBNb3ZpZXM=&rf_from_api=true",
    position: 61,
    productCode: "amazon-us-B07ZLRGJ94-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }],
  metadata: {
    id: 512103979,
    query: "video games",
    queryInfoTop: "Deals are available from 4 stores  and 3 brands. An additional discount is available for 4 items. Last updated on November 11, 2021.",
    queryInfoBottom: ["54 deals were found for Video Games. Deals are available from 4 stores  and 3 brands. An additional discount is available for 4 items. Last updated on November 11, 2021.", "Scanning all available deals for Video Games shows that the average price across all deals is $41.98. The lowest price is $0.00 from amazon while the highest price is $395.00 from amazon.", "The average discount we found across all deals is 31.79%, the largest discount is 46.74% for the product Minecraft - Nintendo Switch Includes Super Mario Mash-Up from ebay.", "New products prices vary between $0.00 and $395.00.", "Free shipping is offered across 3 stores - amazon, ebay, Focus Camera.", null],
    related: ["video games ps4", "video games nintendo switch", "video games for kids 8-12", "video games for kids ages 4-8", "video games xbox one"],
    locale: "us",
    description: null,
    for_adult: null,
    adult_ratio: 0,
    pageSize: 60,
    breadcrumbs: [{
      title: "Video Games",
      path: "video-games"
    }, {
      title: "Nintendo Switch",
      path: "nintendo-switch"
    }],
    noindex: !1,
    amazon_search_url: "https://www.amazon.com/s?SubscriptionId=AKIAJA54JMESX73IGPXQ&ascsubtag=000000000&k=video+games&tag=d_2b_a_d-20",
    ebay_search_url: "https://www.ebay.com/sch/i.html?_nkw=video+games&ff3=2&toolid=10041&pub=5575086808&campid=00000&customid=000000000"
  }
};

// node_modules/@roundforest/bdt-client/lib/fixtures/page-type.db.js
var electronicsMock = {
  page_type: "l1",
  popular_categories: [{
    title: "Office Products",
    img: "https://www.bestdeals.today/assets/l1_categories/office-products-49ee17832aeb456a7deacdf0b1dc7400fdddb13b220638a0d5029dd19da97d33.png",
    url: "/office-products"
  }, {
    title: "Toys & Games",
    img: "https://www.bestdeals.today/assets/l1_categories/toys-games-eba67209d7f4fa3f0250afc2a52f09af671e9594eafdca4d47afc83a97a50e4b.png",
    url: "/toys-games"
  }, {
    title: "Beauty & Personal Care",
    img: "https://www.bestdeals.today/assets/l1_categories/beauty-personal-care-6122ac70e7dd12d6d9ce824d461ba8c38b5ff84c9b9ac879793e78e57206d132.png",
    url: "/beauty-personal-care"
  }, {
    title: "Home & Kitchen",
    img: "https://www.bestdeals.today/assets/l1_categories/home-kitchen-7c22d712e0dcaabcc532ac749c18937b72c59d3347866d5ef20f73b1f97171e1.png",
    url: "/home-kitchen"
  }, {
    title: "Apps & Games",
    img: "https://www.bestdeals.today/assets/l1_categories/apps-games-b07b41ae0fffff73cd57ade76d1c5f765283f598f740c69efaa516d975440e2b.png",
    url: "/apps-games"
  }, {
    title: "Appliances",
    img: "https://www.bestdeals.today/assets/l1_categories/appliances-8b61eb1387dd18137c55ea76e00ed90e1889383534f24734f19f2accad2173a5.png",
    url: "/appliances"
  }],
  subcategories: [{
    title: "Computers & Accessories",
    img: "https://i.ebayimg.com/thumbs/imgs/g/nz0AAOSwne5fCMxH/s-l225.jpg",
    url: "/computers-accessories"
  }, {
    title: "Electronics Features",
    img: "https://i.ebayimg.com/thumbs/imgs/g/UgYAAOSwrptfzcW0/s-l225.jpg",
    url: "/electronics-features"
  }, {
    title: "Portable Audio & Video",
    img: "https://i.ebayimg.com/thumbs/imgs/g/yFcAAOSwreVh2LWv/s-l225.jpg",
    url: "/portable-audio-video"
  }, {
    title: "Headphones",
    img: "https://i.ebayimg.com/thumbs/imgs/g/xvoAAOSwK41gsUDW/s-l225.jpg",
    url: "/headphones"
  }, {
    title: "Home Audio",
    img: "https://i.ebayimg.com/thumbs/imgs/g/cYEAAOSwntNh1U9w/s-l225.jpg",
    url: "/home-audio"
  }, {
    title: "GPS, Finders & Accessories",
    img: "https://i.ebayimg.com/thumbs/imgs/g/-BwAAOSw-ldh08kt/s-l225.jpg",
    url: "/gps-finders-accessories"
  }, {
    title: "Camera & Photo",
    img: "https://i.ebayimg.com/thumbs/imgs/g/ymkAAOSwbk9geiAC/s-l225.jpg",
    url: "/camera-photo"
  }, {
    title: "Television & Video",
    img: "https://i.ebayimg.com/thumbs/imgs/g/hMQAAOSwelthZ2Bz/s-l225.jpg",
    url: "/television-video"
  }, {
    title: "Computers Features",
    img: "https://i.ebayimg.com/thumbs/imgs/g/56gAAOSw9yZhcl8O/s-l225.jpg",
    url: "/computers-features"
  }, {
    title: "Accessories & Supplies",
    img: "https://i.ebayimg.com/thumbs/imgs/g/g~gAAOSwh0Ve97Lf/s-l225.jpg",
    url: "/accessories-supplies"
  }, {
    title: "Camera & Photo Features",
    img: "https://i.ebayimg.com/thumbs/imgs/g/W80AAOSwDtRh00Ae/s-l225.jpg",
    url: "/camera-photo-features"
  }, {
    title: "Wearable Technology",
    img: "https://i.ebayimg.com/thumbs/imgs/g/7D8AAOSwcDZheJTg/s-l225.jpg",
    url: "/wearable-technology"
  }, {
    title: "Car & Vehicle Electronics",
    img: "https://i.ebayimg.com/thumbs/imgs/g/EnoAAOSw3Gthyc8y/s-l225.jpg",
    url: "/car-vehicle-electronics"
  }, {
    title: "eBook Readers & Accessories",
    img: "https://i.ebayimg.com/thumbs/imgs/g/KLcAAOSwdFlhcaJh/s-l225.jpg",
    url: "/ebook-readers-accessories"
  }, {
    title: "Electronics Warranties",
    img: "https://i.ebayimg.com/thumbs/imgs/g/IYEAAOSwt4xaWQTm/s-l225.jpg",
    url: "/electronics-warranties"
  }, {
    title: "Security & Surveillance",
    img: "https://i.ebayimg.com/thumbs/imgs/g/-ZMAAOSwTLNhCYjA/s-l225.jpg",
    url: "/security-surveillance"
  }, {
    title: "Video Projectors",
    img: "https://i.ebayimg.com/thumbs/imgs/g/AssAAOSwnmtgb3xs/s-l225.jpg",
    url: "/video-projectors"
  }, {
    title: "Video Game Consoles & Accessories",
    img: "https://i.ebayimg.com/thumbs/imgs/g/25sAAOSwm2peCkI6/s-l225.jpg",
    url: "/video-game-consoles-accessories"
  }],
  banner: "https://www.bestdeals.today/assets/l1_categories/banners/electronics-6a478f245650d6dcac6874389c84b21c4d3144d0c5c3460b27cbb79a4675ee17.png"
};
function getPageTypeDataMock(searchTerm) {
  switch (searchTerm) {
    case "electronics":
      return electronicsMock;
    case "computers accessories":
      return {
        page_type: "l2",
        popular_categories: [{
          title: "Office Products",
          img: "https://www.bestdeals.today/assets/l1_categories/office-products-49ee17832aeb456a7deacdf0b1dc7400fdddb13b220638a0d5029dd19da97d33.png",
          url: "/office-products"
        }, {
          title: "Toys & Games",
          img: "https://www.bestdeals.today/assets/l1_categories/toys-games-eba67209d7f4fa3f0250afc2a52f09af671e9594eafdca4d47afc83a97a50e4b.png",
          url: "/toys-games"
        }, {
          title: "Beauty & Personal Care",
          img: "https://www.bestdeals.today/assets/l1_categories/beauty-personal-care-6122ac70e7dd12d6d9ce824d461ba8c38b5ff84c9b9ac879793e78e57206d132.png",
          url: "/beauty-personal-care"
        }, {
          title: "Home & Kitchen",
          img: "https://www.bestdeals.today/assets/l1_categories/home-kitchen-7c22d712e0dcaabcc532ac749c18937b72c59d3347866d5ef20f73b1f97171e1.png",
          url: "/home-kitchen"
        }, {
          title: "Apps & Games",
          img: "https://www.bestdeals.today/assets/l1_categories/apps-games-b07b41ae0fffff73cd57ade76d1c5f765283f598f740c69efaa516d975440e2b.png",
          url: "/apps-games"
        }, {
          title: "Appliances",
          img: "https://www.bestdeals.today/assets/l1_categories/appliances-8b61eb1387dd18137c55ea76e00ed90e1889383534f24734f19f2accad2173a5.png",
          url: "/appliances"
        }],
        subcategories: [{
          title: "Electronics Features",
          img: "https://i.ebayimg.com/thumbs/imgs/g/UgYAAOSwrptfzcW0/s-l225.jpg",
          url: "/electronics-features"
        }, {
          title: "Portable Audio & Video",
          img: "https://i.ebayimg.com/thumbs/imgs/g/yFcAAOSwreVh2LWv/s-l225.jpg",
          url: "/portable-audio-video"
        }, {
          title: "Headphones",
          img: "https://i.ebayimg.com/thumbs/imgs/g/xvoAAOSwK41gsUDW/s-l225.jpg",
          url: "/headphones"
        }, {
          title: "Home Audio",
          img: "https://i.ebayimg.com/thumbs/imgs/g/cYEAAOSwntNh1U9w/s-l225.jpg",
          url: "/home-audio"
        }],
        banner: "https://www.bestdeals.today/assets/l1_categories/banners/electronics-6a478f245650d6dcac6874389c84b21c4d3144d0c5c3460b27cbb79a4675ee17.png"
      };
    case "video games":
      return {
        page_type: "store",
        popular_categories: null,
        subcategories: null,
        banner: null
      };
    default:
      return electronicsMock;
  }
}

// node_modules/@roundforest/bdt-client/lib/fixtures/manual-deals.db.js
function getManualDealsMock(_positions) {
  return {
    "Top Deals": {
      items: [{
        id: 1275,
        shop_image: "https://static.bestdeals.today/bdt-prod/shops/amazon-logo.svg",
        shop_name: "amazon",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtSW5zdGFudCBQb3QgVm9ydGV4IFBsdXMtLTEwLVF1YXJ0IEFpciBGcnllciwgUm90aXNzZXJpZSBhbmQgQ29udmVjdGlvbiBPdmVuLUluc3RhbnQgVm9ydGV4IFBsdXMtaW1hZ2UtMjAyMi0wMS0xMCAxMDoxOToxNCBVVEM=.jpg",
        badge_type: "Price Drop",
        title: "Instant Pot Vortex Plus Convection Oven",
        description: "A 10-quart air fryer, rotisserie, and convection oven, capable of frying, broiling, baking, roasting, dehydrating foods, and more!",
        price: 99.95,
        end_time: "2022-01-18T14:00:00.000Z",
        old_price: 139.99,
        discount: 28,
        url: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9JbnN0YW50LVZvcnRleC1QbHVzLVJvdGlzc2VyaWUtMTAvZHAvQjA3Vk0yOFhUUj9TdWJzY3JpcHRpb25JZD1BS0lBSU5JSTNYQkI0WVdOUzVMUSZhc2NzdWJ0YWc9MDAwMDAwMDAwJnRhZz1iZHRfbmV3aG9tZXBhZ2UtMjA=&click_id=067011097-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=1275&rf_source=amazon&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=amazon&rf_manual_deal=true",
        simple_source: "amazon",
        short_title: "Instant Pot Vortex Plus Convection Oven"
      }, {
        id: 1276,
        shop_image: "https://static.bestdeals.today/bdt-prod/shops/V2FsbWFydC11cw==.gif",
        shop_name: "Walmart",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtQ2hpbW5leUZyZWUgUG93ZXJoZWF0IEluZnJhcmVkIFF1YXJ0eiBFbGVjdHJpYyBTdG92ZSBIZWF0ZXItQ2hpbW5leUhlYXQgaGVhdGVyLWltYWdlLTIwMjItMDEtMTAgMTE6NDI6MzYgVVRD.jpeg",
        badge_type: "Best Value",
        title: "ChimneyFree Powerheat Infrared Quartz Electric Stove Heater",
        description: "Warms up to 1000 sq. ft., while providing an aesthetically-pleasing fireplace-look. Eco-friendly, maintaining the room's natural humidity!",
        price: 69,
        end_time: "2022-01-18T11:24:00.000Z",
        old_price: 82,
        discount: 15,
        url: "/redirect?url=aHR0cHM6Ly9nb3RvLndhbG1hcnQuY29tL2MvMzUzNDgzLzU2NjcxOS85MzgzP3N1YklkMT1bMV0mc3ViSWQyPVsyXSZzdWJJZDM9WzNdJnNoYXJlZGlkPVs0XSZ2ZWg9YWZmJnNvdXJjZWlkPWltcF8wMDAwMTExMTIyMjIzMzMzNDQmdT1odHRwcyUzQSUyRiUyRnd3dy53YWxtYXJ0LmNvbSUyRmlwJTJGQ2hpbW5leUZyZWUtUG93ZXJoZWF0LUluZnJhcmVkLVF1YXJ0ei1FbGVjdHJpYy1TdG92ZS1IZWF0ZXIlMkY4MDc4MjUyNTU=&click_id=032503448-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=1276&rf_source=walmart.com_deeplink&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=Walmart&rf_manual_deal=true",
        simple_source: "walmart.com",
        short_title: "ChimneyFree Powerheat Infrared Quartz..."
      }, {
        id: 1277,
        shop_image: "https://static.bestdeals.today/bdt-prod/shops/V2FsbWFydC11cw==.gif",
        shop_name: "Walmart",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtVENMIDU1IiA0SyBVSEQgUm9rdSBTbWFydCBUVi1UQ0wgNTUiIFRWLWltYWdlLTIwMjItMDEtMTAgMTI6Mzk6NTQgVVRD.jpeg",
        badge_type: "On Fire",
        title: 'TCL 55" 4K UHD Roku Smart TV',
        description: "Provides high-dynamic-range technology to enjoy thousands of channels of TV shows, movies, sporting events with breathtaking resolution! Can be coupled with a cable box, Blu-ray player, gaming console, and more!",
        price: 319,
        end_time: "2022-01-18T12:02:00.000Z",
        old_price: 599.99,
        discount: 46,
        url: "/redirect?url=aHR0cHM6Ly9nb3RvLndhbG1hcnQuY29tL2MvMzUzNDgzLzU2NjcxOS85MzgzP3N1YklkMT1bMV0mc3ViSWQyPVsyXSZzdWJJZDM9WzNdJnNoYXJlZGlkPVs0XSZ2ZWg9YWZmJnNvdXJjZWlkPWltcF8wMDAwMTExMTIyMjIzMzMzNDQmdT1odHRwcyUzQSUyRiUyRnd3dy53YWxtYXJ0LmNvbSUyRmlwJTJGVENMLTU1LUNsYXNzLTQtU2VyaWVzLTRLLVVIRC1IRFItUm9rdS1TbWFydC1UVi01NVM0MzElMkYyNzY5NjQ5MDM=&click_id=138329241-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=1277&rf_source=walmart.com_deeplink&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=Walmart&rf_manual_deal=true",
        simple_source: "walmart.com",
        short_title: 'TCL 55" 4K UHD Roku Smart TV'
      }, {
        id: 1278,
        shop_image: "https://static.bestdeals.today/bdt-prod/shops/amazon-logo.svg",
        shop_name: "amazon",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtTm9yZGljVHJhY2sgVCBTZXJpZXMgVHJlYWRtaWxscy1Ob3JkaWMgVHJhY2sgVCBTZXJpZXMtaW1hZ2UtMjAyMi0wMS0xMCAxMzo1NDo0NyBVVEM=.jpg",
        badge_type: "Price Drop",
        title: "NordicTrack T Series Treadmills",
        description: "Allows for speed, interval, and endurance training. Folds up easily and compactly after use! Comes with a 30-day iFit membership to training sessions!",
        price: 549,
        end_time: "2022-01-18T13:43:00.000Z",
        old_price: 649,
        discount: 15,
        url: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDE5M1YzREo2L3JlZj12YV9saXZlX2Nhcm91c2VsP1N1YnNjcmlwdGlvbklkPUFLSUFJTklJM1hCQjRZV05TNUxRJmFzY3N1YnRhZz0wMDAwMDAwMDAmdGFnPWJkdF9uZXdob21lcGFnZS0yMA==&click_id=010207160-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=1278&rf_source=amazon&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=amazon&rf_manual_deal=true",
        simple_source: "amazon",
        short_title: "NordicTrack T Series Treadmills"
      }, {
        id: 1279,
        shop_image: "https://static.bestdeals.today/bdt-prod/shops/V2F5ZmFpci11cw==.gif",
        shop_name: "Wayfair",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtRGF6aWVsIE1pY3JvZmliZXIgQ29tZm9ydGVyIFNldC1EYXppZWwrTWljcm9maWJlcitQb2x5ZXN0ZXIrTW9kZXJuKyYrQ29udGVtcG9yYXJ5K0NvbWZvcnRlcitTZXQtaW1hZ2UtMjAyMi0wMS0xMCAxNDo0NjoxMCBVVEM=.jpg",
        badge_type: "On Fire",
        title: "Daziel Microfiber Comforter Set",
        description: "This set includes a comforter and two pillow shams. Available in twin, Queen, and King sizes, and 4 soft-toned colors!",
        price: 55.83,
        end_time: "2022-01-18T14:12:00.000Z",
        old_price: 109.99,
        discount: 49,
        url: "/redirect?url=aHR0cHM6Ly93d3cud2F5ZmFpci5jb20vYmVkLWJhdGgvcGRwL2dlb3JnZS1vbGl2ZXItZGF6aWVsLWNvbWZvcnRlci1zZXQtdzAwNTQ4MzYyMC5odG1sJmN1c3RvbWlkPTAwMDAwMDAwMA==&click_id=718787213-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=1279&rf_source=bizrate.com_deeplink&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=Wayfair&rf_manual_deal=true",
        simple_source: "bizrate.com",
        short_title: "Daziel Microfiber Comforter Set"
      }, {
        id: 1238,
        shop_image: "https://static.bestdeals.today/bdt-prod/shops/amazon-logo.svg",
        shop_name: "amazon",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtQ29yZWR5IFJvYm90IFZhY3V1bSBDbGVhbmVyLTcxT2hWQWlwZzFMLWltYWdlLTIwMjAtMDUtMTAgMTM6MDA6NDkgVVRD._AC_SL1200_",
        badge_type: "Best Value",
        title: "Coredy Robot Vacuum Cleaner",
        description: "3-in-1 Sweep Vacuum Mop Robotic Vacuum Cleaner: R500+ is a 7.2cm super thin robot vacuum cleaner, eliminate dirt from under beds, sofa and hard to reach areas with zero effort. Include 3-point cleaning system and dual edge-brushes, works on hard floors and carpets to clean the dust and pet hair.",
        price: 136,
        end_time: "2025-07-31T12:53:00.000Z",
        old_price: 189.99,
        discount: 28,
        url: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9Db3JlZHktUm9ib3QtVmFjdXVtLUNsZWFuZXItQWxsLU5ldy9kcC9CMDdMMllCOE5XL3JlZj1nYnBzX2ltZ19tLTlfNDc1ZV81NmNkODliMD9TdWJzY3JpcHRpb25JZD1BS0lBSU5JSTNYQkI0WVdOUzVMUSZhc2NzdWJ0YWc9MDAwMDAwMDAwJnBmX3JkX2k9MTU1Mjk2MDkwMTEmcGZfcmRfbT1BVFZQREtJS1gwREVSJnBmX3JkX3A9NWQ4NmRlZjItZWMxMC00MzY0LTkwMDgtOGZiY2NmMzA0NzVlJnBmX3JkX3I9Sk1DTkRSRTRRQVQ2NzRWOEhCQzkmcGZfcmRfcz1tZXJjaGFuZGlzZWQtc2VhcmNoLTkmcGZfcmRfdD0xMDEmc21pZD1BMTVXNVdQOFU3MDRPNCZzcExhPVpXNWpjbmx3ZEdWa1VYVmhiR2xtYVdWeVBVRXlPRUpQUmpSTk0xVkpTazBtWlc1amNubHdkR1ZrU1dROVFUQTNNREE1T1RNeVV6azRVRk5GUkZVeFMwSkxKbVZ1WTNKNWNIUmxaRUZrU1dROVFUQTVPRFV3TWpNeU5WbzRXRWxaUmxGUVZFNVdKbmRwWkdkbGRFNWhiV1U5YzNCZloySmZiV0ZwYmw5emRYQndiR1VtWVdOMGFXOXVQV05zYVdOclVtVmthWEpsWTNRbVpHOU9iM1JNYjJkRGJHbGphejEwY25WbCZ0YWc9YmR0X25ld2hvbWVwYWdlLTIw&click_id=203650719-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=1238&rf_source=amazon&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=amazon&rf_manual_deal=true",
        simple_source: "amazon",
        short_title: "Coredy Robot Vacuum Cleaner"
      }, {
        id: 1227,
        shop_image: "https://static.bestdeals.today/bdt-prod/shops/V2FsbWFydC11cw==.gif",
        shop_name: "Walmart",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtTGF1cmEgR2VsbGVyIEdpbGRlZCBIb25leSBNYWtldXAgU2V0LUxhdXJhIEdlbGxlciBtYWtldXBfbW9kaWZpZWQtaW1hZ2UtMjAyMC0wNC0yNCAwNzo1MDo0MyBVVEM=.jpg",
        badge_type: "Price Drop",
        title: "Laura Geller Gilded Honey Makeup Set",
        description: "Includes highlighter, lip gloss, and body spray!",
        price: 27.99,
        end_time: "2025-07-31T15:00:00.000Z",
        old_price: 35,
        discount: 20,
        url: "/redirect?url=aHR0cHM6Ly9nb3RvLndhbG1hcnQuY29tL2MvMzUzNDgzLzU2NjcxOS85MzgzP3N1YklkMT1bMV0mc3ViSWQyPVsyXSZzdWJJZDM9WzNdJnNoYXJlZGlkPVs0XSZ2ZWg9YWZmJnNvdXJjZWlkPWltcF8wMDAwMTExMTIyMjIzMzMzNDQmdT1odHRwcyUzQSUyRiUyRnd3dy53YWxtYXJ0LmNvbSUyRmlwJTJGODAtVmFsdWUtTGF1cmEtR2VsbGVyLUdpbGRlZC1Ib25leS1CZXN0LVNlbGxlcnMtTWFrZXVwLUdpZnQtU2V0LUhpZ2hsaWdodGVyLU1ha2V1cC1MaXAtR2xvc3MtQm9keS1TcHJheSUyRjMxNDA4MDgxNg==&click_id=095479972-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=1227&rf_source=walmart.com_deeplink&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=Walmart&rf_manual_deal=true",
        simple_source: "walmart.com",
        short_title: "Laura Geller Gilded Honey Makeup Set"
      }, {
        id: 1242,
        shop_image: "https://static.bestdeals.today/bdt-prod/shops/amazon-logo.svg",
        shop_name: "amazon",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtZ2FyZGVuaW5nIHRvb2xzLWRvd25sb2FkICgxKS1pbWFnZS0yMDIwLTA2LTE4IDA4OjMwOjA0IFVUQw==.jpeg",
        badge_type: "Best Value",
        title: "FANHAO Garden Tool Set, 5 Piece Aluminum Heavy Duty Gardening Tool Set",
        description: "Top Quality No rusting Aluminum. FANHAO Garden tools set contains 5 pieces high quality Gardening tools. Perfect for all your garden needs.",
        price: 32.9,
        end_time: "2025-07-31T08:22:00.000Z",
        old_price: 45,
        discount: 26,
        url: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDgyTkxRQ0hXP1N1YnNjcmlwdGlvbklkPUFLSUFJTklJM1hCQjRZV05TNUxRJmFzY3N1YnRhZz0wMDAwMDAwMDAmdGFnPWJkdF9uZXdob21lcGFnZS0yMA==&click_id=790127937-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=1242&rf_source=amazon&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=amazon&rf_manual_deal=true",
        simple_source: "amazon",
        short_title: "FANHAO Garden Tool Set, 5 Piece Alumi..."
      }, {
        id: 1223,
        shop_image: "https://static.bestdeals.today/bdt-prod/shops/ebay-logo.svg",
        shop_name: "ebay",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtQ2xhc3NpYyBGaWdhcm8gTGluayBCcmFjZWxldC1GaWdhcm8gYnJhY2VsZXRfbW9kaWZpZWQtaW1hZ2UtMjAyMC0wNC0yMyAxNTozMDoyOCBVVEM=.jpg",
        badge_type: "On Fire",
        title: "Classic Figaro Link Bracelet",
        description: 'An 8.5" bronze bracelet, plated with 18K gold!',
        price: 10,
        end_time: "2025-07-31T15:00:00.000Z",
        old_price: 109,
        discount: 90,
        url: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtL0l0YWxpYW4tTWFkZS1DbGFzc2ljLUZpZ2Fyby1MaW5rLUJyYWNlbGV0LWluLTE4Sy1Hb2xkLVBsYXRlZC1Ccm9uemUtOC01LzI2NDU0NjI5Mjk4NT9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9JmNhbXBpZD0wMDAwMCZ0b29saWQ9MTAwNDkmY3VzdG9taWQ9MDAwMDAwMDAw&click_id=087151595-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=1223&rf_source=ebay_deeplink&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=ebay&rf_manual_deal=true",
        simple_source: "ebay",
        short_title: "Classic Figaro Link Bracelet"
      }],
      duration: 11199422681063819e-8
    },
    Offers: {
      items: [{
        id: 1269,
        badge_type: "On Fire",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtU2F2ZSB1cCB0byA1MCUgb24gTWFkZGVuIE5GTCAyMiBDb21wdXRlciBHYW1lcyEtZm9vdGJhbGwtaW1hZ2UtMjAyMS0xMi0yOCAxMzo1MjozMyBVVEM=.jpg",
        additional_image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtU2F2ZSB1cCB0byA1MCUgb24gTWFkZGVuIE5GTCAyMiBDb21wdXRlciBHYW1lcyEtQW1hem9uX2xvZ29fUE5HMy1hZGRpdGlvbmFsX2ltYWdlLTIwMjEtMTItMjggMTM6NTI6MzMgVVRD.png",
        title: "Save up to 50% on Madden NFL 22 Computer Games!",
        shop_name: "amazon",
        end_time: "2022-01-28T12:10:00.000Z",
        url: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9zdG9yZXMvcGFnZS9wcmV2aWV3P1N1YnNjcmlwdGlvbklkPUFLSUFJTklJM1hCQjRZV05TNUxRJmFzY3N1YnRhZz0wMDAwMDAwMDAmYXNpbnM9QjA5Nk5CMUpTOSUyQ0IwOTZOQ1o5RzIlMkNCMDk2TkdMVzc4JTJDQjA5Nk5CMzExSCUyQ0IwOThLVkNGTTglMkNCMDk4S1ZTRjlSJTJDQjA5OEtTMTJOTCUyQ0IwOThLVllXUUQlMkNCMDk4S1ZIWjNQJTJDQjA5RDIzNzg1UCUyQ0IwOUQxV0hRWUYlMkNCMDlEMVozVE5EJTJDQjA5RDIyUTRaSiUyQ0IwOTI1SEg5WVQlMkNCMDkyTkc2ODVNJTJDQjA5MjVIRDdRNSUyQ0IwOE1YVERHTjYlMkNCMDhNWFZOWldQJTJDQjA4UTQzQktIRyUyQ0IwOFEzVjJUWFYlMkNCMDhUNDg4MjU5JTJDQjA4NjlHSzJNSyUyQyZpc1ByZXZpZXc9MSZpc1NscD0xJnJlZj1kbHhfZGVhbHNfZ2RfZGNsX2ltZ184Xzk1MTI1ODIwX2R0X3NsMTVfZDgmdGFnPWJkdF9uZXdob21lcGFnZS0yMA==&click_id=639853195-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=1269&rf_source=amazon&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=amazon&rf_manual_deal=true",
        simple_source: "amazon",
        short_title: "Save up to 50% on Madden NFL 22 Compu..."
      }, {
        id: 72,
        badge_type: "Crowd\u2019s Favorite",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtQW1hem9uIENvdXBvbnMtYW1hem9uLWNvdXBvbi1pbWFnZS0yMDE5LTExLTI2IDE1OjE0OjM5IFVUQw==.jpg",
        additional_image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtQW1hem9uIENvdXBvbnMtQ2FwdHVyZS1hZGRpdGlvbmFsX2ltYWdlLTIwMjAtMDItMTcgMDk6MjY6NTkgVVRD.PNG",
        title: "Save up to 50% off with AMAZON coupons!",
        shop_name: "amazon",
        end_time: "2025-07-31T15:00:00.000Z",
        url: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9jb3Vwb25zP1N1YnNjcmlwdGlvbklkPUFLSUFJTklJM1hCQjRZV05TNUxRJmFzY3N1YnRhZz0wMDAwMDAwMDAmdGFnPWJkdF9uZXdob21lcGFnZS0yMA==&click_id=049885590-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=72&rf_source=amazon&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=amazon&rf_manual_deal=true",
        simple_source: "amazon",
        short_title: "Save up to 50% off with AMAZON coupons!"
      }, {
        id: 990,
        badge_type: "On Fire",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtU2F2ZSBhcyBtdWNoIGFzIDUwJSBvbiBZb2dhIEVxdWlwbWVudCBTZXRzIS1waG90by1vZi13b21hbi1kb2luZy15b2dhLTIyOTQzNTNfbW9kaWZpZWQtaW1hZ2UtMjAyMC0wMy0yNSAxNDozOTo1OSBVVEM=.jpg",
        additional_image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtU2F2ZSBhcyBtdWNoIGFzIDUwJSBvbiBZb2dhIEVxdWlwbWVudCBTZXRzIS13YWxtYXJ0LWFkZGl0aW9uYWxfaW1hZ2UtMjAyMC0wMy0yNSAxNDozOTo1OSBVVEM=.png",
        title: "Save as much as 50% on Yoga Equipment Sets!",
        shop_name: "Walmart",
        end_time: "2025-07-31T15:00:00.000Z",
        url: "/redirect?url=aHR0cHM6Ly9nb3RvLndhbG1hcnQuY29tL2MvMzUzNDgzLzU2NjcxOS85MzgzP3N1YklkMT1bMV0mc3ViSWQyPVsyXSZzdWJJZDM9WzNdJnNoYXJlZGlkPVs0XSZ2ZWg9YWZmJnNvdXJjZWlkPWltcF8wMDAwMTExMTIyMjIzMzMzNDQmdT1odHRwcyUzQSUyRiUyRnd3dy53YWxtYXJ0LmNvbSUyRmJyb3dzZSUyRnNwb3J0cy1vdXRkb29ycyUyRnlvZ2Eta2l0cyUyRjQxMjVfNDEzNF8xMDc4Mzg0XzEwNzgzODg=&click_id=343968322-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=990&rf_source=walmart.com_deeplink&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=Walmart&rf_manual_deal=true",
        simple_source: "walmart.com",
        short_title: "Save as much as 50% on Yoga Equipment..."
      }, {
        id: 814,
        badge_type: "On Fire",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtU2F2ZSBhcyBtdWNoIGFzIDYwJSBvbiBNZW4ncyAmIFdvbWVuJ3MgRnJhZ3JhbmNlcyEtcGVyZnVtZXMtaW1hZ2UtMjAyMC0wMy0wMSAxMDowNjo0MiBVVEM=.jpg",
        additional_image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtU2F2ZSBhcyBtdWNoIGFzIDYwJSBvbiBNZW4ncyAmIFdvbWVuJ3MgRnJhZ3JhbmNlcyEtd2FsbWFydC1hZGRpdGlvbmFsX2ltYWdlLTIwMjAtMDMtMDEgMTA6MDY6NDMgVVRD.png",
        title: "Save as much as 60% on Men's & Women's Fragrances!",
        shop_name: "Walmart",
        end_time: "2025-07-31T15:00:00.000Z",
        url: "/redirect?url=aHR0cHM6Ly9nb3RvLndhbG1hcnQuY29tL2MvMzUzNDgzLzU2NjcxOS85MzgzP3N1YklkMT1bMV0mc3ViSWQyPVsyXSZzdWJJZDM9WzNdJnNoYXJlZGlkPVs0XSZ2ZWg9YWZmJnNvdXJjZWlkPWltcF8wMDAwMTExMTIyMjIzMzMzNDQmdT1odHRwcyUzQSUyRiUyRnd3dy53YWxtYXJ0LmNvbSUyRmJyb3dzZSUyRmJlYXV0eS1kZWFscyUyRjAlM0ZfYmVfc2hlbGZfaWQlM0Q3NTk4OTkzJTI2Y2F0X2lkJTNEMCUyNmZhY2V0JTNEc2hlbGZfaWQlMjUzQTc1OTg5OTMlMjU3QyUyNTdDc3BlY2lhbF9vZmZlcnMlMjUzQVJlZHVjZWQlMkJQcmljZSUyNTdDJTI1N0NjYXRlZ29yeSUyNTNBV29tZW4lMjUyN3MlMkJGcmFncmFuY2U=&click_id=474338470-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=814&rf_source=walmart.com_deeplink&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=Walmart&rf_manual_deal=true",
        simple_source: "walmart.com",
        short_title: "Save as much as 60% on Men's & Women'..."
      }, {
        id: 1220,
        badge_type: "Best Value",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtU2F2ZSBvdmVyIDMwJSBvbiBTZWxlY3QgU3R5bGlzaCBWYXNlcyEtYXNzb3J0ZWQtZ29sZC1wbGF0ZWQtdGFibGUtZmlndXJpbmVzLTEwOTk4MTZfbW9kaWZpZWQtaW1hZ2UtMjAyMC0wNC0yMyAxMDo1MjoyOCBVVEM=.jpg",
        additional_image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtU2F2ZSBvdmVyIDMwJSBvbiBTZWxlY3QgU3R5bGlzaCBWYXNlcyEtd2F5ZmFpci1hZGRpdGlvbmFsX2ltYWdlLTIwMjAtMDQtMjMgMTA6NTI6MjggVVRD.png",
        title: "Save over 30% on Select Stylish Vases!",
        shop_name: "Wayfair",
        end_time: "2025-07-31T15:00:00.000Z",
        url: "/redirect?url=aHR0cHM6Ly93d3cud2F5ZmFpci5jb20vZGVjb3ItcGlsbG93cy9zYjAvdmFzZXMtdXJucy1qYXJzLWJvdHRsZXMtYzIxNTQ1OS5odG1sPyZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=767511375-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=1220&rf_source=bizrate.com_deeplink&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=Wayfair&rf_manual_deal=true",
        simple_source: "bizrate.com",
        short_title: "Save over 30% on Select Stylish Vases!"
      }],
      duration: 11199422680070628e-8
    },
    Coupons: {
      items: [],
      duration: 0
    },
    "Top Offers": void 0,
    Banners: void 0,
    Popups: void 0
  };
}

// node_modules/@roundforest/bdt-client/lib/fixtures/categories.db.js
var categoriesMock = [{
  title: "Appliances",
  img: "https://www.bestdeals.today/assets/l1_categories/appliances-8b61eb1387dd18137c55ea76e00ed90e1889383534f24734f19f2accad2173a5.png",
  url: "/appliances"
}, {
  title: "Apps & Games",
  img: "https://www.bestdeals.today/assets/l1_categories/apps-games-b07b41ae0fffff73cd57ade76d1c5f765283f598f740c69efaa516d975440e2b.png",
  url: "/apps-games"
}, {
  title: "Arts, Crafts & Sewing",
  img: "https://www.bestdeals.today/assets/l1_categories/arts-crafts-sewing-5f2b12fb6280be455889ae5dd23b42b3a9560ac67a117ac1fee37e3f5b3f0deb.png",
  url: "/arts-crafts-sewing"
}, {
  title: "Automotive",
  img: "https://www.bestdeals.today/assets/l1_categories/automotive-4fc39061d6ae5b538b467863d78625f8a54b2e21972f917160df3bd3169985e7.png",
  url: "/automotive"
}, {
  title: "Baby Products",
  img: "https://www.bestdeals.today/assets/l1_categories/baby-products-08a9f23ca2dabfef60d6789329afd4fb736c9e884a54964fd88b0eb4dc40643e.png",
  url: "/baby-products"
}, {
  title: "Beauty & Personal Care",
  img: "https://www.bestdeals.today/assets/l1_categories/beauty-personal-care-6122ac70e7dd12d6d9ce824d461ba8c38b5ff84c9b9ac879793e78e57206d132.png",
  url: "/beauty-personal-care"
}, {
  title: "Books",
  img: "https://www.bestdeals.today/assets/l1_categories/books-e207ee51e888c8630056d4bd4a0dca121d25532c57b8ba6be80d698b660fcd0c.png",
  url: "/books"
}, {
  title: "Cell Phones & Accessories",
  img: "https://www.bestdeals.today/assets/l1_categories/cell-phones-accessories-ddfcd768db5ac1ed7ae248038dc3bdd2e84124eeb30c999a0f0f851955e509e7.png",
  url: "/cell-phones-accessories"
}, {
  title: "Clothing, Shoes & Jewelry",
  img: "https://www.bestdeals.today/assets/l1_categories/clothing-shoes-jewelry-0e2de1e90fd3154892904e14c3b0a88070133402989a33c3286055c826965aae.png",
  url: "/clothing-shoes-jewelry"
}, {
  title: "Collectibles & Fine Art",
  img: "https://www.bestdeals.today/assets/l1_categories/collectibles-fine-art-f5dd4854f1f972478c503d4e2e333ce8a044154f1f97eb5de56e4ed64d06974e.png",
  url: "/collectibles-fine-art"
}, {
  title: "Credit & Payment Cards",
  img: "https://www.bestdeals.today/assets/l1_categories/credit-payment-cards-55e61483e7a156658643cf42a3cb31ccfa0126eb10ef9a91183254316c945df6.png",
  url: "/credit-payment-cards"
}, {
  title: "Digital Music",
  img: "https://www.bestdeals.today/assets/l1_categories/digital-music-650269a233703a8a6b194477051ee084c15857ed05e205d267548172c0219872.png",
  url: "/digital-music"
}, {
  title: "Electronics",
  img: "https://www.bestdeals.today/assets/l1_categories/electronics-d363b9cb9e1d1dbb2674f35e6c44c4cf0a4f2adb20ef1f3ab349a1242f54edc9.png",
  url: "/electronics"
}, {
  title: "Grocery & Gourmet Food",
  img: "https://www.bestdeals.today/assets/l1_categories/grocery-gourmet-food-818ed2016cb287a3eddaf2592121893e28abcc0e7c623d578ca650b978788077.png",
  url: "/grocery-gourmet-food"
}, {
  title: "Handmade Products",
  img: "https://www.bestdeals.today/assets/l1_categories/handmade-products-012672785036b3b86dcc26c280ab2369b0920c04fd330e2ed36c6b01af7bb96c.png",
  url: "/handmade-products"
}, {
  title: "Health & Household",
  img: "https://www.bestdeals.today/assets/l1_categories/health-household-8737e8abb90095f9ac250a9a42c742b65e246054592f4aa74a52d1450238ff7a.png",
  url: "/health-household"
}, {
  title: "Home & Business Services",
  img: "https://www.bestdeals.today/assets/l1_categories/home-business-services-7d9a9d1ee7fd30b8a7c472da9604e5c4a7607ad5bb36021c5cb2b36834451a1b.png",
  url: "/home-business-services"
}, {
  title: "Home & Kitchen",
  img: "https://www.bestdeals.today/assets/l1_categories/home-kitchen-7c22d712e0dcaabcc532ac749c18937b72c59d3347866d5ef20f73b1f97171e1.png",
  url: "/home-kitchen"
}, {
  title: "Industrial & Scientific",
  img: "https://www.bestdeals.today/assets/l1_categories/industrial-scientific-37e77555184fe4fbeceff1fe4b0c54e4e96f342ed7e726cf10fd0b41f3d58e25.png",
  url: "/industrial-scientific"
}, {
  title: "Kindle Store",
  img: "https://www.bestdeals.today/assets/l1_categories/kindle-store-fa2df0a8187201981c4ca070d4ec8dab9110d666fbd1c52b0c6dc2ae5782ed64.png",
  url: "/kindle-store"
}, {
  title: "Magazine Subscriptions",
  img: "https://www.bestdeals.today/assets/l1_categories/magazine-subscriptions-49a1a9dedeaae6dcdcf3f6b7ff00ecb24adebe365c7b9b809ffdfd7c2226c1f3.png",
  url: "/magazine-subscriptions"
}, {
  title: "Movies & TV",
  img: "https://www.bestdeals.today/assets/l1_categories/movies-tv-d7c8874777dc97b06d4ac8a6ba6b96fa4da18a8571304d036a73364fe3bd5892.png",
  url: "/movies-tv"
}, {
  title: "Musical Instruments",
  img: "https://www.bestdeals.today/assets/l1_categories/musical-instruments-a57b1ec3486deab759264b310dd915a14f7725976ba1f79fe4dec011fe184973.png",
  url: "/musical-instruments"
}, {
  title: "Office Products",
  img: "https://www.bestdeals.today/assets/l1_categories/office-products-49ee17832aeb456a7deacdf0b1dc7400fdddb13b220638a0d5029dd19da97d33.png",
  url: "/office-products"
}, {
  title: "Patio, Lawn & Garden",
  img: "https://www.bestdeals.today/assets/l1_categories/patio-lawn-garden-de58edfb9f60c69d7db49ed3aadceb29f7639c6ec1e8c22e08a2a9bafe8210dd.png",
  url: "/patio-lawn-garden"
}, {
  title: "Pet Supplies",
  img: "https://www.bestdeals.today/assets/l1_categories/pet-supplies-0ae03d57ef271fabad998e6d61f91e1f001ba5755fb7241a2a630b0fff82a84a.png",
  url: "/pet-supplies"
}, {
  title: "Software",
  img: "https://www.bestdeals.today/assets/l1_categories/software-8d7fcd634f77e91f96c9c6475b1dd11a1de6d12c778bf163fbcd1376a0e68114.png",
  url: "/software"
}, {
  title: "Sports & Outdoors",
  img: "https://www.bestdeals.today/assets/l1_categories/sports-outdoors-87c0221207330d538b6f124e01f76bec0b0c892d9c2186241433633e62ad737c.png",
  url: "/sports-outdoors"
}, {
  title: "Tools & Home Improvement",
  img: "https://www.bestdeals.today/assets/l1_categories/tools-home-improvement-ff06ccd99b5264dc0e2a60a3f88e992e08eb4345a2f696242e88e2149bf384e2.png",
  url: "/tools-home-improvement"
}, {
  title: "Toys & Games",
  img: "https://www.bestdeals.today/assets/l1_categories/toys-games-eba67209d7f4fa3f0250afc2a52f09af671e9594eafdca4d47afc83a97a50e4b.png",
  url: "/toys-games"
}, {
  title: "Video Games",
  img: "https://www.bestdeals.today/assets/l1_categories/video-games-abc11d3c2205d64878de970642b431f7080a9bd929acc66d3b94df3974f0a650.png",
  url: "/video-games"
}];

// node_modules/@roundforest/bdt-client/lib/bdt-client-fake.js
function makeClient3() {
  return {
    getProductsAndMetadata,
    submitContactForm,
    getPageTypeData,
    getManualDeals,
    trackRequest,
    registerEmail,
    getAllCategories,
    TEST_clear: () => {
    }
  };
  async function submitContactForm() {
  }
  async function registerEmail(data) {
    let dataForApi = {
      email: data.email,
      app_id: data.appId,
      user_id: data.userId,
      subscription_location: data.subscriptionLocation
    };
    if (dataForApi.email === "test@test.com")
      return {
        type: "0"
      };
    if (dataForApi.email === "test1@test.com")
      return {
        type: "1"
      };
    if (dataForApi.email === "test2@test.com")
      return {
        type: "2"
      };
    throw Error;
  }
  async function getProductsAndMetadata() {
    let {
      products,
      metadata
    } = mockData, normalizedProducts = camelcaseKeys(products), normalizedMetadata = camelcaseKeys(metadata);
    return {
      products: normalizedProducts.map((product) => ({
        ...product,
        clickId: 123456
      })),
      metadata: normalizedMetadata
    };
  }
  async function getPageTypeData(_commonBdtParameters, searchTerm) {
    let slugAsText = slugToText(searchTerm, {
      capitalize: !1
    }), {
      page_type,
      popular_categories,
      subcategories,
      banner
    } = await getPageTypeDataMock(slugAsText), popularCategories = normalizePageTypeCategories(popular_categories || []), normalizedSubcategories = normalizePageTypeCategories(subcategories || []);
    return {
      banner,
      pageType: page_type,
      popularCategories,
      subcategories: normalizedSubcategories
    };
  }
  async function getManualDeals({
    positions
  }) {
    let response = getManualDealsMock(positions);
    return {
      topDeals: getManualDealsByPositionOrUndefined(positions, "Top Deals", response),
      topOffers: getManualDealsByPositionOrUndefined(positions, "Top Offers", response),
      popups: getManualDealsByPositionOrUndefined(positions, "Popups", response),
      banners: getManualDealsByPositionOrUndefined(positions, "Banners", response),
      coupons: getManualDealsByPositionOrUndefined(positions, "Coupons", response),
      offers: getManualDealsByPositionOrUndefined(positions, "Offers", response)
    };
  }
  async function trackRequest(_commonBdtParameters) {
    return {
      traffic: {
        type: "direct"
      },
      trackRequestCookies: {}
    };
  }
  async function getAllCategories() {
    return categoriesMock;
  }
}

// server/clients.ts
var client2 = makeClient2("https://www.bestdeals.today/bdt-store-page/api/"), fakeClient = makeClient3(), getData = async (searchTerm) => {
  try {
    return await client2.getProductsAndMetadata(searchTerm);
  } catch (e2) {
    throw e2;
  }
};

// app/routes/products.$searchTerm.tsx
var import_jsx_runtime11 = __toESM(require_jsx_runtime()), loader = async ({ params }) => {
  let { searchTerm } = params, data = await getData(searchTerm || "");
  return (0, import_node3.json)(data);
};
async function action2({ request }) {
  let formData = await request.formData(), byFixedPrice = formData.getAll("byFixedPrice"), byDiscounted = formData.getAll("byDiscounted"), byStore = formData.getAll("byStore"), byCondition = formData.getAll("byCondition"), byBrand = formData.getAll("byBrand"), byShipping = formData.getAll("byShipping");
  return (0, import_node3.json)({ filters: { byBrand, byFixedPrice, byDiscounted, byStore, byCondition, byShipping } });
}
function MainRoute() {
  return /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("main", { className: "flex flex-col", children: [
    /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(appbar_default, {}),
    /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(content_default, {}),
    /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(footer_default, {})
  ] });
}

// app/routes/products.tsx
var products_exports = {};
__export(products_exports, {
  default: () => Products
});
var import_react10 = __toESM(require_dist3()), import_jsx_runtime12 = __toESM(require_jsx_runtime());
function Products() {
  return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(import_react10.Outlet, {});
}

// app/routes/healthz.tsx
var healthz_exports = {};
__export(healthz_exports, {
  default: () => Products2
});
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
function Products2() {
  return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("div", { children: "Healthz" });
}

// app/routes/_index.tsx
var index_exports = {};
__export(index_exports, {
  default: () => index_default,
  loader: () => loader2
});
var import_node4 = __toESM(require_dist2()), import_jsx_runtime14 = __toESM(require_jsx_runtime()), loader2 = async () => (0, import_node4.redirect)("/products/laptops"), Main = () => /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("div", { children: "Main" }), index_default = Main;

// server-assets-manifest:@remix-run/dev/assets-manifest
var assets_manifest_default = { entry: { module: "/build/entry.client-OMH4PYQP.js", imports: ["/build/_shared/chunk-RW4Y6VNK.js", "/build/_shared/chunk-5XCBIPQZ.js"] }, routes: { root: { id: "root", parentId: void 0, path: "", index: void 0, caseSensitive: void 0, module: "/build/root-KES72NW6.js", imports: void 0, hasAction: !0, hasLoader: !1, hasCatchBoundary: !1, hasErrorBoundary: !0 }, "routes/_index": { id: "routes/_index", parentId: "root", path: void 0, index: !0, caseSensitive: void 0, module: "/build/routes/_index-XLEUHKVP.js", imports: void 0, hasAction: !1, hasLoader: !0, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/healthz": { id: "routes/healthz", parentId: "root", path: "healthz", index: void 0, caseSensitive: void 0, module: "/build/routes/healthz-PUYFZXFR.js", imports: void 0, hasAction: !1, hasLoader: !1, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/products": { id: "routes/products", parentId: "root", path: "products", index: void 0, caseSensitive: void 0, module: "/build/routes/products-YUJXZ3XM.js", imports: void 0, hasAction: !1, hasLoader: !1, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/products.$searchTerm": { id: "routes/products.$searchTerm", parentId: "routes/products", path: ":searchTerm", index: void 0, caseSensitive: void 0, module: "/build/routes/products.$searchTerm-SGHCMOO5.js", imports: void 0, hasAction: !0, hasLoader: !0, hasCatchBoundary: !1, hasErrorBoundary: !1 } }, cssBundleHref: void 0, version: "3bbf435a", hmr: void 0, url: "/build/manifest-3BBF435A.js" };

// server-entry-module:@remix-run/dev/server-build
var assetsBuildDirectory = "public/build", future = { unstable_dev: !1, unstable_postcss: !1, unstable_tailwind: !1, v2_errorBoundary: !0, v2_headers: !1, v2_meta: !0, v2_normalizeFormMethod: !0, v2_routeConvention: !0 }, publicPath = "/build/", entry = { module: entry_server_exports }, routes = {
  root: {
    id: "root",
    parentId: void 0,
    path: "",
    index: void 0,
    caseSensitive: void 0,
    module: root_exports
  },
  "routes/products.$searchTerm": {
    id: "routes/products.$searchTerm",
    parentId: "routes/products",
    path: ":searchTerm",
    index: void 0,
    caseSensitive: void 0,
    module: products_searchTerm_exports
  },
  "routes/products": {
    id: "routes/products",
    parentId: "root",
    path: "products",
    index: void 0,
    caseSensitive: void 0,
    module: products_exports
  },
  "routes/healthz": {
    id: "routes/healthz",
    parentId: "root",
    path: "healthz",
    index: void 0,
    caseSensitive: void 0,
    module: healthz_exports
  },
  "routes/_index": {
    id: "routes/_index",
    parentId: "root",
    path: void 0,
    index: !0,
    caseSensitive: void 0,
    module: index_exports
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  assets,
  assetsBuildDirectory,
  entry,
  future,
  publicPath,
  routes
});
/*! Bundled license information:

@remix-run/node/dist/fetch.js:
  (**
   * @remix-run/node v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/base64.js:
  (**
   * @remix-run/node v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/globals.js:
  (**
   * @remix-run/node v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

@remix-run/server-runtime/dist/warnings.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/cookies.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/formData.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/router/dist/router.cjs.js:
  (**
   * @remix-run/router v1.6.3
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/mode.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/errors.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/responses.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/entry.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/headers.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/invariant.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/routeMatching.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/data.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/routes.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/markup.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/serverHandoff.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/server.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/sessions.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/sessions/cookieStorage.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/sessions/memoryStorage.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/upload/errors.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/upload/memoryUploadHandler.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/dev.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/index.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/crypto.js:
  (**
   * @remix-run/node v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/implementations.js:
  (**
   * @remix-run/node v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/sessions/fileStorage.js:
  (**
   * @remix-run/node v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/stream.js:
  (**
   * @remix-run/node v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/upload/fileUploadHandler.js:
  (**
   * @remix-run/node v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/index.js:
  (**
   * @remix-run/node v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react/cjs/react.production.min.js:
  (**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-router/dist/umd/react-router.production.min.js:
  (**
   * React Router v6.12.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router/dist/main.js:
  (**
   * React Router v6.12.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router-dom/dist/umd/react-router-dom.production.min.js:
  (**
   * React Router DOM v6.12.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router-dom/dist/main.js:
  (**
   * React Router DOM v6.12.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/_virtual/_rollupPluginBabelHelpers.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/errorBoundaries.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/invariant.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/routeModules.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/links.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/markup.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/transition.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/warnings.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/components.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/errors.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/data.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/routes.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/browser.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/scroll-restoration.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/server.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/index.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-dom/cjs/react-dom-server-legacy.node.production.min.js:
  (**
   * @license React
   * react-dom-server-legacy.node.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-server.node.production.min.js:
  (**
   * @license React
   * react-dom-server.node.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.min.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

fetch-blob/index.js:
  (*! fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

formdata-polyfill/esm.min.js:
  (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

node-domexception/index.js:
  (*! node-domexception. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)
*/
