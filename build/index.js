var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj)), __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
}, __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

// node_modules/source-map-support/node_modules/source-map/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/base64.js"(exports) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports.encode = function(number) {
      if (0 <= number && number < intToCharMap.length)
        return intToCharMap[number];
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports.decode = function(charCode) {
      var bigA = 65, bigZ = 90, littleA = 97, littleZ = 122, zero = 48, nine = 57, plus = 43, slash = 47, littleOffset = 26, numberOffset = 52;
      return bigA <= charCode && charCode <= bigZ ? charCode - bigA : littleA <= charCode && charCode <= littleZ ? charCode - littleA + littleOffset : zero <= charCode && charCode <= nine ? charCode - zero + numberOffset : charCode == plus ? 62 : charCode == slash ? 63 : -1;
    };
  }
});

// node_modules/source-map-support/node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/base64-vlq.js"(exports) {
    var base64 = require_base64(), VLQ_BASE_SHIFT = 5, VLQ_BASE = 1 << VLQ_BASE_SHIFT, VLQ_BASE_MASK = VLQ_BASE - 1, VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1, shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports.encode = function(aValue) {
      var encoded = "", digit, vlq = toVLQSigned(aValue);
      do
        digit = vlq & VLQ_BASE_MASK, vlq >>>= VLQ_BASE_SHIFT, vlq > 0 && (digit |= VLQ_CONTINUATION_BIT), encoded += base64.encode(digit);
      while (vlq > 0);
      return encoded;
    };
    exports.decode = function(aStr, aIndex, aOutParam) {
      var strLen = aStr.length, result = 0, shift = 0, continuation, digit;
      do {
        if (aIndex >= strLen)
          throw new Error("Expected more digits in base 64 VLQ value.");
        if (digit = base64.decode(aStr.charCodeAt(aIndex++)), digit === -1)
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        continuation = !!(digit & VLQ_CONTINUATION_BIT), digit &= VLQ_BASE_MASK, result = result + (digit << shift), shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result), aOutParam.rest = aIndex;
    };
  }
});

// node_modules/source-map-support/node_modules/source-map/lib/util.js
var require_util = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/util.js"(exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs)
        return aArgs[aName];
      if (arguments.length === 3)
        return aDefaultValue;
      throw new Error('"' + aName + '" is a required argument.');
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      return match ? {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      } : null;
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      return aParsedUrl.scheme && (url += aParsedUrl.scheme + ":"), url += "//", aParsedUrl.auth && (url += aParsedUrl.auth + "@"), aParsedUrl.host && (url += aParsedUrl.host), aParsedUrl.port && (url += ":" + aParsedUrl.port), aParsedUrl.path && (url += aParsedUrl.path), url;
    }
    exports.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path = aPath, url = urlParse(aPath);
      if (url) {
        if (!url.path)
          return aPath;
        path = url.path;
      }
      for (var isAbsolute = exports.isAbsolute(path), parts = path.split(/\/+/), part, up = 0, i2 = parts.length - 1; i2 >= 0; i2--)
        part = parts[i2], part === "." ? parts.splice(i2, 1) : part === ".." ? up++ : up > 0 && (part === "" ? (parts.splice(i2 + 1, up), up = 0) : (parts.splice(i2, 2), up--));
      return path = parts.join("/"), path === "" && (path = isAbsolute ? "/" : "."), url ? (url.path = path, urlGenerate(url)) : path;
    }
    exports.normalize = normalize;
    function join(aRoot, aPath) {
      aRoot === "" && (aRoot = "."), aPath === "" && (aPath = ".");
      var aPathUrl = urlParse(aPath), aRootUrl = urlParse(aRoot);
      if (aRootUrl && (aRoot = aRootUrl.path || "/"), aPathUrl && !aPathUrl.scheme)
        return aRootUrl && (aPathUrl.scheme = aRootUrl.scheme), urlGenerate(aPathUrl);
      if (aPathUrl || aPath.match(dataUrlRegexp))
        return aPath;
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path)
        return aRootUrl.host = aPath, urlGenerate(aRootUrl);
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      return aRootUrl ? (aRootUrl.path = joined, urlGenerate(aRootUrl)) : joined;
    }
    exports.join = join;
    exports.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      aRoot === "" && (aRoot = "."), aRoot = aRoot.replace(/\/$/, "");
      for (var level = 0; aPath.indexOf(aRoot + "/") !== 0; ) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0 || (aRoot = aRoot.slice(0, index), aRoot.match(/^([^\/]+:\/)?\/*$/)))
          return aPath;
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s2) {
      return s2;
    }
    function toSetString(aStr) {
      return isProtoString(aStr) ? "$" + aStr : aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      return isProtoString(aStr) ? aStr.slice(1) : aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s2) {
      if (!s2)
        return !1;
      var length = s2.length;
      if (length < 9 || s2.charCodeAt(length - 1) !== 95 || s2.charCodeAt(length - 2) !== 95 || s2.charCodeAt(length - 3) !== 111 || s2.charCodeAt(length - 4) !== 116 || s2.charCodeAt(length - 5) !== 111 || s2.charCodeAt(length - 6) !== 114 || s2.charCodeAt(length - 7) !== 112 || s2.charCodeAt(length - 8) !== 95 || s2.charCodeAt(length - 9) !== 95)
        return !1;
      for (var i2 = length - 10; i2 >= 0; i2--)
        if (s2.charCodeAt(i2) !== 36)
          return !1;
      return !0;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      return cmp !== 0 || (cmp = mappingA.originalLine - mappingB.originalLine, cmp !== 0) || (cmp = mappingA.originalColumn - mappingB.originalColumn, cmp !== 0 || onlyCompareOriginal) || (cmp = mappingA.generatedColumn - mappingB.generatedColumn, cmp !== 0) || (cmp = mappingA.generatedLine - mappingB.generatedLine, cmp !== 0) ? cmp : strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      return cmp !== 0 || (cmp = mappingA.generatedColumn - mappingB.generatedColumn, cmp !== 0 || onlyCompareGenerated) || (cmp = strcmp(mappingA.source, mappingB.source), cmp !== 0) || (cmp = mappingA.originalLine - mappingB.originalLine, cmp !== 0) || (cmp = mappingA.originalColumn - mappingB.originalColumn, cmp !== 0) ? cmp : strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      return aStr1 === aStr2 ? 0 : aStr1 === null ? 1 : aStr2 === null ? -1 : aStr1 > aStr2 ? 1 : -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      return cmp !== 0 || (cmp = mappingA.generatedColumn - mappingB.generatedColumn, cmp !== 0) || (cmp = strcmp(mappingA.source, mappingB.source), cmp !== 0) || (cmp = mappingA.originalLine - mappingB.originalLine, cmp !== 0) || (cmp = mappingA.originalColumn - mappingB.originalColumn, cmp !== 0) ? cmp : strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      if (sourceURL = sourceURL || "", sourceRoot && (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/" && (sourceRoot += "/"), sourceURL = sourceRoot + sourceURL), sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed)
          throw new Error("sourceMapURL could not be parsed");
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          index >= 0 && (parsed.path = parsed.path.substring(0, index + 1));
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports.computeSourceURL = computeSourceURL;
  }
});

// node_modules/source-map-support/node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/array-set.js"(exports) {
    var util = require_util(), has2 = Object.prototype.hasOwnProperty, hasNativeMap = typeof Map < "u";
    function ArraySet() {
      this._array = [], this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function(aArray, aAllowDuplicates) {
      for (var set = new ArraySet(), i2 = 0, len = aArray.length; i2 < len; i2++)
        set.add(aArray[i2], aAllowDuplicates);
      return set;
    };
    ArraySet.prototype.size = function() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr), isDuplicate = hasNativeMap ? this.has(aStr) : has2.call(this._set, sStr), idx = this._array.length;
      (!isDuplicate || aAllowDuplicates) && this._array.push(aStr), isDuplicate || (hasNativeMap ? this._set.set(aStr, idx) : this._set[sStr] = idx);
    };
    ArraySet.prototype.has = function(aStr) {
      if (hasNativeMap)
        return this._set.has(aStr);
      var sStr = util.toSetString(aStr);
      return has2.call(this._set, sStr);
    };
    ArraySet.prototype.indexOf = function(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0)
          return idx;
      } else {
        var sStr = util.toSetString(aStr);
        if (has2.call(this._set, sStr))
          return this._set[sStr];
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length)
        return this._array[aIdx];
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function() {
      return this._array.slice();
    };
    exports.ArraySet = ArraySet;
  }
});

// node_modules/source-map-support/node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/mapping-list.js"(exports) {
    var util = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine, lineB = mappingB.generatedLine, columnA = mappingA.generatedColumn, columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [], this._sorted = !0, this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function(aMapping) {
      generatedPositionAfter(this._last, aMapping) ? (this._last = aMapping, this._array.push(aMapping)) : (this._sorted = !1, this._array.push(aMapping));
    };
    MappingList.prototype.toArray = function() {
      return this._sorted || (this._array.sort(util.compareByGeneratedPositionsInflated), this._sorted = !0), this._array;
    };
    exports.MappingList = MappingList;
  }
});

// node_modules/source-map-support/node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/source-map-generator.js"(exports) {
    var base64VLQ = require_base64_vlq(), util = require_util(), ArraySet = require_array_set().ArraySet, MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      aArgs || (aArgs = {}), this._file = util.getArg(aArgs, "file", null), this._sourceRoot = util.getArg(aArgs, "sourceRoot", null), this._skipValidation = util.getArg(aArgs, "skipValidation", !1), this._sources = new ArraySet(), this._names = new ArraySet(), this._mappings = new MappingList(), this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot, generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      return aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        mapping.source != null && (newMapping.source = mapping.source, sourceRoot != null && (newMapping.source = util.relative(sourceRoot, newMapping.source)), newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        }, mapping.name != null && (newMapping.name = mapping.name)), generator.addMapping(newMapping);
      }), aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        sourceRoot !== null && (sourceRelative = util.relative(sourceRoot, sourceFile)), generator._sources.has(sourceRelative) || generator._sources.add(sourceRelative);
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        content != null && generator.setSourceContent(sourceFile, content);
      }), generator;
    };
    SourceMapGenerator.prototype.addMapping = function(aArgs) {
      var generated = util.getArg(aArgs, "generated"), original = util.getArg(aArgs, "original", null), source = util.getArg(aArgs, "source", null), name = util.getArg(aArgs, "name", null);
      this._skipValidation || this._validateMapping(generated, original, source, name), source != null && (source = String(source), this._sources.has(source) || this._sources.add(source)), name != null && (name = String(name), this._names.has(name) || this._names.add(name)), this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      this._sourceRoot != null && (source = util.relative(this._sourceRoot, source)), aSourceContent != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[util.toSetString(source)] = aSourceContent) : this._sourcesContents && (delete this._sourcesContents[util.toSetString(source)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
    };
    SourceMapGenerator.prototype.applySourceMap = function(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null)
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      sourceRoot != null && (sourceFile = util.relative(sourceRoot, sourceFile));
      var newSources = new ArraySet(), newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          original.source != null && (mapping.source = original.source, aSourceMapPath != null && (mapping.source = util.join(aSourceMapPath, mapping.source)), sourceRoot != null && (mapping.source = util.relative(sourceRoot, mapping.source)), mapping.originalLine = original.line, mapping.originalColumn = original.column, original.name != null && (mapping.name = original.name));
        }
        var source = mapping.source;
        source != null && !newSources.has(source) && newSources.add(source);
        var name = mapping.name;
        name != null && !newNames.has(name) && newNames.add(name);
      }, this), this._sources = newSources, this._names = newNames, aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        content != null && (aSourceMapPath != null && (sourceFile2 = util.join(aSourceMapPath, sourceFile2)), sourceRoot != null && (sourceFile2 = util.relative(sourceRoot, sourceFile2)), this.setSourceContent(sourceFile2, content));
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line != "number" && typeof aOriginal.column != "number")
        throw new Error(
          "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
        );
      if (!(aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName)) {
        if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource)
          return;
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function() {
      for (var previousGeneratedColumn = 0, previousGeneratedLine = 1, previousOriginalColumn = 0, previousOriginalLine = 0, previousName = 0, previousSource = 0, result = "", next, mapping, nameIdx, sourceIdx, mappings = this._mappings.toArray(), i2 = 0, len = mappings.length; i2 < len; i2++) {
        if (mapping = mappings[i2], next = "", mapping.generatedLine !== previousGeneratedLine)
          for (previousGeneratedColumn = 0; mapping.generatedLine !== previousGeneratedLine; )
            next += ";", previousGeneratedLine++;
        else if (i2 > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i2 - 1]))
            continue;
          next += ",";
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn), previousGeneratedColumn = mapping.generatedColumn, mapping.source != null && (sourceIdx = this._sources.indexOf(mapping.source), next += base64VLQ.encode(sourceIdx - previousSource), previousSource = sourceIdx, next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine), previousOriginalLine = mapping.originalLine - 1, next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn), previousOriginalColumn = mapping.originalColumn, mapping.name != null && (nameIdx = this._names.indexOf(mapping.name), next += base64VLQ.encode(nameIdx - previousName), previousName = nameIdx)), result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents)
          return null;
        aSourceRoot != null && (source = util.relative(aSourceRoot, source));
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      return this._file != null && (map.file = this._file), this._sourceRoot != null && (map.sourceRoot = this._sourceRoot), this._sourcesContents && (map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot)), map;
    };
    SourceMapGenerator.prototype.toString = function() {
      return JSON.stringify(this.toJSON());
    };
    exports.SourceMapGenerator = SourceMapGenerator;
  }
});

// node_modules/source-map-support/node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/binary-search.js"(exports) {
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow, cmp = aCompare(aNeedle, aHaystack[mid], !0);
      return cmp === 0 ? mid : cmp > 0 ? aHigh - mid > 1 ? recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias) : aBias == exports.LEAST_UPPER_BOUND ? aHigh < aHaystack.length ? aHigh : -1 : mid : mid - aLow > 1 ? recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias) : aBias == exports.LEAST_UPPER_BOUND ? mid : aLow < 0 ? -1 : aLow;
    }
    exports.search = function(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0)
        return -1;
      var index = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports.GREATEST_LOWER_BOUND
      );
      if (index < 0)
        return -1;
      for (; index - 1 >= 0 && aCompare(aHaystack[index], aHaystack[index - 1], !0) === 0; )
        --index;
      return index;
    };
  }
});

// node_modules/source-map-support/node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/quick-sort.js"(exports) {
    function swap(ary, x2, y) {
      var temp = ary[x2];
      ary[x2] = ary[y], ary[y] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator, p, r2) {
      if (p < r2) {
        var pivotIndex = randomIntInRange(p, r2), i2 = p - 1;
        swap(ary, pivotIndex, r2);
        for (var pivot = ary[r2], j = p; j < r2; j++)
          comparator(ary[j], pivot) <= 0 && (i2 += 1, swap(ary, i2, j));
        swap(ary, i2 + 1, j);
        var q = i2 + 1;
        doQuickSort(ary, comparator, p, q - 1), doQuickSort(ary, comparator, q + 1, r2);
      }
    }
    exports.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
  }
});

// node_modules/source-map-support/node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/source-map-consumer.js"(exports) {
    var util = require_util(), binarySearch = require_binary_search(), ArraySet = require_array_set().ArraySet, base64VLQ = require_base64_vlq(), quickSort = require_quick_sort().quickSort;
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      return typeof aSourceMap == "string" && (sourceMap = util.parseSourceMapInput(aSourceMap)), sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      configurable: !0,
      enumerable: !0,
      get: function() {
        return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      configurable: !0,
      enumerable: !0,
      get: function() {
        return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function(aCallback, aContext, aOrder) {
      var context = aContext || null, order = aOrder || SourceMapConsumer.GENERATED_ORDER, mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        return source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL), {
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function(aArgs) {
      var line = util.getArg(aArgs, "line"), needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0)
      };
      if (needle.source = this._findSourceIndex(needle.source), needle.source < 0)
        return [];
      var mappings = [], index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        binarySearch.LEAST_UPPER_BOUND
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === void 0)
          for (var originalLine = mapping.originalLine; mapping && mapping.originalLine === originalLine; )
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            }), mapping = this._originalMappings[++index];
        else
          for (var originalColumn = mapping.originalColumn; mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn; )
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            }), mapping = this._originalMappings[++index];
      }
      return mappings;
    };
    exports.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      typeof aSourceMap == "string" && (sourceMap = util.parseSourceMapInput(aSourceMap));
      var version = util.getArg(sourceMap, "version"), sources = util.getArg(sourceMap, "sources"), names = util.getArg(sourceMap, "names", []), sourceRoot = util.getArg(sourceMap, "sourceRoot", null), sourcesContent = util.getArg(sourceMap, "sourcesContent", null), mappings = util.getArg(sourceMap, "mappings"), file = util.getArg(sourceMap, "file", null);
      if (version != this._version)
        throw new Error("Unsupported version: " + version);
      sourceRoot && (sourceRoot = util.normalize(sourceRoot)), sources = sources.map(String).map(util.normalize).map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
      }), this._names = ArraySet.fromArray(names.map(String), !0), this._sources = ArraySet.fromArray(sources, !0), this._absoluteSources = this._sources.toArray().map(function(s2) {
        return util.computeSourceURL(sourceRoot, s2, aSourceMapURL);
      }), this.sourceRoot = sourceRoot, this.sourcesContent = sourcesContent, this._mappings = mappings, this._sourceMapURL = aSourceMapURL, this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null && (relativeSource = util.relative(this.sourceRoot, relativeSource)), this._sources.has(relativeSource))
        return this._sources.indexOf(relativeSource);
      var i2;
      for (i2 = 0; i2 < this._absoluteSources.length; ++i2)
        if (this._absoluteSources[i2] == aSource)
          return i2;
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype), names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), !0), sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), !0);
      smc.sourceRoot = aSourceMap._sourceRoot, smc.sourcesContent = aSourceMap._generateSourcesContent(
        smc._sources.toArray(),
        smc.sourceRoot
      ), smc.file = aSourceMap._file, smc._sourceMapURL = aSourceMapURL, smc._absoluteSources = smc._sources.toArray().map(function(s2) {
        return util.computeSourceURL(smc.sourceRoot, s2, aSourceMapURL);
      });
      for (var generatedMappings = aSourceMap._mappings.toArray().slice(), destGeneratedMappings = smc.__generatedMappings = [], destOriginalMappings = smc.__originalMappings = [], i2 = 0, length = generatedMappings.length; i2 < length; i2++) {
        var srcMapping = generatedMappings[i2], destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine, destMapping.generatedColumn = srcMapping.generatedColumn, srcMapping.source && (destMapping.source = sources.indexOf(srcMapping.source), destMapping.originalLine = srcMapping.originalLine, destMapping.originalColumn = srcMapping.originalColumn, srcMapping.name && (destMapping.name = names.indexOf(srcMapping.name)), destOriginalMappings.push(destMapping)), destGeneratedMappings.push(destMapping);
      }
      return quickSort(smc.__originalMappings, util.compareByOriginalPositions), smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping() {
      this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
    }
    BasicSourceMapConsumer.prototype._parseMappings = function(aStr, aSourceRoot) {
      for (var generatedLine = 1, previousGeneratedColumn = 0, previousOriginalLine = 0, previousOriginalColumn = 0, previousSource = 0, previousName = 0, length = aStr.length, index = 0, cachedSegments = {}, temp = {}, originalMappings = [], generatedMappings = [], mapping, str, segment, end, value; index < length; )
        if (aStr.charAt(index) === ";")
          generatedLine++, index++, previousGeneratedColumn = 0;
        else if (aStr.charAt(index) === ",")
          index++;
        else {
          for (mapping = new Mapping(), mapping.generatedLine = generatedLine, end = index; end < length && !this._charIsMappingSeparator(aStr, end); end++)
            ;
          if (str = aStr.slice(index, end), segment = cachedSegments[str], segment)
            index += str.length;
          else {
            for (segment = []; index < end; )
              base64VLQ.decode(aStr, index, temp), value = temp.value, index = temp.rest, segment.push(value);
            if (segment.length === 2)
              throw new Error("Found a source, but no line and column");
            if (segment.length === 3)
              throw new Error("Found a source and line, but no column");
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0], previousGeneratedColumn = mapping.generatedColumn, segment.length > 1 && (mapping.source = previousSource + segment[1], previousSource += segment[1], mapping.originalLine = previousOriginalLine + segment[2], previousOriginalLine = mapping.originalLine, mapping.originalLine += 1, mapping.originalColumn = previousOriginalColumn + segment[3], previousOriginalColumn = mapping.originalColumn, segment.length > 4 && (mapping.name = previousName + segment[4], previousName += segment[4])), generatedMappings.push(mapping), typeof mapping.originalLine == "number" && originalMappings.push(mapping);
        }
      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated), this.__generatedMappings = generatedMappings, quickSort(originalMappings, util.compareByOriginalPositions), this.__originalMappings = originalMappings;
    };
    BasicSourceMapConsumer.prototype._findMapping = function(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0)
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      if (aNeedle[aColumnName] < 0)
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = 1 / 0;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      }, index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, "source", null);
          source !== null && (source = this._sources.at(source), source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL));
          var name = util.getArg(mapping, "name", null);
          return name !== null && (name = this._names.at(name)), {
            source,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function() {
      return this.sourcesContent ? this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      }) : !1;
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function(aSource, nullOnMissing) {
      if (!this.sourcesContent)
        return null;
      var index = this._findSourceIndex(aSource);
      if (index >= 0)
        return this.sourcesContent[index];
      var relativeSource = aSource;
      this.sourceRoot != null && (relativeSource = util.relative(this.sourceRoot, relativeSource));
      var url;
      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath))
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource))
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
      if (nullOnMissing)
        return null;
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function(aArgs) {
      var source = util.getArg(aArgs, "source");
      if (source = this._findSourceIndex(source), source < 0)
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      var needle = {
        source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column")
      }, index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source)
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          };
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      typeof aSourceMap == "string" && (sourceMap = util.parseSourceMapInput(aSourceMap));
      var version = util.getArg(sourceMap, "version"), sections = util.getArg(sourceMap, "sections");
      if (version != this._version)
        throw new Error("Unsupported version: " + version);
      this._sources = new ArraySet(), this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s2) {
        if (s2.url)
          throw new Error("Support for url field in sections not implemented.");
        var offset = util.getArg(s2, "offset"), offsetLine = util.getArg(offset, "line"), offsetColumn = util.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column)
          throw new Error("Section offsets must be ordered and non-overlapping.");
        return lastOffset = offset, {
          generatedOffset: {
            // The offset fields are 0-based, but we use 1-based indices when
            // encoding/decoding from VLQ.
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util.getArg(s2, "map"), aSourceMapURL)
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        for (var sources = [], i2 = 0; i2 < this._sections.length; i2++)
          for (var j = 0; j < this._sections[i2].consumer.sources.length; j++)
            sources.push(this._sections[i2].consumer.sources[j]);
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      }, sectionIndex = binarySearch.search(
        needle,
        this._sections,
        function(needle2, section2) {
          var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
          return cmp || needle2.generatedColumn - section2.generatedOffset.generatedColumn;
        }
      ), section = this._sections[sectionIndex];
      return section ? section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      }) : {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function() {
      return this._sections.every(function(s2) {
        return s2.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function(aSource, nullOnMissing) {
      for (var i2 = 0; i2 < this._sections.length; i2++) {
        var section = this._sections[i2], content = section.consumer.sourceContentFor(aSource, !0);
        if (content)
          return content;
      }
      if (nullOnMissing)
        return null;
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function(aArgs) {
      for (var i2 = 0; i2 < this._sections.length; i2++) {
        var section = this._sections[i2];
        if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) !== -1) {
          var generatedPosition = section.consumer.generatedPositionFor(aArgs);
          if (generatedPosition) {
            var ret = {
              line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
              column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
            };
            return ret;
          }
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function(aStr, aSourceRoot) {
      this.__generatedMappings = [], this.__originalMappings = [];
      for (var i2 = 0; i2 < this._sections.length; i2++)
        for (var section = this._sections[i2], sectionMappings = section.consumer._generatedMappings, j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j], source = section.consumer._sources.at(mapping.source);
          source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL), this._sources.add(source), source = this._sources.indexOf(source);
          var name = null;
          mapping.name && (name = section.consumer._names.at(mapping.name), this._names.add(name), name = this._names.indexOf(name));
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping), typeof adjustedMapping.originalLine == "number" && this.__originalMappings.push(adjustedMapping);
        }
      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated), quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };
    exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// node_modules/source-map-support/node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/source-node.js"(exports) {
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator, util = require_util(), REGEX_NEWLINE = /(\r?\n)/, NEWLINE_CODE = 10, isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [], this.sourceContents = {}, this.line = aLine ?? null, this.column = aColumn ?? null, this.source = aSource ?? null, this.name = aName ?? null, this[isSourceNode] = !0, aChunks != null && this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode(), remainingLines = aGeneratedCode.split(REGEX_NEWLINE), remainingLinesIndex = 0, shiftNextLine = function() {
        var lineContents = getNextLine(), newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      }, lastGeneratedLine = 1, lastGeneratedColumn = 0, lastMapping = null;
      return aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null)
          if (lastGeneratedLine < mapping.generatedLine)
            addMappingWithCode(lastMapping, shiftNextLine()), lastGeneratedLine++, lastGeneratedColumn = 0;
          else {
            var nextLine = remainingLines[remainingLinesIndex] || "", code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn), lastGeneratedColumn = mapping.generatedColumn, addMappingWithCode(lastMapping, code), lastMapping = mapping;
            return;
          }
        for (; lastGeneratedLine < mapping.generatedLine; )
          node.add(shiftNextLine()), lastGeneratedLine++;
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node.add(nextLine.substr(0, mapping.generatedColumn)), remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn), lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this), remainingLinesIndex < remainingLines.length && (lastMapping && addMappingWithCode(lastMapping, shiftNextLine()), node.add(remainingLines.splice(remainingLinesIndex).join(""))), aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        content != null && (aRelativePath != null && (sourceFile = util.join(aRelativePath, sourceFile)), node.setSourceContent(sourceFile, content));
      }), node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0)
          node.add(code);
        else {
          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(
            mapping.originalLine,
            mapping.originalColumn,
            source,
            code,
            mapping.name
          ));
        }
      }
    };
    SourceNode.prototype.add = function(aChunk) {
      if (Array.isArray(aChunk))
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      else if (aChunk[isSourceNode] || typeof aChunk == "string")
        aChunk && this.children.push(aChunk);
      else
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      return this;
    };
    SourceNode.prototype.prepend = function(aChunk) {
      if (Array.isArray(aChunk))
        for (var i2 = aChunk.length - 1; i2 >= 0; i2--)
          this.prepend(aChunk[i2]);
      else if (aChunk[isSourceNode] || typeof aChunk == "string")
        this.children.unshift(aChunk);
      else
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      return this;
    };
    SourceNode.prototype.walk = function(aFn) {
      for (var chunk, i2 = 0, len = this.children.length; i2 < len; i2++)
        chunk = this.children[i2], chunk[isSourceNode] ? chunk.walk(aFn) : chunk !== "" && aFn(chunk, {
          source: this.source,
          line: this.line,
          column: this.column,
          name: this.name
        });
    };
    SourceNode.prototype.join = function(aSep) {
      var newChildren, i2, len = this.children.length;
      if (len > 0) {
        for (newChildren = [], i2 = 0; i2 < len - 1; i2++)
          newChildren.push(this.children[i2]), newChildren.push(aSep);
        newChildren.push(this.children[i2]), this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      return lastChild[isSourceNode] ? lastChild.replaceRight(aPattern, aReplacement) : typeof lastChild == "string" ? this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement) : this.children.push("".replace(aPattern, aReplacement)), this;
    };
    SourceNode.prototype.setSourceContent = function(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function(aFn) {
      for (var i2 = 0, len = this.children.length; i2 < len; i2++)
        this.children[i2][isSourceNode] && this.children[i2].walkSourceContents(aFn);
      for (var sources = Object.keys(this.sourceContents), i2 = 0, len = sources.length; i2 < len; i2++)
        aFn(util.fromSetString(sources[i2]), this.sourceContents[sources[i2]]);
    };
    SourceNode.prototype.toString = function() {
      var str = "";
      return this.walk(function(chunk) {
        str += chunk;
      }), str;
    };
    SourceNode.prototype.toStringWithSourceMap = function(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      }, map = new SourceMapGenerator(aArgs), sourceMappingActive = !1, lastOriginalSource = null, lastOriginalLine = null, lastOriginalColumn = null, lastOriginalName = null;
      return this.walk(function(chunk, original) {
        generated.code += chunk, original.source !== null && original.line !== null && original.column !== null ? ((lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) && map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        }), lastOriginalSource = original.source, lastOriginalLine = original.line, lastOriginalColumn = original.column, lastOriginalName = original.name, sourceMappingActive = !0) : sourceMappingActive && (map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        }), lastOriginalSource = null, sourceMappingActive = !1);
        for (var idx = 0, length = chunk.length; idx < length; idx++)
          chunk.charCodeAt(idx) === NEWLINE_CODE ? (generated.line++, generated.column = 0, idx + 1 === length ? (lastOriginalSource = null, sourceMappingActive = !1) : sourceMappingActive && map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          })) : generated.column++;
      }), this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      }), { code: generated.code, map };
    };
    exports.SourceNode = SourceNode;
  }
});

// node_modules/source-map-support/node_modules/source-map/source-map.js
var require_source_map = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/source-map.js"(exports) {
    exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports.SourceNode = require_source_node().SourceNode;
  }
});

// node_modules/buffer-from/index.js
var require_buffer_from = __commonJS({
  "node_modules/buffer-from/index.js"(exports, module2) {
    var toString = Object.prototype.toString, isModern = typeof Buffer < "u" && typeof Buffer.alloc == "function" && typeof Buffer.allocUnsafe == "function" && typeof Buffer.from == "function";
    function isArrayBuffer(input) {
      return toString.call(input).slice(8, -1) === "ArrayBuffer";
    }
    function fromArrayBuffer(obj, byteOffset, length) {
      byteOffset >>>= 0;
      var maxLength = obj.byteLength - byteOffset;
      if (maxLength < 0)
        throw new RangeError("'offset' is out of bounds");
      if (length === void 0)
        length = maxLength;
      else if (length >>>= 0, length > maxLength)
        throw new RangeError("'length' is out of bounds");
      return isModern ? Buffer.from(obj.slice(byteOffset, byteOffset + length)) : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)));
    }
    function fromString(string, encoding) {
      if ((typeof encoding != "string" || encoding === "") && (encoding = "utf8"), !Buffer.isEncoding(encoding))
        throw new TypeError('"encoding" must be a valid string encoding');
      return isModern ? Buffer.from(string, encoding) : new Buffer(string, encoding);
    }
    function bufferFrom(value, encodingOrOffset, length) {
      if (typeof value == "number")
        throw new TypeError('"value" argument must not be a number');
      return isArrayBuffer(value) ? fromArrayBuffer(value, encodingOrOffset, length) : typeof value == "string" ? fromString(value, encodingOrOffset) : isModern ? Buffer.from(value) : new Buffer(value);
    }
    module2.exports = bufferFrom;
  }
});

// node_modules/source-map-support/source-map-support.js
var require_source_map_support = __commonJS({
  "node_modules/source-map-support/source-map-support.js"(exports, module2) {
    var SourceMapConsumer = require_source_map().SourceMapConsumer, path = require("path"), fs2;
    try {
      fs2 = require("fs"), (!fs2.existsSync || !fs2.readFileSync) && (fs2 = null);
    } catch {
    }
    var bufferFrom = require_buffer_from();
    function dynamicRequire(mod, request) {
      return mod.require(request);
    }
    var errorFormatterInstalled = !1, uncaughtShimInstalled = !1, emptyCacheBetweenOperations = !1, environment = "auto", fileContentsCache = {}, sourceMapCache = {}, reSourceMap = /^data:application\/json[^,]+base64,/, retrieveFileHandlers = [], retrieveMapHandlers = [];
    function isInBrowser() {
      return environment === "browser" ? !0 : environment === "node" ? !1 : typeof window < "u" && typeof XMLHttpRequest == "function" && !(window.require && window.module && window.process && window.process.type === "renderer");
    }
    function hasGlobalProcessEventEmitter() {
      return typeof process == "object" && process !== null && typeof process.on == "function";
    }
    function globalProcessVersion() {
      return typeof process == "object" && process !== null ? process.version : "";
    }
    function globalProcessStderr() {
      if (typeof process == "object" && process !== null)
        return process.stderr;
    }
    function globalProcessExit(code) {
      if (typeof process == "object" && process !== null && typeof process.exit == "function")
        return process.exit(code);
    }
    function handlerExec(list2) {
      return function(arg) {
        for (var i2 = 0; i2 < list2.length; i2++) {
          var ret = list2[i2](arg);
          if (ret)
            return ret;
        }
        return null;
      };
    }
    var retrieveFile = handlerExec(retrieveFileHandlers);
    retrieveFileHandlers.push(function(path2) {
      if (path2 = path2.trim(), /^file:/.test(path2) && (path2 = path2.replace(/file:\/\/\/(\w:)?/, function(protocol, drive) {
        return drive ? "" : (
          // file:///C:/dir/file -> C:/dir/file
          "/"
        );
      })), path2 in fileContentsCache)
        return fileContentsCache[path2];
      var contents = "";
      try {
        if (fs2)
          fs2.existsSync(path2) && (contents = fs2.readFileSync(path2, "utf8"));
        else {
          var xhr = new XMLHttpRequest();
          xhr.open(
            "GET",
            path2,
            /** async */
            !1
          ), xhr.send(null), xhr.readyState === 4 && xhr.status === 200 && (contents = xhr.responseText);
        }
      } catch {
      }
      return fileContentsCache[path2] = contents;
    });
    function supportRelativeURL(file, url) {
      if (!file)
        return url;
      var dir = path.dirname(file), match = /^\w+:\/\/[^\/]*/.exec(dir), protocol = match ? match[0] : "", startPath = dir.slice(protocol.length);
      return protocol && /^\/\w\:/.test(startPath) ? (protocol += "/", protocol + path.resolve(dir.slice(protocol.length), url).replace(/\\/g, "/")) : protocol + path.resolve(dir.slice(protocol.length), url);
    }
    function retrieveSourceMapURL(source) {
      var fileData;
      if (isInBrowser())
        try {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", source, !1), xhr.send(null), fileData = xhr.readyState === 4 ? xhr.responseText : null;
          var sourceMapHeader = xhr.getResponseHeader("SourceMap") || xhr.getResponseHeader("X-SourceMap");
          if (sourceMapHeader)
            return sourceMapHeader;
        } catch {
        }
      fileData = retrieveFile(source);
      for (var re = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/mg, lastMatch, match; match = re.exec(fileData); )
        lastMatch = match;
      return lastMatch ? lastMatch[1] : null;
    }
    var retrieveSourceMap = handlerExec(retrieveMapHandlers);
    retrieveMapHandlers.push(function(source) {
      var sourceMappingURL = retrieveSourceMapURL(source);
      if (!sourceMappingURL)
        return null;
      var sourceMapData;
      if (reSourceMap.test(sourceMappingURL)) {
        var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(",") + 1);
        sourceMapData = bufferFrom(rawData, "base64").toString(), sourceMappingURL = source;
      } else
        sourceMappingURL = supportRelativeURL(source, sourceMappingURL), sourceMapData = retrieveFile(sourceMappingURL);
      return sourceMapData ? {
        url: sourceMappingURL,
        map: sourceMapData
      } : null;
    });
    function mapSourcePosition(position) {
      var sourceMap = sourceMapCache[position.source];
      if (!sourceMap) {
        var urlAndMap = retrieveSourceMap(position.source);
        urlAndMap ? (sourceMap = sourceMapCache[position.source] = {
          url: urlAndMap.url,
          map: new SourceMapConsumer(urlAndMap.map)
        }, sourceMap.map.sourcesContent && sourceMap.map.sources.forEach(function(source, i2) {
          var contents = sourceMap.map.sourcesContent[i2];
          if (contents) {
            var url = supportRelativeURL(sourceMap.url, source);
            fileContentsCache[url] = contents;
          }
        })) : sourceMap = sourceMapCache[position.source] = {
          url: null,
          map: null
        };
      }
      if (sourceMap && sourceMap.map && typeof sourceMap.map.originalPositionFor == "function") {
        var originalPosition = sourceMap.map.originalPositionFor(position);
        if (originalPosition.source !== null)
          return originalPosition.source = supportRelativeURL(
            sourceMap.url,
            originalPosition.source
          ), originalPosition;
      }
      return position;
    }
    function mapEvalOrigin(origin) {
      var match = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
      if (match) {
        var position = mapSourcePosition({
          source: match[2],
          line: +match[3],
          column: match[4] - 1
        });
        return "eval at " + match[1] + " (" + position.source + ":" + position.line + ":" + (position.column + 1) + ")";
      }
      return match = /^eval at ([^(]+) \((.+)\)$/.exec(origin), match ? "eval at " + match[1] + " (" + mapEvalOrigin(match[2]) + ")" : origin;
    }
    function CallSiteToString() {
      var fileName, fileLocation = "";
      if (this.isNative())
        fileLocation = "native";
      else {
        fileName = this.getScriptNameOrSourceURL(), !fileName && this.isEval() && (fileLocation = this.getEvalOrigin(), fileLocation += ", "), fileName ? fileLocation += fileName : fileLocation += "<anonymous>";
        var lineNumber = this.getLineNumber();
        if (lineNumber != null) {
          fileLocation += ":" + lineNumber;
          var columnNumber = this.getColumnNumber();
          columnNumber && (fileLocation += ":" + columnNumber);
        }
      }
      var line = "", functionName = this.getFunctionName(), addSuffix = !0, isConstructor = this.isConstructor(), isMethodCall = !(this.isToplevel() || isConstructor);
      if (isMethodCall) {
        var typeName = this.getTypeName();
        typeName === "[object Object]" && (typeName = "null");
        var methodName = this.getMethodName();
        functionName ? (typeName && functionName.indexOf(typeName) != 0 && (line += typeName + "."), line += functionName, methodName && functionName.indexOf("." + methodName) != functionName.length - methodName.length - 1 && (line += " [as " + methodName + "]")) : line += typeName + "." + (methodName || "<anonymous>");
      } else
        isConstructor ? line += "new " + (functionName || "<anonymous>") : functionName ? line += functionName : (line += fileLocation, addSuffix = !1);
      return addSuffix && (line += " (" + fileLocation + ")"), line;
    }
    function cloneCallSite(frame) {
      var object = {};
      return Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function(name) {
        object[name] = /^(?:is|get)/.test(name) ? function() {
          return frame[name].call(frame);
        } : frame[name];
      }), object.toString = CallSiteToString, object;
    }
    function wrapCallSite(frame, state) {
      if (state === void 0 && (state = { nextPosition: null, curPosition: null }), frame.isNative())
        return state.curPosition = null, frame;
      var source = frame.getFileName() || frame.getScriptNameOrSourceURL();
      if (source) {
        var line = frame.getLineNumber(), column = frame.getColumnNumber() - 1, noHeader = /^v(10\.1[6-9]|10\.[2-9][0-9]|10\.[0-9]{3,}|1[2-9]\d*|[2-9]\d|\d{3,}|11\.11)/, headerLength = noHeader.test(globalProcessVersion()) ? 0 : 62;
        line === 1 && column > headerLength && !isInBrowser() && !frame.isEval() && (column -= headerLength);
        var position = mapSourcePosition({
          source,
          line,
          column
        });
        state.curPosition = position, frame = cloneCallSite(frame);
        var originalFunctionName = frame.getFunctionName;
        return frame.getFunctionName = function() {
          return state.nextPosition == null ? originalFunctionName() : state.nextPosition.name || originalFunctionName();
        }, frame.getFileName = function() {
          return position.source;
        }, frame.getLineNumber = function() {
          return position.line;
        }, frame.getColumnNumber = function() {
          return position.column + 1;
        }, frame.getScriptNameOrSourceURL = function() {
          return position.source;
        }, frame;
      }
      var origin = frame.isEval() && frame.getEvalOrigin();
      return origin && (origin = mapEvalOrigin(origin), frame = cloneCallSite(frame), frame.getEvalOrigin = function() {
        return origin;
      }), frame;
    }
    function prepareStackTrace(error, stack) {
      emptyCacheBetweenOperations && (fileContentsCache = {}, sourceMapCache = {});
      for (var name = error.name || "Error", message = error.message || "", errorString = name + ": " + message, state = { nextPosition: null, curPosition: null }, processedStack = [], i2 = stack.length - 1; i2 >= 0; i2--)
        processedStack.push(`
    at ` + wrapCallSite(stack[i2], state)), state.nextPosition = state.curPosition;
      return state.curPosition = state.nextPosition = null, errorString + processedStack.reverse().join("");
    }
    function getErrorSource(error) {
      var match = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(error.stack);
      if (match) {
        var source = match[1], line = +match[2], column = +match[3], contents = fileContentsCache[source];
        if (!contents && fs2 && fs2.existsSync(source))
          try {
            contents = fs2.readFileSync(source, "utf8");
          } catch {
            contents = "";
          }
        if (contents) {
          var code = contents.split(/(?:\r\n|\r|\n)/)[line - 1];
          if (code)
            return source + ":" + line + `
` + code + `
` + new Array(column).join(" ") + "^";
        }
      }
      return null;
    }
    function printErrorAndExit(error) {
      var source = getErrorSource(error), stderr = globalProcessStderr();
      stderr && stderr._handle && stderr._handle.setBlocking && stderr._handle.setBlocking(!0), source && (console.error(), console.error(source)), console.error(error.stack), globalProcessExit(1);
    }
    function shimEmitUncaughtException() {
      var origEmit = process.emit;
      process.emit = function(type) {
        if (type === "uncaughtException") {
          var hasStack = arguments[1] && arguments[1].stack, hasListeners = this.listeners(type).length > 0;
          if (hasStack && !hasListeners)
            return printErrorAndExit(arguments[1]);
        }
        return origEmit.apply(this, arguments);
      };
    }
    var originalRetrieveFileHandlers = retrieveFileHandlers.slice(0), originalRetrieveMapHandlers = retrieveMapHandlers.slice(0);
    exports.wrapCallSite = wrapCallSite;
    exports.getErrorSource = getErrorSource;
    exports.mapSourcePosition = mapSourcePosition;
    exports.retrieveSourceMap = retrieveSourceMap;
    exports.install = function(options) {
      if (options = options || {}, options.environment && (environment = options.environment, ["node", "browser", "auto"].indexOf(environment) === -1))
        throw new Error("environment " + environment + " was unknown. Available options are {auto, browser, node}");
      if (options.retrieveFile && (options.overrideRetrieveFile && (retrieveFileHandlers.length = 0), retrieveFileHandlers.unshift(options.retrieveFile)), options.retrieveSourceMap && (options.overrideRetrieveSourceMap && (retrieveMapHandlers.length = 0), retrieveMapHandlers.unshift(options.retrieveSourceMap)), options.hookRequire && !isInBrowser()) {
        var Module = dynamicRequire(module2, "module"), $compile = Module.prototype._compile;
        $compile.__sourceMapSupport || (Module.prototype._compile = function(content, filename) {
          return fileContentsCache[filename] = content, sourceMapCache[filename] = void 0, $compile.call(this, content, filename);
        }, Module.prototype._compile.__sourceMapSupport = !0);
      }
      if (emptyCacheBetweenOperations || (emptyCacheBetweenOperations = "emptyCacheBetweenOperations" in options ? options.emptyCacheBetweenOperations : !1), errorFormatterInstalled || (errorFormatterInstalled = !0, Error.prepareStackTrace = prepareStackTrace), !uncaughtShimInstalled) {
        var installHandler = "handleUncaughtExceptions" in options ? options.handleUncaughtExceptions : !0;
        try {
          var worker_threads = dynamicRequire(module2, "worker_threads");
          worker_threads.isMainThread === !1 && (installHandler = !1);
        } catch {
        }
        installHandler && hasGlobalProcessEventEmitter() && (uncaughtShimInstalled = !0, shimEmitUncaughtException());
      }
    };
    exports.resetRetrieveHandlers = function() {
      retrieveFileHandlers.length = 0, retrieveMapHandlers.length = 0, retrieveFileHandlers = originalRetrieveFileHandlers.slice(0), retrieveMapHandlers = originalRetrieveMapHandlers.slice(0), retrieveSourceMap = handlerExec(retrieveMapHandlers), retrieveFile = handlerExec(retrieveFileHandlers);
    };
  }
});

// node_modules/event-target-shim/dist/event-target-shim.js
var require_event_target_shim = __commonJS({
  "node_modules/event-target-shim/dist/event-target-shim.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var privateData = /* @__PURE__ */ new WeakMap(), wrappers = /* @__PURE__ */ new WeakMap();
    function pd(event) {
      let retv = privateData.get(event);
      return console.assert(
        retv != null,
        "'this' is expected an Event object, but got",
        event
      ), retv;
    }
    function setCancelFlag(data) {
      if (data.passiveListener != null) {
        typeof console < "u" && typeof console.error == "function" && console.error(
          "Unable to preventDefault inside passive event listener invocation.",
          data.passiveListener
        );
        return;
      }
      data.event.cancelable && (data.canceled = !0, typeof data.event.preventDefault == "function" && data.event.preventDefault());
    }
    function Event(eventTarget, event) {
      privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: !1,
        stopped: !1,
        immediateStopped: !1,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now()
      }), Object.defineProperty(this, "isTrusted", { value: !1, enumerable: !0 });
      let keys = Object.keys(event);
      for (let i2 = 0; i2 < keys.length; ++i2) {
        let key = keys[i2];
        key in this || Object.defineProperty(this, key, defineRedirectDescriptor(key));
      }
    }
    Event.prototype = {
      /**
       * The type of this event.
       * @type {string}
       */
      get type() {
        return pd(this).event.type;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get target() {
        return pd(this).eventTarget;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get currentTarget() {
        return pd(this).currentTarget;
      },
      /**
       * @returns {EventTarget[]} The composed path of this event.
       */
      composedPath() {
        let currentTarget = pd(this).currentTarget;
        return currentTarget == null ? [] : [currentTarget];
      },
      /**
       * Constant of NONE.
       * @type {number}
       */
      get NONE() {
        return 0;
      },
      /**
       * Constant of CAPTURING_PHASE.
       * @type {number}
       */
      get CAPTURING_PHASE() {
        return 1;
      },
      /**
       * Constant of AT_TARGET.
       * @type {number}
       */
      get AT_TARGET() {
        return 2;
      },
      /**
       * Constant of BUBBLING_PHASE.
       * @type {number}
       */
      get BUBBLING_PHASE() {
        return 3;
      },
      /**
       * The target of this event.
       * @type {number}
       */
      get eventPhase() {
        return pd(this).eventPhase;
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopPropagation() {
        let data = pd(this);
        data.stopped = !0, typeof data.event.stopPropagation == "function" && data.event.stopPropagation();
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopImmediatePropagation() {
        let data = pd(this);
        data.stopped = !0, data.immediateStopped = !0, typeof data.event.stopImmediatePropagation == "function" && data.event.stopImmediatePropagation();
      },
      /**
       * The flag to be bubbling.
       * @type {boolean}
       */
      get bubbles() {
        return Boolean(pd(this).event.bubbles);
      },
      /**
       * The flag to be cancelable.
       * @type {boolean}
       */
      get cancelable() {
        return Boolean(pd(this).event.cancelable);
      },
      /**
       * Cancel this event.
       * @returns {void}
       */
      preventDefault() {
        setCancelFlag(pd(this));
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       */
      get defaultPrevented() {
        return pd(this).canceled;
      },
      /**
       * The flag to be composed.
       * @type {boolean}
       */
      get composed() {
        return Boolean(pd(this).event.composed);
      },
      /**
       * The unix time of this event.
       * @type {number}
       */
      get timeStamp() {
        return pd(this).timeStamp;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       * @deprecated
       */
      get srcElement() {
        return pd(this).eventTarget;
      },
      /**
       * The flag to stop event bubbling.
       * @type {boolean}
       * @deprecated
       */
      get cancelBubble() {
        return pd(this).stopped;
      },
      set cancelBubble(value) {
        if (!value)
          return;
        let data = pd(this);
        data.stopped = !0, typeof data.event.cancelBubble == "boolean" && (data.event.cancelBubble = !0);
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       * @deprecated
       */
      get returnValue() {
        return !pd(this).canceled;
      },
      set returnValue(value) {
        value || setCancelFlag(pd(this));
      },
      /**
       * Initialize this event object. But do nothing under event dispatching.
       * @param {string} type The event type.
       * @param {boolean} [bubbles=false] The flag to be possible to bubble up.
       * @param {boolean} [cancelable=false] The flag to be possible to cancel.
       * @deprecated
       */
      initEvent() {
      }
    };
    Object.defineProperty(Event.prototype, "constructor", {
      value: Event,
      configurable: !0,
      writable: !0
    });
    typeof window < "u" && typeof window.Event < "u" && (Object.setPrototypeOf(Event.prototype, window.Event.prototype), wrappers.set(window.Event.prototype, Event));
    function defineRedirectDescriptor(key) {
      return {
        get() {
          return pd(this).event[key];
        },
        set(value) {
          pd(this).event[key] = value;
        },
        configurable: !0,
        enumerable: !0
      };
    }
    function defineCallDescriptor(key) {
      return {
        value() {
          let event = pd(this).event;
          return event[key].apply(event, arguments);
        },
        configurable: !0,
        enumerable: !0
      };
    }
    function defineWrapper(BaseEvent, proto) {
      let keys = Object.keys(proto);
      if (keys.length === 0)
        return BaseEvent;
      function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
      }
      CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: !0, writable: !0 }
      });
      for (let i2 = 0; i2 < keys.length; ++i2) {
        let key = keys[i2];
        if (!(key in BaseEvent.prototype)) {
          let isFunc = typeof Object.getOwnPropertyDescriptor(proto, key).value == "function";
          Object.defineProperty(
            CustomEvent.prototype,
            key,
            isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key)
          );
        }
      }
      return CustomEvent;
    }
    function getWrapper(proto) {
      if (proto == null || proto === Object.prototype)
        return Event;
      let wrapper = wrappers.get(proto);
      return wrapper == null && (wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto), wrappers.set(proto, wrapper)), wrapper;
    }
    function wrapEvent(eventTarget, event) {
      let Wrapper = getWrapper(Object.getPrototypeOf(event));
      return new Wrapper(eventTarget, event);
    }
    function isStopped(event) {
      return pd(event).immediateStopped;
    }
    function setEventPhase(event, eventPhase) {
      pd(event).eventPhase = eventPhase;
    }
    function setCurrentTarget(event, currentTarget) {
      pd(event).currentTarget = currentTarget;
    }
    function setPassiveListener(event, passiveListener) {
      pd(event).passiveListener = passiveListener;
    }
    var listenersMap = /* @__PURE__ */ new WeakMap(), CAPTURE = 1, BUBBLE = 2, ATTRIBUTE = 3;
    function isObject2(x2) {
      return x2 !== null && typeof x2 == "object";
    }
    function getListeners(eventTarget) {
      let listeners = listenersMap.get(eventTarget);
      if (listeners == null)
        throw new TypeError(
          "'this' is expected an EventTarget object, but got another value."
        );
      return listeners;
    }
    function defineEventAttributeDescriptor(eventName) {
      return {
        get() {
          let node = getListeners(this).get(eventName);
          for (; node != null; ) {
            if (node.listenerType === ATTRIBUTE)
              return node.listener;
            node = node.next;
          }
          return null;
        },
        set(listener) {
          typeof listener != "function" && !isObject2(listener) && (listener = null);
          let listeners = getListeners(this), prev = null, node = listeners.get(eventName);
          for (; node != null; )
            node.listenerType === ATTRIBUTE ? prev !== null ? prev.next = node.next : node.next !== null ? listeners.set(eventName, node.next) : listeners.delete(eventName) : prev = node, node = node.next;
          if (listener !== null) {
            let newNode = {
              listener,
              listenerType: ATTRIBUTE,
              passive: !1,
              once: !1,
              next: null
            };
            prev === null ? listeners.set(eventName, newNode) : prev.next = newNode;
          }
        },
        configurable: !0,
        enumerable: !0
      };
    }
    function defineEventAttribute(eventTargetPrototype, eventName) {
      Object.defineProperty(
        eventTargetPrototype,
        `on${eventName}`,
        defineEventAttributeDescriptor(eventName)
      );
    }
    function defineCustomEventTarget(eventNames) {
      function CustomEventTarget() {
        EventTarget.call(this);
      }
      CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: {
          value: CustomEventTarget,
          configurable: !0,
          writable: !0
        }
      });
      for (let i2 = 0; i2 < eventNames.length; ++i2)
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i2]);
      return CustomEventTarget;
    }
    function EventTarget() {
      if (this instanceof EventTarget) {
        listenersMap.set(this, /* @__PURE__ */ new Map());
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0]))
        return defineCustomEventTarget(arguments[0]);
      if (arguments.length > 0) {
        let types3 = new Array(arguments.length);
        for (let i2 = 0; i2 < arguments.length; ++i2)
          types3[i2] = arguments[i2];
        return defineCustomEventTarget(types3);
      }
      throw new TypeError("Cannot call a class as a function");
    }
    EventTarget.prototype = {
      /**
       * Add a given listener to this event target.
       * @param {string} eventName The event name to add.
       * @param {Function} listener The listener to add.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      addEventListener(eventName, listener, options) {
        if (listener == null)
          return;
        if (typeof listener != "function" && !isObject2(listener))
          throw new TypeError("'listener' should be a function or an object.");
        let listeners = getListeners(this), optionsIsObj = isObject2(options), listenerType = Boolean(optionsIsObj ? options.capture : options) ? CAPTURE : BUBBLE, newNode = {
          listener,
          listenerType,
          passive: optionsIsObj && Boolean(options.passive),
          once: optionsIsObj && Boolean(options.once),
          next: null
        }, node = listeners.get(eventName);
        if (node === void 0) {
          listeners.set(eventName, newNode);
          return;
        }
        let prev = null;
        for (; node != null; ) {
          if (node.listener === listener && node.listenerType === listenerType)
            return;
          prev = node, node = node.next;
        }
        prev.next = newNode;
      },
      /**
       * Remove a given listener from this event target.
       * @param {string} eventName The event name to remove.
       * @param {Function} listener The listener to remove.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      removeEventListener(eventName, listener, options) {
        if (listener == null)
          return;
        let listeners = getListeners(this), listenerType = (isObject2(options) ? Boolean(options.capture) : Boolean(options)) ? CAPTURE : BUBBLE, prev = null, node = listeners.get(eventName);
        for (; node != null; ) {
          if (node.listener === listener && node.listenerType === listenerType) {
            prev !== null ? prev.next = node.next : node.next !== null ? listeners.set(eventName, node.next) : listeners.delete(eventName);
            return;
          }
          prev = node, node = node.next;
        }
      },
      /**
       * Dispatch a given event.
       * @param {Event|{type:string}} event The event to dispatch.
       * @returns {boolean} `false` if canceled.
       */
      dispatchEvent(event) {
        if (event == null || typeof event.type != "string")
          throw new TypeError('"event.type" should be a string.');
        let listeners = getListeners(this), eventName = event.type, node = listeners.get(eventName);
        if (node == null)
          return !0;
        let wrappedEvent = wrapEvent(this, event), prev = null;
        for (; node != null; ) {
          if (node.once ? prev !== null ? prev.next = node.next : node.next !== null ? listeners.set(eventName, node.next) : listeners.delete(eventName) : prev = node, setPassiveListener(
            wrappedEvent,
            node.passive ? node.listener : null
          ), typeof node.listener == "function")
            try {
              node.listener.call(this, wrappedEvent);
            } catch (err) {
              typeof console < "u" && typeof console.error == "function" && console.error(err);
            }
          else
            node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent == "function" && node.listener.handleEvent(wrappedEvent);
          if (isStopped(wrappedEvent))
            break;
          node = node.next;
        }
        return setPassiveListener(wrappedEvent, null), setEventPhase(wrappedEvent, 0), setCurrentTarget(wrappedEvent, null), !wrappedEvent.defaultPrevented;
      }
    };
    Object.defineProperty(EventTarget.prototype, "constructor", {
      value: EventTarget,
      configurable: !0,
      writable: !0
    });
    typeof window < "u" && typeof window.EventTarget < "u" && Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
    exports.defineEventAttribute = defineEventAttribute;
    exports.EventTarget = EventTarget;
    exports.default = EventTarget;
    module2.exports = EventTarget;
    module2.exports.EventTarget = module2.exports.default = EventTarget;
    module2.exports.defineEventAttribute = defineEventAttribute;
  }
});

// node_modules/abort-controller/dist/abort-controller.js
var require_abort_controller = __commonJS({
  "node_modules/abort-controller/dist/abort-controller.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var eventTargetShim = require_event_target_shim(), AbortSignal = class extends eventTargetShim.EventTarget {
      /**
       * AbortSignal cannot be constructed directly.
       */
      constructor() {
        throw super(), new TypeError("AbortSignal cannot be constructed directly");
      }
      /**
       * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.
       */
      get aborted() {
        let aborted = abortedFlags.get(this);
        if (typeof aborted != "boolean")
          throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        return aborted;
      }
    };
    eventTargetShim.defineEventAttribute(AbortSignal.prototype, "abort");
    function createAbortSignal() {
      let signal = Object.create(AbortSignal.prototype);
      return eventTargetShim.EventTarget.call(signal), abortedFlags.set(signal, !1), signal;
    }
    function abortSignal(signal) {
      abortedFlags.get(signal) === !1 && (abortedFlags.set(signal, !0), signal.dispatchEvent({ type: "abort" }));
    }
    var abortedFlags = /* @__PURE__ */ new WeakMap();
    Object.defineProperties(AbortSignal.prototype, {
      aborted: { enumerable: !0 }
    });
    typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol" && Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {
      configurable: !0,
      value: "AbortSignal"
    });
    var AbortController2 = class {
      /**
       * Initialize this controller.
       */
      constructor() {
        signals.set(this, createAbortSignal());
      }
      /**
       * Returns the `AbortSignal` object associated with this object.
       */
      get signal() {
        return getSignal(this);
      }
      /**
       * Abort and signal to any observers that the associated activity is to be aborted.
       */
      abort() {
        abortSignal(getSignal(this));
      }
    }, signals = /* @__PURE__ */ new WeakMap();
    function getSignal(controller) {
      let signal = signals.get(controller);
      if (signal == null)
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
      return signal;
    }
    Object.defineProperties(AbortController2.prototype, {
      signal: { enumerable: !0 },
      abort: { enumerable: !0 }
    });
    typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol" && Object.defineProperty(AbortController2.prototype, Symbol.toStringTag, {
      configurable: !0,
      value: "AbortController"
    });
    exports.AbortController = AbortController2;
    exports.AbortSignal = AbortSignal;
    exports.default = AbortController2;
    module2.exports = AbortController2;
    module2.exports.AbortController = module2.exports.default = AbortController2;
    module2.exports.AbortSignal = AbortSignal;
  }
});

// node_modules/mrmime/index.js
var require_mrmime = __commonJS({
  "node_modules/mrmime/index.js"(exports) {
    var mimes = {
      ez: "application/andrew-inset",
      aw: "application/applixware",
      atom: "application/atom+xml",
      atomcat: "application/atomcat+xml",
      atomdeleted: "application/atomdeleted+xml",
      atomsvc: "application/atomsvc+xml",
      dwd: "application/atsc-dwd+xml",
      held: "application/atsc-held+xml",
      rsat: "application/atsc-rsat+xml",
      bdoc: "application/bdoc",
      xcs: "application/calendar+xml",
      ccxml: "application/ccxml+xml",
      cdfx: "application/cdfx+xml",
      cdmia: "application/cdmi-capability",
      cdmic: "application/cdmi-container",
      cdmid: "application/cdmi-domain",
      cdmio: "application/cdmi-object",
      cdmiq: "application/cdmi-queue",
      cu: "application/cu-seeme",
      mpd: "application/dash+xml",
      davmount: "application/davmount+xml",
      dbk: "application/docbook+xml",
      dssc: "application/dssc+der",
      xdssc: "application/dssc+xml",
      es: "application/ecmascript",
      ecma: "application/ecmascript",
      emma: "application/emma+xml",
      emotionml: "application/emotionml+xml",
      epub: "application/epub+zip",
      exi: "application/exi",
      fdt: "application/fdt+xml",
      pfr: "application/font-tdpfr",
      geojson: "application/geo+json",
      gml: "application/gml+xml",
      gpx: "application/gpx+xml",
      gxf: "application/gxf",
      gz: "application/gzip",
      hjson: "application/hjson",
      stk: "application/hyperstudio",
      ink: "application/inkml+xml",
      inkml: "application/inkml+xml",
      ipfix: "application/ipfix",
      its: "application/its+xml",
      jar: "application/java-archive",
      war: "application/java-archive",
      ear: "application/java-archive",
      ser: "application/java-serialized-object",
      class: "application/java-vm",
      js: "application/javascript",
      mjs: "application/javascript",
      json: "application/json",
      map: "application/json",
      json5: "application/json5",
      jsonml: "application/jsonml+json",
      jsonld: "application/ld+json",
      lgr: "application/lgr+xml",
      lostxml: "application/lost+xml",
      hqx: "application/mac-binhex40",
      cpt: "application/mac-compactpro",
      mads: "application/mads+xml",
      webmanifest: "application/manifest+json",
      mrc: "application/marc",
      mrcx: "application/marcxml+xml",
      ma: "application/mathematica",
      nb: "application/mathematica",
      mb: "application/mathematica",
      mathml: "application/mathml+xml",
      mbox: "application/mbox",
      mscml: "application/mediaservercontrol+xml",
      metalink: "application/metalink+xml",
      meta4: "application/metalink4+xml",
      mets: "application/mets+xml",
      maei: "application/mmt-aei+xml",
      musd: "application/mmt-usd+xml",
      mods: "application/mods+xml",
      m21: "application/mp21",
      mp21: "application/mp21",
      mp4s: "application/mp4",
      m4p: "application/mp4",
      doc: "application/msword",
      dot: "application/msword",
      mxf: "application/mxf",
      nq: "application/n-quads",
      nt: "application/n-triples",
      cjs: "application/node",
      bin: "application/octet-stream",
      dms: "application/octet-stream",
      lrf: "application/octet-stream",
      mar: "application/octet-stream",
      so: "application/octet-stream",
      dist: "application/octet-stream",
      distz: "application/octet-stream",
      pkg: "application/octet-stream",
      bpk: "application/octet-stream",
      dump: "application/octet-stream",
      elc: "application/octet-stream",
      deploy: "application/octet-stream",
      exe: "application/octet-stream",
      dll: "application/octet-stream",
      deb: "application/octet-stream",
      dmg: "application/octet-stream",
      iso: "application/octet-stream",
      img: "application/octet-stream",
      msi: "application/octet-stream",
      msp: "application/octet-stream",
      msm: "application/octet-stream",
      buffer: "application/octet-stream",
      oda: "application/oda",
      opf: "application/oebps-package+xml",
      ogx: "application/ogg",
      omdoc: "application/omdoc+xml",
      onetoc: "application/onenote",
      onetoc2: "application/onenote",
      onetmp: "application/onenote",
      onepkg: "application/onenote",
      oxps: "application/oxps",
      relo: "application/p2p-overlay+xml",
      xer: "application/patch-ops-error+xml",
      pdf: "application/pdf",
      pgp: "application/pgp-encrypted",
      asc: "application/pgp-signature",
      sig: "application/pgp-signature",
      prf: "application/pics-rules",
      p10: "application/pkcs10",
      p7m: "application/pkcs7-mime",
      p7c: "application/pkcs7-mime",
      p7s: "application/pkcs7-signature",
      p8: "application/pkcs8",
      ac: "application/pkix-attr-cert",
      cer: "application/pkix-cert",
      crl: "application/pkix-crl",
      pkipath: "application/pkix-pkipath",
      pki: "application/pkixcmp",
      pls: "application/pls+xml",
      ai: "application/postscript",
      eps: "application/postscript",
      ps: "application/postscript",
      provx: "application/provenance+xml",
      cww: "application/prs.cww",
      pskcxml: "application/pskc+xml",
      raml: "application/raml+yaml",
      rdf: "application/rdf+xml",
      owl: "application/rdf+xml",
      rif: "application/reginfo+xml",
      rnc: "application/relax-ng-compact-syntax",
      rl: "application/resource-lists+xml",
      rld: "application/resource-lists-diff+xml",
      rs: "application/rls-services+xml",
      rapd: "application/route-apd+xml",
      sls: "application/route-s-tsid+xml",
      rusd: "application/route-usd+xml",
      gbr: "application/rpki-ghostbusters",
      mft: "application/rpki-manifest",
      roa: "application/rpki-roa",
      rsd: "application/rsd+xml",
      rss: "application/rss+xml",
      rtf: "application/rtf",
      sbml: "application/sbml+xml",
      scq: "application/scvp-cv-request",
      scs: "application/scvp-cv-response",
      spq: "application/scvp-vp-request",
      spp: "application/scvp-vp-response",
      sdp: "application/sdp",
      senmlx: "application/senml+xml",
      sensmlx: "application/sensml+xml",
      setpay: "application/set-payment-initiation",
      setreg: "application/set-registration-initiation",
      shf: "application/shf+xml",
      siv: "application/sieve",
      sieve: "application/sieve",
      smi: "application/smil+xml",
      smil: "application/smil+xml",
      rq: "application/sparql-query",
      srx: "application/sparql-results+xml",
      gram: "application/srgs",
      grxml: "application/srgs+xml",
      sru: "application/sru+xml",
      ssdl: "application/ssdl+xml",
      ssml: "application/ssml+xml",
      swidtag: "application/swid+xml",
      tei: "application/tei+xml",
      teicorpus: "application/tei+xml",
      tfi: "application/thraud+xml",
      tsd: "application/timestamped-data",
      toml: "application/toml",
      trig: "application/trig",
      ttml: "application/ttml+xml",
      ubj: "application/ubjson",
      rsheet: "application/urc-ressheet+xml",
      td: "application/urc-targetdesc+xml",
      vxml: "application/voicexml+xml",
      wasm: "application/wasm",
      wgt: "application/widget",
      hlp: "application/winhlp",
      wsdl: "application/wsdl+xml",
      wspolicy: "application/wspolicy+xml",
      xaml: "application/xaml+xml",
      xav: "application/xcap-att+xml",
      xca: "application/xcap-caps+xml",
      xdf: "application/xcap-diff+xml",
      xel: "application/xcap-el+xml",
      xns: "application/xcap-ns+xml",
      xenc: "application/xenc+xml",
      xhtml: "application/xhtml+xml",
      xht: "application/xhtml+xml",
      xlf: "application/xliff+xml",
      xml: "application/xml",
      xsl: "application/xml",
      xsd: "application/xml",
      rng: "application/xml",
      dtd: "application/xml-dtd",
      xop: "application/xop+xml",
      xpl: "application/xproc+xml",
      xslt: "application/xml",
      xspf: "application/xspf+xml",
      mxml: "application/xv+xml",
      xhvml: "application/xv+xml",
      xvml: "application/xv+xml",
      xvm: "application/xv+xml",
      yang: "application/yang",
      yin: "application/yin+xml",
      zip: "application/zip",
      "3gpp": "video/3gpp",
      adp: "audio/adpcm",
      amr: "audio/amr",
      au: "audio/basic",
      snd: "audio/basic",
      mid: "audio/midi",
      midi: "audio/midi",
      kar: "audio/midi",
      rmi: "audio/midi",
      mxmf: "audio/mobile-xmf",
      mp3: "audio/mpeg",
      m4a: "audio/mp4",
      mp4a: "audio/mp4",
      mpga: "audio/mpeg",
      mp2: "audio/mpeg",
      mp2a: "audio/mpeg",
      m2a: "audio/mpeg",
      m3a: "audio/mpeg",
      oga: "audio/ogg",
      ogg: "audio/ogg",
      spx: "audio/ogg",
      opus: "audio/ogg",
      s3m: "audio/s3m",
      sil: "audio/silk",
      wav: "audio/wav",
      weba: "audio/webm",
      xm: "audio/xm",
      ttc: "font/collection",
      otf: "font/otf",
      ttf: "font/ttf",
      woff: "font/woff",
      woff2: "font/woff2",
      exr: "image/aces",
      apng: "image/apng",
      avif: "image/avif",
      bmp: "image/bmp",
      cgm: "image/cgm",
      drle: "image/dicom-rle",
      emf: "image/emf",
      fits: "image/fits",
      g3: "image/g3fax",
      gif: "image/gif",
      heic: "image/heic",
      heics: "image/heic-sequence",
      heif: "image/heif",
      heifs: "image/heif-sequence",
      hej2: "image/hej2k",
      hsj2: "image/hsj2",
      ief: "image/ief",
      jls: "image/jls",
      jp2: "image/jp2",
      jpg2: "image/jp2",
      jpeg: "image/jpeg",
      jpg: "image/jpeg",
      jpe: "image/jpeg",
      jph: "image/jph",
      jhc: "image/jphc",
      jpm: "image/jpm",
      jpx: "image/jpx",
      jpf: "image/jpx",
      jxr: "image/jxr",
      jxra: "image/jxra",
      jxrs: "image/jxrs",
      jxs: "image/jxs",
      jxsc: "image/jxsc",
      jxsi: "image/jxsi",
      jxss: "image/jxss",
      ktx: "image/ktx",
      ktx2: "image/ktx2",
      png: "image/png",
      btif: "image/prs.btif",
      pti: "image/prs.pti",
      sgi: "image/sgi",
      svg: "image/svg+xml",
      svgz: "image/svg+xml",
      t38: "image/t38",
      tif: "image/tiff",
      tiff: "image/tiff",
      tfx: "image/tiff-fx",
      webp: "image/webp",
      wmf: "image/wmf",
      "disposition-notification": "message/disposition-notification",
      u8msg: "message/global",
      u8dsn: "message/global-delivery-status",
      u8mdn: "message/global-disposition-notification",
      u8hdr: "message/global-headers",
      eml: "message/rfc822",
      mime: "message/rfc822",
      "3mf": "model/3mf",
      gltf: "model/gltf+json",
      glb: "model/gltf-binary",
      igs: "model/iges",
      iges: "model/iges",
      msh: "model/mesh",
      mesh: "model/mesh",
      silo: "model/mesh",
      mtl: "model/mtl",
      obj: "model/obj",
      stpz: "model/step+zip",
      stpxz: "model/step-xml+zip",
      stl: "model/stl",
      wrl: "model/vrml",
      vrml: "model/vrml",
      x3db: "model/x3d+fastinfoset",
      x3dbz: "model/x3d+binary",
      x3dv: "model/x3d-vrml",
      x3dvz: "model/x3d+vrml",
      x3d: "model/x3d+xml",
      x3dz: "model/x3d+xml",
      appcache: "text/cache-manifest",
      manifest: "text/cache-manifest",
      ics: "text/calendar",
      ifb: "text/calendar",
      coffee: "text/coffeescript",
      litcoffee: "text/coffeescript",
      css: "text/css",
      csv: "text/csv",
      html: "text/html",
      htm: "text/html",
      shtml: "text/html",
      jade: "text/jade",
      jsx: "text/jsx",
      less: "text/less",
      markdown: "text/markdown",
      md: "text/markdown",
      mml: "text/mathml",
      mdx: "text/mdx",
      n3: "text/n3",
      txt: "text/plain",
      text: "text/plain",
      conf: "text/plain",
      def: "text/plain",
      list: "text/plain",
      log: "text/plain",
      in: "text/plain",
      ini: "text/plain",
      dsc: "text/prs.lines.tag",
      rtx: "text/richtext",
      sgml: "text/sgml",
      sgm: "text/sgml",
      shex: "text/shex",
      slim: "text/slim",
      slm: "text/slim",
      spdx: "text/spdx",
      stylus: "text/stylus",
      styl: "text/stylus",
      tsv: "text/tab-separated-values",
      t: "text/troff",
      tr: "text/troff",
      roff: "text/troff",
      man: "text/troff",
      me: "text/troff",
      ms: "text/troff",
      ttl: "text/turtle",
      uri: "text/uri-list",
      uris: "text/uri-list",
      urls: "text/uri-list",
      vcard: "text/vcard",
      vtt: "text/vtt",
      yaml: "text/yaml",
      yml: "text/yaml",
      "3gp": "video/3gpp",
      "3g2": "video/3gpp2",
      h261: "video/h261",
      h263: "video/h263",
      h264: "video/h264",
      m4s: "video/iso.segment",
      jpgv: "video/jpeg",
      jpgm: "image/jpm",
      mj2: "video/mj2",
      mjp2: "video/mj2",
      ts: "video/mp2t",
      mp4: "video/mp4",
      mp4v: "video/mp4",
      mpg4: "video/mp4",
      mpeg: "video/mpeg",
      mpg: "video/mpeg",
      mpe: "video/mpeg",
      m1v: "video/mpeg",
      m2v: "video/mpeg",
      ogv: "video/ogg",
      qt: "video/quicktime",
      mov: "video/quicktime",
      webm: "video/webm"
    };
    function lookup(extn) {
      let tmp = ("" + extn).trim().toLowerCase(), idx = tmp.lastIndexOf(".");
      return mimes[~idx ? tmp.substring(++idx) : tmp];
    }
    exports.lookup = lookup;
    exports.mimes = mimes;
  }
});

// node_modules/data-uri-to-buffer/dist/src/index.js
var require_src = __commonJS({
  "node_modules/data-uri-to-buffer/dist/src/index.js"(exports, module2) {
    "use strict";
    function dataUriToBuffer2(uri) {
      if (!/^data:/i.test(uri))
        throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
      uri = uri.replace(/\r?\n/g, "");
      let firstComma = uri.indexOf(",");
      if (firstComma === -1 || firstComma <= 4)
        throw new TypeError("malformed data: URI");
      let meta = uri.substring(5, firstComma).split(";"), charset = "", base64 = !1, type = meta[0] || "text/plain", typeFull = type;
      for (let i2 = 1; i2 < meta.length; i2++)
        meta[i2] === "base64" ? base64 = !0 : (typeFull += `;${meta[i2]}`, meta[i2].indexOf("charset=") === 0 && (charset = meta[i2].substring(8)));
      !meta[0] && !charset.length && (typeFull += ";charset=US-ASCII", charset = "US-ASCII");
      let encoding = base64 ? "base64" : "ascii", data = unescape(uri.substring(firstComma + 1)), buffer = Buffer.from(data, encoding);
      return buffer.type = type, buffer.typeFull = typeFull, buffer.charset = charset, buffer;
    }
    module2.exports = dataUriToBuffer2;
  }
});

// node_modules/web-encoding/src/lib.js
var require_lib = __commonJS({
  "node_modules/web-encoding/src/lib.js"(exports) {
    "use strict";
    exports.TextEncoder = typeof TextEncoder < "u" ? TextEncoder : require("util").TextEncoder;
    exports.TextDecoder = typeof TextDecoder < "u" ? TextDecoder : require("util").TextDecoder;
  }
});

// node_modules/web-streams-polyfill/dist/ponyfill.js
var require_ponyfill = __commonJS({
  "node_modules/web-streams-polyfill/dist/ponyfill.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports == "object" && typeof module2 < "u" ? factory(exports) : typeof define == "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis < "u" ? globalThis : global2 || self, factory(global2.WebStreamsPolyfill = {}));
    })(exports, function(exports2) {
      "use strict";
      var SymbolPolyfill = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol : function(description) {
        return "Symbol(" + description + ")";
      };
      function noop2() {
      }
      function getGlobals() {
        if (typeof self < "u")
          return self;
        if (typeof window < "u")
          return window;
        if (typeof global < "u")
          return global;
      }
      var globals = getGlobals();
      function typeIsObject(x2) {
        return typeof x2 == "object" && x2 !== null || typeof x2 == "function";
      }
      var rethrowAssertionErrorRejection = noop2, originalPromise = Promise, originalPromiseThen = Promise.prototype.then, originalPromiseResolve = Promise.resolve.bind(originalPromise), originalPromiseReject = Promise.reject.bind(originalPromise);
      function newPromise(executor) {
        return new originalPromise(executor);
      }
      function promiseResolvedWith(value) {
        return originalPromiseResolve(value);
      }
      function promiseRejectedWith(reason) {
        return originalPromiseReject(reason);
      }
      function PerformPromiseThen(promise, onFulfilled, onRejected) {
        return originalPromiseThen.call(promise, onFulfilled, onRejected);
      }
      function uponPromise(promise, onFulfilled, onRejected) {
        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
      }
      function uponFulfillment(promise, onFulfilled) {
        uponPromise(promise, onFulfilled);
      }
      function uponRejection(promise, onRejected) {
        uponPromise(promise, void 0, onRejected);
      }
      function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
      }
      function setPromiseIsHandledToTrue(promise) {
        PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
      }
      var queueMicrotask = function() {
        var globalQueueMicrotask = globals && globals.queueMicrotask;
        if (typeof globalQueueMicrotask == "function")
          return globalQueueMicrotask;
        var resolvedPromise = promiseResolvedWith(void 0);
        return function(fn) {
          return PerformPromiseThen(resolvedPromise, fn);
        };
      }();
      function reflectCall(F2, V, args) {
        if (typeof F2 != "function")
          throw new TypeError("Argument is not a function");
        return Function.prototype.apply.call(F2, V, args);
      }
      function promiseCall(F2, V, args) {
        try {
          return promiseResolvedWith(reflectCall(F2, V, args));
        } catch (value) {
          return promiseRejectedWith(value);
        }
      }
      var QUEUE_MAX_ARRAY_SIZE = 16384, SimpleQueue = (
        /** @class */
        function() {
          function SimpleQueue2() {
            this._cursor = 0, this._size = 0, this._front = {
              _elements: [],
              _next: void 0
            }, this._back = this._front, this._cursor = 0, this._size = 0;
          }
          return Object.defineProperty(SimpleQueue2.prototype, "length", {
            get: function() {
              return this._size;
            },
            enumerable: !1,
            configurable: !0
          }), SimpleQueue2.prototype.push = function(element) {
            var oldBack = this._back, newBack = oldBack;
            oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1 && (newBack = {
              _elements: [],
              _next: void 0
            }), oldBack._elements.push(element), newBack !== oldBack && (this._back = newBack, oldBack._next = newBack), ++this._size;
          }, SimpleQueue2.prototype.shift = function() {
            var oldFront = this._front, newFront = oldFront, oldCursor = this._cursor, newCursor = oldCursor + 1, elements = oldFront._elements, element = elements[oldCursor];
            return newCursor === QUEUE_MAX_ARRAY_SIZE && (newFront = oldFront._next, newCursor = 0), --this._size, this._cursor = newCursor, oldFront !== newFront && (this._front = newFront), elements[oldCursor] = void 0, element;
          }, SimpleQueue2.prototype.forEach = function(callback) {
            for (var i2 = this._cursor, node = this._front, elements = node._elements; (i2 !== elements.length || node._next !== void 0) && !(i2 === elements.length && (node = node._next, elements = node._elements, i2 = 0, elements.length === 0)); )
              callback(elements[i2]), ++i2;
          }, SimpleQueue2.prototype.peek = function() {
            var front = this._front, cursor = this._cursor;
            return front._elements[cursor];
          }, SimpleQueue2;
        }()
      );
      function ReadableStreamReaderGenericInitialize(reader, stream) {
        reader._ownerReadableStream = stream, stream._reader = reader, stream._state === "readable" ? defaultReaderClosedPromiseInitialize(reader) : stream._state === "closed" ? defaultReaderClosedPromiseInitializeAsResolved(reader) : defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
      }
      function ReadableStreamReaderGenericCancel(reader, reason) {
        var stream = reader._ownerReadableStream;
        return ReadableStreamCancel(stream, reason);
      }
      function ReadableStreamReaderGenericRelease(reader) {
        reader._ownerReadableStream._state === "readable" ? defaultReaderClosedPromiseReject(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : defaultReaderClosedPromiseResetToRejected(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), reader._ownerReadableStream._reader = void 0, reader._ownerReadableStream = void 0;
      }
      function readerLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released reader");
      }
      function defaultReaderClosedPromiseInitialize(reader) {
        reader._closedPromise = newPromise(function(resolve, reject) {
          reader._closedPromise_resolve = resolve, reader._closedPromise_reject = reject;
        });
      }
      function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
        defaultReaderClosedPromiseInitialize(reader), defaultReaderClosedPromiseReject(reader, reason);
      }
      function defaultReaderClosedPromiseInitializeAsResolved(reader) {
        defaultReaderClosedPromiseInitialize(reader), defaultReaderClosedPromiseResolve(reader);
      }
      function defaultReaderClosedPromiseReject(reader, reason) {
        reader._closedPromise_reject !== void 0 && (setPromiseIsHandledToTrue(reader._closedPromise), reader._closedPromise_reject(reason), reader._closedPromise_resolve = void 0, reader._closedPromise_reject = void 0);
      }
      function defaultReaderClosedPromiseResetToRejected(reader, reason) {
        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
      }
      function defaultReaderClosedPromiseResolve(reader) {
        reader._closedPromise_resolve !== void 0 && (reader._closedPromise_resolve(void 0), reader._closedPromise_resolve = void 0, reader._closedPromise_reject = void 0);
      }
      var AbortSteps = SymbolPolyfill("[[AbortSteps]]"), ErrorSteps = SymbolPolyfill("[[ErrorSteps]]"), CancelSteps = SymbolPolyfill("[[CancelSteps]]"), PullSteps = SymbolPolyfill("[[PullSteps]]"), NumberIsFinite = Number.isFinite || function(x2) {
        return typeof x2 == "number" && isFinite(x2);
      }, MathTrunc = Math.trunc || function(v) {
        return v < 0 ? Math.ceil(v) : Math.floor(v);
      };
      function isDictionary(x2) {
        return typeof x2 == "object" || typeof x2 == "function";
      }
      function assertDictionary(obj, context) {
        if (obj !== void 0 && !isDictionary(obj))
          throw new TypeError(context + " is not an object.");
      }
      function assertFunction(x2, context) {
        if (typeof x2 != "function")
          throw new TypeError(context + " is not a function.");
      }
      function isObject2(x2) {
        return typeof x2 == "object" && x2 !== null || typeof x2 == "function";
      }
      function assertObject(x2, context) {
        if (!isObject2(x2))
          throw new TypeError(context + " is not an object.");
      }
      function assertRequiredArgument(x2, position, context) {
        if (x2 === void 0)
          throw new TypeError("Parameter " + position + " is required in '" + context + "'.");
      }
      function assertRequiredField(x2, field, context) {
        if (x2 === void 0)
          throw new TypeError(field + " is required in '" + context + "'.");
      }
      function convertUnrestrictedDouble(value) {
        return Number(value);
      }
      function censorNegativeZero(x2) {
        return x2 === 0 ? 0 : x2;
      }
      function integerPart(x2) {
        return censorNegativeZero(MathTrunc(x2));
      }
      function convertUnsignedLongLongWithEnforceRange(value, context) {
        var lowerBound = 0, upperBound = Number.MAX_SAFE_INTEGER, x2 = Number(value);
        if (x2 = censorNegativeZero(x2), !NumberIsFinite(x2))
          throw new TypeError(context + " is not a finite number");
        if (x2 = integerPart(x2), x2 < lowerBound || x2 > upperBound)
          throw new TypeError(context + " is outside the accepted range of " + lowerBound + " to " + upperBound + ", inclusive");
        return !NumberIsFinite(x2) || x2 === 0 ? 0 : x2;
      }
      function assertReadableStream(x2, context) {
        if (!IsReadableStream(x2))
          throw new TypeError(context + " is not a ReadableStream.");
      }
      function AcquireReadableStreamDefaultReader(stream) {
        return new ReadableStreamDefaultReader(stream);
      }
      function ReadableStreamAddReadRequest(stream, readRequest) {
        stream._reader._readRequests.push(readRequest);
      }
      function ReadableStreamFulfillReadRequest(stream, chunk, done) {
        var reader = stream._reader, readRequest = reader._readRequests.shift();
        done ? readRequest._closeSteps() : readRequest._chunkSteps(chunk);
      }
      function ReadableStreamGetNumReadRequests(stream) {
        return stream._reader._readRequests.length;
      }
      function ReadableStreamHasDefaultReader(stream) {
        var reader = stream._reader;
        return !(reader === void 0 || !IsReadableStreamDefaultReader(reader));
      }
      var ReadableStreamDefaultReader = (
        /** @class */
        function() {
          function ReadableStreamDefaultReader2(stream) {
            if (assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader"), assertReadableStream(stream, "First parameter"), IsReadableStreamLocked(stream))
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            ReadableStreamReaderGenericInitialize(this, stream), this._readRequests = new SimpleQueue();
          }
          return Object.defineProperty(ReadableStreamDefaultReader2.prototype, "closed", {
            /**
             * Returns a promise that will be fulfilled when the stream becomes closed,
             * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
             */
            get: function() {
              return IsReadableStreamDefaultReader(this) ? this._closedPromise : promiseRejectedWith(defaultReaderBrandCheckException("closed"));
            },
            enumerable: !1,
            configurable: !0
          }), ReadableStreamDefaultReader2.prototype.cancel = function(reason) {
            return reason === void 0 && (reason = void 0), IsReadableStreamDefaultReader(this) ? this._ownerReadableStream === void 0 ? promiseRejectedWith(readerLockException("cancel")) : ReadableStreamReaderGenericCancel(this, reason) : promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
          }, ReadableStreamDefaultReader2.prototype.read = function() {
            if (!IsReadableStreamDefaultReader(this))
              return promiseRejectedWith(defaultReaderBrandCheckException("read"));
            if (this._ownerReadableStream === void 0)
              return promiseRejectedWith(readerLockException("read from"));
            var resolvePromise, rejectPromise, promise = newPromise(function(resolve, reject) {
              resolvePromise = resolve, rejectPromise = reject;
            }), readRequest = {
              _chunkSteps: function(chunk) {
                return resolvePromise({ value: chunk, done: !1 });
              },
              _closeSteps: function() {
                return resolvePromise({ value: void 0, done: !0 });
              },
              _errorSteps: function(e2) {
                return rejectPromise(e2);
              }
            };
            return ReadableStreamDefaultReaderRead(this, readRequest), promise;
          }, ReadableStreamDefaultReader2.prototype.releaseLock = function() {
            if (!IsReadableStreamDefaultReader(this))
              throw defaultReaderBrandCheckException("releaseLock");
            if (this._ownerReadableStream !== void 0) {
              if (this._readRequests.length > 0)
                throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
              ReadableStreamReaderGenericRelease(this);
            }
          }, ReadableStreamDefaultReader2;
        }()
      );
      Object.defineProperties(ReadableStreamDefaultReader.prototype, {
        cancel: { enumerable: !0 },
        read: { enumerable: !0 },
        releaseLock: { enumerable: !0 },
        closed: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamDefaultReader",
        configurable: !0
      });
      function IsReadableStreamDefaultReader(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_readRequests") ? !1 : x2 instanceof ReadableStreamDefaultReader;
      }
      function ReadableStreamDefaultReaderRead(reader, readRequest) {
        var stream = reader._ownerReadableStream;
        stream._disturbed = !0, stream._state === "closed" ? readRequest._closeSteps() : stream._state === "errored" ? readRequest._errorSteps(stream._storedError) : stream._readableStreamController[PullSteps](readRequest);
      }
      function defaultReaderBrandCheckException(name) {
        return new TypeError("ReadableStreamDefaultReader.prototype." + name + " can only be used on a ReadableStreamDefaultReader");
      }
      var _a4, AsyncIteratorPrototype;
      typeof SymbolPolyfill.asyncIterator == "symbol" && (AsyncIteratorPrototype = (_a4 = {}, // 25.1.3.1 %AsyncIteratorPrototype% [ @@asyncIterator ] ( )
      // https://tc39.github.io/ecma262/#sec-asynciteratorprototype-asynciterator
      _a4[SymbolPolyfill.asyncIterator] = function() {
        return this;
      }, _a4), Object.defineProperty(AsyncIteratorPrototype, SymbolPolyfill.asyncIterator, { enumerable: !1 }));
      var ReadableStreamAsyncIteratorImpl = (
        /** @class */
        function() {
          function ReadableStreamAsyncIteratorImpl2(reader, preventCancel) {
            this._ongoingPromise = void 0, this._isFinished = !1, this._reader = reader, this._preventCancel = preventCancel;
          }
          return ReadableStreamAsyncIteratorImpl2.prototype.next = function() {
            var _this = this, nextSteps = function() {
              return _this._nextSteps();
            };
            return this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps(), this._ongoingPromise;
          }, ReadableStreamAsyncIteratorImpl2.prototype.return = function(value) {
            var _this = this, returnSteps = function() {
              return _this._returnSteps(value);
            };
            return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
          }, ReadableStreamAsyncIteratorImpl2.prototype._nextSteps = function() {
            var _this = this;
            if (this._isFinished)
              return Promise.resolve({ value: void 0, done: !0 });
            var reader = this._reader;
            if (reader._ownerReadableStream === void 0)
              return promiseRejectedWith(readerLockException("iterate"));
            var resolvePromise, rejectPromise, promise = newPromise(function(resolve, reject) {
              resolvePromise = resolve, rejectPromise = reject;
            }), readRequest = {
              _chunkSteps: function(chunk) {
                _this._ongoingPromise = void 0, queueMicrotask(function() {
                  return resolvePromise({ value: chunk, done: !1 });
                });
              },
              _closeSteps: function() {
                _this._ongoingPromise = void 0, _this._isFinished = !0, ReadableStreamReaderGenericRelease(reader), resolvePromise({ value: void 0, done: !0 });
              },
              _errorSteps: function(reason) {
                _this._ongoingPromise = void 0, _this._isFinished = !0, ReadableStreamReaderGenericRelease(reader), rejectPromise(reason);
              }
            };
            return ReadableStreamDefaultReaderRead(reader, readRequest), promise;
          }, ReadableStreamAsyncIteratorImpl2.prototype._returnSteps = function(value) {
            if (this._isFinished)
              return Promise.resolve({ value, done: !0 });
            this._isFinished = !0;
            var reader = this._reader;
            if (reader._ownerReadableStream === void 0)
              return promiseRejectedWith(readerLockException("finish iterating"));
            if (!this._preventCancel) {
              var result = ReadableStreamReaderGenericCancel(reader, value);
              return ReadableStreamReaderGenericRelease(reader), transformPromiseWith(result, function() {
                return { value, done: !0 };
              });
            }
            return ReadableStreamReaderGenericRelease(reader), promiseResolvedWith({ value, done: !0 });
          }, ReadableStreamAsyncIteratorImpl2;
        }()
      ), ReadableStreamAsyncIteratorPrototype = {
        next: function() {
          return IsReadableStreamAsyncIterator(this) ? this._asyncIteratorImpl.next() : promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
        },
        return: function(value) {
          return IsReadableStreamAsyncIterator(this) ? this._asyncIteratorImpl.return(value) : promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
        }
      };
      AsyncIteratorPrototype !== void 0 && Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
      function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
        var reader = AcquireReadableStreamDefaultReader(stream), impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel), iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
        return iterator._asyncIteratorImpl = impl, iterator;
      }
      function IsReadableStreamAsyncIterator(x2) {
        if (!typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_asyncIteratorImpl"))
          return !1;
        try {
          return x2._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
        } catch {
          return !1;
        }
      }
      function streamAsyncIteratorBrandCheckException(name) {
        return new TypeError("ReadableStreamAsyncIterator." + name + " can only be used on a ReadableSteamAsyncIterator");
      }
      var NumberIsNaN = Number.isNaN || function(x2) {
        return x2 !== x2;
      };
      function CreateArrayFromList(elements) {
        return elements.slice();
      }
      function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
      }
      function TransferArrayBuffer(O) {
        return O;
      }
      function IsDetachedBuffer(O) {
        return !1;
      }
      function ArrayBufferSlice(buffer, begin, end) {
        if (buffer.slice)
          return buffer.slice(begin, end);
        var length = end - begin, slice = new ArrayBuffer(length);
        return CopyDataBlockBytes(slice, 0, buffer, begin, length), slice;
      }
      function IsNonNegativeNumber(v) {
        return !(typeof v != "number" || NumberIsNaN(v) || v < 0);
      }
      function CloneAsUint8Array(O) {
        var buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
        return new Uint8Array(buffer);
      }
      function DequeueValue(container) {
        var pair = container._queue.shift();
        return container._queueTotalSize -= pair.size, container._queueTotalSize < 0 && (container._queueTotalSize = 0), pair.value;
      }
      function EnqueueValueWithSize(container, value, size) {
        if (!IsNonNegativeNumber(size) || size === 1 / 0)
          throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
        container._queue.push({ value, size }), container._queueTotalSize += size;
      }
      function PeekQueueValue(container) {
        var pair = container._queue.peek();
        return pair.value;
      }
      function ResetQueue(container) {
        container._queue = new SimpleQueue(), container._queueTotalSize = 0;
      }
      var ReadableStreamBYOBRequest = (
        /** @class */
        function() {
          function ReadableStreamBYOBRequest2() {
            throw new TypeError("Illegal constructor");
          }
          return Object.defineProperty(ReadableStreamBYOBRequest2.prototype, "view", {
            /**
             * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
             */
            get: function() {
              if (!IsReadableStreamBYOBRequest(this))
                throw byobRequestBrandCheckException("view");
              return this._view;
            },
            enumerable: !1,
            configurable: !0
          }), ReadableStreamBYOBRequest2.prototype.respond = function(bytesWritten) {
            if (!IsReadableStreamBYOBRequest(this))
              throw byobRequestBrandCheckException("respond");
            if (assertRequiredArgument(bytesWritten, 1, "respond"), bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter"), this._associatedReadableByteStreamController === void 0)
              throw new TypeError("This BYOB request has been invalidated");
            IsDetachedBuffer(this._view.buffer), ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
          }, ReadableStreamBYOBRequest2.prototype.respondWithNewView = function(view) {
            if (!IsReadableStreamBYOBRequest(this))
              throw byobRequestBrandCheckException("respondWithNewView");
            if (assertRequiredArgument(view, 1, "respondWithNewView"), !ArrayBuffer.isView(view))
              throw new TypeError("You can only respond with array buffer views");
            if (this._associatedReadableByteStreamController === void 0)
              throw new TypeError("This BYOB request has been invalidated");
            IsDetachedBuffer(view.buffer), ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
          }, ReadableStreamBYOBRequest2;
        }()
      );
      Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
        respond: { enumerable: !0 },
        respondWithNewView: { enumerable: !0 },
        view: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamBYOBRequest",
        configurable: !0
      });
      var ReadableByteStreamController = (
        /** @class */
        function() {
          function ReadableByteStreamController2() {
            throw new TypeError("Illegal constructor");
          }
          return Object.defineProperty(ReadableByteStreamController2.prototype, "byobRequest", {
            /**
             * Returns the current BYOB pull request, or `null` if there isn't one.
             */
            get: function() {
              if (!IsReadableByteStreamController(this))
                throw byteStreamControllerBrandCheckException("byobRequest");
              return ReadableByteStreamControllerGetBYOBRequest(this);
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(ReadableByteStreamController2.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
             * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
             */
            get: function() {
              if (!IsReadableByteStreamController(this))
                throw byteStreamControllerBrandCheckException("desiredSize");
              return ReadableByteStreamControllerGetDesiredSize(this);
            },
            enumerable: !1,
            configurable: !0
          }), ReadableByteStreamController2.prototype.close = function() {
            if (!IsReadableByteStreamController(this))
              throw byteStreamControllerBrandCheckException("close");
            if (this._closeRequested)
              throw new TypeError("The stream has already been closed; do not close it again!");
            var state = this._controlledReadableByteStream._state;
            if (state !== "readable")
              throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be closed");
            ReadableByteStreamControllerClose(this);
          }, ReadableByteStreamController2.prototype.enqueue = function(chunk) {
            if (!IsReadableByteStreamController(this))
              throw byteStreamControllerBrandCheckException("enqueue");
            if (assertRequiredArgument(chunk, 1, "enqueue"), !ArrayBuffer.isView(chunk))
              throw new TypeError("chunk must be an array buffer view");
            if (chunk.byteLength === 0)
              throw new TypeError("chunk must have non-zero byteLength");
            if (chunk.buffer.byteLength === 0)
              throw new TypeError("chunk's buffer must have non-zero byteLength");
            if (this._closeRequested)
              throw new TypeError("stream is closed or draining");
            var state = this._controlledReadableByteStream._state;
            if (state !== "readable")
              throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be enqueued to");
            ReadableByteStreamControllerEnqueue(this, chunk);
          }, ReadableByteStreamController2.prototype.error = function(e2) {
            if (e2 === void 0 && (e2 = void 0), !IsReadableByteStreamController(this))
              throw byteStreamControllerBrandCheckException("error");
            ReadableByteStreamControllerError(this, e2);
          }, ReadableByteStreamController2.prototype[CancelSteps] = function(reason) {
            ReadableByteStreamControllerClearPendingPullIntos(this), ResetQueue(this);
            var result = this._cancelAlgorithm(reason);
            return ReadableByteStreamControllerClearAlgorithms(this), result;
          }, ReadableByteStreamController2.prototype[PullSteps] = function(readRequest) {
            var stream = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) {
              var entry2 = this._queue.shift();
              this._queueTotalSize -= entry2.byteLength, ReadableByteStreamControllerHandleQueueDrain(this);
              var view = new Uint8Array(entry2.buffer, entry2.byteOffset, entry2.byteLength);
              readRequest._chunkSteps(view);
              return;
            }
            var autoAllocateChunkSize = this._autoAllocateChunkSize;
            if (autoAllocateChunkSize !== void 0) {
              var buffer = void 0;
              try {
                buffer = new ArrayBuffer(autoAllocateChunkSize);
              } catch (bufferE) {
                readRequest._errorSteps(bufferE);
                return;
              }
              var pullIntoDescriptor = {
                buffer,
                bufferByteLength: autoAllocateChunkSize,
                byteOffset: 0,
                byteLength: autoAllocateChunkSize,
                bytesFilled: 0,
                elementSize: 1,
                viewConstructor: Uint8Array,
                readerType: "default"
              };
              this._pendingPullIntos.push(pullIntoDescriptor);
            }
            ReadableStreamAddReadRequest(stream, readRequest), ReadableByteStreamControllerCallPullIfNeeded(this);
          }, ReadableByteStreamController2;
        }()
      );
      Object.defineProperties(ReadableByteStreamController.prototype, {
        close: { enumerable: !0 },
        enqueue: { enumerable: !0 },
        error: { enumerable: !0 },
        byobRequest: { enumerable: !0 },
        desiredSize: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableByteStreamController",
        configurable: !0
      });
      function IsReadableByteStreamController(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_controlledReadableByteStream") ? !1 : x2 instanceof ReadableByteStreamController;
      }
      function IsReadableStreamBYOBRequest(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_associatedReadableByteStreamController") ? !1 : x2 instanceof ReadableStreamBYOBRequest;
      }
      function ReadableByteStreamControllerCallPullIfNeeded(controller) {
        var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
        if (shouldPull) {
          if (controller._pulling) {
            controller._pullAgain = !0;
            return;
          }
          controller._pulling = !0;
          var pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, function() {
            controller._pulling = !1, controller._pullAgain && (controller._pullAgain = !1, ReadableByteStreamControllerCallPullIfNeeded(controller));
          }, function(e2) {
            ReadableByteStreamControllerError(controller, e2);
          });
        }
      }
      function ReadableByteStreamControllerClearPendingPullIntos(controller) {
        ReadableByteStreamControllerInvalidateBYOBRequest(controller), controller._pendingPullIntos = new SimpleQueue();
      }
      function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
        var done = !1;
        stream._state === "closed" && (done = !0);
        var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        pullIntoDescriptor.readerType === "default" ? ReadableStreamFulfillReadRequest(stream, filledView, done) : ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
      }
      function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
        var bytesFilled = pullIntoDescriptor.bytesFilled, elementSize = pullIntoDescriptor.elementSize;
        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
      }
      function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
        controller._queue.push({ buffer, byteOffset, byteLength }), controller._queueTotalSize += byteLength;
      }
      function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
        var elementSize = pullIntoDescriptor.elementSize, currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize, maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled), maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy, maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize, totalBytesToCopyRemaining = maxBytesToCopy, ready = !1;
        maxAlignedBytes > currentAlignedBytes && (totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled, ready = !0);
        for (var queue = controller._queue; totalBytesToCopyRemaining > 0; ) {
          var headOfQueue = queue.peek(), bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength), destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy), headOfQueue.byteLength === bytesToCopy ? queue.shift() : (headOfQueue.byteOffset += bytesToCopy, headOfQueue.byteLength -= bytesToCopy), controller._queueTotalSize -= bytesToCopy, ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor), totalBytesToCopyRemaining -= bytesToCopy;
        }
        return ready;
      }
      function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
        pullIntoDescriptor.bytesFilled += size;
      }
      function ReadableByteStreamControllerHandleQueueDrain(controller) {
        controller._queueTotalSize === 0 && controller._closeRequested ? (ReadableByteStreamControllerClearAlgorithms(controller), ReadableStreamClose(controller._controlledReadableByteStream)) : ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
        controller._byobRequest !== null && (controller._byobRequest._associatedReadableByteStreamController = void 0, controller._byobRequest._view = null, controller._byobRequest = null);
      }
      function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
        for (; controller._pendingPullIntos.length > 0; ) {
          if (controller._queueTotalSize === 0)
            return;
          var pullIntoDescriptor = controller._pendingPullIntos.peek();
          ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) && (ReadableByteStreamControllerShiftPendingPullInto(controller), ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor));
        }
      }
      function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
        var stream = controller._controlledReadableByteStream, elementSize = 1;
        view.constructor !== DataView && (elementSize = view.constructor.BYTES_PER_ELEMENT);
        var ctor = view.constructor, buffer = view.buffer, pullIntoDescriptor = {
          buffer,
          bufferByteLength: buffer.byteLength,
          byteOffset: view.byteOffset,
          byteLength: view.byteLength,
          bytesFilled: 0,
          elementSize,
          viewConstructor: ctor,
          readerType: "byob"
        };
        if (controller._pendingPullIntos.length > 0) {
          controller._pendingPullIntos.push(pullIntoDescriptor), ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          return;
        }
        if (stream._state === "closed") {
          var emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
          readIntoRequest._closeSteps(emptyView);
          return;
        }
        if (controller._queueTotalSize > 0) {
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
            ReadableByteStreamControllerHandleQueueDrain(controller), readIntoRequest._chunkSteps(filledView);
            return;
          }
          if (controller._closeRequested) {
            var e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e2), readIntoRequest._errorSteps(e2);
            return;
          }
        }
        controller._pendingPullIntos.push(pullIntoDescriptor), ReadableStreamAddReadIntoRequest(stream, readIntoRequest), ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
        var stream = controller._controlledReadableByteStream;
        if (ReadableStreamHasBYOBReader(stream))
          for (; ReadableStreamGetNumReadIntoRequests(stream) > 0; ) {
            var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
          }
      }
      function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
        if (ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor), !(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize)) {
          ReadableByteStreamControllerShiftPendingPullInto(controller);
          var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
          if (remainderSize > 0) {
            var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled, remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
          }
          pullIntoDescriptor.bytesFilled -= remainderSize, ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor), ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        }
      }
      function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
        var firstDescriptor = controller._pendingPullIntos.peek();
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        var state = controller._controlledReadableByteStream._state;
        state === "closed" ? ReadableByteStreamControllerRespondInClosedState(controller) : ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor), ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerShiftPendingPullInto(controller) {
        var descriptor = controller._pendingPullIntos.shift();
        return descriptor;
      }
      function ReadableByteStreamControllerShouldCallPull(controller) {
        var stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable" || controller._closeRequested || !controller._started)
          return !1;
        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0 || ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0)
          return !0;
        var desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
        return desiredSize > 0;
      }
      function ReadableByteStreamControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0, controller._cancelAlgorithm = void 0;
      }
      function ReadableByteStreamControllerClose(controller) {
        var stream = controller._controlledReadableByteStream;
        if (!(controller._closeRequested || stream._state !== "readable")) {
          if (controller._queueTotalSize > 0) {
            controller._closeRequested = !0;
            return;
          }
          if (controller._pendingPullIntos.length > 0) {
            var firstPendingPullInto = controller._pendingPullIntos.peek();
            if (firstPendingPullInto.bytesFilled > 0) {
              var e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              throw ReadableByteStreamControllerError(controller, e2), e2;
            }
          }
          ReadableByteStreamControllerClearAlgorithms(controller), ReadableStreamClose(stream);
        }
      }
      function ReadableByteStreamControllerEnqueue(controller, chunk) {
        var stream = controller._controlledReadableByteStream;
        if (!(controller._closeRequested || stream._state !== "readable")) {
          var buffer = chunk.buffer, byteOffset = chunk.byteOffset, byteLength = chunk.byteLength, transferredBuffer = buffer;
          if (controller._pendingPullIntos.length > 0) {
            var firstPendingPullInto = controller._pendingPullIntos.peek();
            IsDetachedBuffer(firstPendingPullInto.buffer), firstPendingPullInto.buffer = firstPendingPullInto.buffer;
          }
          if (ReadableByteStreamControllerInvalidateBYOBRequest(controller), ReadableStreamHasDefaultReader(stream))
            if (ReadableStreamGetNumReadRequests(stream) === 0)
              ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            else {
              controller._pendingPullIntos.length > 0 && ReadableByteStreamControllerShiftPendingPullInto(controller);
              var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
              ReadableStreamFulfillReadRequest(stream, transferredView, !1);
            }
          else
            ReadableStreamHasBYOBReader(stream) ? (ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength), ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller)) : ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
      }
      function ReadableByteStreamControllerError(controller, e2) {
        var stream = controller._controlledReadableByteStream;
        stream._state === "readable" && (ReadableByteStreamControllerClearPendingPullIntos(controller), ResetQueue(controller), ReadableByteStreamControllerClearAlgorithms(controller), ReadableStreamError(stream, e2));
      }
      function ReadableByteStreamControllerGetBYOBRequest(controller) {
        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
          var firstDescriptor = controller._pendingPullIntos.peek(), view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled), byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
          SetUpReadableStreamBYOBRequest(byobRequest, controller, view), controller._byobRequest = byobRequest;
        }
        return controller._byobRequest;
      }
      function ReadableByteStreamControllerGetDesiredSize(controller) {
        var state = controller._controlledReadableByteStream._state;
        return state === "errored" ? null : state === "closed" ? 0 : controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableByteStreamControllerRespond(controller, bytesWritten) {
        var firstDescriptor = controller._pendingPullIntos.peek(), state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (bytesWritten !== 0)
            throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
        } else {
          if (bytesWritten === 0)
            throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
          if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength)
            throw new RangeError("bytesWritten out of range");
        }
        firstDescriptor.buffer = firstDescriptor.buffer, ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
      }
      function ReadableByteStreamControllerRespondWithNewView(controller, view) {
        var firstDescriptor = controller._pendingPullIntos.peek(), state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (view.byteLength !== 0)
            throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
        } else if (view.byteLength === 0)
          throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset)
          throw new RangeError("The region specified by view does not match byobRequest");
        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength)
          throw new RangeError("The buffer of view has different capacity than byobRequest");
        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength)
          throw new RangeError("The region specified by view is larger than byobRequest");
        var viewByteLength = view.byteLength;
        firstDescriptor.buffer = view.buffer, ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
      }
      function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
        controller._controlledReadableByteStream = stream, controller._pullAgain = !1, controller._pulling = !1, controller._byobRequest = null, controller._queue = controller._queueTotalSize = void 0, ResetQueue(controller), controller._closeRequested = !1, controller._started = !1, controller._strategyHWM = highWaterMark, controller._pullAlgorithm = pullAlgorithm, controller._cancelAlgorithm = cancelAlgorithm, controller._autoAllocateChunkSize = autoAllocateChunkSize, controller._pendingPullIntos = new SimpleQueue(), stream._readableStreamController = controller;
        var startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), function() {
          controller._started = !0, ReadableByteStreamControllerCallPullIfNeeded(controller);
        }, function(r2) {
          ReadableByteStreamControllerError(controller, r2);
        });
      }
      function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
        var controller = Object.create(ReadableByteStreamController.prototype), startAlgorithm = function() {
        }, pullAlgorithm = function() {
          return promiseResolvedWith(void 0);
        }, cancelAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        underlyingByteSource.start !== void 0 && (startAlgorithm = function() {
          return underlyingByteSource.start(controller);
        }), underlyingByteSource.pull !== void 0 && (pullAlgorithm = function() {
          return underlyingByteSource.pull(controller);
        }), underlyingByteSource.cancel !== void 0 && (cancelAlgorithm = function(reason) {
          return underlyingByteSource.cancel(reason);
        });
        var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
        if (autoAllocateChunkSize === 0)
          throw new TypeError("autoAllocateChunkSize must be greater than 0");
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
      }
      function SetUpReadableStreamBYOBRequest(request, controller, view) {
        request._associatedReadableByteStreamController = controller, request._view = view;
      }
      function byobRequestBrandCheckException(name) {
        return new TypeError("ReadableStreamBYOBRequest.prototype." + name + " can only be used on a ReadableStreamBYOBRequest");
      }
      function byteStreamControllerBrandCheckException(name) {
        return new TypeError("ReadableByteStreamController.prototype." + name + " can only be used on a ReadableByteStreamController");
      }
      function AcquireReadableStreamBYOBReader(stream) {
        return new ReadableStreamBYOBReader(stream);
      }
      function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
        stream._reader._readIntoRequests.push(readIntoRequest);
      }
      function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
        var reader = stream._reader, readIntoRequest = reader._readIntoRequests.shift();
        done ? readIntoRequest._closeSteps(chunk) : readIntoRequest._chunkSteps(chunk);
      }
      function ReadableStreamGetNumReadIntoRequests(stream) {
        return stream._reader._readIntoRequests.length;
      }
      function ReadableStreamHasBYOBReader(stream) {
        var reader = stream._reader;
        return !(reader === void 0 || !IsReadableStreamBYOBReader(reader));
      }
      var ReadableStreamBYOBReader = (
        /** @class */
        function() {
          function ReadableStreamBYOBReader2(stream) {
            if (assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader"), assertReadableStream(stream, "First parameter"), IsReadableStreamLocked(stream))
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            if (!IsReadableByteStreamController(stream._readableStreamController))
              throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
            ReadableStreamReaderGenericInitialize(this, stream), this._readIntoRequests = new SimpleQueue();
          }
          return Object.defineProperty(ReadableStreamBYOBReader2.prototype, "closed", {
            /**
             * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
             * the reader's lock is released before the stream finishes closing.
             */
            get: function() {
              return IsReadableStreamBYOBReader(this) ? this._closedPromise : promiseRejectedWith(byobReaderBrandCheckException("closed"));
            },
            enumerable: !1,
            configurable: !0
          }), ReadableStreamBYOBReader2.prototype.cancel = function(reason) {
            return reason === void 0 && (reason = void 0), IsReadableStreamBYOBReader(this) ? this._ownerReadableStream === void 0 ? promiseRejectedWith(readerLockException("cancel")) : ReadableStreamReaderGenericCancel(this, reason) : promiseRejectedWith(byobReaderBrandCheckException("cancel"));
          }, ReadableStreamBYOBReader2.prototype.read = function(view) {
            if (!IsReadableStreamBYOBReader(this))
              return promiseRejectedWith(byobReaderBrandCheckException("read"));
            if (!ArrayBuffer.isView(view))
              return promiseRejectedWith(new TypeError("view must be an array buffer view"));
            if (view.byteLength === 0)
              return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
            if (view.buffer.byteLength === 0)
              return promiseRejectedWith(new TypeError("view's buffer must have non-zero byteLength"));
            if (IsDetachedBuffer(view.buffer), this._ownerReadableStream === void 0)
              return promiseRejectedWith(readerLockException("read from"));
            var resolvePromise, rejectPromise, promise = newPromise(function(resolve, reject) {
              resolvePromise = resolve, rejectPromise = reject;
            }), readIntoRequest = {
              _chunkSteps: function(chunk) {
                return resolvePromise({ value: chunk, done: !1 });
              },
              _closeSteps: function(chunk) {
                return resolvePromise({ value: chunk, done: !0 });
              },
              _errorSteps: function(e2) {
                return rejectPromise(e2);
              }
            };
            return ReadableStreamBYOBReaderRead(this, view, readIntoRequest), promise;
          }, ReadableStreamBYOBReader2.prototype.releaseLock = function() {
            if (!IsReadableStreamBYOBReader(this))
              throw byobReaderBrandCheckException("releaseLock");
            if (this._ownerReadableStream !== void 0) {
              if (this._readIntoRequests.length > 0)
                throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
              ReadableStreamReaderGenericRelease(this);
            }
          }, ReadableStreamBYOBReader2;
        }()
      );
      Object.defineProperties(ReadableStreamBYOBReader.prototype, {
        cancel: { enumerable: !0 },
        read: { enumerable: !0 },
        releaseLock: { enumerable: !0 },
        closed: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamBYOBReader",
        configurable: !0
      });
      function IsReadableStreamBYOBReader(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_readIntoRequests") ? !1 : x2 instanceof ReadableStreamBYOBReader;
      }
      function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
        var stream = reader._ownerReadableStream;
        stream._disturbed = !0, stream._state === "errored" ? readIntoRequest._errorSteps(stream._storedError) : ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
      }
      function byobReaderBrandCheckException(name) {
        return new TypeError("ReadableStreamBYOBReader.prototype." + name + " can only be used on a ReadableStreamBYOBReader");
      }
      function ExtractHighWaterMark(strategy, defaultHWM) {
        var highWaterMark = strategy.highWaterMark;
        if (highWaterMark === void 0)
          return defaultHWM;
        if (NumberIsNaN(highWaterMark) || highWaterMark < 0)
          throw new RangeError("Invalid highWaterMark");
        return highWaterMark;
      }
      function ExtractSizeAlgorithm(strategy) {
        var size = strategy.size;
        return size || function() {
          return 1;
        };
      }
      function convertQueuingStrategy(init, context) {
        assertDictionary(init, context);
        var highWaterMark = init == null ? void 0 : init.highWaterMark, size = init == null ? void 0 : init.size;
        return {
          highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
          size: size === void 0 ? void 0 : convertQueuingStrategySize(size, context + " has member 'size' that")
        };
      }
      function convertQueuingStrategySize(fn, context) {
        return assertFunction(fn, context), function(chunk) {
          return convertUnrestrictedDouble(fn(chunk));
        };
      }
      function convertUnderlyingSink(original, context) {
        assertDictionary(original, context);
        var abort = original == null ? void 0 : original.abort, close = original == null ? void 0 : original.close, start = original == null ? void 0 : original.start, type = original == null ? void 0 : original.type, write = original == null ? void 0 : original.write;
        return {
          abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, context + " has member 'abort' that"),
          close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, context + " has member 'close' that"),
          start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, context + " has member 'start' that"),
          write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, context + " has member 'write' that"),
          type
        };
      }
      function convertUnderlyingSinkAbortCallback(fn, original, context) {
        return assertFunction(fn, context), function(reason) {
          return promiseCall(fn, original, [reason]);
        };
      }
      function convertUnderlyingSinkCloseCallback(fn, original, context) {
        return assertFunction(fn, context), function() {
          return promiseCall(fn, original, []);
        };
      }
      function convertUnderlyingSinkStartCallback(fn, original, context) {
        return assertFunction(fn, context), function(controller) {
          return reflectCall(fn, original, [controller]);
        };
      }
      function convertUnderlyingSinkWriteCallback(fn, original, context) {
        return assertFunction(fn, context), function(chunk, controller) {
          return promiseCall(fn, original, [chunk, controller]);
        };
      }
      function assertWritableStream(x2, context) {
        if (!IsWritableStream(x2))
          throw new TypeError(context + " is not a WritableStream.");
      }
      function isAbortSignal2(value) {
        if (typeof value != "object" || value === null)
          return !1;
        try {
          return typeof value.aborted == "boolean";
        } catch {
          return !1;
        }
      }
      var supportsAbortController = typeof AbortController == "function";
      function createAbortController() {
        if (supportsAbortController)
          return new AbortController();
      }
      var WritableStream = (
        /** @class */
        function() {
          function WritableStream2(rawUnderlyingSink, rawStrategy) {
            rawUnderlyingSink === void 0 && (rawUnderlyingSink = {}), rawStrategy === void 0 && (rawStrategy = {}), rawUnderlyingSink === void 0 ? rawUnderlyingSink = null : assertObject(rawUnderlyingSink, "First parameter");
            var strategy = convertQueuingStrategy(rawStrategy, "Second parameter"), underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
            InitializeWritableStream(this);
            var type = underlyingSink.type;
            if (type !== void 0)
              throw new RangeError("Invalid type is specified");
            var sizeAlgorithm = ExtractSizeAlgorithm(strategy), highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
          }
          return Object.defineProperty(WritableStream2.prototype, "locked", {
            /**
             * Returns whether or not the writable stream is locked to a writer.
             */
            get: function() {
              if (!IsWritableStream(this))
                throw streamBrandCheckException$2("locked");
              return IsWritableStreamLocked(this);
            },
            enumerable: !1,
            configurable: !0
          }), WritableStream2.prototype.abort = function(reason) {
            return reason === void 0 && (reason = void 0), IsWritableStream(this) ? IsWritableStreamLocked(this) ? promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer")) : WritableStreamAbort(this, reason) : promiseRejectedWith(streamBrandCheckException$2("abort"));
          }, WritableStream2.prototype.close = function() {
            return IsWritableStream(this) ? IsWritableStreamLocked(this) ? promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer")) : WritableStreamCloseQueuedOrInFlight(this) ? promiseRejectedWith(new TypeError("Cannot close an already-closing stream")) : WritableStreamClose(this) : promiseRejectedWith(streamBrandCheckException$2("close"));
          }, WritableStream2.prototype.getWriter = function() {
            if (!IsWritableStream(this))
              throw streamBrandCheckException$2("getWriter");
            return AcquireWritableStreamDefaultWriter(this);
          }, WritableStream2;
        }()
      );
      Object.defineProperties(WritableStream.prototype, {
        abort: { enumerable: !0 },
        close: { enumerable: !0 },
        getWriter: { enumerable: !0 },
        locked: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
        value: "WritableStream",
        configurable: !0
      });
      function AcquireWritableStreamDefaultWriter(stream) {
        return new WritableStreamDefaultWriter(stream);
      }
      function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        highWaterMark === void 0 && (highWaterMark = 1), sizeAlgorithm === void 0 && (sizeAlgorithm = function() {
          return 1;
        });
        var stream = Object.create(WritableStream.prototype);
        InitializeWritableStream(stream);
        var controller = Object.create(WritableStreamDefaultController.prototype);
        return SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm), stream;
      }
      function InitializeWritableStream(stream) {
        stream._state = "writable", stream._storedError = void 0, stream._writer = void 0, stream._writableStreamController = void 0, stream._writeRequests = new SimpleQueue(), stream._inFlightWriteRequest = void 0, stream._closeRequest = void 0, stream._inFlightCloseRequest = void 0, stream._pendingAbortRequest = void 0, stream._backpressure = !1;
      }
      function IsWritableStream(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_writableStreamController") ? !1 : x2 instanceof WritableStream;
      }
      function IsWritableStreamLocked(stream) {
        return stream._writer !== void 0;
      }
      function WritableStreamAbort(stream, reason) {
        var _a5;
        if (stream._state === "closed" || stream._state === "errored")
          return promiseResolvedWith(void 0);
        stream._writableStreamController._abortReason = reason, (_a5 = stream._writableStreamController._abortController) === null || _a5 === void 0 || _a5.abort();
        var state = stream._state;
        if (state === "closed" || state === "errored")
          return promiseResolvedWith(void 0);
        if (stream._pendingAbortRequest !== void 0)
          return stream._pendingAbortRequest._promise;
        var wasAlreadyErroring = !1;
        state === "erroring" && (wasAlreadyErroring = !0, reason = void 0);
        var promise = newPromise(function(resolve, reject) {
          stream._pendingAbortRequest = {
            _promise: void 0,
            _resolve: resolve,
            _reject: reject,
            _reason: reason,
            _wasAlreadyErroring: wasAlreadyErroring
          };
        });
        return stream._pendingAbortRequest._promise = promise, wasAlreadyErroring || WritableStreamStartErroring(stream, reason), promise;
      }
      function WritableStreamClose(stream) {
        var state = stream._state;
        if (state === "closed" || state === "errored")
          return promiseRejectedWith(new TypeError("The stream (in " + state + " state) is not in the writable state and cannot be closed"));
        var promise = newPromise(function(resolve, reject) {
          var closeRequest = {
            _resolve: resolve,
            _reject: reject
          };
          stream._closeRequest = closeRequest;
        }), writer = stream._writer;
        return writer !== void 0 && stream._backpressure && state === "writable" && defaultWriterReadyPromiseResolve(writer), WritableStreamDefaultControllerClose(stream._writableStreamController), promise;
      }
      function WritableStreamAddWriteRequest(stream) {
        var promise = newPromise(function(resolve, reject) {
          var writeRequest = {
            _resolve: resolve,
            _reject: reject
          };
          stream._writeRequests.push(writeRequest);
        });
        return promise;
      }
      function WritableStreamDealWithRejection(stream, error) {
        var state = stream._state;
        if (state === "writable") {
          WritableStreamStartErroring(stream, error);
          return;
        }
        WritableStreamFinishErroring(stream);
      }
      function WritableStreamStartErroring(stream, reason) {
        var controller = stream._writableStreamController;
        stream._state = "erroring", stream._storedError = reason;
        var writer = stream._writer;
        writer !== void 0 && WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason), !WritableStreamHasOperationMarkedInFlight(stream) && controller._started && WritableStreamFinishErroring(stream);
      }
      function WritableStreamFinishErroring(stream) {
        stream._state = "errored", stream._writableStreamController[ErrorSteps]();
        var storedError = stream._storedError;
        if (stream._writeRequests.forEach(function(writeRequest) {
          writeRequest._reject(storedError);
        }), stream._writeRequests = new SimpleQueue(), stream._pendingAbortRequest === void 0) {
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        var abortRequest = stream._pendingAbortRequest;
        if (stream._pendingAbortRequest = void 0, abortRequest._wasAlreadyErroring) {
          abortRequest._reject(storedError), WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        var promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
        uponPromise(promise, function() {
          abortRequest._resolve(), WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        }, function(reason) {
          abortRequest._reject(reason), WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        });
      }
      function WritableStreamFinishInFlightWrite(stream) {
        stream._inFlightWriteRequest._resolve(void 0), stream._inFlightWriteRequest = void 0;
      }
      function WritableStreamFinishInFlightWriteWithError(stream, error) {
        stream._inFlightWriteRequest._reject(error), stream._inFlightWriteRequest = void 0, WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamFinishInFlightClose(stream) {
        stream._inFlightCloseRequest._resolve(void 0), stream._inFlightCloseRequest = void 0;
        var state = stream._state;
        state === "erroring" && (stream._storedError = void 0, stream._pendingAbortRequest !== void 0 && (stream._pendingAbortRequest._resolve(), stream._pendingAbortRequest = void 0)), stream._state = "closed";
        var writer = stream._writer;
        writer !== void 0 && defaultWriterClosedPromiseResolve(writer);
      }
      function WritableStreamFinishInFlightCloseWithError(stream, error) {
        stream._inFlightCloseRequest._reject(error), stream._inFlightCloseRequest = void 0, stream._pendingAbortRequest !== void 0 && (stream._pendingAbortRequest._reject(error), stream._pendingAbortRequest = void 0), WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamCloseQueuedOrInFlight(stream) {
        return !(stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0);
      }
      function WritableStreamHasOperationMarkedInFlight(stream) {
        return !(stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0);
      }
      function WritableStreamMarkCloseRequestInFlight(stream) {
        stream._inFlightCloseRequest = stream._closeRequest, stream._closeRequest = void 0;
      }
      function WritableStreamMarkFirstWriteRequestInFlight(stream) {
        stream._inFlightWriteRequest = stream._writeRequests.shift();
      }
      function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
        stream._closeRequest !== void 0 && (stream._closeRequest._reject(stream._storedError), stream._closeRequest = void 0);
        var writer = stream._writer;
        writer !== void 0 && defaultWriterClosedPromiseReject(writer, stream._storedError);
      }
      function WritableStreamUpdateBackpressure(stream, backpressure) {
        var writer = stream._writer;
        writer !== void 0 && backpressure !== stream._backpressure && (backpressure ? defaultWriterReadyPromiseReset(writer) : defaultWriterReadyPromiseResolve(writer)), stream._backpressure = backpressure;
      }
      var WritableStreamDefaultWriter = (
        /** @class */
        function() {
          function WritableStreamDefaultWriter2(stream) {
            if (assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter"), assertWritableStream(stream, "First parameter"), IsWritableStreamLocked(stream))
              throw new TypeError("This stream has already been locked for exclusive writing by another writer");
            this._ownerWritableStream = stream, stream._writer = this;
            var state = stream._state;
            if (state === "writable")
              !WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure ? defaultWriterReadyPromiseInitialize(this) : defaultWriterReadyPromiseInitializeAsResolved(this), defaultWriterClosedPromiseInitialize(this);
            else if (state === "erroring")
              defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError), defaultWriterClosedPromiseInitialize(this);
            else if (state === "closed")
              defaultWriterReadyPromiseInitializeAsResolved(this), defaultWriterClosedPromiseInitializeAsResolved(this);
            else {
              var storedError = stream._storedError;
              defaultWriterReadyPromiseInitializeAsRejected(this, storedError), defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
            }
          }
          return Object.defineProperty(WritableStreamDefaultWriter2.prototype, "closed", {
            /**
             * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
             * the writers lock is released before the stream finishes closing.
             */
            get: function() {
              return IsWritableStreamDefaultWriter(this) ? this._closedPromise : promiseRejectedWith(defaultWriterBrandCheckException("closed"));
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(WritableStreamDefaultWriter2.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the streams internal queue. It can be negative, if the queue is over-full.
             * A producer can use this information to determine the right amount of data to write.
             *
             * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
             * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
             * the writers lock is released.
             */
            get: function() {
              if (!IsWritableStreamDefaultWriter(this))
                throw defaultWriterBrandCheckException("desiredSize");
              if (this._ownerWritableStream === void 0)
                throw defaultWriterLockException("desiredSize");
              return WritableStreamDefaultWriterGetDesiredSize(this);
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(WritableStreamDefaultWriter2.prototype, "ready", {
            /**
             * Returns a promise that will be fulfilled when the desired size to fill the streams internal queue transitions
             * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
             * back to zero or below, the getter will return a new promise that stays pending until the next transition.
             *
             * If the stream becomes errored or aborted, or the writers lock is released, the returned promise will become
             * rejected.
             */
            get: function() {
              return IsWritableStreamDefaultWriter(this) ? this._readyPromise : promiseRejectedWith(defaultWriterBrandCheckException("ready"));
            },
            enumerable: !1,
            configurable: !0
          }), WritableStreamDefaultWriter2.prototype.abort = function(reason) {
            return reason === void 0 && (reason = void 0), IsWritableStreamDefaultWriter(this) ? this._ownerWritableStream === void 0 ? promiseRejectedWith(defaultWriterLockException("abort")) : WritableStreamDefaultWriterAbort(this, reason) : promiseRejectedWith(defaultWriterBrandCheckException("abort"));
          }, WritableStreamDefaultWriter2.prototype.close = function() {
            if (!IsWritableStreamDefaultWriter(this))
              return promiseRejectedWith(defaultWriterBrandCheckException("close"));
            var stream = this._ownerWritableStream;
            return stream === void 0 ? promiseRejectedWith(defaultWriterLockException("close")) : WritableStreamCloseQueuedOrInFlight(stream) ? promiseRejectedWith(new TypeError("Cannot close an already-closing stream")) : WritableStreamDefaultWriterClose(this);
          }, WritableStreamDefaultWriter2.prototype.releaseLock = function() {
            if (!IsWritableStreamDefaultWriter(this))
              throw defaultWriterBrandCheckException("releaseLock");
            var stream = this._ownerWritableStream;
            stream !== void 0 && WritableStreamDefaultWriterRelease(this);
          }, WritableStreamDefaultWriter2.prototype.write = function(chunk) {
            return chunk === void 0 && (chunk = void 0), IsWritableStreamDefaultWriter(this) ? this._ownerWritableStream === void 0 ? promiseRejectedWith(defaultWriterLockException("write to")) : WritableStreamDefaultWriterWrite(this, chunk) : promiseRejectedWith(defaultWriterBrandCheckException("write"));
          }, WritableStreamDefaultWriter2;
        }()
      );
      Object.defineProperties(WritableStreamDefaultWriter.prototype, {
        abort: { enumerable: !0 },
        close: { enumerable: !0 },
        releaseLock: { enumerable: !0 },
        write: { enumerable: !0 },
        closed: { enumerable: !0 },
        desiredSize: { enumerable: !0 },
        ready: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
        value: "WritableStreamDefaultWriter",
        configurable: !0
      });
      function IsWritableStreamDefaultWriter(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_ownerWritableStream") ? !1 : x2 instanceof WritableStreamDefaultWriter;
      }
      function WritableStreamDefaultWriterAbort(writer, reason) {
        var stream = writer._ownerWritableStream;
        return WritableStreamAbort(stream, reason);
      }
      function WritableStreamDefaultWriterClose(writer) {
        var stream = writer._ownerWritableStream;
        return WritableStreamClose(stream);
      }
      function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
        var stream = writer._ownerWritableStream, state = stream._state;
        return WritableStreamCloseQueuedOrInFlight(stream) || state === "closed" ? promiseResolvedWith(void 0) : state === "errored" ? promiseRejectedWith(stream._storedError) : WritableStreamDefaultWriterClose(writer);
      }
      function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
        writer._closedPromiseState === "pending" ? defaultWriterClosedPromiseReject(writer, error) : defaultWriterClosedPromiseResetToRejected(writer, error);
      }
      function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
        writer._readyPromiseState === "pending" ? defaultWriterReadyPromiseReject(writer, error) : defaultWriterReadyPromiseResetToRejected(writer, error);
      }
      function WritableStreamDefaultWriterGetDesiredSize(writer) {
        var stream = writer._ownerWritableStream, state = stream._state;
        return state === "errored" || state === "erroring" ? null : state === "closed" ? 0 : WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
      }
      function WritableStreamDefaultWriterRelease(writer) {
        var stream = writer._ownerWritableStream, releasedError = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError), WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError), stream._writer = void 0, writer._ownerWritableStream = void 0;
      }
      function WritableStreamDefaultWriterWrite(writer, chunk) {
        var stream = writer._ownerWritableStream, controller = stream._writableStreamController, chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
        if (stream !== writer._ownerWritableStream)
          return promiseRejectedWith(defaultWriterLockException("write to"));
        var state = stream._state;
        if (state === "errored")
          return promiseRejectedWith(stream._storedError);
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed")
          return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
        if (state === "erroring")
          return promiseRejectedWith(stream._storedError);
        var promise = WritableStreamAddWriteRequest(stream);
        return WritableStreamDefaultControllerWrite(controller, chunk, chunkSize), promise;
      }
      var closeSentinel = {}, WritableStreamDefaultController = (
        /** @class */
        function() {
          function WritableStreamDefaultController2() {
            throw new TypeError("Illegal constructor");
          }
          return Object.defineProperty(WritableStreamDefaultController2.prototype, "abortReason", {
            /**
             * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
             *
             * @deprecated
             *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
             *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
             */
            get: function() {
              if (!IsWritableStreamDefaultController(this))
                throw defaultControllerBrandCheckException$2("abortReason");
              return this._abortReason;
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(WritableStreamDefaultController2.prototype, "signal", {
            /**
             * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
             */
            get: function() {
              if (!IsWritableStreamDefaultController(this))
                throw defaultControllerBrandCheckException$2("signal");
              if (this._abortController === void 0)
                throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
              return this._abortController.signal;
            },
            enumerable: !1,
            configurable: !0
          }), WritableStreamDefaultController2.prototype.error = function(e2) {
            if (e2 === void 0 && (e2 = void 0), !IsWritableStreamDefaultController(this))
              throw defaultControllerBrandCheckException$2("error");
            var state = this._controlledWritableStream._state;
            state === "writable" && WritableStreamDefaultControllerError(this, e2);
          }, WritableStreamDefaultController2.prototype[AbortSteps] = function(reason) {
            var result = this._abortAlgorithm(reason);
            return WritableStreamDefaultControllerClearAlgorithms(this), result;
          }, WritableStreamDefaultController2.prototype[ErrorSteps] = function() {
            ResetQueue(this);
          }, WritableStreamDefaultController2;
        }()
      );
      Object.defineProperties(WritableStreamDefaultController.prototype, {
        abortReason: { enumerable: !0 },
        signal: { enumerable: !0 },
        error: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
        value: "WritableStreamDefaultController",
        configurable: !0
      });
      function IsWritableStreamDefaultController(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_controlledWritableStream") ? !1 : x2 instanceof WritableStreamDefaultController;
      }
      function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledWritableStream = stream, stream._writableStreamController = controller, controller._queue = void 0, controller._queueTotalSize = void 0, ResetQueue(controller), controller._abortReason = void 0, controller._abortController = createAbortController(), controller._started = !1, controller._strategySizeAlgorithm = sizeAlgorithm, controller._strategyHWM = highWaterMark, controller._writeAlgorithm = writeAlgorithm, controller._closeAlgorithm = closeAlgorithm, controller._abortAlgorithm = abortAlgorithm;
        var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
        var startResult = startAlgorithm(), startPromise = promiseResolvedWith(startResult);
        uponPromise(startPromise, function() {
          controller._started = !0, WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, function(r2) {
          controller._started = !0, WritableStreamDealWithRejection(stream, r2);
        });
      }
      function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
        var controller = Object.create(WritableStreamDefaultController.prototype), startAlgorithm = function() {
        }, writeAlgorithm = function() {
          return promiseResolvedWith(void 0);
        }, closeAlgorithm = function() {
          return promiseResolvedWith(void 0);
        }, abortAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        underlyingSink.start !== void 0 && (startAlgorithm = function() {
          return underlyingSink.start(controller);
        }), underlyingSink.write !== void 0 && (writeAlgorithm = function(chunk) {
          return underlyingSink.write(chunk, controller);
        }), underlyingSink.close !== void 0 && (closeAlgorithm = function() {
          return underlyingSink.close();
        }), underlyingSink.abort !== void 0 && (abortAlgorithm = function(reason) {
          return underlyingSink.abort(reason);
        }), SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function WritableStreamDefaultControllerClearAlgorithms(controller) {
        controller._writeAlgorithm = void 0, controller._closeAlgorithm = void 0, controller._abortAlgorithm = void 0, controller._strategySizeAlgorithm = void 0;
      }
      function WritableStreamDefaultControllerClose(controller) {
        EnqueueValueWithSize(controller, closeSentinel, 0), WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
        try {
          return controller._strategySizeAlgorithm(chunk);
        } catch (chunkSizeE) {
          return WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE), 1;
        }
      }
      function WritableStreamDefaultControllerGetDesiredSize(controller) {
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
        try {
          EnqueueValueWithSize(controller, chunk, chunkSize);
        } catch (enqueueE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
          return;
        }
        var stream = controller._controlledWritableStream;
        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
          var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
        var stream = controller._controlledWritableStream;
        if (controller._started && stream._inFlightWriteRequest === void 0) {
          var state = stream._state;
          if (state === "erroring") {
            WritableStreamFinishErroring(stream);
            return;
          }
          if (controller._queue.length !== 0) {
            var value = PeekQueueValue(controller);
            value === closeSentinel ? WritableStreamDefaultControllerProcessClose(controller) : WritableStreamDefaultControllerProcessWrite(controller, value);
          }
        }
      }
      function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
        controller._controlledWritableStream._state === "writable" && WritableStreamDefaultControllerError(controller, error);
      }
      function WritableStreamDefaultControllerProcessClose(controller) {
        var stream = controller._controlledWritableStream;
        WritableStreamMarkCloseRequestInFlight(stream), DequeueValue(controller);
        var sinkClosePromise = controller._closeAlgorithm();
        WritableStreamDefaultControllerClearAlgorithms(controller), uponPromise(sinkClosePromise, function() {
          WritableStreamFinishInFlightClose(stream);
        }, function(reason) {
          WritableStreamFinishInFlightCloseWithError(stream, reason);
        });
      }
      function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
        var stream = controller._controlledWritableStream;
        WritableStreamMarkFirstWriteRequestInFlight(stream);
        var sinkWritePromise = controller._writeAlgorithm(chunk);
        uponPromise(sinkWritePromise, function() {
          WritableStreamFinishInFlightWrite(stream);
          var state = stream._state;
          if (DequeueValue(controller), !WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
            var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, function(reason) {
          stream._state === "writable" && WritableStreamDefaultControllerClearAlgorithms(controller), WritableStreamFinishInFlightWriteWithError(stream, reason);
        });
      }
      function WritableStreamDefaultControllerGetBackpressure(controller) {
        var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
        return desiredSize <= 0;
      }
      function WritableStreamDefaultControllerError(controller, error) {
        var stream = controller._controlledWritableStream;
        WritableStreamDefaultControllerClearAlgorithms(controller), WritableStreamStartErroring(stream, error);
      }
      function streamBrandCheckException$2(name) {
        return new TypeError("WritableStream.prototype." + name + " can only be used on a WritableStream");
      }
      function defaultControllerBrandCheckException$2(name) {
        return new TypeError("WritableStreamDefaultController.prototype." + name + " can only be used on a WritableStreamDefaultController");
      }
      function defaultWriterBrandCheckException(name) {
        return new TypeError("WritableStreamDefaultWriter.prototype." + name + " can only be used on a WritableStreamDefaultWriter");
      }
      function defaultWriterLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released writer");
      }
      function defaultWriterClosedPromiseInitialize(writer) {
        writer._closedPromise = newPromise(function(resolve, reject) {
          writer._closedPromise_resolve = resolve, writer._closedPromise_reject = reject, writer._closedPromiseState = "pending";
        });
      }
      function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
        defaultWriterClosedPromiseInitialize(writer), defaultWriterClosedPromiseReject(writer, reason);
      }
      function defaultWriterClosedPromiseInitializeAsResolved(writer) {
        defaultWriterClosedPromiseInitialize(writer), defaultWriterClosedPromiseResolve(writer);
      }
      function defaultWriterClosedPromiseReject(writer, reason) {
        writer._closedPromise_reject !== void 0 && (setPromiseIsHandledToTrue(writer._closedPromise), writer._closedPromise_reject(reason), writer._closedPromise_resolve = void 0, writer._closedPromise_reject = void 0, writer._closedPromiseState = "rejected");
      }
      function defaultWriterClosedPromiseResetToRejected(writer, reason) {
        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterClosedPromiseResolve(writer) {
        writer._closedPromise_resolve !== void 0 && (writer._closedPromise_resolve(void 0), writer._closedPromise_resolve = void 0, writer._closedPromise_reject = void 0, writer._closedPromiseState = "resolved");
      }
      function defaultWriterReadyPromiseInitialize(writer) {
        writer._readyPromise = newPromise(function(resolve, reject) {
          writer._readyPromise_resolve = resolve, writer._readyPromise_reject = reject;
        }), writer._readyPromiseState = "pending";
      }
      function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
        defaultWriterReadyPromiseInitialize(writer), defaultWriterReadyPromiseReject(writer, reason);
      }
      function defaultWriterReadyPromiseInitializeAsResolved(writer) {
        defaultWriterReadyPromiseInitialize(writer), defaultWriterReadyPromiseResolve(writer);
      }
      function defaultWriterReadyPromiseReject(writer, reason) {
        writer._readyPromise_reject !== void 0 && (setPromiseIsHandledToTrue(writer._readyPromise), writer._readyPromise_reject(reason), writer._readyPromise_resolve = void 0, writer._readyPromise_reject = void 0, writer._readyPromiseState = "rejected");
      }
      function defaultWriterReadyPromiseReset(writer) {
        defaultWriterReadyPromiseInitialize(writer);
      }
      function defaultWriterReadyPromiseResetToRejected(writer, reason) {
        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterReadyPromiseResolve(writer) {
        writer._readyPromise_resolve !== void 0 && (writer._readyPromise_resolve(void 0), writer._readyPromise_resolve = void 0, writer._readyPromise_reject = void 0, writer._readyPromiseState = "fulfilled");
      }
      var NativeDOMException = typeof DOMException < "u" ? DOMException : void 0;
      function isDOMExceptionConstructor(ctor) {
        if (!(typeof ctor == "function" || typeof ctor == "object"))
          return !1;
        try {
          return new ctor(), !0;
        } catch {
          return !1;
        }
      }
      function createDOMExceptionPolyfill() {
        var ctor = function(message, name) {
          this.message = message || "", this.name = name || "Error", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
        };
        return ctor.prototype = Object.create(Error.prototype), Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: !0, configurable: !0 }), ctor;
      }
      var DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
      function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
        var reader = AcquireReadableStreamDefaultReader(source), writer = AcquireWritableStreamDefaultWriter(dest);
        source._disturbed = !0;
        var shuttingDown = !1, currentWrite = promiseResolvedWith(void 0);
        return newPromise(function(resolve, reject) {
          var abortAlgorithm;
          if (signal !== void 0) {
            if (abortAlgorithm = function() {
              var error = new DOMException$1("Aborted", "AbortError"), actions = [];
              preventAbort || actions.push(function() {
                return dest._state === "writable" ? WritableStreamAbort(dest, error) : promiseResolvedWith(void 0);
              }), preventCancel || actions.push(function() {
                return source._state === "readable" ? ReadableStreamCancel(source, error) : promiseResolvedWith(void 0);
              }), shutdownWithAction(function() {
                return Promise.all(actions.map(function(action3) {
                  return action3();
                }));
              }, !0, error);
            }, signal.aborted) {
              abortAlgorithm();
              return;
            }
            signal.addEventListener("abort", abortAlgorithm);
          }
          function pipeLoop() {
            return newPromise(function(resolveLoop, rejectLoop) {
              function next(done) {
                done ? resolveLoop() : PerformPromiseThen(pipeStep(), next, rejectLoop);
              }
              next(!1);
            });
          }
          function pipeStep() {
            return shuttingDown ? promiseResolvedWith(!0) : PerformPromiseThen(writer._readyPromise, function() {
              return newPromise(function(resolveRead, rejectRead) {
                ReadableStreamDefaultReaderRead(reader, {
                  _chunkSteps: function(chunk) {
                    currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop2), resolveRead(!1);
                  },
                  _closeSteps: function() {
                    return resolveRead(!0);
                  },
                  _errorSteps: rejectRead
                });
              });
            });
          }
          if (isOrBecomesErrored(source, reader._closedPromise, function(storedError) {
            preventAbort ? shutdown(!0, storedError) : shutdownWithAction(function() {
              return WritableStreamAbort(dest, storedError);
            }, !0, storedError);
          }), isOrBecomesErrored(dest, writer._closedPromise, function(storedError) {
            preventCancel ? shutdown(!0, storedError) : shutdownWithAction(function() {
              return ReadableStreamCancel(source, storedError);
            }, !0, storedError);
          }), isOrBecomesClosed(source, reader._closedPromise, function() {
            preventClose ? shutdown() : shutdownWithAction(function() {
              return WritableStreamDefaultWriterCloseWithErrorPropagation(writer);
            });
          }), WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
            var destClosed_1 = new TypeError("the destination writable stream closed before all data could be piped to it");
            preventCancel ? shutdown(!0, destClosed_1) : shutdownWithAction(function() {
              return ReadableStreamCancel(source, destClosed_1);
            }, !0, destClosed_1);
          }
          setPromiseIsHandledToTrue(pipeLoop());
          function waitForWritesToFinish() {
            var oldCurrentWrite = currentWrite;
            return PerformPromiseThen(currentWrite, function() {
              return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0;
            });
          }
          function isOrBecomesErrored(stream, promise, action3) {
            stream._state === "errored" ? action3(stream._storedError) : uponRejection(promise, action3);
          }
          function isOrBecomesClosed(stream, promise, action3) {
            stream._state === "closed" ? action3() : uponFulfillment(promise, action3);
          }
          function shutdownWithAction(action3, originalIsError, originalError) {
            if (shuttingDown)
              return;
            shuttingDown = !0, dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest) ? uponFulfillment(waitForWritesToFinish(), doTheRest) : doTheRest();
            function doTheRest() {
              uponPromise(action3(), function() {
                return finalize(originalIsError, originalError);
              }, function(newError) {
                return finalize(!0, newError);
              });
            }
          }
          function shutdown(isError, error) {
            shuttingDown || (shuttingDown = !0, dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest) ? uponFulfillment(waitForWritesToFinish(), function() {
              return finalize(isError, error);
            }) : finalize(isError, error));
          }
          function finalize(isError, error) {
            WritableStreamDefaultWriterRelease(writer), ReadableStreamReaderGenericRelease(reader), signal !== void 0 && signal.removeEventListener("abort", abortAlgorithm), isError ? reject(error) : resolve(void 0);
          }
        });
      }
      var ReadableStreamDefaultController = (
        /** @class */
        function() {
          function ReadableStreamDefaultController2() {
            throw new TypeError("Illegal constructor");
          }
          return Object.defineProperty(ReadableStreamDefaultController2.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
             * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
             */
            get: function() {
              if (!IsReadableStreamDefaultController(this))
                throw defaultControllerBrandCheckException$1("desiredSize");
              return ReadableStreamDefaultControllerGetDesiredSize(this);
            },
            enumerable: !1,
            configurable: !0
          }), ReadableStreamDefaultController2.prototype.close = function() {
            if (!IsReadableStreamDefaultController(this))
              throw defaultControllerBrandCheckException$1("close");
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this))
              throw new TypeError("The stream is not in a state that permits close");
            ReadableStreamDefaultControllerClose(this);
          }, ReadableStreamDefaultController2.prototype.enqueue = function(chunk) {
            if (chunk === void 0 && (chunk = void 0), !IsReadableStreamDefaultController(this))
              throw defaultControllerBrandCheckException$1("enqueue");
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this))
              throw new TypeError("The stream is not in a state that permits enqueue");
            return ReadableStreamDefaultControllerEnqueue(this, chunk);
          }, ReadableStreamDefaultController2.prototype.error = function(e2) {
            if (e2 === void 0 && (e2 = void 0), !IsReadableStreamDefaultController(this))
              throw defaultControllerBrandCheckException$1("error");
            ReadableStreamDefaultControllerError(this, e2);
          }, ReadableStreamDefaultController2.prototype[CancelSteps] = function(reason) {
            ResetQueue(this);
            var result = this._cancelAlgorithm(reason);
            return ReadableStreamDefaultControllerClearAlgorithms(this), result;
          }, ReadableStreamDefaultController2.prototype[PullSteps] = function(readRequest) {
            var stream = this._controlledReadableStream;
            if (this._queue.length > 0) {
              var chunk = DequeueValue(this);
              this._closeRequested && this._queue.length === 0 ? (ReadableStreamDefaultControllerClearAlgorithms(this), ReadableStreamClose(stream)) : ReadableStreamDefaultControllerCallPullIfNeeded(this), readRequest._chunkSteps(chunk);
            } else
              ReadableStreamAddReadRequest(stream, readRequest), ReadableStreamDefaultControllerCallPullIfNeeded(this);
          }, ReadableStreamDefaultController2;
        }()
      );
      Object.defineProperties(ReadableStreamDefaultController.prototype, {
        close: { enumerable: !0 },
        enqueue: { enumerable: !0 },
        error: { enumerable: !0 },
        desiredSize: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamDefaultController",
        configurable: !0
      });
      function IsReadableStreamDefaultController(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_controlledReadableStream") ? !1 : x2 instanceof ReadableStreamDefaultController;
      }
      function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
        var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
        if (shouldPull) {
          if (controller._pulling) {
            controller._pullAgain = !0;
            return;
          }
          controller._pulling = !0;
          var pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, function() {
            controller._pulling = !1, controller._pullAgain && (controller._pullAgain = !1, ReadableStreamDefaultControllerCallPullIfNeeded(controller));
          }, function(e2) {
            ReadableStreamDefaultControllerError(controller, e2);
          });
        }
      }
      function ReadableStreamDefaultControllerShouldCallPull(controller) {
        var stream = controller._controlledReadableStream;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) || !controller._started)
          return !1;
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0)
          return !0;
        var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
        return desiredSize > 0;
      }
      function ReadableStreamDefaultControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0, controller._cancelAlgorithm = void 0, controller._strategySizeAlgorithm = void 0;
      }
      function ReadableStreamDefaultControllerClose(controller) {
        if (ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          var stream = controller._controlledReadableStream;
          controller._closeRequested = !0, controller._queue.length === 0 && (ReadableStreamDefaultControllerClearAlgorithms(controller), ReadableStreamClose(stream));
        }
      }
      function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
        if (ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          var stream = controller._controlledReadableStream;
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0)
            ReadableStreamFulfillReadRequest(stream, chunk, !1);
          else {
            var chunkSize = void 0;
            try {
              chunkSize = controller._strategySizeAlgorithm(chunk);
            } catch (chunkSizeE) {
              throw ReadableStreamDefaultControllerError(controller, chunkSizeE), chunkSizeE;
            }
            try {
              EnqueueValueWithSize(controller, chunk, chunkSize);
            } catch (enqueueE) {
              throw ReadableStreamDefaultControllerError(controller, enqueueE), enqueueE;
            }
          }
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }
      }
      function ReadableStreamDefaultControllerError(controller, e2) {
        var stream = controller._controlledReadableStream;
        stream._state === "readable" && (ResetQueue(controller), ReadableStreamDefaultControllerClearAlgorithms(controller), ReadableStreamError(stream, e2));
      }
      function ReadableStreamDefaultControllerGetDesiredSize(controller) {
        var state = controller._controlledReadableStream._state;
        return state === "errored" ? null : state === "closed" ? 0 : controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableStreamDefaultControllerHasBackpressure(controller) {
        return !ReadableStreamDefaultControllerShouldCallPull(controller);
      }
      function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
        var state = controller._controlledReadableStream._state;
        return !controller._closeRequested && state === "readable";
      }
      function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledReadableStream = stream, controller._queue = void 0, controller._queueTotalSize = void 0, ResetQueue(controller), controller._started = !1, controller._closeRequested = !1, controller._pullAgain = !1, controller._pulling = !1, controller._strategySizeAlgorithm = sizeAlgorithm, controller._strategyHWM = highWaterMark, controller._pullAlgorithm = pullAlgorithm, controller._cancelAlgorithm = cancelAlgorithm, stream._readableStreamController = controller;
        var startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), function() {
          controller._started = !0, ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }, function(r2) {
          ReadableStreamDefaultControllerError(controller, r2);
        });
      }
      function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
        var controller = Object.create(ReadableStreamDefaultController.prototype), startAlgorithm = function() {
        }, pullAlgorithm = function() {
          return promiseResolvedWith(void 0);
        }, cancelAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        underlyingSource.start !== void 0 && (startAlgorithm = function() {
          return underlyingSource.start(controller);
        }), underlyingSource.pull !== void 0 && (pullAlgorithm = function() {
          return underlyingSource.pull(controller);
        }), underlyingSource.cancel !== void 0 && (cancelAlgorithm = function(reason) {
          return underlyingSource.cancel(reason);
        }), SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function defaultControllerBrandCheckException$1(name) {
        return new TypeError("ReadableStreamDefaultController.prototype." + name + " can only be used on a ReadableStreamDefaultController");
      }
      function ReadableStreamTee(stream, cloneForBranch2) {
        return IsReadableByteStreamController(stream._readableStreamController) ? ReadableByteStreamTee(stream) : ReadableStreamDefaultTee(stream);
      }
      function ReadableStreamDefaultTee(stream, cloneForBranch2) {
        var reader = AcquireReadableStreamDefaultReader(stream), reading = !1, readAgain = !1, canceled1 = !1, canceled2 = !1, reason1, reason2, branch1, branch2, resolveCancelPromise, cancelPromise = newPromise(function(resolve) {
          resolveCancelPromise = resolve;
        });
        function pullAlgorithm() {
          if (reading)
            return readAgain = !0, promiseResolvedWith(void 0);
          reading = !0;
          var readRequest = {
            _chunkSteps: function(chunk) {
              queueMicrotask(function() {
                readAgain = !1;
                var chunk1 = chunk, chunk2 = chunk;
                canceled1 || ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1), canceled2 || ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2), reading = !1, readAgain && pullAlgorithm();
              });
            },
            _closeSteps: function() {
              reading = !1, canceled1 || ReadableStreamDefaultControllerClose(branch1._readableStreamController), canceled2 || ReadableStreamDefaultControllerClose(branch2._readableStreamController), (!canceled1 || !canceled2) && resolveCancelPromise(void 0);
            },
            _errorSteps: function() {
              reading = !1;
            }
          };
          return ReadableStreamDefaultReaderRead(reader, readRequest), promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          if (canceled1 = !0, reason1 = reason, canceled2) {
            var compositeReason = CreateArrayFromList([reason1, reason2]), cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          if (canceled2 = !0, reason2 = reason, canceled1) {
            var compositeReason = CreateArrayFromList([reason1, reason2]), cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
        }
        return branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm), branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm), uponRejection(reader._closedPromise, function(r2) {
          ReadableStreamDefaultControllerError(branch1._readableStreamController, r2), ReadableStreamDefaultControllerError(branch2._readableStreamController, r2), (!canceled1 || !canceled2) && resolveCancelPromise(void 0);
        }), [branch1, branch2];
      }
      function ReadableByteStreamTee(stream) {
        var reader = AcquireReadableStreamDefaultReader(stream), reading = !1, readAgainForBranch1 = !1, readAgainForBranch2 = !1, canceled1 = !1, canceled2 = !1, reason1, reason2, branch1, branch2, resolveCancelPromise, cancelPromise = newPromise(function(resolve) {
          resolveCancelPromise = resolve;
        });
        function forwardReaderError(thisReader) {
          uponRejection(thisReader._closedPromise, function(r2) {
            thisReader === reader && (ReadableByteStreamControllerError(branch1._readableStreamController, r2), ReadableByteStreamControllerError(branch2._readableStreamController, r2), (!canceled1 || !canceled2) && resolveCancelPromise(void 0));
          });
        }
        function pullWithDefaultReader() {
          IsReadableStreamBYOBReader(reader) && (ReadableStreamReaderGenericRelease(reader), reader = AcquireReadableStreamDefaultReader(stream), forwardReaderError(reader));
          var readRequest = {
            _chunkSteps: function(chunk) {
              queueMicrotask(function() {
                readAgainForBranch1 = !1, readAgainForBranch2 = !1;
                var chunk1 = chunk, chunk2 = chunk;
                if (!canceled1 && !canceled2)
                  try {
                    chunk2 = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(branch1._readableStreamController, cloneE), ReadableByteStreamControllerError(branch2._readableStreamController, cloneE), resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                canceled1 || ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1), canceled2 || ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2), reading = !1, readAgainForBranch1 ? pull1Algorithm() : readAgainForBranch2 && pull2Algorithm();
              });
            },
            _closeSteps: function() {
              reading = !1, canceled1 || ReadableByteStreamControllerClose(branch1._readableStreamController), canceled2 || ReadableByteStreamControllerClose(branch2._readableStreamController), branch1._readableStreamController._pendingPullIntos.length > 0 && ReadableByteStreamControllerRespond(branch1._readableStreamController, 0), branch2._readableStreamController._pendingPullIntos.length > 0 && ReadableByteStreamControllerRespond(branch2._readableStreamController, 0), (!canceled1 || !canceled2) && resolveCancelPromise(void 0);
            },
            _errorSteps: function() {
              reading = !1;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
        }
        function pullWithBYOBReader(view, forBranch2) {
          IsReadableStreamDefaultReader(reader) && (ReadableStreamReaderGenericRelease(reader), reader = AcquireReadableStreamBYOBReader(stream), forwardReaderError(reader));
          var byobBranch = forBranch2 ? branch2 : branch1, otherBranch = forBranch2 ? branch1 : branch2, readIntoRequest = {
            _chunkSteps: function(chunk) {
              queueMicrotask(function() {
                readAgainForBranch1 = !1, readAgainForBranch2 = !1;
                var byobCanceled = forBranch2 ? canceled2 : canceled1, otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (otherCanceled)
                  byobCanceled || ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                else {
                  var clonedChunk = void 0;
                  try {
                    clonedChunk = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE), ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE), resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                  byobCanceled || ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk), ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                }
                reading = !1, readAgainForBranch1 ? pull1Algorithm() : readAgainForBranch2 && pull2Algorithm();
              });
            },
            _closeSteps: function(chunk) {
              reading = !1;
              var byobCanceled = forBranch2 ? canceled2 : canceled1, otherCanceled = forBranch2 ? canceled1 : canceled2;
              byobCanceled || ReadableByteStreamControllerClose(byobBranch._readableStreamController), otherCanceled || ReadableByteStreamControllerClose(otherBranch._readableStreamController), chunk !== void 0 && (byobCanceled || ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk), !otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0 && ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0)), (!byobCanceled || !otherCanceled) && resolveCancelPromise(void 0);
            },
            _errorSteps: function() {
              reading = !1;
            }
          };
          ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
        }
        function pull1Algorithm() {
          if (reading)
            return readAgainForBranch1 = !0, promiseResolvedWith(void 0);
          reading = !0;
          var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
          return byobRequest === null ? pullWithDefaultReader() : pullWithBYOBReader(byobRequest._view, !1), promiseResolvedWith(void 0);
        }
        function pull2Algorithm() {
          if (reading)
            return readAgainForBranch2 = !0, promiseResolvedWith(void 0);
          reading = !0;
          var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
          return byobRequest === null ? pullWithDefaultReader() : pullWithBYOBReader(byobRequest._view, !0), promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          if (canceled1 = !0, reason1 = reason, canceled2) {
            var compositeReason = CreateArrayFromList([reason1, reason2]), cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          if (canceled2 = !0, reason2 = reason, canceled1) {
            var compositeReason = CreateArrayFromList([reason1, reason2]), cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
        }
        return branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm), branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm), forwardReaderError(reader), [branch1, branch2];
      }
      function convertUnderlyingDefaultOrByteSource(source, context) {
        assertDictionary(source, context);
        var original = source, autoAllocateChunkSize = original == null ? void 0 : original.autoAllocateChunkSize, cancel = original == null ? void 0 : original.cancel, pull = original == null ? void 0 : original.pull, start = original == null ? void 0 : original.start, type = original == null ? void 0 : original.type;
        return {
          autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, context + " has member 'autoAllocateChunkSize' that"),
          cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, context + " has member 'cancel' that"),
          pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, context + " has member 'pull' that"),
          start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, context + " has member 'start' that"),
          type: type === void 0 ? void 0 : convertReadableStreamType(type, context + " has member 'type' that")
        };
      }
      function convertUnderlyingSourceCancelCallback(fn, original, context) {
        return assertFunction(fn, context), function(reason) {
          return promiseCall(fn, original, [reason]);
        };
      }
      function convertUnderlyingSourcePullCallback(fn, original, context) {
        return assertFunction(fn, context), function(controller) {
          return promiseCall(fn, original, [controller]);
        };
      }
      function convertUnderlyingSourceStartCallback(fn, original, context) {
        return assertFunction(fn, context), function(controller) {
          return reflectCall(fn, original, [controller]);
        };
      }
      function convertReadableStreamType(type, context) {
        if (type = "" + type, type !== "bytes")
          throw new TypeError(context + " '" + type + "' is not a valid enumeration value for ReadableStreamType");
        return type;
      }
      function convertReaderOptions(options, context) {
        assertDictionary(options, context);
        var mode = options == null ? void 0 : options.mode;
        return {
          mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, context + " has member 'mode' that")
        };
      }
      function convertReadableStreamReaderMode(mode, context) {
        if (mode = "" + mode, mode !== "byob")
          throw new TypeError(context + " '" + mode + "' is not a valid enumeration value for ReadableStreamReaderMode");
        return mode;
      }
      function convertIteratorOptions(options, context) {
        assertDictionary(options, context);
        var preventCancel = options == null ? void 0 : options.preventCancel;
        return { preventCancel: Boolean(preventCancel) };
      }
      function convertPipeOptions(options, context) {
        assertDictionary(options, context);
        var preventAbort = options == null ? void 0 : options.preventAbort, preventCancel = options == null ? void 0 : options.preventCancel, preventClose = options == null ? void 0 : options.preventClose, signal = options == null ? void 0 : options.signal;
        return signal !== void 0 && assertAbortSignal(signal, context + " has member 'signal' that"), {
          preventAbort: Boolean(preventAbort),
          preventCancel: Boolean(preventCancel),
          preventClose: Boolean(preventClose),
          signal
        };
      }
      function assertAbortSignal(signal, context) {
        if (!isAbortSignal2(signal))
          throw new TypeError(context + " is not an AbortSignal.");
      }
      function convertReadableWritablePair(pair, context) {
        assertDictionary(pair, context);
        var readable = pair == null ? void 0 : pair.readable;
        assertRequiredField(readable, "readable", "ReadableWritablePair"), assertReadableStream(readable, context + " has member 'readable' that");
        var writable = pair == null ? void 0 : pair.writable;
        return assertRequiredField(writable, "writable", "ReadableWritablePair"), assertWritableStream(writable, context + " has member 'writable' that"), { readable, writable };
      }
      var ReadableStream2 = (
        /** @class */
        function() {
          function ReadableStream3(rawUnderlyingSource, rawStrategy) {
            rawUnderlyingSource === void 0 && (rawUnderlyingSource = {}), rawStrategy === void 0 && (rawStrategy = {}), rawUnderlyingSource === void 0 ? rawUnderlyingSource = null : assertObject(rawUnderlyingSource, "First parameter");
            var strategy = convertQueuingStrategy(rawStrategy, "Second parameter"), underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
            if (InitializeReadableStream(this), underlyingSource.type === "bytes") {
              if (strategy.size !== void 0)
                throw new RangeError("The strategy for a byte stream cannot have a size function");
              var highWaterMark = ExtractHighWaterMark(strategy, 0);
              SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
            } else {
              var sizeAlgorithm = ExtractSizeAlgorithm(strategy), highWaterMark = ExtractHighWaterMark(strategy, 1);
              SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
            }
          }
          return Object.defineProperty(ReadableStream3.prototype, "locked", {
            /**
             * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
             */
            get: function() {
              if (!IsReadableStream(this))
                throw streamBrandCheckException$1("locked");
              return IsReadableStreamLocked(this);
            },
            enumerable: !1,
            configurable: !0
          }), ReadableStream3.prototype.cancel = function(reason) {
            return reason === void 0 && (reason = void 0), IsReadableStream(this) ? IsReadableStreamLocked(this) ? promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader")) : ReadableStreamCancel(this, reason) : promiseRejectedWith(streamBrandCheckException$1("cancel"));
          }, ReadableStream3.prototype.getReader = function(rawOptions) {
            if (rawOptions === void 0 && (rawOptions = void 0), !IsReadableStream(this))
              throw streamBrandCheckException$1("getReader");
            var options = convertReaderOptions(rawOptions, "First parameter");
            return options.mode === void 0 ? AcquireReadableStreamDefaultReader(this) : AcquireReadableStreamBYOBReader(this);
          }, ReadableStream3.prototype.pipeThrough = function(rawTransform, rawOptions) {
            if (rawOptions === void 0 && (rawOptions = {}), !IsReadableStream(this))
              throw streamBrandCheckException$1("pipeThrough");
            assertRequiredArgument(rawTransform, 1, "pipeThrough");
            var transform = convertReadableWritablePair(rawTransform, "First parameter"), options = convertPipeOptions(rawOptions, "Second parameter");
            if (IsReadableStreamLocked(this))
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
            if (IsWritableStreamLocked(transform.writable))
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
            var promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
            return setPromiseIsHandledToTrue(promise), transform.readable;
          }, ReadableStream3.prototype.pipeTo = function(destination, rawOptions) {
            if (rawOptions === void 0 && (rawOptions = {}), !IsReadableStream(this))
              return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
            if (destination === void 0)
              return promiseRejectedWith("Parameter 1 is required in 'pipeTo'.");
            if (!IsWritableStream(destination))
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
            var options;
            try {
              options = convertPipeOptions(rawOptions, "Second parameter");
            } catch (e2) {
              return promiseRejectedWith(e2);
            }
            return IsReadableStreamLocked(this) ? promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")) : IsWritableStreamLocked(destination) ? promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")) : ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
          }, ReadableStream3.prototype.tee = function() {
            if (!IsReadableStream(this))
              throw streamBrandCheckException$1("tee");
            var branches = ReadableStreamTee(this);
            return CreateArrayFromList(branches);
          }, ReadableStream3.prototype.values = function(rawOptions) {
            if (rawOptions === void 0 && (rawOptions = void 0), !IsReadableStream(this))
              throw streamBrandCheckException$1("values");
            var options = convertIteratorOptions(rawOptions, "First parameter");
            return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
          }, ReadableStream3;
        }()
      );
      Object.defineProperties(ReadableStream2.prototype, {
        cancel: { enumerable: !0 },
        getReader: { enumerable: !0 },
        pipeThrough: { enumerable: !0 },
        pipeTo: { enumerable: !0 },
        tee: { enumerable: !0 },
        values: { enumerable: !0 },
        locked: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStream",
        configurable: !0
      }), typeof SymbolPolyfill.asyncIterator == "symbol" && Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
        value: ReadableStream2.prototype.values,
        writable: !0,
        configurable: !0
      });
      function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        highWaterMark === void 0 && (highWaterMark = 1), sizeAlgorithm === void 0 && (sizeAlgorithm = function() {
          return 1;
        });
        var stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        var controller = Object.create(ReadableStreamDefaultController.prototype);
        return SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm), stream;
      }
      function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
        var stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        var controller = Object.create(ReadableByteStreamController.prototype);
        return SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0), stream;
      }
      function InitializeReadableStream(stream) {
        stream._state = "readable", stream._reader = void 0, stream._storedError = void 0, stream._disturbed = !1;
      }
      function IsReadableStream(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_readableStreamController") ? !1 : x2 instanceof ReadableStream2;
      }
      function IsReadableStreamLocked(stream) {
        return stream._reader !== void 0;
      }
      function ReadableStreamCancel(stream, reason) {
        if (stream._disturbed = !0, stream._state === "closed")
          return promiseResolvedWith(void 0);
        if (stream._state === "errored")
          return promiseRejectedWith(stream._storedError);
        ReadableStreamClose(stream);
        var reader = stream._reader;
        reader !== void 0 && IsReadableStreamBYOBReader(reader) && (reader._readIntoRequests.forEach(function(readIntoRequest) {
          readIntoRequest._closeSteps(void 0);
        }), reader._readIntoRequests = new SimpleQueue());
        var sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
        return transformPromiseWith(sourceCancelPromise, noop2);
      }
      function ReadableStreamClose(stream) {
        stream._state = "closed";
        var reader = stream._reader;
        reader !== void 0 && (defaultReaderClosedPromiseResolve(reader), IsReadableStreamDefaultReader(reader) && (reader._readRequests.forEach(function(readRequest) {
          readRequest._closeSteps();
        }), reader._readRequests = new SimpleQueue()));
      }
      function ReadableStreamError(stream, e2) {
        stream._state = "errored", stream._storedError = e2;
        var reader = stream._reader;
        reader !== void 0 && (defaultReaderClosedPromiseReject(reader, e2), IsReadableStreamDefaultReader(reader) ? (reader._readRequests.forEach(function(readRequest) {
          readRequest._errorSteps(e2);
        }), reader._readRequests = new SimpleQueue()) : (reader._readIntoRequests.forEach(function(readIntoRequest) {
          readIntoRequest._errorSteps(e2);
        }), reader._readIntoRequests = new SimpleQueue()));
      }
      function streamBrandCheckException$1(name) {
        return new TypeError("ReadableStream.prototype." + name + " can only be used on a ReadableStream");
      }
      function convertQueuingStrategyInit(init, context) {
        assertDictionary(init, context);
        var highWaterMark = init == null ? void 0 : init.highWaterMark;
        return assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit"), {
          highWaterMark: convertUnrestrictedDouble(highWaterMark)
        };
      }
      var byteLengthSizeFunction = function(chunk) {
        return chunk.byteLength;
      };
      try {
        Object.defineProperty(byteLengthSizeFunction, "name", {
          value: "size",
          configurable: !0
        });
      } catch {
      }
      var ByteLengthQueuingStrategy = (
        /** @class */
        function() {
          function ByteLengthQueuingStrategy2(options) {
            assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy"), options = convertQueuingStrategyInit(options, "First parameter"), this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
          }
          return Object.defineProperty(ByteLengthQueuingStrategy2.prototype, "highWaterMark", {
            /**
             * Returns the high water mark provided to the constructor.
             */
            get: function() {
              if (!IsByteLengthQueuingStrategy(this))
                throw byteLengthBrandCheckException("highWaterMark");
              return this._byteLengthQueuingStrategyHighWaterMark;
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(ByteLengthQueuingStrategy2.prototype, "size", {
            /**
             * Measures the size of `chunk` by returning the value of its `byteLength` property.
             */
            get: function() {
              if (!IsByteLengthQueuingStrategy(this))
                throw byteLengthBrandCheckException("size");
              return byteLengthSizeFunction;
            },
            enumerable: !1,
            configurable: !0
          }), ByteLengthQueuingStrategy2;
        }()
      );
      Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
        highWaterMark: { enumerable: !0 },
        size: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
        value: "ByteLengthQueuingStrategy",
        configurable: !0
      });
      function byteLengthBrandCheckException(name) {
        return new TypeError("ByteLengthQueuingStrategy.prototype." + name + " can only be used on a ByteLengthQueuingStrategy");
      }
      function IsByteLengthQueuingStrategy(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_byteLengthQueuingStrategyHighWaterMark") ? !1 : x2 instanceof ByteLengthQueuingStrategy;
      }
      var countSizeFunction = function() {
        return 1;
      };
      try {
        Object.defineProperty(countSizeFunction, "name", {
          value: "size",
          configurable: !0
        });
      } catch {
      }
      var CountQueuingStrategy = (
        /** @class */
        function() {
          function CountQueuingStrategy2(options) {
            assertRequiredArgument(options, 1, "CountQueuingStrategy"), options = convertQueuingStrategyInit(options, "First parameter"), this._countQueuingStrategyHighWaterMark = options.highWaterMark;
          }
          return Object.defineProperty(CountQueuingStrategy2.prototype, "highWaterMark", {
            /**
             * Returns the high water mark provided to the constructor.
             */
            get: function() {
              if (!IsCountQueuingStrategy(this))
                throw countBrandCheckException("highWaterMark");
              return this._countQueuingStrategyHighWaterMark;
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(CountQueuingStrategy2.prototype, "size", {
            /**
             * Measures the size of `chunk` by always returning 1.
             * This ensures that the total queue size is a count of the number of chunks in the queue.
             */
            get: function() {
              if (!IsCountQueuingStrategy(this))
                throw countBrandCheckException("size");
              return countSizeFunction;
            },
            enumerable: !1,
            configurable: !0
          }), CountQueuingStrategy2;
        }()
      );
      Object.defineProperties(CountQueuingStrategy.prototype, {
        highWaterMark: { enumerable: !0 },
        size: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
        value: "CountQueuingStrategy",
        configurable: !0
      });
      function countBrandCheckException(name) {
        return new TypeError("CountQueuingStrategy.prototype." + name + " can only be used on a CountQueuingStrategy");
      }
      function IsCountQueuingStrategy(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_countQueuingStrategyHighWaterMark") ? !1 : x2 instanceof CountQueuingStrategy;
      }
      function convertTransformer(original, context) {
        assertDictionary(original, context);
        var flush = original == null ? void 0 : original.flush, readableType = original == null ? void 0 : original.readableType, start = original == null ? void 0 : original.start, transform = original == null ? void 0 : original.transform, writableType = original == null ? void 0 : original.writableType;
        return {
          flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, context + " has member 'flush' that"),
          readableType,
          start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, context + " has member 'start' that"),
          transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, context + " has member 'transform' that"),
          writableType
        };
      }
      function convertTransformerFlushCallback(fn, original, context) {
        return assertFunction(fn, context), function(controller) {
          return promiseCall(fn, original, [controller]);
        };
      }
      function convertTransformerStartCallback(fn, original, context) {
        return assertFunction(fn, context), function(controller) {
          return reflectCall(fn, original, [controller]);
        };
      }
      function convertTransformerTransformCallback(fn, original, context) {
        return assertFunction(fn, context), function(chunk, controller) {
          return promiseCall(fn, original, [chunk, controller]);
        };
      }
      var TransformStream = (
        /** @class */
        function() {
          function TransformStream2(rawTransformer, rawWritableStrategy, rawReadableStrategy) {
            rawTransformer === void 0 && (rawTransformer = {}), rawWritableStrategy === void 0 && (rawWritableStrategy = {}), rawReadableStrategy === void 0 && (rawReadableStrategy = {}), rawTransformer === void 0 && (rawTransformer = null);
            var writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter"), readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter"), transformer = convertTransformer(rawTransformer, "First parameter");
            if (transformer.readableType !== void 0)
              throw new RangeError("Invalid readableType specified");
            if (transformer.writableType !== void 0)
              throw new RangeError("Invalid writableType specified");
            var readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0), readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy), writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1), writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy), startPromise_resolve, startPromise = newPromise(function(resolve) {
              startPromise_resolve = resolve;
            });
            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm), SetUpTransformStreamDefaultControllerFromTransformer(this, transformer), transformer.start !== void 0 ? startPromise_resolve(transformer.start(this._transformStreamController)) : startPromise_resolve(void 0);
          }
          return Object.defineProperty(TransformStream2.prototype, "readable", {
            /**
             * The readable side of the transform stream.
             */
            get: function() {
              if (!IsTransformStream(this))
                throw streamBrandCheckException("readable");
              return this._readable;
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(TransformStream2.prototype, "writable", {
            /**
             * The writable side of the transform stream.
             */
            get: function() {
              if (!IsTransformStream(this))
                throw streamBrandCheckException("writable");
              return this._writable;
            },
            enumerable: !1,
            configurable: !0
          }), TransformStream2;
        }()
      );
      Object.defineProperties(TransformStream.prototype, {
        readable: { enumerable: !0 },
        writable: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
        value: "TransformStream",
        configurable: !0
      });
      function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
        function startAlgorithm() {
          return startPromise;
        }
        function writeAlgorithm(chunk) {
          return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
        }
        function abortAlgorithm(reason) {
          return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
        }
        function closeAlgorithm() {
          return TransformStreamDefaultSinkCloseAlgorithm(stream);
        }
        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
        function pullAlgorithm() {
          return TransformStreamDefaultSourcePullAlgorithm(stream);
        }
        function cancelAlgorithm(reason) {
          return TransformStreamErrorWritableAndUnblockWrite(stream, reason), promiseResolvedWith(void 0);
        }
        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm), stream._backpressure = void 0, stream._backpressureChangePromise = void 0, stream._backpressureChangePromise_resolve = void 0, TransformStreamSetBackpressure(stream, !0), stream._transformStreamController = void 0;
      }
      function IsTransformStream(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_transformStreamController") ? !1 : x2 instanceof TransformStream;
      }
      function TransformStreamError(stream, e2) {
        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e2), TransformStreamErrorWritableAndUnblockWrite(stream, e2);
      }
      function TransformStreamErrorWritableAndUnblockWrite(stream, e2) {
        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController), WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e2), stream._backpressure && TransformStreamSetBackpressure(stream, !1);
      }
      function TransformStreamSetBackpressure(stream, backpressure) {
        stream._backpressureChangePromise !== void 0 && stream._backpressureChangePromise_resolve(), stream._backpressureChangePromise = newPromise(function(resolve) {
          stream._backpressureChangePromise_resolve = resolve;
        }), stream._backpressure = backpressure;
      }
      var TransformStreamDefaultController = (
        /** @class */
        function() {
          function TransformStreamDefaultController2() {
            throw new TypeError("Illegal constructor");
          }
          return Object.defineProperty(TransformStreamDefaultController2.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the readable sides internal queue. It can be negative, if the queue is over-full.
             */
            get: function() {
              if (!IsTransformStreamDefaultController(this))
                throw defaultControllerBrandCheckException("desiredSize");
              var readableController = this._controlledTransformStream._readable._readableStreamController;
              return ReadableStreamDefaultControllerGetDesiredSize(readableController);
            },
            enumerable: !1,
            configurable: !0
          }), TransformStreamDefaultController2.prototype.enqueue = function(chunk) {
            if (chunk === void 0 && (chunk = void 0), !IsTransformStreamDefaultController(this))
              throw defaultControllerBrandCheckException("enqueue");
            TransformStreamDefaultControllerEnqueue(this, chunk);
          }, TransformStreamDefaultController2.prototype.error = function(reason) {
            if (reason === void 0 && (reason = void 0), !IsTransformStreamDefaultController(this))
              throw defaultControllerBrandCheckException("error");
            TransformStreamDefaultControllerError(this, reason);
          }, TransformStreamDefaultController2.prototype.terminate = function() {
            if (!IsTransformStreamDefaultController(this))
              throw defaultControllerBrandCheckException("terminate");
            TransformStreamDefaultControllerTerminate(this);
          }, TransformStreamDefaultController2;
        }()
      );
      Object.defineProperties(TransformStreamDefaultController.prototype, {
        enqueue: { enumerable: !0 },
        error: { enumerable: !0 },
        terminate: { enumerable: !0 },
        desiredSize: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
        value: "TransformStreamDefaultController",
        configurable: !0
      });
      function IsTransformStreamDefaultController(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_controlledTransformStream") ? !1 : x2 instanceof TransformStreamDefaultController;
      }
      function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
        controller._controlledTransformStream = stream, stream._transformStreamController = controller, controller._transformAlgorithm = transformAlgorithm, controller._flushAlgorithm = flushAlgorithm;
      }
      function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
        var controller = Object.create(TransformStreamDefaultController.prototype), transformAlgorithm = function(chunk) {
          try {
            return TransformStreamDefaultControllerEnqueue(controller, chunk), promiseResolvedWith(void 0);
          } catch (transformResultE) {
            return promiseRejectedWith(transformResultE);
          }
        }, flushAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        transformer.transform !== void 0 && (transformAlgorithm = function(chunk) {
          return transformer.transform(chunk, controller);
        }), transformer.flush !== void 0 && (flushAlgorithm = function() {
          return transformer.flush(controller);
        }), SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
      }
      function TransformStreamDefaultControllerClearAlgorithms(controller) {
        controller._transformAlgorithm = void 0, controller._flushAlgorithm = void 0;
      }
      function TransformStreamDefaultControllerEnqueue(controller, chunk) {
        var stream = controller._controlledTransformStream, readableController = stream._readable._readableStreamController;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController))
          throw new TypeError("Readable side is not in a state that permits enqueue");
        try {
          ReadableStreamDefaultControllerEnqueue(readableController, chunk);
        } catch (e2) {
          throw TransformStreamErrorWritableAndUnblockWrite(stream, e2), stream._readable._storedError;
        }
        var backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
        backpressure !== stream._backpressure && TransformStreamSetBackpressure(stream, !0);
      }
      function TransformStreamDefaultControllerError(controller, e2) {
        TransformStreamError(controller._controlledTransformStream, e2);
      }
      function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
        var transformPromise = controller._transformAlgorithm(chunk);
        return transformPromiseWith(transformPromise, void 0, function(r2) {
          throw TransformStreamError(controller._controlledTransformStream, r2), r2;
        });
      }
      function TransformStreamDefaultControllerTerminate(controller) {
        var stream = controller._controlledTransformStream, readableController = stream._readable._readableStreamController;
        ReadableStreamDefaultControllerClose(readableController);
        var error = new TypeError("TransformStream terminated");
        TransformStreamErrorWritableAndUnblockWrite(stream, error);
      }
      function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
        var controller = stream._transformStreamController;
        if (stream._backpressure) {
          var backpressureChangePromise = stream._backpressureChangePromise;
          return transformPromiseWith(backpressureChangePromise, function() {
            var writable = stream._writable, state = writable._state;
            if (state === "erroring")
              throw writable._storedError;
            return TransformStreamDefaultControllerPerformTransform(controller, chunk);
          });
        }
        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
      }
      function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
        return TransformStreamError(stream, reason), promiseResolvedWith(void 0);
      }
      function TransformStreamDefaultSinkCloseAlgorithm(stream) {
        var readable = stream._readable, controller = stream._transformStreamController, flushPromise = controller._flushAlgorithm();
        return TransformStreamDefaultControllerClearAlgorithms(controller), transformPromiseWith(flushPromise, function() {
          if (readable._state === "errored")
            throw readable._storedError;
          ReadableStreamDefaultControllerClose(readable._readableStreamController);
        }, function(r2) {
          throw TransformStreamError(stream, r2), readable._storedError;
        });
      }
      function TransformStreamDefaultSourcePullAlgorithm(stream) {
        return TransformStreamSetBackpressure(stream, !1), stream._backpressureChangePromise;
      }
      function defaultControllerBrandCheckException(name) {
        return new TypeError("TransformStreamDefaultController.prototype." + name + " can only be used on a TransformStreamDefaultController");
      }
      function streamBrandCheckException(name) {
        return new TypeError("TransformStream.prototype." + name + " can only be used on a TransformStream");
      }
      exports2.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy, exports2.CountQueuingStrategy = CountQueuingStrategy, exports2.ReadableByteStreamController = ReadableByteStreamController, exports2.ReadableStream = ReadableStream2, exports2.ReadableStreamBYOBReader = ReadableStreamBYOBReader, exports2.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest, exports2.ReadableStreamDefaultController = ReadableStreamDefaultController, exports2.ReadableStreamDefaultReader = ReadableStreamDefaultReader, exports2.TransformStream = TransformStream, exports2.TransformStreamDefaultController = TransformStreamDefaultController, exports2.WritableStream = WritableStream, exports2.WritableStreamDefaultController = WritableStreamDefaultController, exports2.WritableStreamDefaultWriter = WritableStreamDefaultWriter, Object.defineProperty(exports2, "__esModule", { value: !0 });
    });
  }
});

// node_modules/@remix-run/web-stream/src/stream.cjs
var require_stream = __commonJS({
  "node_modules/@remix-run/web-stream/src/stream.cjs"(exports, module2) {
    module2.exports = require_ponyfill();
  }
});

// node_modules/@remix-run/web-blob/dist/src/blob.cjs
var require_blob = __commonJS({
  "node_modules/@remix-run/web-blob/dist/src/blob.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var webEncoding = require_lib(), webStream = require_stream(), WebBlob = class Blob4 {
      /**
       * @param {BlobPart[]} [init]
       * @param {BlobPropertyBag} [options]
       */
      constructor(init = [], options = {}) {
        let parts = [], size = 0;
        for (let part of init)
          if (typeof part == "string") {
            let bytes = new webEncoding.TextEncoder().encode(part);
            parts.push(bytes), size += bytes.byteLength;
          } else if (part instanceof WebBlob)
            size += part.size, parts.push(...part._parts);
          else if (part instanceof ArrayBuffer)
            parts.push(new Uint8Array(part)), size += part.byteLength;
          else if (part instanceof Uint8Array)
            parts.push(part), size += part.byteLength;
          else if (ArrayBuffer.isView(part)) {
            let { buffer, byteOffset, byteLength } = part;
            parts.push(new Uint8Array(buffer, byteOffset, byteLength)), size += byteLength;
          } else {
            let bytes = new webEncoding.TextEncoder().encode(String(part));
            parts.push(bytes), size += bytes.byteLength;
          }
        this._size = size, this._type = readType(options.type), this._parts = parts, Object.defineProperties(this, {
          _size: { enumerable: !1 },
          _type: { enumerable: !1 },
          _parts: { enumerable: !1 }
        });
      }
      /**
       * A string indicating the MIME type of the data contained in the Blob.
       * If the type is unknown, this string is empty.
       * @type {string}
       */
      get type() {
        return this._type;
      }
      /**
       * The size, in bytes, of the data contained in the Blob object.
       * @type {number}
       */
      get size() {
        return this._size;
      }
      /**
       * Returns a new Blob object containing the data in the specified range of
       * bytes of the blob on which it's called.
       * @param {number} [start=0] - An index into the Blob indicating the first
       * byte to include in the new Blob. If you specify a negative value, it's
       * treated as an offset from the end of the Blob toward the beginning. For
       * example, `-10` would be the 10th from last byte in the Blob. The default
       * value is `0`. If you specify a value for start that is larger than the
       * size of the source Blob, the returned Blob has size 0 and contains no
       * data.
       * @param {number} [end] - An index into the `Blob` indicating the first byte
       *  that will *not* be included in the new `Blob` (i.e. the byte exactly at
       * this index is not included). If you specify a negative value, it's treated
       * as an offset from the end of the Blob toward the beginning. For example,
       * `-10` would be the 10th from last byte in the `Blob`. The default value is
       * size.
       * @param {string} [type] - The content type to assign to the new Blob;
       * this will be the value of its type property. The default value is an empty
       * string.
       * @returns {Blob}
       */
      slice(start = 0, end = this.size, type = "") {
        let { size, _parts: _parts2 } = this, offset = start < 0 ? Math.max(size + start, 0) : Math.min(start, size), limit = end < 0 ? Math.max(size + end, 0) : Math.min(end, size), span = Math.max(limit - offset, 0), blob = new Blob4([], { type });
        if (span === 0)
          return blob;
        let blobSize = 0, blobParts = [];
        for (let part of _parts2) {
          let { byteLength } = part;
          if (offset > 0 && byteLength <= offset)
            offset -= byteLength, limit -= byteLength;
          else {
            let chunk = part.subarray(offset, Math.min(byteLength, limit));
            if (blobParts.push(chunk), blobSize += chunk.byteLength, offset = 0, blobSize >= span)
              break;
          }
        }
        return blob._parts = blobParts, blob._size = blobSize, blob;
      }
      /**
       * Returns a promise that resolves with an ArrayBuffer containing the entire
       * contents of the Blob as binary data.
       * @returns {Promise<ArrayBuffer>}
       */
      // eslint-disable-next-line require-await
      async arrayBuffer() {
        let buffer = new ArrayBuffer(this.size), bytes = new Uint8Array(buffer), offset = 0;
        for (let part of this._parts)
          bytes.set(part, offset), offset += part.byteLength;
        return buffer;
      }
      /**
       * Returns a promise that resolves with a USVString containing the entire
       * contents of the Blob interpreted as UTF-8 text.
       * @returns {Promise<string>}
       */
      // eslint-disable-next-line require-await
      async text() {
        let decoder = new webEncoding.TextDecoder(), text = "";
        for (let part of this._parts)
          text += decoder.decode(part);
        return text;
      }
      /**
       * @returns {BlobStream}
       */
      stream() {
        return new BlobStream(this._parts);
      }
      /**
       * @returns {string}
       */
      toString() {
        return "[object Blob]";
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
    }, Blob3 = WebBlob, BlobStream = class extends webStream.ReadableStream {
      /**
       * @param {Uint8Array[]} chunks
       */
      constructor(chunks) {
        super(new BlobStreamController(chunks.values()), { type: "bytes" }), this._chunks = chunks;
      }
      /**
       * @param {Object} [_options]
       * @property {boolean} [_options.preventCancel]
       * @returns {AsyncIterator<Uint8Array>}
       */
      async *[Symbol.asyncIterator](_options) {
        let reader = this.getReader();
        yield* this._chunks, reader.releaseLock();
      }
    }, BlobStreamController = class {
      /**
       * @param {Iterator<Uint8Array>} chunks
       */
      constructor(chunks) {
        this.chunks = chunks;
      }
      /**
       * @param {ReadableStreamDefaultController} controller
       */
      start(controller) {
        this.work(controller), this.isWorking = !1, this.isCancelled = !1;
      }
      /**
       *
       * @param {ReadableStreamDefaultController} controller
       */
      async work(controller) {
        let { chunks } = this;
        for (this.isWorking = !0; !this.isCancelled && (controller.desiredSize || 0) > 0; ) {
          let next = null;
          try {
            next = chunks.next();
          } catch (error) {
            controller.error(error);
            break;
          }
          next && (!next.done && !this.isCancelled ? controller.enqueue(next.value) : controller.close());
        }
        this.isWorking = !1;
      }
      /**
       * @param {ReadableStreamDefaultController} controller
       */
      pull(controller) {
        this.isWorking || this.work(controller);
      }
      cancel() {
        this.isCancelled = !0;
      }
    }, readType = (input = "") => {
      let type = String(input).toLowerCase();
      return /[^\u0020-\u007E]/.test(type) ? "" : type;
    };
    Object.defineProperty(exports, "TextDecoder", {
      enumerable: !0,
      get: function() {
        return webEncoding.TextDecoder;
      }
    });
    Object.defineProperty(exports, "TextEncoder", {
      enumerable: !0,
      get: function() {
        return webEncoding.TextEncoder;
      }
    });
    Object.defineProperty(exports, "ReadableStream", {
      enumerable: !0,
      get: function() {
        return webStream.ReadableStream;
      }
    });
    exports.Blob = Blob3;
  }
});

// node_modules/@remix-run/web-blob/dist/src/lib.node.cjs
var require_lib_node = __commonJS({
  "node_modules/@remix-run/web-blob/dist/src/lib.node.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var webEncoding = require_lib(), webStream = require_stream(), blob = require_blob(), Blob3 = globalThis.Blob || // Disable node native blob until impractical perf issue is fixed
    // @see https://github.com/nodejs/node/issues/42108
    // NodeBlob ||
    blob.Blob;
    Object.defineProperty(exports, "TextDecoder", {
      enumerable: !0,
      get: function() {
        return webEncoding.TextDecoder;
      }
    });
    Object.defineProperty(exports, "TextEncoder", {
      enumerable: !0,
      get: function() {
        return webEncoding.TextEncoder;
      }
    });
    Object.defineProperty(exports, "ReadableStream", {
      enumerable: !0,
      get: function() {
        return webStream.ReadableStream;
      }
    });
    exports.Blob = Blob3;
  }
});

// node_modules/@remix-run/web-form-data/dist/src/form-data.cjs
var require_form_data = __commonJS({
  "node_modules/@remix-run/web-form-data/dist/src/form-data.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var FormData4 = class {
      /**
       * @param {HTMLFormElement} [form]
       */
      constructor(form) {
        if (this._entries = [], Object.defineProperty(this, "_entries", { enumerable: !1 }), isHTMLFormElement(form))
          for (let element of form.elements)
            if (isSelectElement(element))
              for (let option of element.options)
                option.selected && this.append(element.name, option.value);
            else
              isInputElement(element) && (element.checked || !["radio", "checkbox"].includes(element.type)) && element.name && this.append(element.name, element.value);
      }
      get [Symbol.toStringTag]() {
        return "FormData";
      }
      /**
       * Appends a new value onto an existing key inside a FormData object, or adds
       * the key if it does not already exist.
       *
       * The difference between `set` and `append` is that if the specified key
       * already exists, `set` will overwrite all existing values with the new one,
       * whereas `append` will append the new value onto the end of the existing
       * set of values.
       *
       * @param {string} name
       * @param {string|Blob|File} value - The name of the field whose data is
       * contained in value.
       * @param {string} [filename] - The filename reported to the server, when a
       * value is a `Blob` or a `File`. The default filename for a `Blob` objects is
       * `"blob"`. The default filename for a `File` is the it's name.
       */
      append(name, value = panic(
        new TypeError("FormData.append: requires at least 2 arguments")
      ), filename) {
        this._entries.push([name, toEntryValue(value, filename)]);
      }
      /**
       * Deletes a key and all its values from a FormData object.
       *
       * @param {string} name
       */
      delete(name = panic(new TypeError("FormData.delete: requires string argument"))) {
        let entries = this._entries, index = 0;
        for (; index < entries.length; ) {
          let [entryName] = (
            /** @type {[string, FormDataEntryValue]}*/
            entries[index]
          );
          entryName === name ? entries.splice(index, 1) : index++;
        }
      }
      /**
       * Returns the first value associated with a given key from within a
       * FormData object.
       *
       * @param {string} name
       * @returns {FormDataEntryValue|null}
       */
      get(name = panic(new TypeError("FormData.get: requires string argument"))) {
        for (let [entryName, value] of this._entries)
          if (entryName === name)
            return value;
        return null;
      }
      /**
       * Returns an array of all the values associated with a given key from within
       * a FormData.
       *
       * @param {string} name
       * @returns {FormDataEntryValue[]}
       */
      getAll(name = panic(new TypeError("FormData.getAll: requires string argument"))) {
        let values = [];
        for (let [entryName, value] of this._entries)
          entryName === name && values.push(value);
        return values;
      }
      /**
       * Returns a boolean stating whether a FormData object contains a certain key.
       *
       * @param {string} name
       */
      has(name = panic(new TypeError("FormData.has: requires string argument"))) {
        for (let [entryName] of this._entries)
          if (entryName === name)
            return !0;
        return !1;
      }
      /**
       * Sets a new value for an existing key inside a FormData object, or adds the
       * key/value if it does not already exist.
       *
       * @param {string} name
       * @param {string|Blob|File} value
       * @param {string} [filename]
       */
      set(name, value = panic(new TypeError("FormData.set: requires at least 2 arguments")), filename) {
        let index = 0, { _entries: entries } = this, entryValue = toEntryValue(value, filename), wasSet = !1;
        for (; index < entries.length; ) {
          let entry2 = (
            /** @type {[string, FormDataEntryValue]}*/
            entries[index]
          );
          entry2[0] === name ? wasSet ? entries.splice(index, 1) : (wasSet = !0, entry2[1] = entryValue, index++) : index++;
        }
        wasSet || entries.push([name, entryValue]);
      }
      /**
       * Method returns an iterator allowing to go through all key/value pairs
       * contained in this object.
       */
      entries() {
        return this._entries.values();
      }
      /**
       * Returns an iterator allowing to go through all keys of the key/value pairs
       * contained in this object.
       *
       * @returns {IterableIterator<string>}
       */
      *keys() {
        for (let [name] of this._entries)
          yield name;
      }
      /**
       * Returns an iterator allowing to go through all values contained in this
       * object.
       *
       * @returns {IterableIterator<FormDataEntryValue>}
       */
      *values() {
        for (let [_, value] of this._entries)
          yield value;
      }
      [Symbol.iterator]() {
        return this._entries.values();
      }
      /**
       * @param {(value: FormDataEntryValue, key: string, parent: globalThis.FormData) => void} fn
       * @param {any} [thisArg]
       * @returns {void}
       */
      forEach(fn, thisArg) {
        for (let [key, value] of this._entries)
          fn.call(thisArg, value, key, this);
      }
    }, isHTMLFormElement = (value) => Object.prototype.toString.call(value) === "[object HTMLFormElement]", toEntryValue = (value, filename) => {
      if (isFile(value))
        return filename != null ? new BlobFile([value], filename, value) : value;
      if (isBlob2(value))
        return new BlobFile([value], filename ?? "blob");
      if (filename != null && filename != "")
        throw new TypeError(
          "filename is only supported when value is Blob or File"
        );
      return `${value}`;
    }, isFile = (value) => Object.prototype.toString.call(value) === "[object File]" && typeof value.name == "string", isBlob2 = (value) => Object.prototype.toString.call(value) === "[object Blob]", BlobFile = class {
      /**
       * @param {[Blob]} parts
       * @param {string} name
       * @param {FilePropertyBag} [options]
       */
      constructor([blob], name, { lastModified = Date.now() } = {}) {
        this.blob = blob, this.name = name, this.lastModified = lastModified;
      }
      get webkitRelativePath() {
        return "";
      }
      get size() {
        return this.blob.size;
      }
      get type() {
        return this.blob.type;
      }
      /**
       *
       * @param {number} [start]
       * @param {number} [end]
       * @param {string} [contentType]
       */
      slice(start, end, contentType) {
        return this.blob.slice(start, end, contentType);
      }
      stream() {
        return this.blob.stream();
      }
      text() {
        return this.blob.text();
      }
      arrayBuffer() {
        return this.blob.arrayBuffer();
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    }, panic = (error) => {
      throw error;
    };
    function isSelectElement(element) {
      return element.tagName === "SELECT";
    }
    function isInputElement(element) {
      return element.tagName === "INPUT" || element.tagName === "TEXTAREA";
    }
    exports.FormData = FormData4;
  }
});

// node_modules/@remix-run/web-form-data/dist/src/lib.node.cjs
var require_lib_node2 = __commonJS({
  "node_modules/@remix-run/web-form-data/dist/src/lib.node.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var formData = require_form_data(), FormData4 = formData.FormData;
    exports.FormData = FormData4;
  }
});

// node_modules/@web3-storage/multipart-parser/cjs/src/utils.js
var require_utils = __commonJS({
  "node_modules/@web3-storage/multipart-parser/cjs/src/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function stringToArray(s2) {
      let utf8 = unescape(encodeURIComponent(s2));
      return Uint8Array.from(utf8, (_, i2) => utf8.charCodeAt(i2));
    }
    function arrayToString(a) {
      let utf8 = String.fromCharCode.apply(null, a);
      return decodeURIComponent(escape(utf8));
    }
    function mergeArrays(...arrays) {
      let out = new Uint8Array(arrays.reduce((total, arr) => total + arr.length, 0)), offset = 0;
      for (let arr of arrays)
        out.set(arr, offset), offset += arr.length;
      return out;
    }
    function arraysEqual(a, b) {
      if (a.length !== b.length)
        return !1;
      for (let i2 = 0; i2 < a.length; i2++)
        if (a[i2] !== b[i2])
          return !1;
      return !0;
    }
    exports.arrayToString = arrayToString;
    exports.arraysEqual = arraysEqual;
    exports.mergeArrays = mergeArrays;
    exports.stringToArray = stringToArray;
  }
});

// node_modules/@web3-storage/multipart-parser/cjs/src/search.js
var require_search = __commonJS({
  "node_modules/@web3-storage/multipart-parser/cjs/src/search.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var utils = require_utils();
    function coerce(a) {
      return a instanceof Uint8Array ? (index) => a[index] : a;
    }
    function jsmemcmp(buf1, pos1, buf2, pos2, len) {
      let fn1 = coerce(buf1), fn2 = coerce(buf2);
      for (let i2 = 0; i2 < len; ++i2)
        if (fn1(pos1 + i2) !== fn2(pos2 + i2))
          return !1;
      return !0;
    }
    function createOccurenceTable(s2) {
      let table = new Array(256).fill(s2.length);
      if (s2.length > 1)
        for (let i2 = 0; i2 < s2.length - 1; i2++)
          table[s2[i2]] = s2.length - 1 - i2;
      return table;
    }
    var MATCH = Symbol("Match"), StreamSearch = class {
      constructor(needle) {
        this._lookbehind = new Uint8Array(), typeof needle == "string" ? this._needle = needle = utils.stringToArray(needle) : this._needle = needle, this._lastChar = needle[needle.length - 1], this._occ = createOccurenceTable(needle);
      }
      feed(chunk) {
        let pos = 0, tokens, allTokens = [];
        for (; pos !== chunk.length; )
          [pos, ...tokens] = this._feed(chunk, pos), allTokens.push(...tokens);
        return allTokens;
      }
      end() {
        let tail = this._lookbehind;
        return this._lookbehind = new Uint8Array(), tail;
      }
      _feed(data, bufPos) {
        let tokens = [], pos = -this._lookbehind.length;
        if (pos < 0) {
          for (; pos < 0 && pos <= data.length - this._needle.length; ) {
            let ch = this._charAt(data, pos + this._needle.length - 1);
            if (ch === this._lastChar && this._memcmp(data, pos, this._needle.length - 1))
              return pos > -this._lookbehind.length && tokens.push(this._lookbehind.slice(0, this._lookbehind.length + pos)), tokens.push(MATCH), this._lookbehind = new Uint8Array(), [
                pos + this._needle.length,
                ...tokens
              ];
            pos += this._occ[ch];
          }
          if (pos < 0)
            for (; pos < 0 && !this._memcmp(data, pos, data.length - pos); )
              pos++;
          if (pos >= 0)
            tokens.push(this._lookbehind), this._lookbehind = new Uint8Array();
          else {
            let bytesToCutOff = this._lookbehind.length + pos;
            return bytesToCutOff > 0 && (tokens.push(this._lookbehind.slice(0, bytesToCutOff)), this._lookbehind = this._lookbehind.slice(bytesToCutOff)), this._lookbehind = Uint8Array.from(new Array(this._lookbehind.length + data.length), (_, i2) => this._charAt(data, i2 - this._lookbehind.length)), [
              data.length,
              ...tokens
            ];
          }
        }
        for (pos += bufPos; pos <= data.length - this._needle.length; ) {
          let ch = data[pos + this._needle.length - 1];
          if (ch === this._lastChar && data[pos] === this._needle[0] && jsmemcmp(this._needle, 0, data, pos, this._needle.length - 1))
            return pos > bufPos && tokens.push(data.slice(bufPos, pos)), tokens.push(MATCH), [
              pos + this._needle.length,
              ...tokens
            ];
          pos += this._occ[ch];
        }
        if (pos < data.length) {
          for (; pos < data.length && (data[pos] !== this._needle[0] || !jsmemcmp(data, pos, this._needle, 0, data.length - pos)); )
            ++pos;
          pos < data.length && (this._lookbehind = data.slice(pos));
        }
        return pos > 0 && tokens.push(data.slice(bufPos, pos < data.length ? pos : data.length)), [
          data.length,
          ...tokens
        ];
      }
      _charAt(data, pos) {
        return pos < 0 ? this._lookbehind[this._lookbehind.length + pos] : data[pos];
      }
      _memcmp(data, pos, len) {
        return jsmemcmp(this._charAt.bind(this, data), pos, this._needle, 0, len);
      }
    }, ReadableStreamSearch = class {
      constructor(needle, _readableStream) {
        this._readableStream = _readableStream, this._search = new StreamSearch(needle);
      }
      async *[Symbol.asyncIterator]() {
        let reader = this._readableStream.getReader();
        try {
          for (; ; ) {
            let result = await reader.read();
            if (result.done)
              break;
            yield* this._search.feed(result.value);
          }
          let tail = this._search.end();
          tail.length && (yield tail);
        } finally {
          reader.releaseLock();
        }
      }
    }, EOQ = Symbol("End of Queue"), QueueableStreamSearch = class {
      constructor(needle) {
        this._chunksQueue = [], this._closed = !1, this._search = new StreamSearch(needle);
      }
      push(...chunks) {
        if (this._closed)
          throw new Error("cannot call push after close");
        this._chunksQueue.push(...chunks), this._notify && this._notify();
      }
      close() {
        if (this._closed)
          throw new Error("close was already called");
        this._closed = !0, this._chunksQueue.push(EOQ), this._notify && this._notify();
      }
      async *[Symbol.asyncIterator]() {
        for (; ; ) {
          let chunk;
          for (; !(chunk = this._chunksQueue.shift()); )
            await new Promise((resolve) => this._notify = resolve), this._notify = void 0;
          if (chunk === EOQ)
            break;
          yield* this._search.feed(chunk);
        }
        let tail = this._search.end();
        tail.length && (yield tail);
      }
    };
    function splitChunks(chunks, needle) {
      let search = new StreamSearch(needle), outchunks = [[]];
      for (let chunk of chunks)
        for (let token of search.feed(chunk))
          token === MATCH ? outchunks.push([]) : outchunks[outchunks.length - 1].push(token);
      let end = search.end();
      return outchunks[outchunks.length - 1].push(end), outchunks.map((chunks2) => utils.mergeArrays(...chunks2));
    }
    function split(buf, needle) {
      return splitChunks([buf], needle);
    }
    async function* chunksIterator(iter) {
      let chunks = [];
      for await (let value of iter)
        value === MATCH ? (yield chunks, chunks = []) : chunks.push(value);
      yield chunks;
    }
    async function* stringIterator(iter) {
      for await (let chunk of chunksIterator(iter))
        yield chunk.map(utils.arrayToString).join("");
    }
    async function allStrings(iter) {
      let segments = [];
      for await (let value of stringIterator(iter))
        segments.push(value);
      return segments;
    }
    async function* arrayIterator(iter) {
      for await (let chunk of chunksIterator(iter))
        yield utils.mergeArrays(...chunk);
    }
    exports.MATCH = MATCH;
    exports.QueueableStreamSearch = QueueableStreamSearch;
    exports.ReadableStreamSearch = ReadableStreamSearch;
    exports.StreamSearch = StreamSearch;
    exports.allStrings = allStrings;
    exports.arrayIterator = arrayIterator;
    exports.chunksIterator = chunksIterator;
    exports.split = split;
    exports.splitChunks = splitChunks;
    exports.stringIterator = stringIterator;
  }
});

// node_modules/@web3-storage/multipart-parser/cjs/src/index.js
var require_src2 = __commonJS({
  "node_modules/@web3-storage/multipart-parser/cjs/src/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var search = require_search(), utils = require_utils(), mergeArrays2 = Function.prototype.apply.bind(utils.mergeArrays, void 0), dash = utils.stringToArray("--"), CRLF = utils.stringToArray(`\r
`);
    function parseContentDisposition(header) {
      let parts = header.split(";").map((part) => part.trim());
      if (parts.shift() !== "form-data")
        throw new Error('malformed content-disposition header: missing "form-data" in `' + JSON.stringify(parts) + "`");
      let out = {};
      for (let part of parts) {
        let kv = part.split("=", 2);
        if (kv.length !== 2)
          throw new Error("malformed content-disposition header: key-value pair not found - " + part + " in `" + header + "`");
        let [name, value] = kv;
        if (value[0] === '"' && value[value.length - 1] === '"')
          out[name] = value.slice(1, -1).replace(/\\"/g, '"');
        else if (value[0] !== '"' && value[value.length - 1] !== '"')
          out[name] = value;
        else if (value[0] === '"' && value[value.length - 1] !== '"' || value[0] !== '"' && value[value.length - 1] === '"')
          throw new Error("malformed content-disposition header: mismatched quotations in `" + header + "`");
      }
      if (!out.name)
        throw new Error("malformed content-disposition header: missing field name in `" + header + "`");
      return out;
    }
    function parsePartHeaders(lines) {
      let entries = [], disposition = !1, line;
      for (; typeof (line = lines.shift()) < "u"; ) {
        let colon = line.indexOf(":");
        if (colon === -1)
          throw new Error("malformed multipart-form header: missing colon");
        let header = line.slice(0, colon).trim().toLowerCase(), value = line.slice(colon + 1).trim();
        switch (header) {
          case "content-disposition":
            disposition = !0, entries.push(...Object.entries(parseContentDisposition(value)));
            break;
          case "content-type":
            entries.push([
              "contentType",
              value
            ]);
        }
      }
      if (!disposition)
        throw new Error("malformed multipart-form header: missing content-disposition");
      return Object.fromEntries(entries);
    }
    async function readHeaderLines(it, needle) {
      let firstChunk = !0, lastTokenWasMatch = !1, headerLines = [[]], crlfSearch = new search.StreamSearch(CRLF);
      for (; ; ) {
        let result = await it.next();
        if (result.done)
          throw new Error("malformed multipart-form data: unexpected end of stream");
        if (firstChunk && result.value !== search.MATCH && utils.arraysEqual(result.value.slice(0, 2), dash))
          return [
            void 0,
            new Uint8Array()
          ];
        let chunk;
        if (result.value !== search.MATCH)
          chunk = result.value;
        else if (!lastTokenWasMatch)
          chunk = needle;
        else
          throw new Error("malformed multipart-form data: unexpected boundary");
        if (!chunk.length)
          continue;
        firstChunk && (firstChunk = !1);
        let tokens = crlfSearch.feed(chunk);
        for (let [i2, token] of tokens.entries()) {
          let isMatch = token === search.MATCH;
          if (!(!isMatch && !token.length)) {
            if (lastTokenWasMatch && isMatch)
              return tokens.push(crlfSearch.end()), [
                headerLines.filter((chunks) => chunks.length).map(mergeArrays2).map(utils.arrayToString),
                utils.mergeArrays(...tokens.slice(i2 + 1).map((token2) => token2 === search.MATCH ? CRLF : token2))
              ];
            (lastTokenWasMatch = isMatch) ? headerLines.push([]) : headerLines[headerLines.length - 1].push(token);
          }
        }
      }
    }
    async function* streamMultipart(body, boundary) {
      let needle = utils.mergeArrays(dash, utils.stringToArray(boundary)), it = new search.ReadableStreamSearch(needle, body)[Symbol.asyncIterator]();
      for (; ; ) {
        let result = await it.next();
        if (result.done)
          return;
        if (result.value === search.MATCH)
          break;
      }
      let crlfSearch = new search.StreamSearch(CRLF);
      for (; ; ) {
        let feedChunk = function(chunk) {
          let chunks = [];
          for (let token of crlfSearch.feed(chunk))
            trailingCRLF && chunks.push(CRLF), (trailingCRLF = token === search.MATCH) || chunks.push(token);
          return utils.mergeArrays(...chunks);
        }, [headerLines, tail] = await readHeaderLines(it, needle);
        if (!headerLines)
          return;
        async function nextToken() {
          let result = await it.next();
          if (result.done)
            throw new Error("malformed multipart-form data: unexpected end of stream");
          return result;
        }
        let trailingCRLF = !1, done = !1;
        async function nextChunk() {
          let result = await nextToken(), chunk;
          if (result.value !== search.MATCH)
            chunk = result.value;
          else if (!trailingCRLF)
            chunk = CRLF;
          else
            return done = !0, { value: crlfSearch.end() };
          return { value: feedChunk(chunk) };
        }
        let bufferedChunks = [{ value: feedChunk(tail) }];
        for (yield {
          ...parsePartHeaders(headerLines),
          data: {
            [Symbol.asyncIterator]() {
              return this;
            },
            async next() {
              for (; ; ) {
                let result = bufferedChunks.shift();
                if (!result)
                  break;
                if (result.value.length > 0)
                  return result;
              }
              for (; ; ) {
                if (done)
                  return {
                    done,
                    value: void 0
                  };
                let result = await nextChunk();
                if (result.value.length > 0)
                  return result;
              }
            }
          }
        }; !done; )
          bufferedChunks.push(await nextChunk());
      }
    }
    async function* iterateMultipart(body, boundary) {
      for await (let part of streamMultipart(body, boundary)) {
        let chunks = [];
        for await (let chunk of part.data)
          chunks.push(chunk);
        yield {
          ...part,
          data: utils.mergeArrays(...chunks)
        };
      }
    }
    exports.iterateMultipart = iterateMultipart;
    exports.streamMultipart = streamMultipart;
  }
});

// node_modules/@remix-run/web-fetch/dist/lib.node.cjs
var require_lib_node3 = __commonJS({
  "node_modules/@remix-run/web-fetch/dist/lib.node.cjs"(exports, module2) {
    "use strict";
    var http3 = require("http"), https2 = require("https"), zlib2 = require("zlib"), fs2 = require("fs"), mime = require_mrmime(), dataUriToBuffer2 = require_src(), Stream3 = require("stream"), util = require("util"), webBlob = require_lib_node(), webFormData = require_lib_node2(), crypto = require("crypto"), multipartParser = require_src2(), url = require("url"), abortController = require_abort_controller(), FetchBaseError2 = class extends Error {
      /**
       * @param {string} message 
       * @param {string} type 
       */
      constructor(message, type) {
        super(message), Error.captureStackTrace(this, this.constructor), this.type = type;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    }, FetchError2 = class extends FetchBaseError2 {
      /**
       * @param  {string} message -      Error message for human
       * @param  {string} type -        Error type for machine
       * @param  {SystemError} [systemError] - For Node.js system error
       */
      constructor(message, type, systemError) {
        super(message, type), systemError && (this.code = this.errno = systemError.code, this.erroredSysCall = systemError.syscall);
      }
    }, NAME2 = Symbol.toStringTag, isURLSearchParameters2 = (object) => typeof object == "object" && typeof object.append == "function" && typeof object.delete == "function" && typeof object.get == "function" && typeof object.getAll == "function" && typeof object.has == "function" && typeof object.set == "function" && typeof object.sort == "function" && object[NAME2] === "URLSearchParams", isBlob2 = (object) => typeof object == "object" && typeof object.arrayBuffer == "function" && typeof object.type == "string" && typeof object.stream == "function" && typeof object.constructor == "function" && /^(Blob|File)$/.test(object[NAME2]);
    function isFormData(object) {
      return typeof object == "object" && typeof object.append == "function" && typeof object.set == "function" && typeof object.get == "function" && typeof object.getAll == "function" && typeof object.delete == "function" && typeof object.keys == "function" && typeof object.values == "function" && typeof object.entries == "function" && typeof object.constructor == "function" && object[NAME2] === "FormData";
    }
    var isMultipartFormDataStream = (value) => value instanceof Stream3 && typeof value.getBoundary == "function" && typeof value.hasKnownLength == "function" && typeof value.getLengthSync == "function", isAbortSignal2 = (object) => typeof object == "object" && (object[NAME2] === "AbortSignal" || object[NAME2] === "EventTarget"), isReadableStream = (value) => typeof value == "object" && typeof value.getReader == "function" && typeof value.cancel == "function" && typeof value.tee == "function", isIterable = (value) => value && Symbol.iterator in value, carriage = `\r
`, dashes = "-".repeat(2), carriageLength = Buffer.byteLength(carriage), getFooter = (boundary) => `${dashes}${boundary}${dashes}${carriage.repeat(2)}`;
    function getHeader(boundary, name, field) {
      let header = "";
      if (header += `${dashes}${boundary}${carriage}`, header += `Content-Disposition: form-data; name="${name}"`, isBlob2(field)) {
        let { name: name2 = "blob", type } = (
          /** @type {Blob & {name?:string}} */
          field
        );
        header += `; filename="${name2}"${carriage}`, header += `Content-Type: ${type || "application/octet-stream"}`;
      }
      return `${header}${carriage.repeat(2)}`;
    }
    var getBoundary = () => crypto.randomBytes(8).toString("hex");
    async function* formDataIterator(form, boundary) {
      let encoder2 = new TextEncoder();
      for (let [name, value] of form)
        yield encoder2.encode(getHeader(boundary, name, value)), isBlob2(value) ? yield* value.stream() : yield encoder2.encode(value), yield encoder2.encode(carriage);
      yield encoder2.encode(getFooter(boundary));
    }
    function getFormDataLength(form, boundary) {
      let length = 0;
      for (let [name, value] of form)
        length += Buffer.byteLength(getHeader(boundary, name, value)), isBlob2(value) ? length += value.size : length += Buffer.byteLength(String(value)), length += carriageLength;
      return length += Buffer.byteLength(getFooter(boundary)), length;
    }
    var toFormData2 = async (source) => {
      let { body, headers } = source, contentType = (headers == null ? void 0 : headers.get("Content-Type")) || "";
      if (contentType.startsWith("application/x-www-form-urlencoded") && body != null) {
        let form = new webFormData.FormData(), bodyText = await source.text();
        return new URLSearchParams(bodyText).forEach((v, k) => form.append(k, v)), form;
      }
      let [type, boundary] = contentType.split(/\s*;\s*boundary=/);
      if (type === "multipart/form-data" && boundary != null && body != null) {
        let form = new webFormData.FormData(), parts = multipartParser.iterateMultipart(body, boundary);
        for await (let { name, data, filename, contentType: contentType2 } of parts)
          filename ? form.append(name, new File([data], filename, { type: contentType2 })) : form.append(name, new TextDecoder().decode(data), filename);
        return form;
      } else
        throw new TypeError("Could not parse content as FormData.");
    }, encoder = new util.TextEncoder(), decoder = new util.TextDecoder(), encode = (text) => encoder.encode(text), decode = (bytes) => decoder.decode(bytes), { readableHighWaterMark } = new Stream3.Readable(), INTERNALS$2 = Symbol("Body internals"), Body2 = class {
      /**
       * @param {BodyInit|Stream|null} body
       * @param {{size?:number}} options
       */
      constructor(body, {
        size = 0
      } = {}) {
        let state = {
          /** @type {null|ReadableStream<Uint8Array>} */
          body: null,
          /** @type {string|null} */
          type: null,
          /** @type {number|null} */
          size: null,
          /** @type {null|string} */
          boundary: null,
          disturbed: !1,
          /** @type {null|Error} */
          error: null
        };
        if (this[INTERNALS$2] = state, body === null)
          state.body = null, state.size = 0;
        else if (isURLSearchParameters2(body)) {
          let bytes = encode(body.toString());
          state.body = fromBytes(bytes), state.size = bytes.byteLength, state.type = "application/x-www-form-urlencoded;charset=UTF-8";
        } else if (isBlob2(body))
          state.size = body.size, state.type = body.type || null, state.body = body.stream();
        else if (body instanceof Uint8Array)
          state.body = fromBytes(body), state.size = body.byteLength;
        else if (util.types.isAnyArrayBuffer(body)) {
          let bytes = new Uint8Array(body);
          state.body = fromBytes(bytes), state.size = bytes.byteLength;
        } else if (ArrayBuffer.isView(body)) {
          let bytes = new Uint8Array(body.buffer, body.byteOffset, body.byteLength);
          state.body = fromBytes(bytes), state.size = bytes.byteLength;
        } else if (isReadableStream(body))
          state.body = body;
        else if (isFormData(body)) {
          let boundary = `NodeFetchFormDataBoundary${getBoundary()}`;
          state.type = `multipart/form-data; boundary=${boundary}`, state.size = getFormDataLength(body, boundary), state.body = fromAsyncIterable(formDataIterator(body, boundary));
        } else if (isMultipartFormDataStream(body))
          state.type = `multipart/form-data; boundary=${body.getBoundary()}`, state.size = body.hasKnownLength() ? body.getLengthSync() : null, state.body = fromStream(body);
        else if (body instanceof Stream3)
          state.body = fromStream(body);
        else {
          let bytes = encode(String(body));
          state.type = "text/plain;charset=UTF-8", state.size = bytes.byteLength, state.body = fromBytes(bytes);
        }
        this.size = size;
      }
      /** @type {Headers} */
      /* c8 ignore next 3 */
      get headers() {
        throw new TypeError("'get headers' called on an object that does not implements interface.");
      }
      get body() {
        return this[INTERNALS$2].body;
      }
      get bodyUsed() {
        return this[INTERNALS$2].disturbed;
      }
      /**
       * Decode response as ArrayBuffer
       *
       * @return {Promise<ArrayBuffer>}
       */
      async arrayBuffer() {
        let { buffer, byteOffset, byteLength } = await consumeBody2(this);
        return buffer.slice(byteOffset, byteOffset + byteLength);
      }
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      async blob() {
        let ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].type || "", buf = await consumeBody2(this);
        return new webBlob.Blob([buf], {
          type: ct
        });
      }
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      async json() {
        return JSON.parse(await this.text());
      }
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      async text() {
        let buffer = await consumeBody2(this);
        return decode(buffer);
      }
      /**
       * @returns {Promise<FormData>}
       */
      async formData() {
        return toFormData2(this);
      }
    };
    Object.defineProperties(Body2.prototype, {
      body: { enumerable: !0 },
      bodyUsed: { enumerable: !0 },
      arrayBuffer: { enumerable: !0 },
      blob: { enumerable: !0 },
      json: { enumerable: !0 },
      text: { enumerable: !0 },
      formData: { enumerable: !0 }
    });
    async function consumeBody2(data) {
      let state = data[INTERNALS$2];
      if (state.disturbed)
        throw new TypeError(`body used already for: ${data.url}`);
      if (state.disturbed = !0, state.error)
        throw state.error;
      let { body } = state;
      if (body === null)
        return new Uint8Array(0);
      let [buffer, chunks, limit] = data.size > 0 ? [new Uint8Array(data.size), [], data.size] : [null, [], 1 / 0], offset = 0, source = streamIterator(body);
      try {
        for await (let chunk of source) {
          let bytes = chunk instanceof Uint8Array ? chunk : Buffer.from(chunk);
          if (offset + bytes.byteLength > limit) {
            let error = new FetchError2(`content size at ${data.url} over limit: ${limit}`, "max-size");
            throw source.throw(error), error;
          } else
            buffer ? buffer.set(bytes, offset) : chunks.push(bytes);
          offset += bytes.byteLength;
        }
        if (buffer) {
          if (offset < buffer.byteLength)
            throw new FetchError2(`Premature close of server response while trying to fetch ${data.url}`, "premature-close");
          return buffer;
        } else
          return writeBytes(new Uint8Array(offset), chunks);
      } catch (error) {
        if (error instanceof FetchBaseError2)
          throw error;
        if (error && error.name === "AbortError")
          throw error;
        {
          let e2 = (
            /** @type {import('./errors/fetch-error').SystemError} */
            error
          );
          throw new FetchError2(`Invalid response body while trying to fetch ${data.url}: ${e2.message}`, "system", e2);
        }
      }
    }
    var clone2 = (instance) => {
      let { body } = instance;
      if (instance.bodyUsed)
        throw new Error("cannot clone body after it is used");
      if (!body)
        return null;
      let [left, right] = body.tee();
      return instance[INTERNALS$2].body = left, right;
    }, extractContentType2 = (source) => source[INTERNALS$2].type, getTotalBytes2 = (source) => source[INTERNALS$2].size, writeToStream2 = (dest, { body }) => {
      body === null ? dest.end() : Stream3.Readable.from(streamIterator(body)).pipe(dest);
    }, StreamIterableIterator = class {
      /**
       * @param {ReadableStream<T>} stream
       */
      constructor(stream) {
        this.stream = stream, this.reader = null;
      }
      /**
       * @returns {AsyncGenerator<T, void, void>}
       */
      [Symbol.asyncIterator]() {
        return this;
      }
      getReader() {
        if (this.reader)
          return this.reader;
        let reader = this.stream.getReader();
        return this.reader = reader, reader;
      }
      /**
       * @returns {Promise<IteratorResult<T, void>>}
       */
      next() {
        return (
          /** @type {Promise<IteratorResult<T, void>>} */
          this.getReader().read()
        );
      }
      /**
       * @returns {Promise<IteratorResult<T, void>>}
       */
      async return() {
        return this.reader && await this.reader.cancel(), { done: !0, value: void 0 };
      }
      /**
       * 
       * @param {any} error 
       * @returns {Promise<IteratorResult<T, void>>}
       */
      async throw(error) {
        return await this.getReader().cancel(error), { done: !0, value: void 0 };
      }
    }, streamIterator = (stream) => new StreamIterableIterator(stream), writeBytes = (buffer, chunks) => {
      let offset = 0;
      for (let chunk of chunks)
        buffer.set(chunk, offset), offset += chunk.byteLength;
      return buffer;
    }, fromBytes = (bytes) => new webBlob.ReadableStream({
      start(controller) {
        controller.enqueue(bytes), controller.close();
      }
    }), fromAsyncIterable = (content) => new webBlob.ReadableStream(new AsyncIterablePump(content)), AsyncIterablePump = class {
      /**
       * @param {AsyncIterable<Uint8Array>} source
       */
      constructor(source) {
        this.source = source[Symbol.asyncIterator]();
      }
      /**
       * @param {ReadableStreamController<Uint8Array>} controller
       */
      async pull(controller) {
        try {
          for (; controller.desiredSize || 0 > 0; ) {
            let next = await this.source.next();
            if (next.done) {
              controller.close();
              break;
            } else
              controller.enqueue(next.value);
          }
        } catch (error) {
          controller.error(error);
        }
      }
      /**
       * @param {any} [reason]
       */
      cancel(reason) {
        reason ? typeof this.source.throw == "function" ? this.source.throw(reason) : typeof this.source.return == "function" && this.source.return() : typeof this.source.return == "function" && this.source.return();
      }
    }, fromStream = (source) => {
      let pump2 = new StreamPump(source);
      return new webBlob.ReadableStream(pump2, pump2);
    }, StreamPump = class {
      /**
       * @param {Stream & {
       * 	readableHighWaterMark?: number
       * 	readable?:boolean,
       * 	resume?: () => void,
       * 	pause?: () => void
       * 	destroy?: (error?:Error) => void
       * }} stream
       */
      constructor(stream) {
        this.highWaterMark = stream.readableHighWaterMark || readableHighWaterMark, this.accumalatedSize = 0, this.stream = stream, this.enqueue = this.enqueue.bind(this), this.error = this.error.bind(this), this.close = this.close.bind(this);
      }
      /**
       * @param {Uint8Array} [chunk]
       */
      size(chunk) {
        return (chunk == null ? void 0 : chunk.byteLength) || 0;
      }
      /**
       * @param {ReadableStreamController<Uint8Array>} controller
       */
      start(controller) {
        this.controller = controller, this.stream.on("data", this.enqueue), this.stream.once("error", this.error), this.stream.once("end", this.close), this.stream.once("close", this.close);
      }
      pull() {
        this.resume();
      }
      /**
       * @param {any} [reason]
       */
      cancel(reason) {
        this.stream.destroy && this.stream.destroy(reason), this.stream.off("data", this.enqueue), this.stream.off("error", this.error), this.stream.off("end", this.close), this.stream.off("close", this.close);
      }
      /**
       * @param {Uint8Array|string} chunk
       */
      enqueue(chunk) {
        if (this.controller)
          try {
            let bytes = chunk instanceof Uint8Array ? chunk : Buffer.from(chunk), available = (this.controller.desiredSize || 0) - bytes.byteLength;
            this.controller.enqueue(bytes), available <= 0 && this.pause();
          } catch {
            this.controller.error(new Error("Could not create Buffer, chunk must be of type string or an instance of Buffer, ArrayBuffer, or Array or an Array-like Object")), this.cancel();
          }
      }
      pause() {
        this.stream.pause && this.stream.pause();
      }
      resume() {
        this.stream.readable && this.stream.resume && this.stream.resume();
      }
      close() {
        this.controller && (this.controller.close(), delete this.controller);
      }
      /**
       * @param {Error} error 
       */
      error(error) {
        this.controller && (this.controller.error(error), delete this.controller);
      }
    }, validators = (
      /** @type {{validateHeaderName?:(name:string) => any, validateHeaderValue?:(name:string, value:string) => any}} */
      http3
    ), validateHeaderName2 = typeof validators.validateHeaderName == "function" ? validators.validateHeaderName : (
      /**
       * @param {string} name
       */
      (name) => {
        if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
          let err = new TypeError(`Header name must be a valid HTTP token [${name}]`);
          throw Object.defineProperty(err, "code", { value: "ERR_INVALID_HTTP_TOKEN" }), err;
        }
      }
    ), validateHeaderValue2 = typeof validators.validateHeaderValue == "function" ? validators.validateHeaderValue : (
      /**
       * @param {string} name
       * @param {string} value
       */
      (name, value) => {
        if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
          let err = new TypeError(`Invalid character in header content ["${name}"]`);
          throw Object.defineProperty(err, "code", { value: "ERR_INVALID_CHAR" }), err;
        }
      }
    ), Headers3 = class extends URLSearchParams {
      /**
       * Headers class
       *
       * @constructor
       * @param {HeadersInit} [init] - Response headers
       */
      constructor(init) {
        let result = [];
        if (init instanceof Headers3) {
          let raw = init.raw();
          for (let [name, values] of Object.entries(raw))
            result.push(...values.map((value) => [name, value]));
        } else if (init != null)
          if (isIterable(init))
            result = [...init].map((pair) => {
              if (typeof pair != "object" || util.types.isBoxedPrimitive(pair))
                throw new TypeError("Each header pair must be an iterable object");
              return [...pair];
            }).map((pair) => {
              if (pair.length !== 2)
                throw new TypeError("Each header pair must be a name/value tuple");
              return [...pair];
            });
          else if (typeof init == "object" && init !== null)
            result.push(...Object.entries(init));
          else
            throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        return result = result.length > 0 ? result.map(([name, value]) => (validateHeaderName2(name), validateHeaderValue2(name, String(value)), [String(name).toLowerCase(), String(value)])) : [], super(result), new Proxy(this, {
          get(target, p, receiver) {
            switch (p) {
              case "append":
              case "set":
                return (name, value) => (validateHeaderName2(name), validateHeaderValue2(name, String(value)), URLSearchParams.prototype[p].call(
                  target,
                  String(name).toLowerCase(),
                  String(value)
                ));
              case "delete":
              case "has":
              case "getAll":
                return (name) => (validateHeaderName2(name), URLSearchParams.prototype[p].call(
                  target,
                  String(name).toLowerCase()
                ));
              case "keys":
                return () => (target.sort(), new Set(URLSearchParams.prototype.keys.call(target)).keys());
              default:
                return Reflect.get(target, p, receiver);
            }
          }
          /* c8 ignore next */
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      /**
       *
       * @param {string} name
       */
      get(name) {
        let values = this.getAll(name);
        if (values.length === 0)
          return null;
        let value = values.join(", ");
        return /^content-encoding$/i.test(name) && (value = value.toLowerCase()), value;
      }
      /**
       * @param {(value: string, key: string, parent: this) => void} callback
       * @param {any} thisArg
       * @returns {void}
       */
      forEach(callback, thisArg = void 0) {
        for (let name of this.keys())
          Reflect.apply(callback, thisArg, [this.get(name), name, this]);
      }
      /**
       * @returns {IterableIterator<string>}
       */
      *values() {
        for (let name of this.keys())
          yield (
            /** @type {string} */
            this.get(name)
          );
      }
      /**
       * @returns {IterableIterator<[string, string]>}
       */
      *entries() {
        for (let name of this.keys())
          yield [
            name,
            /** @type {string} */
            this.get(name)
          ];
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      /**
       * Node-fetch non-spec method
       * returning all headers and their values as array
       * @returns {Record<string, string[]>}
       */
      raw() {
        return [...this.keys()].reduce(
          (result, key) => (result[key] = this.getAll(key), result),
          /** @type {Record<string, string[]>} */
          {}
        );
      }
      /**
       * For better console.log(headers) and also to convert Headers into Node.js Request compatible format
       */
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce(
          (result, key) => {
            let values = this.getAll(key);
            return key === "host" ? result[key] = values[0] : result[key] = values.length > 1 ? values : values[0], result;
          },
          /** @type {Record<string, string|string[]>} */
          {}
        );
      }
    };
    Object.defineProperties(
      Headers3.prototype,
      ["get", "entries", "forEach", "values"].reduce(
        (result, property) => (result[property] = { enumerable: !0 }, result),
        /** @type {Record<string, {enumerable:true}>} */
        {}
      )
    );
    function fromRawHeaders2(headers = []) {
      return new Headers3(
        headers.reduce(
          (result, value, index, array) => (index % 2 === 0 && result.push(array.slice(index, index + 2)), result),
          /** @type {string[][]} */
          []
        ).filter(([name, value]) => {
          try {
            return validateHeaderName2(name), validateHeaderValue2(name, String(value)), !0;
          } catch {
            return !1;
          }
        })
      );
    }
    var redirectStatus2 = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]), isRedirect2 = (code) => redirectStatus2.has(code), INTERNALS$1 = Symbol("Response internals"), Response4 = class extends Body2 {
      /**
       * @param {BodyInit|import('stream').Stream|null} [body] - Readable stream
       * @param {ResponseInit & Ext} [options] - Response options
       */
      constructor(body = null, options = {}) {
        super(body, options);
        let status = options.status || 200, headers = new Headers3(options.headers);
        if (body !== null && !headers.has("Content-Type")) {
          let contentType = extractContentType2(this);
          contentType && headers.append("Content-Type", contentType);
        }
        this[INTERNALS$1] = {
          url: options.url,
          status,
          statusText: options.statusText || "",
          headers,
          counter: options.counter || 0,
          highWaterMark: options.highWaterMark
        };
      }
      /**
       * @type {ResponseType}
       */
      get type() {
        return "default";
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      /**
       * @type {Headers}
       */
      get headers() {
        return this[INTERNALS$1].headers;
      }
      get highWaterMark() {
        return this[INTERNALS$1].highWaterMark;
      }
      /**
       * Clone this response
       *
       * @returns {Response}
       */
      clone() {
        return new Response4(clone2(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          size: this.size
        });
      }
      /**
       * @param {string} url    The URL that the new response is to originate from.
       * @param {number} status An optional status code for the response (e.g., 302.)
       * @returns {Response}    A Response object.
       */
      static redirect(url2, status = 302) {
        if (!isRedirect2(status))
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        return new Response4(null, {
          headers: {
            location: new URL(url2).toString()
          },
          status
        });
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response4.prototype, {
      url: { enumerable: !0 },
      status: { enumerable: !0 },
      ok: { enumerable: !0 },
      redirected: { enumerable: !0 },
      statusText: { enumerable: !0 },
      headers: { enumerable: !0 },
      clone: { enumerable: !0 }
    });
    var getSearch2 = (parsedURL) => {
      if (parsedURL.search)
        return parsedURL.search;
      let lastOffset = parsedURL.href.length - 1, hash = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
      return parsedURL.href[lastOffset - hash.length] === "?" ? "?" : "";
    }, INTERNALS4 = Symbol("Request internals"), forbiddenMethods = /* @__PURE__ */ new Set(["CONNECT", "TRACE", "TRACK"]), normalizedMethods = /* @__PURE__ */ new Set(["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"]), isRequest2 = (object) => typeof object == "object" && typeof object[INTERNALS4] == "object", Request3 = class extends Body2 {
      /**
       * @param {string|Request|URL} info  Url or Request instance
       * @param {RequestInit & RequestExtraOptions} init   Custom options
       */
      constructor(info, init = {}) {
        let parsedURL, settings;
        isRequest2(info) ? (parsedURL = new URL(info.url), settings = info) : (parsedURL = new URL(info), settings = {});
        let method = init.method || settings.method || "GET";
        if (forbiddenMethods.has(method.toUpperCase()))
          throw new TypeError(`Failed to construct 'Request': '${method}' HTTP method is unsupported.`);
        normalizedMethods.has(method.toUpperCase()) && (method = method.toUpperCase());
        let inputBody = init.body != null ? init.body : isRequest2(info) && info.body !== null ? clone2(info) : null;
        if (inputBody != null && (method === "GET" || method === "HEAD"))
          throw new TypeError("Request with GET/HEAD method cannot have body");
        super(inputBody, {
          size: init.size || settings.size || 0
        });
        let input = settings, headers = (
          /** @type {globalThis.Headers} */
          new Headers3(init.headers || input.headers || {})
        );
        if (inputBody !== null && !headers.has("Content-Type")) {
          let contentType = extractContentType2(this);
          contentType && headers.append("Content-Type", contentType);
        }
        let signal = "signal" in init ? init.signal : isRequest2(input) ? input.signal : null;
        if (signal != null && !isAbortSignal2(signal))
          throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
        if (!signal) {
          let AbortControllerConstructor = typeof AbortController < "u" ? AbortController : abortController.AbortController;
          signal = new AbortControllerConstructor().signal;
        }
        this[INTERNALS4] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          credentials: init.credentials || "same-origin",
          parsedURL,
          signal: signal || null
        }, this.keepalive, this.follow = init.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init.follow, this.compress = init.compress === void 0 ? input.compress === void 0 ? !0 : input.compress : init.compress, this.counter = init.counter || input.counter || 0, this.agent = init.agent || input.agent, this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384, this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || !1;
      }
      /**
       * @type {RequestCache}
       */
      get cache() {
        return "default";
      }
      /**
       * @type {RequestCredentials}
       */
      get credentials() {
        return this[INTERNALS4].credentials;
      }
      /**
       * @type {RequestDestination}
       */
      get destination() {
        return "";
      }
      get integrity() {
        return "";
      }
      /** @type {RequestMode} */
      get mode() {
        return "cors";
      }
      /** @type {string} */
      get referrer() {
        return "";
      }
      /** @type {ReferrerPolicy} */
      get referrerPolicy() {
        return "";
      }
      get method() {
        return this[INTERNALS4].method;
      }
      /**
       * @type {string}
       */
      get url() {
        return url.format(this[INTERNALS4].parsedURL);
      }
      /**
       * @type {globalThis.Headers}
       */
      get headers() {
        return this[INTERNALS4].headers;
      }
      get redirect() {
        return this[INTERNALS4].redirect;
      }
      /**
       * @returns {AbortSignal}
       */
      get signal() {
        return this[INTERNALS4].signal;
      }
      /**
       * Clone this request
       *
       * @return  {globalThis.Request}
       */
      clone() {
        return new Request3(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request3.prototype, {
      method: { enumerable: !0 },
      url: { enumerable: !0 },
      headers: { enumerable: !0 },
      redirect: { enumerable: !0 },
      clone: { enumerable: !0 },
      signal: { enumerable: !0 }
    });
    var getNodeRequestOptions2 = (request) => {
      let { parsedURL } = request[INTERNALS4], headers = new Headers3(request[INTERNALS4].headers);
      headers.has("Accept") || headers.set("Accept", "*/*");
      let contentLengthValue = null;
      if (request.body === null && /^(post|put)$/i.test(request.method) && (contentLengthValue = "0"), request.body !== null) {
        let totalBytes = getTotalBytes2(request);
        typeof totalBytes == "number" && !Number.isNaN(totalBytes) && (contentLengthValue = String(totalBytes));
      }
      contentLengthValue && headers.set("Content-Length", contentLengthValue), headers.has("User-Agent") || headers.set("User-Agent", "node-fetch"), request.compress && !headers.has("Accept-Encoding") && headers.set("Accept-Encoding", "gzip,deflate,br");
      let { agent } = request;
      typeof agent == "function" && (agent = agent(parsedURL)), !headers.has("Connection") && !agent && headers.set("Connection", "close");
      let search = getSearch2(parsedURL);
      return {
        path: parsedURL.pathname + search,
        pathname: parsedURL.pathname,
        hostname: parsedURL.hostname,
        protocol: parsedURL.protocol,
        port: parsedURL.port,
        hash: parsedURL.hash,
        search: parsedURL.search,
        // @ts-ignore - it does not has a query
        query: parsedURL.query,
        href: parsedURL.href,
        method: request.method,
        // @ts-ignore - not sure what this supposed to do
        headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
        insecureHTTPParser: request.insecureHTTPParser,
        agent
      };
    }, AbortError2 = class extends FetchBaseError2 {
      /**
       * @param {string} message 
       * @param {string} [type]
       */
      constructor(message, type = "aborted") {
        super(message, type);
      }
    }, supportedSchemas2 = /* @__PURE__ */ new Set(["data:", "http:", "https:", "file:"]);
    async function fetch4(url2, options_ = {}) {
      return new Promise((resolve, reject) => {
        let request = new Request3(url2, options_), options = getNodeRequestOptions2(request);
        if (!supportedSchemas2.has(options.protocol))
          throw new TypeError(`node-fetch cannot load ${url2}. URL scheme "${options.protocol.replace(/:$/, "")}" is not supported.`);
        if (options.protocol === "data:") {
          let data = dataUriToBuffer2(request.url.toString()), response2 = new Response4(data, { headers: { "Content-Type": data.typeFull } });
          resolve(response2);
          return;
        }
        if (options.protocol === "file:") {
          let stream = fs2.createReadStream(new URL(request.url)), type = mime.lookup(request.url) || "application/octet-stream", response2 = new Response4(stream, { headers: { "Content-Type": type } });
          resolve(response2);
          return;
        }
        let send = (options.protocol === "https:" ? https2 : http3).request, { signal } = request, response = null, response_ = null, abort = () => {
          let error = new AbortError2("The operation was aborted.");
          reject(error), request.body && request.body.cancel(error), response_ && response_.emit("error", error);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        let abortAndFinalize = () => {
          abort(), finalize();
        }, request_ = send(options);
        signal && signal.addEventListener("abort", abortAndFinalize);
        let finalize = () => {
          request_.abort(), signal && signal.removeEventListener("abort", abortAndFinalize);
        };
        request_.on("error", (err) => {
          reject(new FetchError2(`request to ${request.url} failed, reason: ${err.message}`, "system", err)), finalize();
        }), fixResponseChunkedTransferBadEnding2(request_, (err) => {
          signal && signal.aborted || response_ == null || response_.emit("error", err);
        }), parseInt(process.version.substring(1)) < 14 && request_.on("socket", (s2) => {
          s2.prependListener("close", (hadError) => {
            let hasDataListener = s2.listenerCount("data") > 0;
            if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
              let err = Object.assign(new Error("Premature close"), {
                code: "ERR_STREAM_PREMATURE_CLOSE"
              });
              response_ == null || response_.emit("error", err);
            }
          });
        }), request_.on("response", (incoming) => {
          response_ = incoming, request_.setTimeout(0);
          let headers = fromRawHeaders2(response_.rawHeaders);
          if (isRedirect2(Number(response_.statusCode))) {
            let location = headers.get("Location"), locationURL = location === null ? null : new URL(location, request.url);
            switch (request.redirect) {
              case "error":
                reject(new FetchError2(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect")), finalize();
                return;
              case "manual":
                locationURL !== null && headers.set("Location", locationURL.toString());
                break;
              case "follow": {
                if (locationURL === null)
                  break;
                if (request.counter >= request.follow) {
                  reject(new FetchError2(`maximum redirect reached at: ${request.url}`, "max-redirect")), finalize();
                  return;
                }
                let requestOptions = {
                  headers: new Headers3(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  // Note: We can not use `request.body` because send would have
                  // consumed it already.
                  body: options_.body,
                  signal,
                  size: request.size
                }, isStreamBody = requestOptions.body instanceof webBlob.ReadableStream || requestOptions.body instanceof Stream3.Readable;
                if (response_.statusCode !== 303 && isStreamBody) {
                  reject(new FetchError2("Cannot follow redirect with body being a readable stream", "unsupported-redirect")), finalize();
                  return;
                }
                (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") && (requestOptions.method = "GET", requestOptions.body = void 0, requestOptions.headers.delete("content-length")), fetch4(new Request3(locationURL.href, requestOptions)).then(resolve, reject), finalize();
                return;
              }
              default:
                return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
            }
          }
          signal && response_.once("end", () => {
            signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = Stream3.pipeline(response_, new Stream3.PassThrough(), reject);
          process.version < "v12.10" && response_.on("aborted", abortAndFinalize);
          let responseOptions = {
            url: request.url,
            status: response_.statusCode,
            statusText: response_.statusMessage,
            headers,
            size: request.size,
            counter: request.counter,
            highWaterMark: request.highWaterMark
          }, codings = headers.get("Content-Encoding");
          if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
            response = new Response4(body, responseOptions), resolve(response);
            return;
          }
          let zlibOptions = {
            flush: zlib2.Z_SYNC_FLUSH,
            finishFlush: zlib2.Z_SYNC_FLUSH
          };
          if (codings === "gzip" || codings === "x-gzip") {
            body = Stream3.pipeline(body, zlib2.createGunzip(zlibOptions), reject), response = new Response4(fromAsyncIterable(body), responseOptions), resolve(response);
            return;
          }
          if (codings === "deflate" || codings === "x-deflate") {
            Stream3.pipeline(response_, new Stream3.PassThrough(), reject).once("data", (chunk) => {
              (chunk[0] & 15) === 8 ? body = Stream3.pipeline(body, zlib2.createInflate(), reject) : body = Stream3.pipeline(body, zlib2.createInflateRaw(), reject), response = new Response4(fromAsyncIterable(body), responseOptions), resolve(response);
            });
            return;
          }
          if (codings === "br") {
            body = Stream3.pipeline(body, zlib2.createBrotliDecompress(), reject), response = new Response4(fromAsyncIterable(body), responseOptions), resolve(response);
            return;
          }
          response = new Response4(fromAsyncIterable(body), responseOptions), resolve(response);
        }), writeToStream2(request_, request);
      });
    }
    function fixResponseChunkedTransferBadEnding2(request, errorCallback) {
      let LAST_CHUNK = Buffer.from(`0\r
\r
`), isChunkedTransfer = !1, properLastChunkReceived = !1, previousChunk;
      request.on("response", (response) => {
        let { headers } = response;
        isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
      }), request.on("socket", (socket) => {
        let onSocketClose = () => {
          if (isChunkedTransfer && !properLastChunkReceived) {
            let error = Object.assign(new Error("Premature close"), {
              code: "ERR_STREAM_PREMATURE_CLOSE"
            });
            errorCallback(error);
          }
        }, onData = (buf) => {
          properLastChunkReceived = Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0, !properLastChunkReceived && previousChunk && (properLastChunkReceived = Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0), previousChunk = buf;
        };
        socket.prependListener("close", onSocketClose), socket.on("data", onData), request.on("close", () => {
          socket.removeListener("close", onSocketClose), socket.removeListener("data", onData);
        });
      });
    }
    Object.defineProperty(exports, "Blob", {
      enumerable: !0,
      get: function() {
        return webBlob.Blob;
      }
    });
    Object.defineProperty(exports, "ReadableStream", {
      enumerable: !0,
      get: function() {
        return webBlob.ReadableStream;
      }
    });
    Object.defineProperty(exports, "FormData", {
      enumerable: !0,
      get: function() {
        return webFormData.FormData;
      }
    });
    exports.Headers = Headers3;
    exports.Request = Request3;
    exports.Response = Response4;
    exports.default = fetch4;
    exports.fetch = fetch4;
    exports = module2.exports = Object.assign(fetch4, exports);
  }
});

// node_modules/@remix-run/web-file/dist/src/file.cjs
var require_file = __commonJS({
  "node_modules/@remix-run/web-file/dist/src/file.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var webBlob = require_lib_node(), File4 = class extends webBlob.Blob {
      /**
       *
       * @param {BlobPart[]} init
       * @param {string} name - A USVString representing the file name or the path
       * to the file.
       * @param {FilePropertyBag} [options]
       */
      constructor(init, name = panic(new TypeError("File constructor requires name argument")), options = {}) {
        super(init, options), this._name = name, this._lastModified = options.lastModified || Date.now();
      }
      /**
       * The name of the file referenced by the File object.
       * @type {string}
       */
      get name() {
        return this._name;
      }
      /**
       * The path the URL of the File is relative to.
       * @type {string}
       */
      get webkitRelativePath() {
        return "";
      }
      /**
       * Returns the last modified time of the file, in millisecond since the UNIX
       * epoch (January 1st, 1970 at Midnight).
       * @returns {number}
       */
      get lastModified() {
        return this._lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    }, panic = (error) => {
      throw error;
    };
    exports.File = File4;
  }
});

// node_modules/@remix-run/web-file/dist/src/lib.node.cjs
var require_lib_node4 = __commonJS({
  "node_modules/@remix-run/web-file/dist/src/lib.node.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var webBlob = require_lib_node(), file = require_file(), File4 = file.File;
    Object.defineProperty(exports, "Blob", {
      enumerable: !0,
      get: function() {
        return webBlob.Blob;
      }
    });
    exports.File = File4;
  }
});

// node_modules/@remix-run/node/dist/fetch.js
var require_fetch = __commonJS({
  "node_modules/@remix-run/node/dist/fetch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var webFetch = require_lib_node3(), webFile = require_lib_node4(), NodeRequest = class extends webFetch.Request {
      constructor(info, init) {
        super(info, init);
      }
      get headers() {
        return super.headers;
      }
      clone() {
        return new NodeRequest(this);
      }
    }, NodeResponse = class extends webFetch.Response {
      get headers() {
        return super.headers;
      }
      clone() {
        return super.clone();
      }
    }, fetch4 = (info, init) => (init = {
      // Disable compression handling so people can return the result of a fetch
      // directly in the loader without messing with the Content-Encoding header.
      compress: !1,
      ...init
    }, webFetch.fetch(info, init));
    Object.defineProperty(exports, "FormData", {
      enumerable: !0,
      get: function() {
        return webFetch.FormData;
      }
    });
    Object.defineProperty(exports, "Headers", {
      enumerable: !0,
      get: function() {
        return webFetch.Headers;
      }
    });
    Object.defineProperty(exports, "Blob", {
      enumerable: !0,
      get: function() {
        return webFile.Blob;
      }
    });
    Object.defineProperty(exports, "File", {
      enumerable: !0,
      get: function() {
        return webFile.File;
      }
    });
    exports.Request = NodeRequest;
    exports.Response = NodeResponse;
    exports.fetch = fetch4;
  }
});

// node_modules/@remix-run/node/dist/base64.js
var require_base642 = __commonJS({
  "node_modules/@remix-run/node/dist/base64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function atob2(a) {
      return Buffer.from(a, "base64").toString("binary");
    }
    function btoa2(b) {
      return Buffer.from(b, "binary").toString("base64");
    }
    exports.atob = atob2;
    exports.btoa = btoa2;
  }
});

// node_modules/@remix-run/node/dist/globals.js
var require_globals = __commonJS({
  "node_modules/@remix-run/node/dist/globals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var webStream = require_stream(), abortController = require_abort_controller(), base64 = require_base642(), fetch4 = require_fetch(), webFile = require_lib_node4(), webFetch = require_lib_node3();
    function installGlobals() {
      global.atob = base64.atob, global.btoa = base64.btoa, global.Blob = webFile.Blob, global.File = webFile.File, global.Headers = webFetch.Headers, global.Request = fetch4.Request, global.Response = fetch4.Response, global.fetch = fetch4.fetch, global.FormData = webFetch.FormData, global.ReadableStream = webStream.ReadableStream, global.WritableStream = webStream.WritableStream, global.AbortController = global.AbortController || abortController.AbortController;
    }
    exports.installGlobals = installGlobals;
  }
});

// node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/cookie/index.js"(exports) {
    "use strict";
    exports.parse = parse;
    exports.serialize = serialize;
    var decode = decodeURIComponent, encode = encodeURIComponent, fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse(str, options) {
      if (typeof str != "string")
        throw new TypeError("argument str must be a string");
      for (var obj = {}, opt = options || {}, pairs = str.split(";"), dec = opt.decode || decode, i2 = 0; i2 < pairs.length; i2++) {
        var pair = pairs[i2], index = pair.indexOf("=");
        if (!(index < 0)) {
          var key = pair.substring(0, index).trim();
          if (obj[key] == null) {
            var val = pair.substring(index + 1, pair.length).trim();
            val[0] === '"' && (val = val.slice(1, -1)), obj[key] = tryDecode(val, dec);
          }
        }
      }
      return obj;
    }
    function serialize(name, val, options) {
      var opt = options || {}, enc = opt.encode || encode;
      if (typeof enc != "function")
        throw new TypeError("option encode is invalid");
      if (!fieldContentRegExp.test(name))
        throw new TypeError("argument name is invalid");
      var value = enc(val);
      if (value && !fieldContentRegExp.test(value))
        throw new TypeError("argument val is invalid");
      var str = name + "=" + value;
      if (opt.maxAge != null) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge))
          throw new TypeError("option maxAge is invalid");
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain))
          throw new TypeError("option domain is invalid");
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path))
          throw new TypeError("option path is invalid");
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        if (typeof opt.expires.toUTCString != "function")
          throw new TypeError("option expires is invalid");
        str += "; Expires=" + opt.expires.toUTCString();
      }
      if (opt.httpOnly && (str += "; HttpOnly"), opt.secure && (str += "; Secure"), opt.sameSite) {
        var sameSite = typeof opt.sameSite == "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case !0:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function tryDecode(str, decode2) {
      try {
        return decode2(str);
      } catch {
        return str;
      }
    }
  }
});

// node_modules/@remix-run/server-runtime/dist/warnings.js
var require_warnings = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/warnings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var alreadyWarned = {};
    function warnOnce(condition, message) {
      !condition && !alreadyWarned[message] && (alreadyWarned[message] = !0, console.warn(message));
    }
    exports.warnOnce = warnOnce;
  }
});

// node_modules/@remix-run/server-runtime/dist/cookies.js
var require_cookies = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/cookies.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var cookie = require_cookie(), warnings = require_warnings(), createCookieFactory = ({
      sign,
      unsign
    }) => (name, cookieOptions = {}) => {
      let {
        secrets = [],
        ...options
      } = {
        path: "/",
        sameSite: "lax",
        ...cookieOptions
      };
      return warnOnceAboutExpiresCookie(name, options.expires), {
        get name() {
          return name;
        },
        get isSigned() {
          return secrets.length > 0;
        },
        get expires() {
          return typeof options.maxAge < "u" ? new Date(Date.now() + options.maxAge * 1e3) : options.expires;
        },
        async parse(cookieHeader, parseOptions) {
          if (!cookieHeader)
            return null;
          let cookies = cookie.parse(cookieHeader, {
            ...options,
            ...parseOptions
          });
          return name in cookies ? cookies[name] === "" ? "" : await decodeCookieValue(unsign, cookies[name], secrets) : null;
        },
        async serialize(value, serializeOptions) {
          return cookie.serialize(name, value === "" ? "" : await encodeCookieValue(sign, value, secrets), {
            ...options,
            ...serializeOptions
          });
        }
      };
    }, isCookie = (object) => object != null && typeof object.name == "string" && typeof object.isSigned == "boolean" && typeof object.parse == "function" && typeof object.serialize == "function";
    async function encodeCookieValue(sign, value, secrets) {
      let encoded = encodeData(value);
      return secrets.length > 0 && (encoded = await sign(encoded, secrets[0])), encoded;
    }
    async function decodeCookieValue(unsign, value, secrets) {
      if (secrets.length > 0) {
        for (let secret of secrets) {
          let unsignedValue = await unsign(value, secret);
          if (unsignedValue !== !1)
            return decodeData(unsignedValue);
        }
        return null;
      }
      return decodeData(value);
    }
    function encodeData(value) {
      return btoa(myUnescape(encodeURIComponent(JSON.stringify(value))));
    }
    function decodeData(value) {
      try {
        return JSON.parse(decodeURIComponent(myEscape(atob(value))));
      } catch {
        return {};
      }
    }
    function myEscape(value) {
      let str = value.toString(), result = "", index = 0, chr, code;
      for (; index < str.length; )
        chr = str.charAt(index++), /[\w*+\-./@]/.exec(chr) ? result += chr : (code = chr.charCodeAt(0), code < 256 ? result += "%" + hex(code, 2) : result += "%u" + hex(code, 4).toUpperCase());
      return result;
    }
    function hex(code, length) {
      let result = code.toString(16);
      for (; result.length < length; )
        result = "0" + result;
      return result;
    }
    function myUnescape(value) {
      let str = value.toString(), result = "", index = 0, chr, part;
      for (; index < str.length; ) {
        if (chr = str.charAt(index++), chr === "%") {
          if (str.charAt(index) === "u") {
            if (part = str.slice(index + 1, index + 5), /^[\da-f]{4}$/i.exec(part)) {
              result += String.fromCharCode(parseInt(part, 16)), index += 5;
              continue;
            }
          } else if (part = str.slice(index, index + 2), /^[\da-f]{2}$/i.exec(part)) {
            result += String.fromCharCode(parseInt(part, 16)), index += 2;
            continue;
          }
        }
        result += chr;
      }
      return result;
    }
    function warnOnceAboutExpiresCookie(name, expires) {
      warnings.warnOnce(!expires, `The "${name}" cookie has an "expires" property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use \`commitSession(session, { expires })\` if using a session storage object, or \`cookie.serialize("value", { expires })\` if you're using the cookie directly.`);
    }
    exports.createCookieFactory = createCookieFactory;
    exports.isCookie = isCookie;
  }
});

// node_modules/@remix-run/server-runtime/dist/formData.js
var require_formData = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/formData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var multipartParser = require_src2();
    function composeUploadHandlers(...handlers) {
      return async (part) => {
        for (let handler of handlers) {
          let value = await handler(part);
          if (typeof value < "u" && value !== null)
            return value;
        }
      };
    }
    async function parseMultipartFormData(request, uploadHandler) {
      let contentType = request.headers.get("Content-Type") || "", [type, boundary] = contentType.split(/\s*;\s*boundary=/);
      if (!request.body || !boundary || type !== "multipart/form-data")
        throw new TypeError("Could not parse content as FormData.");
      let formData = new FormData(), parts = multipartParser.streamMultipart(request.body, boundary);
      for await (let part of parts) {
        if (part.done)
          break;
        typeof part.filename == "string" && (part.filename = part.filename.split(/[/\\]/).pop());
        let value = await uploadHandler(part);
        typeof value < "u" && value !== null && formData.append(part.name, value);
      }
      return formData;
    }
    exports.composeUploadHandlers = composeUploadHandlers;
    exports.parseMultipartFormData = parseMultipartFormData;
  }
});

// node_modules/@remix-run/router/dist/router.cjs.js
var require_router_cjs = __commonJS({
  "node_modules/@remix-run/router/dist/router.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function _extends() {
      return _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    exports.Action = void 0;
    (function(Action) {
      Action.Pop = "POP", Action.Push = "PUSH", Action.Replace = "REPLACE";
    })(exports.Action || (exports.Action = {}));
    var PopStateEventType = "popstate";
    function createMemoryHistory(options) {
      options === void 0 && (options = {});
      let {
        initialEntries = ["/"],
        initialIndex,
        v5Compat = !1
      } = options, entries;
      entries = initialEntries.map((entry2, index2) => createMemoryLocation(entry2, typeof entry2 == "string" ? null : entry2.state, index2 === 0 ? "default" : void 0));
      let index = clampIndex(initialIndex ?? entries.length - 1), action3 = exports.Action.Pop, listener = null;
      function clampIndex(n) {
        return Math.min(Math.max(n, 0), entries.length - 1);
      }
      function getCurrentLocation() {
        return entries[index];
      }
      function createMemoryLocation(to, state, key) {
        state === void 0 && (state = null);
        let location = createLocation(entries ? getCurrentLocation().pathname : "/", to, state, key);
        return warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in memory history: " + JSON.stringify(to)), location;
      }
      function createHref(to) {
        return typeof to == "string" ? to : createPath(to);
      }
      return {
        get index() {
          return index;
        },
        get action() {
          return action3;
        },
        get location() {
          return getCurrentLocation();
        },
        createHref,
        createURL(to) {
          return new URL(createHref(to), "http://localhost");
        },
        encodeLocation(to) {
          let path = typeof to == "string" ? parsePath(to) : to;
          return {
            pathname: path.pathname || "",
            search: path.search || "",
            hash: path.hash || ""
          };
        },
        push(to, state) {
          action3 = exports.Action.Push;
          let nextLocation = createMemoryLocation(to, state);
          index += 1, entries.splice(index, entries.length, nextLocation), v5Compat && listener && listener({
            action: action3,
            location: nextLocation,
            delta: 1
          });
        },
        replace(to, state) {
          action3 = exports.Action.Replace;
          let nextLocation = createMemoryLocation(to, state);
          entries[index] = nextLocation, v5Compat && listener && listener({
            action: action3,
            location: nextLocation,
            delta: 0
          });
        },
        go(delta) {
          action3 = exports.Action.Pop;
          let nextIndex = clampIndex(index + delta), nextLocation = entries[nextIndex];
          index = nextIndex, listener && listener({
            action: action3,
            location: nextLocation,
            delta
          });
        },
        listen(fn) {
          return listener = fn, () => {
            listener = null;
          };
        }
      };
    }
    function createBrowserHistory(options) {
      options === void 0 && (options = {});
      function createBrowserLocation(window2, globalHistory) {
        let {
          pathname,
          search,
          hash
        } = window2.location;
        return createLocation(
          "",
          {
            pathname,
            search,
            hash
          },
          // state defaults to `null` because `window.history.state` does
          globalHistory.state && globalHistory.state.usr || null,
          globalHistory.state && globalHistory.state.key || "default"
        );
      }
      function createBrowserHref(window2, to) {
        return typeof to == "string" ? to : createPath(to);
      }
      return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
    }
    function createHashHistory(options) {
      options === void 0 && (options = {});
      function createHashLocation(window2, globalHistory) {
        let {
          pathname = "/",
          search = "",
          hash = ""
        } = parsePath(window2.location.hash.substr(1));
        return createLocation(
          "",
          {
            pathname,
            search,
            hash
          },
          // state defaults to `null` because `window.history.state` does
          globalHistory.state && globalHistory.state.usr || null,
          globalHistory.state && globalHistory.state.key || "default"
        );
      }
      function createHashHref(window2, to) {
        let base = window2.document.querySelector("base"), href = "";
        if (base && base.getAttribute("href")) {
          let url = window2.location.href, hashIndex = url.indexOf("#");
          href = hashIndex === -1 ? url : url.slice(0, hashIndex);
        }
        return href + "#" + (typeof to == "string" ? to : createPath(to));
      }
      function validateHashLocation(location, to) {
        warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")");
      }
      return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);
    }
    function invariant(value, message) {
      if (value === !1 || value === null || typeof value > "u")
        throw new Error(message);
    }
    function warning(cond, message) {
      if (!cond) {
        typeof console < "u" && console.warn(message);
        try {
          throw new Error(message);
        } catch {
        }
      }
    }
    function createKey() {
      return Math.random().toString(36).substr(2, 8);
    }
    function getHistoryState(location, index) {
      return {
        usr: location.state,
        key: location.key,
        idx: index
      };
    }
    function createLocation(current, to, state, key) {
      return state === void 0 && (state = null), _extends({
        pathname: typeof current == "string" ? current : current.pathname,
        search: "",
        hash: ""
      }, typeof to == "string" ? parsePath(to) : to, {
        state,
        // TODO: This could be cleaned up.  push/replace should probably just take
        // full Locations now and avoid the need to run through this flow at all
        // But that's a pretty big refactor to the current test suite so going to
        // keep as is for the time being and just let any incoming keys take precedence
        key: to && to.key || key || createKey()
      });
    }
    function createPath(_ref) {
      let {
        pathname = "/",
        search = "",
        hash = ""
      } = _ref;
      return search && search !== "?" && (pathname += search.charAt(0) === "?" ? search : "?" + search), hash && hash !== "#" && (pathname += hash.charAt(0) === "#" ? hash : "#" + hash), pathname;
    }
    function parsePath(path) {
      let parsedPath = {};
      if (path) {
        let hashIndex = path.indexOf("#");
        hashIndex >= 0 && (parsedPath.hash = path.substr(hashIndex), path = path.substr(0, hashIndex));
        let searchIndex = path.indexOf("?");
        searchIndex >= 0 && (parsedPath.search = path.substr(searchIndex), path = path.substr(0, searchIndex)), path && (parsedPath.pathname = path);
      }
      return parsedPath;
    }
    function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
      options === void 0 && (options = {});
      let {
        window: window2 = document.defaultView,
        v5Compat = !1
      } = options, globalHistory = window2.history, action3 = exports.Action.Pop, listener = null, index = getIndex();
      index == null && (index = 0, globalHistory.replaceState(_extends({}, globalHistory.state, {
        idx: index
      }), ""));
      function getIndex() {
        return (globalHistory.state || {
          idx: null
        }).idx;
      }
      function handlePop() {
        action3 = exports.Action.Pop;
        let nextIndex = getIndex(), delta = nextIndex == null ? null : nextIndex - index;
        index = nextIndex, listener && listener({
          action: action3,
          location: history.location,
          delta
        });
      }
      function push(to, state) {
        action3 = exports.Action.Push;
        let location = createLocation(history.location, to, state);
        validateLocation && validateLocation(location, to), index = getIndex() + 1;
        let historyState = getHistoryState(location, index), url = history.createHref(location);
        try {
          globalHistory.pushState(historyState, "", url);
        } catch (error) {
          if (error instanceof DOMException && error.name === "DataCloneError")
            throw error;
          window2.location.assign(url);
        }
        v5Compat && listener && listener({
          action: action3,
          location: history.location,
          delta: 1
        });
      }
      function replace(to, state) {
        action3 = exports.Action.Replace;
        let location = createLocation(history.location, to, state);
        validateLocation && validateLocation(location, to), index = getIndex();
        let historyState = getHistoryState(location, index), url = history.createHref(location);
        globalHistory.replaceState(historyState, "", url), v5Compat && listener && listener({
          action: action3,
          location: history.location,
          delta: 0
        });
      }
      function createURL(to) {
        let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href, href = typeof to == "string" ? to : createPath(to);
        return invariant(base, "No window.location.(origin|href) available to create URL for href: " + href), new URL(href, base);
      }
      let history = {
        get action() {
          return action3;
        },
        get location() {
          return getLocation(window2, globalHistory);
        },
        listen(fn) {
          if (listener)
            throw new Error("A history only accepts one active listener");
          return window2.addEventListener(PopStateEventType, handlePop), listener = fn, () => {
            window2.removeEventListener(PopStateEventType, handlePop), listener = null;
          };
        },
        createHref(to) {
          return createHref(window2, to);
        },
        createURL,
        encodeLocation(to) {
          let url = createURL(to);
          return {
            pathname: url.pathname,
            search: url.search,
            hash: url.hash
          };
        },
        push,
        replace,
        go(n) {
          return globalHistory.go(n);
        }
      };
      return history;
    }
    var ResultType;
    (function(ResultType2) {
      ResultType2.data = "data", ResultType2.deferred = "deferred", ResultType2.redirect = "redirect", ResultType2.error = "error";
    })(ResultType || (ResultType = {}));
    var immutableRouteKeys = /* @__PURE__ */ new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
    function isIndexRoute(route) {
      return route.index === !0;
    }
    function convertRoutesToDataRoutes(routes2, mapRouteProperties, parentPath, manifest) {
      return parentPath === void 0 && (parentPath = []), manifest === void 0 && (manifest = {}), routes2.map((route, index) => {
        let treePath = [...parentPath, index], id = typeof route.id == "string" ? route.id : treePath.join("-");
        if (invariant(route.index !== !0 || !route.children, "Cannot specify children on an index route"), invariant(!manifest[id], 'Found a route id collision on id "' + id + `".  Route id's must be globally unique within Data Router usages`), isIndexRoute(route)) {
          let indexRoute = _extends({}, route, mapRouteProperties(route), {
            id
          });
          return manifest[id] = indexRoute, indexRoute;
        } else {
          let pathOrLayoutRoute = _extends({}, route, mapRouteProperties(route), {
            id,
            children: void 0
          });
          return manifest[id] = pathOrLayoutRoute, route.children && (pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties, treePath, manifest)), pathOrLayoutRoute;
        }
      });
    }
    function matchRoutes(routes2, locationArg, basename) {
      basename === void 0 && (basename = "/");
      let location = typeof locationArg == "string" ? parsePath(locationArg) : locationArg, pathname = stripBasename(location.pathname || "/", basename);
      if (pathname == null)
        return null;
      let branches = flattenRoutes(routes2);
      rankRouteBranches(branches);
      let matches = null;
      for (let i2 = 0; matches == null && i2 < branches.length; ++i2)
        matches = matchRouteBranch(
          branches[i2],
          // Incoming pathnames are generally encoded from either window.location
          // or from router.navigate, but we want to match against the unencoded
          // paths in the route definitions.  Memory router locations won't be
          // encoded here but there also shouldn't be anything to decode so this
          // should be a safe operation.  This avoids needing matchRoutes to be
          // history-aware.
          safelyDecodeURI(pathname)
        );
      return matches;
    }
    function flattenRoutes(routes2, branches, parentsMeta, parentPath) {
      branches === void 0 && (branches = []), parentsMeta === void 0 && (parentsMeta = []), parentPath === void 0 && (parentPath = "");
      let flattenRoute = (route, index, relativePath) => {
        let meta = {
          relativePath: relativePath === void 0 ? route.path || "" : relativePath,
          caseSensitive: route.caseSensitive === !0,
          childrenIndex: index,
          route
        };
        meta.relativePath.startsWith("/") && (invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), meta.relativePath = meta.relativePath.slice(parentPath.length));
        let path = joinPaths([parentPath, meta.relativePath]), routesMeta = parentsMeta.concat(meta);
        route.children && route.children.length > 0 && (invariant(
          // Our types know better, but runtime JS may not!
          // @ts-expect-error
          route.index !== !0,
          "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
        ), flattenRoutes(route.children, branches, routesMeta, path)), !(route.path == null && !route.index) && branches.push({
          path,
          score: computeScore(path, route.index),
          routesMeta
        });
      };
      return routes2.forEach((route, index) => {
        var _route$path;
        if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?")))
          flattenRoute(route, index);
        else
          for (let exploded of explodeOptionalSegments(route.path))
            flattenRoute(route, index, exploded);
      }), branches;
    }
    function explodeOptionalSegments(path) {
      let segments = path.split("/");
      if (segments.length === 0)
        return [];
      let [first, ...rest] = segments, isOptional = first.endsWith("?"), required = first.replace(/\?$/, "");
      if (rest.length === 0)
        return isOptional ? [required, ""] : [required];
      let restExploded = explodeOptionalSegments(rest.join("/")), result = [];
      return result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/"))), isOptional && result.push(...restExploded), result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
    }
    function rankRouteBranches(branches) {
      branches.sort((a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map((meta) => meta.childrenIndex), b.routesMeta.map((meta) => meta.childrenIndex)));
    }
    var paramRe = /^:\w+$/, dynamicSegmentValue = 3, indexRouteValue = 2, emptySegmentValue = 1, staticSegmentValue = 10, splatPenalty = -2, isSplat = (s2) => s2 === "*";
    function computeScore(path, index) {
      let segments = path.split("/"), initialScore = segments.length;
      return segments.some(isSplat) && (initialScore += splatPenalty), index && (initialScore += indexRouteValue), segments.filter((s2) => !isSplat(s2)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
    }
    function compareIndexes(a, b) {
      return a.length === b.length && a.slice(0, -1).every((n, i2) => n === b[i2]) ? (
        // If two routes are siblings, we should try to match the earlier sibling
        // first. This allows people to have fine-grained control over the matching
        // behavior by simply putting routes with identical paths in the order they
        // want them tried.
        a[a.length - 1] - b[b.length - 1]
      ) : (
        // Otherwise, it doesn't really make sense to rank non-siblings by index,
        // so they sort equally.
        0
      );
    }
    function matchRouteBranch(branch, pathname) {
      let {
        routesMeta
      } = branch, matchedParams = {}, matchedPathname = "/", matches = [];
      for (let i2 = 0; i2 < routesMeta.length; ++i2) {
        let meta = routesMeta[i2], end = i2 === routesMeta.length - 1, remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/", match = matchPath({
          path: meta.relativePath,
          caseSensitive: meta.caseSensitive,
          end
        }, remainingPathname);
        if (!match)
          return null;
        Object.assign(matchedParams, match.params);
        let route = meta.route;
        matches.push({
          // TODO: Can this as be avoided?
          params: matchedParams,
          pathname: joinPaths([matchedPathname, match.pathname]),
          pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
          route
        }), match.pathnameBase !== "/" && (matchedPathname = joinPaths([matchedPathname, match.pathnameBase]));
      }
      return matches;
    }
    function generatePath(originalPath, params) {
      params === void 0 && (params = {});
      let path = originalPath;
      path.endsWith("*") && path !== "*" && !path.endsWith("/*") && (warning(!1, 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".')), path = path.replace(/\*$/, "/*"));
      let prefix = path.startsWith("/") ? "/" : "", segments = path.split(/\/+/).map((segment, index, array) => {
        if (index === array.length - 1 && segment === "*")
          return params["*"];
        let keyMatch = segment.match(/^:(\w+)(\??)$/);
        if (keyMatch) {
          let [, key, optional] = keyMatch, param = params[key];
          return optional === "?" ? param ?? "" : (param == null && invariant(!1, 'Missing ":' + key + '" param'), param);
        }
        return segment.replace(/\?$/g, "");
      }).filter((segment) => !!segment);
      return prefix + segments.join("/");
    }
    function matchPath(pattern, pathname) {
      typeof pattern == "string" && (pattern = {
        path: pattern,
        caseSensitive: !1,
        end: !0
      });
      let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end), match = pathname.match(matcher);
      if (!match)
        return null;
      let matchedPathname = match[0], pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1"), captureGroups = match.slice(1);
      return {
        params: paramNames.reduce((memo2, paramName, index) => {
          if (paramName === "*") {
            let splatValue = captureGroups[index] || "";
            pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
          }
          return memo2[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName), memo2;
        }, {}),
        pathname: matchedPathname,
        pathnameBase,
        pattern
      };
    }
    function compilePath(path, caseSensitive, end) {
      caseSensitive === void 0 && (caseSensitive = !1), end === void 0 && (end = !0), warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
      let paramNames = [], regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/\/:(\w+)/g, (_, paramName) => (paramNames.push(paramName), "/([^\\/]+)"));
      return path.endsWith("*") ? (paramNames.push("*"), regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : end ? regexpSource += "\\/*$" : path !== "" && path !== "/" && (regexpSource += "(?:(?=\\/|$))"), [new RegExp(regexpSource, caseSensitive ? void 0 : "i"), paramNames];
    }
    function safelyDecodeURI(value) {
      try {
        return decodeURI(value);
      } catch (error) {
        return warning(!1, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ").")), value;
      }
    }
    function safelyDecodeURIComponent(value, paramName) {
      try {
        return decodeURIComponent(value);
      } catch (error) {
        return warning(!1, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ").")), value;
      }
    }
    function stripBasename(pathname, basename) {
      if (basename === "/")
        return pathname;
      if (!pathname.toLowerCase().startsWith(basename.toLowerCase()))
        return null;
      let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length, nextChar = pathname.charAt(startIndex);
      return nextChar && nextChar !== "/" ? null : pathname.slice(startIndex) || "/";
    }
    function resolvePath(to, fromPathname) {
      fromPathname === void 0 && (fromPathname = "/");
      let {
        pathname: toPathname,
        search = "",
        hash = ""
      } = typeof to == "string" ? parsePath(to) : to;
      return {
        pathname: toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname,
        search: normalizeSearch(search),
        hash: normalizeHash(hash)
      };
    }
    function resolvePathname(relativePath, fromPathname) {
      let segments = fromPathname.replace(/\/+$/, "").split("/");
      return relativePath.split("/").forEach((segment) => {
        segment === ".." ? segments.length > 1 && segments.pop() : segment !== "." && segments.push(segment);
      }), segments.length > 1 ? segments.join("/") : "/";
    }
    function getInvalidPathError(char, field, dest, path) {
      return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
    }
    function getPathContributingMatches(matches) {
      return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);
    }
    function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
      isPathRelative === void 0 && (isPathRelative = !1);
      let to;
      typeof toArg == "string" ? to = parsePath(toArg) : (to = _extends({}, toArg), invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to)), invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to)), invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to)));
      let isEmptyPath = toArg === "" || to.pathname === "", toPathname = isEmptyPath ? "/" : to.pathname, from;
      if (isPathRelative || toPathname == null)
        from = locationPathname;
      else {
        let routePathnameIndex = routePathnames.length - 1;
        if (toPathname.startsWith("..")) {
          let toSegments = toPathname.split("/");
          for (; toSegments[0] === ".."; )
            toSegments.shift(), routePathnameIndex -= 1;
          to.pathname = toSegments.join("/");
        }
        from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
      }
      let path = resolvePath(to, from), hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/"), hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
      return !path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash) && (path.pathname += "/"), path;
    }
    function getToPathname(to) {
      return to === "" || to.pathname === "" ? "/" : typeof to == "string" ? parsePath(to).pathname : to.pathname;
    }
    var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/"), normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/"), normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search, normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash, json2 = function(data, init) {
      init === void 0 && (init = {});
      let responseInit = typeof init == "number" ? {
        status: init
      } : init, headers = new Headers(responseInit.headers);
      return headers.has("Content-Type") || headers.set("Content-Type", "application/json; charset=utf-8"), new Response(JSON.stringify(data), _extends({}, responseInit, {
        headers
      }));
    }, AbortedDeferredError = class extends Error {
    }, DeferredData = class {
      constructor(data, responseInit) {
        this.pendingKeysSet = /* @__PURE__ */ new Set(), this.subscribers = /* @__PURE__ */ new Set(), this.deferredKeys = [], invariant(data && typeof data == "object" && !Array.isArray(data), "defer() only accepts plain objects");
        let reject;
        this.abortPromise = new Promise((_, r2) => reject = r2), this.controller = new AbortController();
        let onAbort = () => reject(new AbortedDeferredError("Deferred data aborted"));
        this.unlistenAbortSignal = () => this.controller.signal.removeEventListener("abort", onAbort), this.controller.signal.addEventListener("abort", onAbort), this.data = Object.entries(data).reduce((acc, _ref) => {
          let [key, value] = _ref;
          return Object.assign(acc, {
            [key]: this.trackPromise(key, value)
          });
        }, {}), this.done && this.unlistenAbortSignal(), this.init = responseInit;
      }
      trackPromise(key, value) {
        if (!(value instanceof Promise))
          return value;
        this.deferredKeys.push(key), this.pendingKeysSet.add(key);
        let promise = Promise.race([value, this.abortPromise]).then((data) => this.onSettle(promise, key, null, data), (error) => this.onSettle(promise, key, error));
        return promise.catch(() => {
        }), Object.defineProperty(promise, "_tracked", {
          get: () => !0
        }), promise;
      }
      onSettle(promise, key, error, data) {
        return this.controller.signal.aborted && error instanceof AbortedDeferredError ? (this.unlistenAbortSignal(), Object.defineProperty(promise, "_error", {
          get: () => error
        }), Promise.reject(error)) : (this.pendingKeysSet.delete(key), this.done && this.unlistenAbortSignal(), error ? (Object.defineProperty(promise, "_error", {
          get: () => error
        }), this.emit(!1, key), Promise.reject(error)) : (Object.defineProperty(promise, "_data", {
          get: () => data
        }), this.emit(!1, key), data));
      }
      emit(aborted, settledKey) {
        this.subscribers.forEach((subscriber) => subscriber(aborted, settledKey));
      }
      subscribe(fn) {
        return this.subscribers.add(fn), () => this.subscribers.delete(fn);
      }
      cancel() {
        this.controller.abort(), this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k)), this.emit(!0);
      }
      async resolveData(signal) {
        let aborted = !1;
        if (!this.done) {
          let onAbort = () => this.cancel();
          signal.addEventListener("abort", onAbort), aborted = await new Promise((resolve) => {
            this.subscribe((aborted2) => {
              signal.removeEventListener("abort", onAbort), (aborted2 || this.done) && resolve(aborted2);
            });
          });
        }
        return aborted;
      }
      get done() {
        return this.pendingKeysSet.size === 0;
      }
      get unwrappedData() {
        return invariant(this.data !== null && this.done, "Can only unwrap data on initialized and settled deferreds"), Object.entries(this.data).reduce((acc, _ref2) => {
          let [key, value] = _ref2;
          return Object.assign(acc, {
            [key]: unwrapTrackedPromise(value)
          });
        }, {});
      }
      get pendingKeys() {
        return Array.from(this.pendingKeysSet);
      }
    };
    function isTrackedPromise(value) {
      return value instanceof Promise && value._tracked === !0;
    }
    function unwrapTrackedPromise(value) {
      if (!isTrackedPromise(value))
        return value;
      if (value._error)
        throw value._error;
      return value._data;
    }
    var defer = function(data, init) {
      init === void 0 && (init = {});
      let responseInit = typeof init == "number" ? {
        status: init
      } : init;
      return new DeferredData(data, responseInit);
    }, redirect2 = function(url, init) {
      init === void 0 && (init = 302);
      let responseInit = init;
      typeof responseInit == "number" ? responseInit = {
        status: responseInit
      } : typeof responseInit.status > "u" && (responseInit.status = 302);
      let headers = new Headers(responseInit.headers);
      return headers.set("Location", url), new Response(null, _extends({}, responseInit, {
        headers
      }));
    }, ErrorResponse = class {
      constructor(status, statusText, data, internal) {
        internal === void 0 && (internal = !1), this.status = status, this.statusText = statusText || "", this.internal = internal, data instanceof Error ? (this.data = data.toString(), this.error = data) : this.data = data;
      }
    };
    function isRouteErrorResponse2(error) {
      return error != null && typeof error.status == "number" && typeof error.statusText == "string" && typeof error.internal == "boolean" && "data" in error;
    }
    var validMutationMethodsArr = ["post", "put", "patch", "delete"], validMutationMethods = new Set(validMutationMethodsArr), validRequestMethodsArr = ["get", ...validMutationMethodsArr], validRequestMethods = new Set(validRequestMethodsArr), redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]), redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]), IDLE_NAVIGATION = {
      state: "idle",
      location: void 0,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0
    }, IDLE_FETCHER = {
      state: "idle",
      data: void 0,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0
    }, IDLE_BLOCKER = {
      state: "unblocked",
      proceed: void 0,
      reset: void 0,
      location: void 0
    }, ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, defaultMapRouteProperties = (route) => ({
      hasErrorBoundary: Boolean(route.hasErrorBoundary)
    });
    function createRouter(init) {
      let routerWindow = init.window ? init.window : typeof window < "u" ? window : void 0, isBrowser = typeof routerWindow < "u" && typeof routerWindow.document < "u" && typeof routerWindow.document.createElement < "u", isServer = !isBrowser;
      invariant(init.routes.length > 0, "You must provide a non-empty routes array to createRouter");
      let mapRouteProperties;
      if (init.mapRouteProperties)
        mapRouteProperties = init.mapRouteProperties;
      else if (init.detectErrorBoundary) {
        let detectErrorBoundary = init.detectErrorBoundary;
        mapRouteProperties = (route) => ({
          hasErrorBoundary: detectErrorBoundary(route)
        });
      } else
        mapRouteProperties = defaultMapRouteProperties;
      let manifest = {}, dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties, void 0, manifest), inFlightDataRoutes, basename = init.basename || "/", future2 = _extends({
        v7_normalizeFormMethod: !1,
        v7_prependBasename: !1
      }, init.future), unlistenHistory = null, subscribers = /* @__PURE__ */ new Set(), savedScrollPositions = null, getScrollRestorationKey = null, getScrollPosition = null, initialScrollRestored = init.hydrationData != null, initialMatches = matchRoutes(dataRoutes, init.history.location, basename), initialErrors = null;
      if (initialMatches == null) {
        let error = getInternalRouterError(404, {
          pathname: init.history.location.pathname
        }), {
          matches,
          route
        } = getShortCircuitMatches(dataRoutes);
        initialMatches = matches, initialErrors = {
          [route.id]: error
        };
      }
      let initialized = (
        // All initialMatches need to be loaded before we're ready.  If we have lazy
        // functions around still then we'll need to run them in initialize()
        !initialMatches.some((m2) => m2.route.lazy) && // And we have to either have no loaders or have been provided hydrationData
        (!initialMatches.some((m2) => m2.route.loader) || init.hydrationData != null)
      ), router, state = {
        historyAction: init.history.action,
        location: init.history.location,
        matches: initialMatches,
        initialized,
        navigation: IDLE_NAVIGATION,
        // Don't restore on initial updateState() if we were SSR'd
        restoreScrollPosition: init.hydrationData != null ? !1 : null,
        preventScrollReset: !1,
        revalidation: "idle",
        loaderData: init.hydrationData && init.hydrationData.loaderData || {},
        actionData: init.hydrationData && init.hydrationData.actionData || null,
        errors: init.hydrationData && init.hydrationData.errors || initialErrors,
        fetchers: /* @__PURE__ */ new Map(),
        blockers: /* @__PURE__ */ new Map()
      }, pendingAction = exports.Action.Pop, pendingPreventScrollReset = !1, pendingNavigationController, isUninterruptedRevalidation = !1, isRevalidationRequired = !1, cancelledDeferredRoutes = [], cancelledFetcherLoads = [], fetchControllers = /* @__PURE__ */ new Map(), incrementingLoadId = 0, pendingNavigationLoadId = -1, fetchReloadIds = /* @__PURE__ */ new Map(), fetchRedirectIds = /* @__PURE__ */ new Set(), fetchLoadMatches = /* @__PURE__ */ new Map(), activeDeferreds = /* @__PURE__ */ new Map(), blockerFunctions = /* @__PURE__ */ new Map(), ignoreNextHistoryUpdate = !1;
      function initialize() {
        return unlistenHistory = init.history.listen((_ref) => {
          let {
            action: historyAction,
            location,
            delta
          } = _ref;
          if (ignoreNextHistoryUpdate) {
            ignoreNextHistoryUpdate = !1;
            return;
          }
          warning(blockerFunctions.size === 0 || delta != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
          let blockerKey = shouldBlockNavigation({
            currentLocation: state.location,
            nextLocation: location,
            historyAction
          });
          if (blockerKey && delta != null) {
            ignoreNextHistoryUpdate = !0, init.history.go(delta * -1), updateBlocker(blockerKey, {
              state: "blocked",
              location,
              proceed() {
                updateBlocker(blockerKey, {
                  state: "proceeding",
                  proceed: void 0,
                  reset: void 0,
                  location
                }), init.history.go(delta);
              },
              reset() {
                deleteBlocker(blockerKey), updateState({
                  blockers: new Map(router.state.blockers)
                });
              }
            });
            return;
          }
          return startNavigation(historyAction, location);
        }), state.initialized || startNavigation(exports.Action.Pop, state.location), router;
      }
      function dispose() {
        unlistenHistory && unlistenHistory(), subscribers.clear(), pendingNavigationController && pendingNavigationController.abort(), state.fetchers.forEach((_, key) => deleteFetcher(key)), state.blockers.forEach((_, key) => deleteBlocker(key));
      }
      function subscribe(fn) {
        return subscribers.add(fn), () => subscribers.delete(fn);
      }
      function updateState(newState) {
        state = _extends({}, state, newState), subscribers.forEach((subscriber) => subscriber(state));
      }
      function completeNavigation(location, newState) {
        var _location$state, _location$state2;
        let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== !0, actionData;
        newState.actionData ? Object.keys(newState.actionData).length > 0 ? actionData = newState.actionData : actionData = null : isActionReload ? actionData = state.actionData : actionData = null;
        let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;
        for (let [key] of blockerFunctions)
          deleteBlocker(key);
        let preventScrollReset = pendingPreventScrollReset === !0 || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== !0;
        inFlightDataRoutes && (dataRoutes = inFlightDataRoutes, inFlightDataRoutes = void 0), updateState(_extends({}, newState, {
          // matches, errors, fetchers go through as-is
          actionData,
          loaderData,
          historyAction: pendingAction,
          location,
          initialized: !0,
          navigation: IDLE_NAVIGATION,
          revalidation: "idle",
          restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),
          preventScrollReset,
          blockers: new Map(state.blockers)
        })), isUninterruptedRevalidation || pendingAction === exports.Action.Pop || (pendingAction === exports.Action.Push ? init.history.push(location, location.state) : pendingAction === exports.Action.Replace && init.history.replace(location, location.state)), pendingAction = exports.Action.Pop, pendingPreventScrollReset = !1, isUninterruptedRevalidation = !1, isRevalidationRequired = !1, cancelledDeferredRoutes = [], cancelledFetcherLoads = [];
      }
      async function navigate(to, opts) {
        if (typeof to == "number") {
          init.history.go(to);
          return;
        }
        let normalizedPath = normalizeTo(state.location, state.matches, basename, future2.v7_prependBasename, to, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative), {
          path,
          submission,
          error
        } = normalizeNavigateOptions(future2.v7_normalizeFormMethod, !1, normalizedPath, opts), currentLocation = state.location, nextLocation = createLocation(state.location, path, opts && opts.state);
        nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));
        let userReplace = opts && opts.replace != null ? opts.replace : void 0, historyAction = exports.Action.Push;
        userReplace === !0 ? historyAction = exports.Action.Replace : userReplace === !1 || submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search && (historyAction = exports.Action.Replace);
        let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === !0 : void 0, blockerKey = shouldBlockNavigation({
          currentLocation,
          nextLocation,
          historyAction
        });
        if (blockerKey) {
          updateBlocker(blockerKey, {
            state: "blocked",
            location: nextLocation,
            proceed() {
              updateBlocker(blockerKey, {
                state: "proceeding",
                proceed: void 0,
                reset: void 0,
                location: nextLocation
              }), navigate(to, opts);
            },
            reset() {
              deleteBlocker(blockerKey), updateState({
                blockers: new Map(state.blockers)
              });
            }
          });
          return;
        }
        return await startNavigation(historyAction, nextLocation, {
          submission,
          // Send through the formData serialization error if we have one so we can
          // render at the right error boundary after we match routes
          pendingError: error,
          preventScrollReset,
          replace: opts && opts.replace
        });
      }
      function revalidate() {
        if (interruptActiveLoads(), updateState({
          revalidation: "loading"
        }), state.navigation.state !== "submitting") {
          if (state.navigation.state === "idle") {
            startNavigation(state.historyAction, state.location, {
              startUninterruptedRevalidation: !0
            });
            return;
          }
          startNavigation(pendingAction || state.historyAction, state.navigation.location, {
            overrideNavigation: state.navigation
          });
        }
      }
      async function startNavigation(historyAction, location, opts) {
        pendingNavigationController && pendingNavigationController.abort(), pendingNavigationController = null, pendingAction = historyAction, isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === !0, saveScrollPosition(state.location, state.matches), pendingPreventScrollReset = (opts && opts.preventScrollReset) === !0;
        let routesToUse = inFlightDataRoutes || dataRoutes, loadingNavigation = opts && opts.overrideNavigation, matches = matchRoutes(routesToUse, location, basename);
        if (!matches) {
          let error = getInternalRouterError(404, {
            pathname: location.pathname
          }), {
            matches: notFoundMatches,
            route
          } = getShortCircuitMatches(routesToUse);
          cancelActiveDeferreds(), completeNavigation(location, {
            matches: notFoundMatches,
            loaderData: {},
            errors: {
              [route.id]: error
            }
          });
          return;
        }
        if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
          completeNavigation(location, {
            matches
          });
          return;
        }
        pendingNavigationController = new AbortController();
        let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission), pendingActionData, pendingError;
        if (opts && opts.pendingError)
          pendingError = {
            [findNearestBoundary(matches).route.id]: opts.pendingError
          };
        else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
          let actionOutput = await handleAction(request, location, opts.submission, matches, {
            replace: opts.replace
          });
          if (actionOutput.shortCircuited)
            return;
          pendingActionData = actionOutput.pendingActionData, pendingError = actionOutput.pendingActionError, loadingNavigation = _extends({
            state: "loading",
            location
          }, opts.submission), request = new Request(request.url, {
            signal: request.signal
          });
        }
        let {
          shortCircuited,
          loaderData,
          errors
        } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, pendingActionData, pendingError);
        shortCircuited || (pendingNavigationController = null, completeNavigation(location, _extends({
          matches
        }, pendingActionData ? {
          actionData: pendingActionData
        } : {}, {
          loaderData,
          errors
        })));
      }
      async function handleAction(request, location, submission, matches, opts) {
        interruptActiveLoads();
        let navigation = _extends({
          state: "submitting",
          location
        }, submission);
        updateState({
          navigation
        });
        let result, actionMatch = getTargetMatch(matches, location);
        if (!actionMatch.route.action && !actionMatch.route.lazy)
          result = {
            type: ResultType.error,
            error: getInternalRouterError(405, {
              method: request.method,
              pathname: location.pathname,
              routeId: actionMatch.route.id
            })
          };
        else if (result = await callLoaderOrAction("action", request, actionMatch, matches, manifest, mapRouteProperties, basename), request.signal.aborted)
          return {
            shortCircuited: !0
          };
        if (isRedirectResult(result)) {
          let replace;
          return opts && opts.replace != null ? replace = opts.replace : replace = result.location === state.location.pathname + state.location.search, await startRedirectNavigation(state, result, {
            submission,
            replace
          }), {
            shortCircuited: !0
          };
        }
        if (isErrorResult(result)) {
          let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
          return (opts && opts.replace) !== !0 && (pendingAction = exports.Action.Push), {
            // Send back an empty object we can use to clear out any prior actionData
            pendingActionData: {},
            pendingActionError: {
              [boundaryMatch.route.id]: result.error
            }
          };
        }
        if (isDeferredResult(result))
          throw getInternalRouterError(400, {
            type: "defer-action"
          });
        return {
          pendingActionData: {
            [actionMatch.route.id]: result.data
          }
        };
      }
      async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, pendingActionData, pendingError) {
        let loadingNavigation = overrideNavigation;
        loadingNavigation || (loadingNavigation = _extends({
          state: "loading",
          location,
          formMethod: void 0,
          formAction: void 0,
          formEncType: void 0,
          formData: void 0
        }, submission));
        let activeSubmission = submission || fetcherSubmission ? submission || fetcherSubmission : loadingNavigation.formMethod && loadingNavigation.formAction && loadingNavigation.formData && loadingNavigation.formEncType ? {
          formMethod: loadingNavigation.formMethod,
          formAction: loadingNavigation.formAction,
          formData: loadingNavigation.formData,
          formEncType: loadingNavigation.formEncType
        } : void 0, routesToUse = inFlightDataRoutes || dataRoutes, [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, routesToUse, basename, pendingActionData, pendingError);
        if (cancelActiveDeferreds((routeId) => !(matches && matches.some((m2) => m2.route.id === routeId)) || matchesToLoad && matchesToLoad.some((m2) => m2.route.id === routeId)), matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {
          let updatedFetchers2 = markFetchRedirectsDone();
          return completeNavigation(location, _extends({
            matches,
            loaderData: {},
            // Commit pending error if we're short circuiting
            errors: pendingError || null
          }, pendingActionData ? {
            actionData: pendingActionData
          } : {}, updatedFetchers2 ? {
            fetchers: new Map(state.fetchers)
          } : {})), {
            shortCircuited: !0
          };
        }
        if (!isUninterruptedRevalidation) {
          revalidatingFetchers.forEach((rf) => {
            let fetcher2 = state.fetchers.get(rf.key), revalidatingFetcher = {
              state: "loading",
              data: fetcher2 && fetcher2.data,
              formMethod: void 0,
              formAction: void 0,
              formEncType: void 0,
              formData: void 0,
              " _hasFetcherDoneAnything ": !0
            };
            state.fetchers.set(rf.key, revalidatingFetcher);
          });
          let actionData = pendingActionData || state.actionData;
          updateState(_extends({
            navigation: loadingNavigation
          }, actionData ? Object.keys(actionData).length === 0 ? {
            actionData: null
          } : {
            actionData
          } : {}, revalidatingFetchers.length > 0 ? {
            fetchers: new Map(state.fetchers)
          } : {}));
        }
        pendingNavigationLoadId = ++incrementingLoadId, revalidatingFetchers.forEach((rf) => {
          rf.controller && fetchControllers.set(rf.key, rf.controller);
        });
        let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((f3) => abortFetcher(f3.key));
        pendingNavigationController && pendingNavigationController.signal.addEventListener("abort", abortPendingFetchRevalidations);
        let {
          results,
          loaderResults,
          fetcherResults
        } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);
        if (request.signal.aborted)
          return {
            shortCircuited: !0
          };
        pendingNavigationController && pendingNavigationController.signal.removeEventListener("abort", abortPendingFetchRevalidations), revalidatingFetchers.forEach((rf) => fetchControllers.delete(rf.key));
        let redirect3 = findRedirect(results);
        if (redirect3)
          return await startRedirectNavigation(state, redirect3, {
            replace
          }), {
            shortCircuited: !0
          };
        let {
          loaderData,
          errors
        } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds);
        activeDeferreds.forEach((deferredData, routeId) => {
          deferredData.subscribe((aborted) => {
            (aborted || deferredData.done) && activeDeferreds.delete(routeId);
          });
        });
        let updatedFetchers = markFetchRedirectsDone(), didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId), shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;
        return _extends({
          loaderData,
          errors
        }, shouldUpdateFetchers ? {
          fetchers: new Map(state.fetchers)
        } : {});
      }
      function getFetcher(key) {
        return state.fetchers.get(key) || IDLE_FETCHER;
      }
      function fetch4(key, routeId, href, opts) {
        if (isServer)
          throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
        fetchControllers.has(key) && abortFetcher(key);
        let routesToUse = inFlightDataRoutes || dataRoutes, normalizedPath = normalizeTo(state.location, state.matches, basename, future2.v7_prependBasename, href, routeId, opts == null ? void 0 : opts.relative), matches = matchRoutes(routesToUse, normalizedPath, basename);
        if (!matches) {
          setFetcherError(key, routeId, getInternalRouterError(404, {
            pathname: normalizedPath
          }));
          return;
        }
        let {
          path,
          submission
        } = normalizeNavigateOptions(future2.v7_normalizeFormMethod, !0, normalizedPath, opts), match = getTargetMatch(matches, path);
        if (pendingPreventScrollReset = (opts && opts.preventScrollReset) === !0, submission && isMutationMethod(submission.formMethod)) {
          handleFetcherAction(key, routeId, path, match, matches, submission);
          return;
        }
        fetchLoadMatches.set(key, {
          routeId,
          path
        }), handleFetcherLoader(key, routeId, path, match, matches, submission);
      }
      async function handleFetcherAction(key, routeId, path, match, requestMatches, submission) {
        if (interruptActiveLoads(), fetchLoadMatches.delete(key), !match.route.action && !match.route.lazy) {
          let error = getInternalRouterError(405, {
            method: submission.formMethod,
            pathname: path,
            routeId
          });
          setFetcherError(key, routeId, error);
          return;
        }
        let existingFetcher = state.fetchers.get(key), fetcher2 = _extends({
          state: "submitting"
        }, submission, {
          data: existingFetcher && existingFetcher.data,
          " _hasFetcherDoneAnything ": !0
        });
        state.fetchers.set(key, fetcher2), updateState({
          fetchers: new Map(state.fetchers)
        });
        let abortController = new AbortController(), fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);
        fetchControllers.set(key, abortController);
        let actionResult = await callLoaderOrAction("action", fetchRequest, match, requestMatches, manifest, mapRouteProperties, basename);
        if (fetchRequest.signal.aborted) {
          fetchControllers.get(key) === abortController && fetchControllers.delete(key);
          return;
        }
        if (isRedirectResult(actionResult)) {
          fetchControllers.delete(key), fetchRedirectIds.add(key);
          let loadingFetcher = _extends({
            state: "loading"
          }, submission, {
            data: void 0,
            " _hasFetcherDoneAnything ": !0
          });
          return state.fetchers.set(key, loadingFetcher), updateState({
            fetchers: new Map(state.fetchers)
          }), startRedirectNavigation(state, actionResult, {
            submission,
            isFetchActionRedirect: !0
          });
        }
        if (isErrorResult(actionResult)) {
          setFetcherError(key, routeId, actionResult.error);
          return;
        }
        if (isDeferredResult(actionResult))
          throw getInternalRouterError(400, {
            type: "defer-action"
          });
        let nextLocation = state.navigation.location || state.location, revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal), routesToUse = inFlightDataRoutes || dataRoutes, matches = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;
        invariant(matches, "Didn't find any matches after fetcher action");
        let loadId = ++incrementingLoadId;
        fetchReloadIds.set(key, loadId);
        let loadFetcher = _extends({
          state: "loading",
          data: actionResult.data
        }, submission, {
          " _hasFetcherDoneAnything ": !0
        });
        state.fetchers.set(key, loadFetcher);
        let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(
          init.history,
          state,
          matches,
          submission,
          nextLocation,
          isRevalidationRequired,
          cancelledDeferredRoutes,
          cancelledFetcherLoads,
          fetchLoadMatches,
          routesToUse,
          basename,
          {
            [match.route.id]: actionResult.data
          },
          void 0
          // No need to send through errors since we short circuit above
        );
        revalidatingFetchers.filter((rf) => rf.key !== key).forEach((rf) => {
          let staleKey = rf.key, existingFetcher2 = state.fetchers.get(staleKey), revalidatingFetcher = {
            state: "loading",
            data: existingFetcher2 && existingFetcher2.data,
            formMethod: void 0,
            formAction: void 0,
            formEncType: void 0,
            formData: void 0,
            " _hasFetcherDoneAnything ": !0
          };
          state.fetchers.set(staleKey, revalidatingFetcher), rf.controller && fetchControllers.set(staleKey, rf.controller);
        }), updateState({
          fetchers: new Map(state.fetchers)
        });
        let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((rf) => abortFetcher(rf.key));
        abortController.signal.addEventListener("abort", abortPendingFetchRevalidations);
        let {
          results,
          loaderResults,
          fetcherResults
        } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);
        if (abortController.signal.aborted)
          return;
        abortController.signal.removeEventListener("abort", abortPendingFetchRevalidations), fetchReloadIds.delete(key), fetchControllers.delete(key), revalidatingFetchers.forEach((r2) => fetchControllers.delete(r2.key));
        let redirect3 = findRedirect(results);
        if (redirect3)
          return startRedirectNavigation(state, redirect3);
        let {
          loaderData,
          errors
        } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, void 0, revalidatingFetchers, fetcherResults, activeDeferreds);
        if (state.fetchers.has(key)) {
          let doneFetcher = {
            state: "idle",
            data: actionResult.data,
            formMethod: void 0,
            formAction: void 0,
            formEncType: void 0,
            formData: void 0,
            " _hasFetcherDoneAnything ": !0
          };
          state.fetchers.set(key, doneFetcher);
        }
        let didAbortFetchLoads = abortStaleFetchLoads(loadId);
        state.navigation.state === "loading" && loadId > pendingNavigationLoadId ? (invariant(pendingAction, "Expected pending action"), pendingNavigationController && pendingNavigationController.abort(), completeNavigation(state.navigation.location, {
          matches,
          loaderData,
          errors,
          fetchers: new Map(state.fetchers)
        })) : (updateState(_extends({
          errors,
          loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors)
        }, didAbortFetchLoads || revalidatingFetchers.length > 0 ? {
          fetchers: new Map(state.fetchers)
        } : {})), isRevalidationRequired = !1);
      }
      async function handleFetcherLoader(key, routeId, path, match, matches, submission) {
        let existingFetcher = state.fetchers.get(key), loadingFetcher = _extends({
          state: "loading",
          formMethod: void 0,
          formAction: void 0,
          formEncType: void 0,
          formData: void 0
        }, submission, {
          data: existingFetcher && existingFetcher.data,
          " _hasFetcherDoneAnything ": !0
        });
        state.fetchers.set(key, loadingFetcher), updateState({
          fetchers: new Map(state.fetchers)
        });
        let abortController = new AbortController(), fetchRequest = createClientSideRequest(init.history, path, abortController.signal);
        fetchControllers.set(key, abortController);
        let result = await callLoaderOrAction("loader", fetchRequest, match, matches, manifest, mapRouteProperties, basename);
        if (isDeferredResult(result) && (result = await resolveDeferredData(result, fetchRequest.signal, !0) || result), fetchControllers.get(key) === abortController && fetchControllers.delete(key), fetchRequest.signal.aborted)
          return;
        if (isRedirectResult(result)) {
          fetchRedirectIds.add(key), await startRedirectNavigation(state, result);
          return;
        }
        if (isErrorResult(result)) {
          let boundaryMatch = findNearestBoundary(state.matches, routeId);
          state.fetchers.delete(key), updateState({
            fetchers: new Map(state.fetchers),
            errors: {
              [boundaryMatch.route.id]: result.error
            }
          });
          return;
        }
        invariant(!isDeferredResult(result), "Unhandled fetcher deferred data");
        let doneFetcher = {
          state: "idle",
          data: result.data,
          formMethod: void 0,
          formAction: void 0,
          formEncType: void 0,
          formData: void 0,
          " _hasFetcherDoneAnything ": !0
        };
        state.fetchers.set(key, doneFetcher), updateState({
          fetchers: new Map(state.fetchers)
        });
      }
      async function startRedirectNavigation(state2, redirect3, _temp) {
        let {
          submission,
          replace,
          isFetchActionRedirect
        } = _temp === void 0 ? {} : _temp;
        redirect3.revalidate && (isRevalidationRequired = !0);
        let redirectLocation = createLocation(
          state2.location,
          redirect3.location,
          // TODO: This can be removed once we get rid of useTransition in Remix v2
          _extends({
            _isRedirect: !0
          }, isFetchActionRedirect ? {
            _isFetchActionRedirect: !0
          } : {})
        );
        if (invariant(redirectLocation, "Expected a location on the redirect navigation"), ABSOLUTE_URL_REGEX.test(redirect3.location) && isBrowser) {
          let url = init.history.createURL(redirect3.location), isDifferentBasename = stripBasename(url.pathname, basename) == null;
          if (routerWindow.location.origin !== url.origin || isDifferentBasename) {
            replace ? routerWindow.location.replace(redirect3.location) : routerWindow.location.assign(redirect3.location);
            return;
          }
        }
        pendingNavigationController = null;
        let redirectHistoryAction = replace === !0 ? exports.Action.Replace : exports.Action.Push, {
          formMethod,
          formAction,
          formEncType,
          formData
        } = state2.navigation;
        !submission && formMethod && formAction && formData && formEncType && (submission = {
          formMethod,
          formAction,
          formEncType,
          formData
        }), redirectPreserveMethodStatusCodes.has(redirect3.status) && submission && isMutationMethod(submission.formMethod) ? await startNavigation(redirectHistoryAction, redirectLocation, {
          submission: _extends({}, submission, {
            formAction: redirect3.location
          }),
          // Preserve this flag across redirects
          preventScrollReset: pendingPreventScrollReset
        }) : isFetchActionRedirect ? await startNavigation(redirectHistoryAction, redirectLocation, {
          overrideNavigation: {
            state: "loading",
            location: redirectLocation,
            formMethod: void 0,
            formAction: void 0,
            formEncType: void 0,
            formData: void 0
          },
          fetcherSubmission: submission,
          // Preserve this flag across redirects
          preventScrollReset: pendingPreventScrollReset
        }) : await startNavigation(redirectHistoryAction, redirectLocation, {
          overrideNavigation: {
            state: "loading",
            location: redirectLocation,
            formMethod: submission ? submission.formMethod : void 0,
            formAction: submission ? submission.formAction : void 0,
            formEncType: submission ? submission.formEncType : void 0,
            formData: submission ? submission.formData : void 0
          },
          // Preserve this flag across redirects
          preventScrollReset: pendingPreventScrollReset
        });
      }
      async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {
        let results = await Promise.all([...matchesToLoad.map((match) => callLoaderOrAction("loader", request, match, matches, manifest, mapRouteProperties, basename)), ...fetchersToLoad.map((f3) => f3.matches && f3.match && f3.controller ? callLoaderOrAction("loader", createClientSideRequest(init.history, f3.path, f3.controller.signal), f3.match, f3.matches, manifest, mapRouteProperties, basename) : {
          type: ResultType.error,
          error: getInternalRouterError(404, {
            pathname: f3.path
          })
        })]), loaderResults = results.slice(0, matchesToLoad.length), fetcherResults = results.slice(matchesToLoad.length);
        return await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(() => request.signal), !1, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map((f3) => f3.match), fetcherResults, fetchersToLoad.map((f3) => f3.controller ? f3.controller.signal : null), !0)]), {
          results,
          loaderResults,
          fetcherResults
        };
      }
      function interruptActiveLoads() {
        isRevalidationRequired = !0, cancelledDeferredRoutes.push(...cancelActiveDeferreds()), fetchLoadMatches.forEach((_, key) => {
          fetchControllers.has(key) && (cancelledFetcherLoads.push(key), abortFetcher(key));
        });
      }
      function setFetcherError(key, routeId, error) {
        let boundaryMatch = findNearestBoundary(state.matches, routeId);
        deleteFetcher(key), updateState({
          errors: {
            [boundaryMatch.route.id]: error
          },
          fetchers: new Map(state.fetchers)
        });
      }
      function deleteFetcher(key) {
        let fetcher2 = state.fetchers.get(key);
        fetchControllers.has(key) && !(fetcher2 && fetcher2.state === "loading" && fetchReloadIds.has(key)) && abortFetcher(key), fetchLoadMatches.delete(key), fetchReloadIds.delete(key), fetchRedirectIds.delete(key), state.fetchers.delete(key);
      }
      function abortFetcher(key) {
        let controller = fetchControllers.get(key);
        invariant(controller, "Expected fetch controller: " + key), controller.abort(), fetchControllers.delete(key);
      }
      function markFetchersDone(keys) {
        for (let key of keys) {
          let doneFetcher = {
            state: "idle",
            data: getFetcher(key).data,
            formMethod: void 0,
            formAction: void 0,
            formEncType: void 0,
            formData: void 0,
            " _hasFetcherDoneAnything ": !0
          };
          state.fetchers.set(key, doneFetcher);
        }
      }
      function markFetchRedirectsDone() {
        let doneKeys = [], updatedFetchers = !1;
        for (let key of fetchRedirectIds) {
          let fetcher2 = state.fetchers.get(key);
          invariant(fetcher2, "Expected fetcher: " + key), fetcher2.state === "loading" && (fetchRedirectIds.delete(key), doneKeys.push(key), updatedFetchers = !0);
        }
        return markFetchersDone(doneKeys), updatedFetchers;
      }
      function abortStaleFetchLoads(landedId) {
        let yeetedKeys = [];
        for (let [key, id] of fetchReloadIds)
          if (id < landedId) {
            let fetcher2 = state.fetchers.get(key);
            invariant(fetcher2, "Expected fetcher: " + key), fetcher2.state === "loading" && (abortFetcher(key), fetchReloadIds.delete(key), yeetedKeys.push(key));
          }
        return markFetchersDone(yeetedKeys), yeetedKeys.length > 0;
      }
      function getBlocker(key, fn) {
        let blocker = state.blockers.get(key) || IDLE_BLOCKER;
        return blockerFunctions.get(key) !== fn && blockerFunctions.set(key, fn), blocker;
      }
      function deleteBlocker(key) {
        state.blockers.delete(key), blockerFunctions.delete(key);
      }
      function updateBlocker(key, newBlocker) {
        let blocker = state.blockers.get(key) || IDLE_BLOCKER;
        invariant(blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked", "Invalid blocker state transition: " + blocker.state + " -> " + newBlocker.state), state.blockers.set(key, newBlocker), updateState({
          blockers: new Map(state.blockers)
        });
      }
      function shouldBlockNavigation(_ref2) {
        let {
          currentLocation,
          nextLocation,
          historyAction
        } = _ref2;
        if (blockerFunctions.size === 0)
          return;
        blockerFunctions.size > 1 && warning(!1, "A router only supports one blocker at a time");
        let entries = Array.from(blockerFunctions.entries()), [blockerKey, blockerFunction] = entries[entries.length - 1], blocker = state.blockers.get(blockerKey);
        if (!(blocker && blocker.state === "proceeding") && blockerFunction({
          currentLocation,
          nextLocation,
          historyAction
        }))
          return blockerKey;
      }
      function cancelActiveDeferreds(predicate) {
        let cancelledRouteIds = [];
        return activeDeferreds.forEach((dfd, routeId) => {
          (!predicate || predicate(routeId)) && (dfd.cancel(), cancelledRouteIds.push(routeId), activeDeferreds.delete(routeId));
        }), cancelledRouteIds;
      }
      function enableScrollRestoration(positions, getPosition, getKey) {
        if (savedScrollPositions = positions, getScrollPosition = getPosition, getScrollRestorationKey = getKey || ((location) => location.key), !initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
          initialScrollRestored = !0;
          let y = getSavedScrollPosition(state.location, state.matches);
          y != null && updateState({
            restoreScrollPosition: y
          });
        }
        return () => {
          savedScrollPositions = null, getScrollPosition = null, getScrollRestorationKey = null;
        };
      }
      function saveScrollPosition(location, matches) {
        if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) {
          let userMatches = matches.map((m2) => createUseMatchesMatch(m2, state.loaderData)), key = getScrollRestorationKey(location, userMatches) || location.key;
          savedScrollPositions[key] = getScrollPosition();
        }
      }
      function getSavedScrollPosition(location, matches) {
        if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) {
          let userMatches = matches.map((m2) => createUseMatchesMatch(m2, state.loaderData)), key = getScrollRestorationKey(location, userMatches) || location.key, y = savedScrollPositions[key];
          if (typeof y == "number")
            return y;
        }
        return null;
      }
      function _internalSetRoutes(newRoutes) {
        manifest = {}, inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties, void 0, manifest);
      }
      return router = {
        get basename() {
          return basename;
        },
        get state() {
          return state;
        },
        get routes() {
          return dataRoutes;
        },
        initialize,
        subscribe,
        enableScrollRestoration,
        navigate,
        fetch: fetch4,
        revalidate,
        // Passthrough to history-aware createHref used by useHref so we get proper
        // hash-aware URLs in DOM paths
        createHref: (to) => init.history.createHref(to),
        encodeLocation: (to) => init.history.encodeLocation(to),
        getFetcher,
        deleteFetcher,
        dispose,
        getBlocker,
        deleteBlocker,
        _internalFetchControllers: fetchControllers,
        _internalActiveDeferreds: activeDeferreds,
        // TODO: Remove setRoutes, it's temporary to avoid dealing with
        // updating the tree while validating the update algorithm.
        _internalSetRoutes
      }, router;
    }
    var UNSAFE_DEFERRED_SYMBOL = Symbol("deferred");
    function createStaticHandler(routes2, opts) {
      invariant(routes2.length > 0, "You must provide a non-empty routes array to createStaticHandler");
      let manifest = {}, basename = (opts ? opts.basename : null) || "/", mapRouteProperties;
      if (opts != null && opts.mapRouteProperties)
        mapRouteProperties = opts.mapRouteProperties;
      else if (opts != null && opts.detectErrorBoundary) {
        let detectErrorBoundary = opts.detectErrorBoundary;
        mapRouteProperties = (route) => ({
          hasErrorBoundary: detectErrorBoundary(route)
        });
      } else
        mapRouteProperties = defaultMapRouteProperties;
      let dataRoutes = convertRoutesToDataRoutes(routes2, mapRouteProperties, void 0, manifest);
      async function query(request, _temp2) {
        let {
          requestContext
        } = _temp2 === void 0 ? {} : _temp2, url = new URL(request.url), method = request.method, location = createLocation("", createPath(url), null, "default"), matches = matchRoutes(dataRoutes, location, basename);
        if (!isValidMethod(method) && method !== "HEAD") {
          let error = getInternalRouterError(405, {
            method
          }), {
            matches: methodNotAllowedMatches,
            route
          } = getShortCircuitMatches(dataRoutes);
          return {
            basename,
            location,
            matches: methodNotAllowedMatches,
            loaderData: {},
            actionData: null,
            errors: {
              [route.id]: error
            },
            statusCode: error.status,
            loaderHeaders: {},
            actionHeaders: {},
            activeDeferreds: null
          };
        } else if (!matches) {
          let error = getInternalRouterError(404, {
            pathname: location.pathname
          }), {
            matches: notFoundMatches,
            route
          } = getShortCircuitMatches(dataRoutes);
          return {
            basename,
            location,
            matches: notFoundMatches,
            loaderData: {},
            actionData: null,
            errors: {
              [route.id]: error
            },
            statusCode: error.status,
            loaderHeaders: {},
            actionHeaders: {},
            activeDeferreds: null
          };
        }
        let result = await queryImpl(request, location, matches, requestContext);
        return isResponse(result) ? result : _extends({
          location,
          basename
        }, result);
      }
      async function queryRoute(request, _temp3) {
        let {
          routeId,
          requestContext
        } = _temp3 === void 0 ? {} : _temp3, url = new URL(request.url), method = request.method, location = createLocation("", createPath(url), null, "default"), matches = matchRoutes(dataRoutes, location, basename);
        if (!isValidMethod(method) && method !== "HEAD" && method !== "OPTIONS")
          throw getInternalRouterError(405, {
            method
          });
        if (!matches)
          throw getInternalRouterError(404, {
            pathname: location.pathname
          });
        let match = routeId ? matches.find((m2) => m2.route.id === routeId) : getTargetMatch(matches, location);
        if (routeId && !match)
          throw getInternalRouterError(403, {
            pathname: location.pathname,
            routeId
          });
        if (!match)
          throw getInternalRouterError(404, {
            pathname: location.pathname
          });
        let result = await queryImpl(request, location, matches, requestContext, match);
        if (isResponse(result))
          return result;
        let error = result.errors ? Object.values(result.errors)[0] : void 0;
        if (error !== void 0)
          throw error;
        if (result.actionData)
          return Object.values(result.actionData)[0];
        if (result.loaderData) {
          var _result$activeDeferre;
          let data = Object.values(result.loaderData)[0];
          return (_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id] && (data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id]), data;
        }
      }
      async function queryImpl(request, location, matches, requestContext, routeMatch) {
        invariant(request.signal, "query()/queryRoute() requests must contain an AbortController signal");
        try {
          if (isMutationMethod(request.method.toLowerCase()))
            return await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, routeMatch != null);
          let result = await loadRouteData(request, matches, requestContext, routeMatch);
          return isResponse(result) ? result : _extends({}, result, {
            actionData: null,
            actionHeaders: {}
          });
        } catch (e2) {
          if (isQueryRouteResponse(e2)) {
            if (e2.type === ResultType.error && !isRedirectResponse(e2.response))
              throw e2.response;
            return e2.response;
          }
          if (isRedirectResponse(e2))
            return e2;
          throw e2;
        }
      }
      async function submit(request, matches, actionMatch, requestContext, isRouteRequest) {
        let result;
        if (!actionMatch.route.action && !actionMatch.route.lazy) {
          let error = getInternalRouterError(405, {
            method: request.method,
            pathname: new URL(request.url).pathname,
            routeId: actionMatch.route.id
          });
          if (isRouteRequest)
            throw error;
          result = {
            type: ResultType.error,
            error
          };
        } else if (result = await callLoaderOrAction("action", request, actionMatch, matches, manifest, mapRouteProperties, basename, !0, isRouteRequest, requestContext), request.signal.aborted) {
          let method = isRouteRequest ? "queryRoute" : "query";
          throw new Error(method + "() call aborted");
        }
        if (isRedirectResult(result))
          throw new Response(null, {
            status: result.status,
            headers: {
              Location: result.location
            }
          });
        if (isDeferredResult(result)) {
          let error = getInternalRouterError(400, {
            type: "defer-action"
          });
          if (isRouteRequest)
            throw error;
          result = {
            type: ResultType.error,
            error
          };
        }
        if (isRouteRequest) {
          if (isErrorResult(result))
            throw result.error;
          return {
            matches: [actionMatch],
            loaderData: {},
            actionData: {
              [actionMatch.route.id]: result.data
            },
            errors: null,
            // Note: statusCode + headers are unused here since queryRoute will
            // return the raw Response or value
            statusCode: 200,
            loaderHeaders: {},
            actionHeaders: {},
            activeDeferreds: null
          };
        }
        if (isErrorResult(result)) {
          let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id), context2 = await loadRouteData(request, matches, requestContext, void 0, {
            [boundaryMatch.route.id]: result.error
          });
          return _extends({}, context2, {
            statusCode: isRouteErrorResponse2(result.error) ? result.error.status : 500,
            actionData: null,
            actionHeaders: _extends({}, result.headers ? {
              [actionMatch.route.id]: result.headers
            } : {})
          });
        }
        let loaderRequest = new Request(request.url, {
          headers: request.headers,
          redirect: request.redirect,
          signal: request.signal
        }), context = await loadRouteData(loaderRequest, matches, requestContext);
        return _extends({}, context, result.statusCode ? {
          statusCode: result.statusCode
        } : {}, {
          actionData: {
            [actionMatch.route.id]: result.data
          },
          actionHeaders: _extends({}, result.headers ? {
            [actionMatch.route.id]: result.headers
          } : {})
        });
      }
      async function loadRouteData(request, matches, requestContext, routeMatch, pendingActionError) {
        let isRouteRequest = routeMatch != null;
        if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy))
          throw getInternalRouterError(400, {
            method: request.method,
            pathname: new URL(request.url).pathname,
            routeId: routeMatch == null ? void 0 : routeMatch.route.id
          });
        let matchesToLoad = (routeMatch ? [routeMatch] : getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || {})[0])).filter((m2) => m2.route.loader || m2.route.lazy);
        if (matchesToLoad.length === 0)
          return {
            matches,
            // Add a null for all matched routes for proper revalidation on the client
            loaderData: matches.reduce((acc, m2) => Object.assign(acc, {
              [m2.route.id]: null
            }), {}),
            errors: pendingActionError || null,
            statusCode: 200,
            loaderHeaders: {},
            activeDeferreds: null
          };
        let results = await Promise.all([...matchesToLoad.map((match) => callLoaderOrAction("loader", request, match, matches, manifest, mapRouteProperties, basename, !0, isRouteRequest, requestContext))]);
        if (request.signal.aborted) {
          let method = isRouteRequest ? "queryRoute" : "query";
          throw new Error(method + "() call aborted");
        }
        let activeDeferreds = /* @__PURE__ */ new Map(), context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionError, activeDeferreds), executedLoaders = new Set(matchesToLoad.map((match) => match.route.id));
        return matches.forEach((match) => {
          executedLoaders.has(match.route.id) || (context.loaderData[match.route.id] = null);
        }), _extends({}, context, {
          matches,
          activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null
        });
      }
      return {
        dataRoutes,
        query,
        queryRoute
      };
    }
    function getStaticContextFromError(routes2, context, error) {
      return _extends({}, context, {
        statusCode: 500,
        errors: {
          [context._deepestRenderedBoundaryId || routes2[0].id]: error
        }
      });
    }
    function isSubmissionNavigation(opts) {
      return opts != null && "formData" in opts;
    }
    function normalizeTo(location, matches, basename, prependBasename, to, fromRouteId, relative) {
      let contextualMatches, activeRouteMatch;
      if (fromRouteId != null && relative !== "path") {
        contextualMatches = [];
        for (let match of matches)
          if (contextualMatches.push(match), match.route.id === fromRouteId) {
            activeRouteMatch = match;
            break;
          }
      } else
        contextualMatches = matches, activeRouteMatch = matches[matches.length - 1];
      let path = resolveTo(to || ".", getPathContributingMatches(contextualMatches).map((m2) => m2.pathnameBase), stripBasename(location.pathname, basename) || location.pathname, relative === "path");
      return to == null && (path.search = location.search, path.hash = location.hash), (to == null || to === "" || to === ".") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search) && (path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index"), prependBasename && basename !== "/" && (path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname])), createPath(path);
    }
    function normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {
      if (!opts || !isSubmissionNavigation(opts))
        return {
          path
        };
      if (opts.formMethod && !isValidMethod(opts.formMethod))
        return {
          path,
          error: getInternalRouterError(405, {
            method: opts.formMethod
          })
        };
      let submission;
      if (opts.formData) {
        let formMethod = opts.formMethod || "get";
        if (submission = {
          formMethod: normalizeFormMethod ? formMethod.toUpperCase() : formMethod.toLowerCase(),
          formAction: stripHashFromPath(path),
          formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
          formData: opts.formData
        }, isMutationMethod(submission.formMethod))
          return {
            path,
            submission
          };
      }
      let parsedPath = parsePath(path), searchParams = convertFormDataToSearchParams(opts.formData);
      return isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search) && searchParams.append("index", ""), parsedPath.search = "?" + searchParams, {
        path: createPath(parsedPath),
        submission
      };
    }
    function getLoaderMatchesUntilBoundary(matches, boundaryId) {
      let boundaryMatches = matches;
      if (boundaryId) {
        let index = matches.findIndex((m2) => m2.route.id === boundaryId);
        index >= 0 && (boundaryMatches = matches.slice(0, index));
      }
      return boundaryMatches;
    }
    function getMatchesToLoad(history, state, matches, submission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, routesToUse, basename, pendingActionData, pendingError) {
      let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : void 0, currentUrl = history.createURL(state.location), nextUrl = history.createURL(location), boundaryId = pendingError ? Object.keys(pendingError)[0] : void 0, navigationMatches = getLoaderMatchesUntilBoundary(matches, boundaryId).filter((match, index) => {
        if (match.route.lazy)
          return !0;
        if (match.route.loader == null)
          return !1;
        if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some((id) => id === match.route.id))
          return !0;
        let currentRouteMatch = state.matches[index], nextRouteMatch = match;
        return shouldRevalidateLoader(match, _extends({
          currentUrl,
          currentParams: currentRouteMatch.params,
          nextUrl,
          nextParams: nextRouteMatch.params
        }, submission, {
          actionResult,
          defaultShouldRevalidate: (
            // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
            isRevalidationRequired || // Clicked the same link, resubmitted a GET form
            currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders
            currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)
          )
        }));
      }), revalidatingFetchers = [];
      return fetchLoadMatches.forEach((f3, key) => {
        if (!matches.some((m2) => m2.route.id === f3.routeId))
          return;
        let fetcherMatches = matchRoutes(routesToUse, f3.path, basename);
        if (!fetcherMatches) {
          revalidatingFetchers.push({
            key,
            routeId: f3.routeId,
            path: f3.path,
            matches: null,
            match: null,
            controller: null
          });
          return;
        }
        let fetcherMatch = getTargetMatch(fetcherMatches, f3.path);
        if (cancelledFetcherLoads.includes(key)) {
          revalidatingFetchers.push({
            key,
            routeId: f3.routeId,
            path: f3.path,
            matches: fetcherMatches,
            match: fetcherMatch,
            controller: new AbortController()
          });
          return;
        }
        shouldRevalidateLoader(fetcherMatch, _extends({
          currentUrl,
          currentParams: state.matches[state.matches.length - 1].params,
          nextUrl,
          nextParams: matches[matches.length - 1].params
        }, submission, {
          actionResult,
          // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
          defaultShouldRevalidate: isRevalidationRequired
        })) && revalidatingFetchers.push({
          key,
          routeId: f3.routeId,
          path: f3.path,
          matches: fetcherMatches,
          match: fetcherMatch,
          controller: new AbortController()
        });
      }), [navigationMatches, revalidatingFetchers];
    }
    function isNewLoader(currentLoaderData, currentMatch, match) {
      let isNew = (
        // [a] -> [a, b]
        !currentMatch || // [a, b] -> [a, c]
        match.route.id !== currentMatch.route.id
      ), isMissingData = currentLoaderData[match.route.id] === void 0;
      return isNew || isMissingData;
    }
    function isNewRouteInstance(currentMatch, match) {
      let currentPath = currentMatch.route.path;
      return (
        // param change for this match, /users/123 -> /users/456
        currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path
        // e.g. /files/images/avatar.jpg -> files/finances.xls
        currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"]
      );
    }
    function shouldRevalidateLoader(loaderMatch, arg) {
      if (loaderMatch.route.shouldRevalidate) {
        let routeChoice = loaderMatch.route.shouldRevalidate(arg);
        if (typeof routeChoice == "boolean")
          return routeChoice;
      }
      return arg.defaultShouldRevalidate;
    }
    async function loadLazyRouteModule(route, mapRouteProperties, manifest) {
      if (!route.lazy)
        return;
      let lazyRoute = await route.lazy();
      if (!route.lazy)
        return;
      let routeToUpdate = manifest[route.id];
      invariant(routeToUpdate, "No route found in manifest");
      let routeUpdates = {};
      for (let lazyRouteProperty in lazyRoute) {
        let isPropertyStaticallyDefined = routeToUpdate[lazyRouteProperty] !== void 0 && // This property isn't static since it should always be updated based
        // on the route updates
        lazyRouteProperty !== "hasErrorBoundary";
        warning(!isPropertyStaticallyDefined, 'Route "' + routeToUpdate.id + '" has a static property "' + lazyRouteProperty + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + lazyRouteProperty + '" will be ignored.')), !isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty) && (routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty]);
      }
      Object.assign(routeToUpdate, routeUpdates), Object.assign(routeToUpdate, _extends({}, mapRouteProperties(routeToUpdate), {
        lazy: void 0
      }));
    }
    async function callLoaderOrAction(type, request, match, matches, manifest, mapRouteProperties, basename, isStaticRequest, isRouteRequest, requestContext) {
      isStaticRequest === void 0 && (isStaticRequest = !1), isRouteRequest === void 0 && (isRouteRequest = !1);
      let resultType, result, onReject, runHandler = (handler) => {
        let reject, abortPromise = new Promise((_, r2) => reject = r2);
        return onReject = () => reject(), request.signal.addEventListener("abort", onReject), Promise.race([handler({
          request,
          params: match.params,
          context: requestContext
        }), abortPromise]);
      };
      try {
        let handler = match.route[type];
        if (match.route.lazy)
          if (handler)
            result = (await Promise.all([runHandler(handler), loadLazyRouteModule(match.route, mapRouteProperties, manifest)]))[0];
          else if (await loadLazyRouteModule(match.route, mapRouteProperties, manifest), handler = match.route[type], handler)
            result = await runHandler(handler);
          else if (type === "action") {
            let url = new URL(request.url), pathname = url.pathname + url.search;
            throw getInternalRouterError(405, {
              method: request.method,
              pathname,
              routeId: match.route.id
            });
          } else
            return {
              type: ResultType.data,
              data: void 0
            };
        else if (handler)
          result = await runHandler(handler);
        else {
          let url = new URL(request.url), pathname = url.pathname + url.search;
          throw getInternalRouterError(404, {
            pathname
          });
        }
        invariant(result !== void 0, "You defined " + (type === "action" ? "an action" : "a loader") + " for route " + ('"' + match.route.id + "\" but didn't return anything from your `" + type + "` ") + "function. Please return a value or `null`.");
      } catch (e2) {
        resultType = ResultType.error, result = e2;
      } finally {
        onReject && request.signal.removeEventListener("abort", onReject);
      }
      if (isResponse(result)) {
        let status = result.status;
        if (redirectStatusCodes.has(status)) {
          let location = result.headers.get("Location");
          if (invariant(location, "Redirects returned/thrown from loaders/actions must have a Location header"), !ABSOLUTE_URL_REGEX.test(location))
            location = normalizeTo(new URL(request.url), matches.slice(0, matches.indexOf(match) + 1), basename, !0, location);
          else if (!isStaticRequest) {
            let currentUrl = new URL(request.url), url = location.startsWith("//") ? new URL(currentUrl.protocol + location) : new URL(location), isSameBasename = stripBasename(url.pathname, basename) != null;
            url.origin === currentUrl.origin && isSameBasename && (location = url.pathname + url.search + url.hash);
          }
          if (isStaticRequest)
            throw result.headers.set("Location", location), result;
          return {
            type: ResultType.redirect,
            status,
            location,
            revalidate: result.headers.get("X-Remix-Revalidate") !== null
          };
        }
        if (isRouteRequest)
          throw {
            type: resultType || ResultType.data,
            response: result
          };
        let data, contentType = result.headers.get("Content-Type");
        return contentType && /\bapplication\/json\b/.test(contentType) ? data = await result.json() : data = await result.text(), resultType === ResultType.error ? {
          type: resultType,
          error: new ErrorResponse(status, result.statusText, data),
          headers: result.headers
        } : {
          type: ResultType.data,
          data,
          statusCode: result.status,
          headers: result.headers
        };
      }
      if (resultType === ResultType.error)
        return {
          type: resultType,
          error: result
        };
      if (isDeferredData(result)) {
        var _result$init, _result$init2;
        return {
          type: ResultType.deferred,
          deferredData: result,
          statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,
          headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)
        };
      }
      return {
        type: ResultType.data,
        data: result
      };
    }
    function createClientSideRequest(history, location, signal, submission) {
      let url = history.createURL(stripHashFromPath(location)).toString(), init = {
        signal
      };
      if (submission && isMutationMethod(submission.formMethod)) {
        let {
          formMethod,
          formEncType,
          formData
        } = submission;
        init.method = formMethod.toUpperCase(), init.body = formEncType === "application/x-www-form-urlencoded" ? convertFormDataToSearchParams(formData) : formData;
      }
      return new Request(url, init);
    }
    function convertFormDataToSearchParams(formData) {
      let searchParams = new URLSearchParams();
      for (let [key, value] of formData.entries())
        searchParams.append(key, value instanceof File ? value.name : value);
      return searchParams;
    }
    function processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {
      let loaderData = {}, errors = null, statusCode, foundError = !1, loaderHeaders = {};
      return results.forEach((result, index) => {
        let id = matchesToLoad[index].route.id;
        if (invariant(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData"), isErrorResult(result)) {
          let boundaryMatch = findNearestBoundary(matches, id), error = result.error;
          pendingError && (error = Object.values(pendingError)[0], pendingError = void 0), errors = errors || {}, errors[boundaryMatch.route.id] == null && (errors[boundaryMatch.route.id] = error), loaderData[id] = void 0, foundError || (foundError = !0, statusCode = isRouteErrorResponse2(result.error) ? result.error.status : 500), result.headers && (loaderHeaders[id] = result.headers);
        } else
          isDeferredResult(result) ? (activeDeferreds.set(id, result.deferredData), loaderData[id] = result.deferredData.data) : loaderData[id] = result.data, result.statusCode != null && result.statusCode !== 200 && !foundError && (statusCode = result.statusCode), result.headers && (loaderHeaders[id] = result.headers);
      }), pendingError && (errors = pendingError, loaderData[Object.keys(pendingError)[0]] = void 0), {
        loaderData,
        errors,
        statusCode: statusCode || 200,
        loaderHeaders
      };
    }
    function processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {
      let {
        loaderData,
        errors
      } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds);
      for (let index = 0; index < revalidatingFetchers.length; index++) {
        let {
          key,
          match,
          controller
        } = revalidatingFetchers[index];
        invariant(fetcherResults !== void 0 && fetcherResults[index] !== void 0, "Did not find corresponding fetcher result");
        let result = fetcherResults[index];
        if (!(controller && controller.signal.aborted))
          if (isErrorResult(result)) {
            let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);
            errors && errors[boundaryMatch.route.id] || (errors = _extends({}, errors, {
              [boundaryMatch.route.id]: result.error
            })), state.fetchers.delete(key);
          } else if (isRedirectResult(result))
            invariant(!1, "Unhandled fetcher revalidation redirect");
          else if (isDeferredResult(result))
            invariant(!1, "Unhandled fetcher deferred data");
          else {
            let doneFetcher = {
              state: "idle",
              data: result.data,
              formMethod: void 0,
              formAction: void 0,
              formEncType: void 0,
              formData: void 0,
              " _hasFetcherDoneAnything ": !0
            };
            state.fetchers.set(key, doneFetcher);
          }
      }
      return {
        loaderData,
        errors
      };
    }
    function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
      let mergedLoaderData = _extends({}, newLoaderData);
      for (let match of matches) {
        let id = match.route.id;
        if (newLoaderData.hasOwnProperty(id) ? newLoaderData[id] !== void 0 && (mergedLoaderData[id] = newLoaderData[id]) : loaderData[id] !== void 0 && match.route.loader && (mergedLoaderData[id] = loaderData[id]), errors && errors.hasOwnProperty(id))
          break;
      }
      return mergedLoaderData;
    }
    function findNearestBoundary(matches, routeId) {
      return (routeId ? matches.slice(0, matches.findIndex((m2) => m2.route.id === routeId) + 1) : [...matches]).reverse().find((m2) => m2.route.hasErrorBoundary === !0) || matches[0];
    }
    function getShortCircuitMatches(routes2) {
      let route = routes2.find((r2) => r2.index || !r2.path || r2.path === "/") || {
        id: "__shim-error-route__"
      };
      return {
        matches: [{
          params: {},
          pathname: "",
          pathnameBase: "",
          route
        }],
        route
      };
    }
    function getInternalRouterError(status, _temp4) {
      let {
        pathname,
        routeId,
        method,
        type
      } = _temp4 === void 0 ? {} : _temp4, statusText = "Unknown Server Error", errorMessage = "Unknown @remix-run/router error";
      return status === 400 ? (statusText = "Bad Request", method && pathname && routeId ? errorMessage = "You made a " + method + ' request to "' + pathname + '" but ' + ('did not provide a `loader` for route "' + routeId + '", ') + "so there is no way to handle the request." : type === "defer-action" && (errorMessage = "defer() is not supported in actions")) : status === 403 ? (statusText = "Forbidden", errorMessage = 'Route "' + routeId + '" does not match URL "' + pathname + '"') : status === 404 ? (statusText = "Not Found", errorMessage = 'No route matches URL "' + pathname + '"') : status === 405 && (statusText = "Method Not Allowed", method && pathname && routeId ? errorMessage = "You made a " + method.toUpperCase() + ' request to "' + pathname + '" but ' + ('did not provide an `action` for route "' + routeId + '", ') + "so there is no way to handle the request." : method && (errorMessage = 'Invalid request method "' + method.toUpperCase() + '"')), new ErrorResponse(status || 500, statusText, new Error(errorMessage), !0);
    }
    function findRedirect(results) {
      for (let i2 = results.length - 1; i2 >= 0; i2--) {
        let result = results[i2];
        if (isRedirectResult(result))
          return result;
      }
    }
    function stripHashFromPath(path) {
      let parsedPath = typeof path == "string" ? parsePath(path) : path;
      return createPath(_extends({}, parsedPath, {
        hash: ""
      }));
    }
    function isHashChangeOnly(a, b) {
      return a.pathname !== b.pathname || a.search !== b.search ? !1 : a.hash === "" ? b.hash !== "" : a.hash === b.hash ? !0 : b.hash !== "";
    }
    function isDeferredResult(result) {
      return result.type === ResultType.deferred;
    }
    function isErrorResult(result) {
      return result.type === ResultType.error;
    }
    function isRedirectResult(result) {
      return (result && result.type) === ResultType.redirect;
    }
    function isDeferredData(value) {
      let deferred = value;
      return deferred && typeof deferred == "object" && typeof deferred.data == "object" && typeof deferred.subscribe == "function" && typeof deferred.cancel == "function" && typeof deferred.resolveData == "function";
    }
    function isResponse(value) {
      return value != null && typeof value.status == "number" && typeof value.statusText == "string" && typeof value.headers == "object" && typeof value.body < "u";
    }
    function isRedirectResponse(result) {
      if (!isResponse(result))
        return !1;
      let status = result.status, location = result.headers.get("Location");
      return status >= 300 && status <= 399 && location != null;
    }
    function isQueryRouteResponse(obj) {
      return obj && isResponse(obj.response) && (obj.type === ResultType.data || ResultType.error);
    }
    function isValidMethod(method) {
      return validRequestMethods.has(method.toLowerCase());
    }
    function isMutationMethod(method) {
      return validMutationMethods.has(method.toLowerCase());
    }
    async function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {
      for (let index = 0; index < results.length; index++) {
        let result = results[index], match = matchesToLoad[index];
        if (!match)
          continue;
        let currentMatch = currentMatches.find((m2) => m2.route.id === match.route.id), isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== void 0;
        if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {
          let signal = signals[index];
          invariant(signal, "Expected an AbortSignal for revalidating fetcher deferred result"), await resolveDeferredData(result, signal, isFetcher).then((result2) => {
            result2 && (results[index] = result2 || results[index]);
          });
        }
      }
    }
    async function resolveDeferredData(result, signal, unwrap) {
      if (unwrap === void 0 && (unwrap = !1), !await result.deferredData.resolveData(signal)) {
        if (unwrap)
          try {
            return {
              type: ResultType.data,
              data: result.deferredData.unwrappedData
            };
          } catch (e2) {
            return {
              type: ResultType.error,
              error: e2
            };
          }
        return {
          type: ResultType.data,
          data: result.deferredData.data
        };
      }
    }
    function hasNakedIndexQuery(search) {
      return new URLSearchParams(search).getAll("index").some((v) => v === "");
    }
    function createUseMatchesMatch(match, loaderData) {
      let {
        route,
        pathname,
        params
      } = match;
      return {
        id: route.id,
        pathname,
        params,
        data: loaderData[route.id],
        handle: route.handle
      };
    }
    function getTargetMatch(matches, location) {
      let search = typeof location == "string" ? parsePath(location).search : location.search;
      if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || ""))
        return matches[matches.length - 1];
      let pathMatches = getPathContributingMatches(matches);
      return pathMatches[pathMatches.length - 1];
    }
    exports.AbortedDeferredError = AbortedDeferredError;
    exports.ErrorResponse = ErrorResponse;
    exports.IDLE_BLOCKER = IDLE_BLOCKER;
    exports.IDLE_FETCHER = IDLE_FETCHER;
    exports.IDLE_NAVIGATION = IDLE_NAVIGATION;
    exports.UNSAFE_DEFERRED_SYMBOL = UNSAFE_DEFERRED_SYMBOL;
    exports.UNSAFE_DeferredData = DeferredData;
    exports.UNSAFE_convertRoutesToDataRoutes = convertRoutesToDataRoutes;
    exports.UNSAFE_getPathContributingMatches = getPathContributingMatches;
    exports.UNSAFE_invariant = invariant;
    exports.UNSAFE_warning = warning;
    exports.createBrowserHistory = createBrowserHistory;
    exports.createHashHistory = createHashHistory;
    exports.createMemoryHistory = createMemoryHistory;
    exports.createPath = createPath;
    exports.createRouter = createRouter;
    exports.createStaticHandler = createStaticHandler;
    exports.defer = defer;
    exports.generatePath = generatePath;
    exports.getStaticContextFromError = getStaticContextFromError;
    exports.getToPathname = getToPathname;
    exports.isDeferredData = isDeferredData;
    exports.isRouteErrorResponse = isRouteErrorResponse2;
    exports.joinPaths = joinPaths;
    exports.json = json2;
    exports.matchPath = matchPath;
    exports.matchRoutes = matchRoutes;
    exports.normalizePathname = normalizePathname;
    exports.parsePath = parsePath;
    exports.redirect = redirect2;
    exports.resolvePath = resolvePath;
    exports.resolveTo = resolveTo;
    exports.stripBasename = stripBasename;
  }
});

// node_modules/@remix-run/server-runtime/dist/mode.js
var require_mode = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var ServerMode = /* @__PURE__ */ function(ServerMode2) {
      return ServerMode2.Development = "development", ServerMode2.Production = "production", ServerMode2.Test = "test", ServerMode2;
    }({});
    function isServerMode(value) {
      return value === ServerMode.Development || value === ServerMode.Production || value === ServerMode.Test;
    }
    exports.ServerMode = ServerMode;
    exports.isServerMode = isServerMode;
  }
});

// node_modules/@remix-run/server-runtime/dist/errors.js
var require_errors = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var router = require_router_cjs(), mode = require_mode();
    function sanitizeError(error, serverMode) {
      if (error instanceof Error && serverMode !== mode.ServerMode.Development) {
        let sanitized = new Error("Unexpected Server Error");
        return sanitized.stack = void 0, sanitized;
      }
      return error;
    }
    function sanitizeErrors(errors, serverMode) {
      return Object.entries(errors).reduce((acc, [routeId, error]) => Object.assign(acc, {
        [routeId]: sanitizeError(error, serverMode)
      }), {});
    }
    function serializeError(error, serverMode) {
      let sanitized = sanitizeError(error, serverMode);
      return {
        message: sanitized.message,
        stack: sanitized.stack
      };
    }
    function serializeErrors(errors, serverMode) {
      if (!errors)
        return null;
      let entries = Object.entries(errors), serialized = {};
      for (let [key, val] of entries)
        if (router.isRouteErrorResponse(val))
          serialized[key] = {
            ...val,
            __type: "RouteErrorResponse"
          };
        else if (val instanceof Error) {
          let sanitized = sanitizeError(val, serverMode);
          serialized[key] = {
            message: sanitized.message,
            stack: sanitized.stack,
            __type: "Error"
          };
        } else
          serialized[key] = val;
      return serialized;
    }
    exports.sanitizeError = sanitizeError;
    exports.sanitizeErrors = sanitizeErrors;
    exports.serializeError = serializeError;
    exports.serializeErrors = serializeErrors;
  }
});

// node_modules/@remix-run/server-runtime/dist/responses.js
var require_responses = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var router = require_router_cjs(), errors = require_errors(), json2 = (data, init = {}) => router.json(data, init), defer = (data, init = {}) => router.defer(data, init), redirect2 = (url, init = 302) => router.redirect(url, init);
    function isDeferredData(value) {
      let deferred = value;
      return deferred && typeof deferred == "object" && typeof deferred.data == "object" && typeof deferred.subscribe == "function" && typeof deferred.cancel == "function" && typeof deferred.resolveData == "function";
    }
    function isResponse(value) {
      return value != null && typeof value.status == "number" && typeof value.statusText == "string" && typeof value.headers == "object" && typeof value.body < "u";
    }
    var redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
    function isRedirectStatusCode(statusCode) {
      return redirectStatusCodes.has(statusCode);
    }
    function isRedirectResponse(response) {
      return isRedirectStatusCode(response.status);
    }
    function isTrackedPromise(value) {
      return value != null && typeof value.then == "function" && value._tracked === !0;
    }
    var DEFERRED_VALUE_PLACEHOLDER_PREFIX = "__deferred_promise:";
    function createDeferredReadableStream(deferredData, signal, serverMode) {
      let encoder = new TextEncoder();
      return new ReadableStream({
        async start(controller) {
          let criticalData = {}, preresolvedKeys = [];
          for (let [key, value] of Object.entries(deferredData.data))
            isTrackedPromise(value) ? (criticalData[key] = `${DEFERRED_VALUE_PLACEHOLDER_PREFIX}${key}`, (typeof value._data < "u" || typeof value._error < "u") && preresolvedKeys.push(key)) : criticalData[key] = value;
          controller.enqueue(encoder.encode(JSON.stringify(criticalData) + `

`));
          for (let preresolvedKey of preresolvedKeys)
            enqueueTrackedPromise(controller, encoder, preresolvedKey, deferredData.data[preresolvedKey], serverMode);
          let unsubscribe = deferredData.subscribe((aborted, settledKey) => {
            settledKey && enqueueTrackedPromise(controller, encoder, settledKey, deferredData.data[settledKey], serverMode);
          });
          await deferredData.resolveData(signal), unsubscribe(), controller.close();
        }
      });
    }
    function enqueueTrackedPromise(controller, encoder, settledKey, promise, serverMode) {
      "_error" in promise ? controller.enqueue(encoder.encode("error:" + JSON.stringify({
        [settledKey]: promise._error instanceof Error ? errors.serializeError(promise._error, serverMode) : promise._error
      }) + `

`)) : controller.enqueue(encoder.encode("data:" + JSON.stringify({
        [settledKey]: promise._data ?? null
      }) + `

`));
    }
    exports.createDeferredReadableStream = createDeferredReadableStream;
    exports.defer = defer;
    exports.isDeferredData = isDeferredData;
    exports.isRedirectResponse = isRedirectResponse;
    exports.isRedirectStatusCode = isRedirectStatusCode;
    exports.isResponse = isResponse;
    exports.json = json2;
    exports.redirect = redirect2;
  }
});

// node_modules/@remix-run/server-runtime/dist/entry.js
var require_entry = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/entry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function createEntryRouteModules(manifest) {
      return Object.keys(manifest).reduce((memo2, routeId) => (memo2[routeId] = manifest[routeId].module, memo2), {});
    }
    exports.createEntryRouteModules = createEntryRouteModules;
  }
});

// node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS({
  "node_modules/set-cookie-parser/lib/set-cookie.js"(exports, module2) {
    "use strict";
    var defaultParseOptions = {
      decodeValues: !0,
      map: !1,
      silent: !1
    };
    function isNonEmptyString(str) {
      return typeof str == "string" && !!str.trim();
    }
    function parseString(setCookieValue, options) {
      var parts = setCookieValue.split(";").filter(isNonEmptyString), nameValuePairStr = parts.shift(), parsed = parseNameValuePair(nameValuePairStr), name = parsed.name, value = parsed.value;
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      try {
        value = options.decodeValues ? decodeURIComponent(value) : value;
      } catch (e2) {
        console.error(
          "set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.",
          e2
        );
      }
      var cookie = {
        name,
        value
      };
      return parts.forEach(function(part) {
        var sides = part.split("="), key = sides.shift().trimLeft().toLowerCase(), value2 = sides.join("=");
        key === "expires" ? cookie.expires = new Date(value2) : key === "max-age" ? cookie.maxAge = parseInt(value2, 10) : key === "secure" ? cookie.secure = !0 : key === "httponly" ? cookie.httpOnly = !0 : key === "samesite" ? cookie.sameSite = value2 : cookie[key] = value2;
      }), cookie;
    }
    function parseNameValuePair(nameValuePairStr) {
      var name = "", value = "", nameValueArr = nameValuePairStr.split("=");
      return nameValueArr.length > 1 ? (name = nameValueArr.shift(), value = nameValueArr.join("=")) : value = nameValuePairStr, { name, value };
    }
    function parse(input, options) {
      if (options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions, !input)
        return options.map ? {} : [];
      if (input.headers)
        if (typeof input.headers.getSetCookie == "function")
          input = input.headers.getSetCookie();
        else if (input.headers["set-cookie"])
          input = input.headers["set-cookie"];
        else {
          var sch = input.headers[Object.keys(input.headers).find(function(key) {
            return key.toLowerCase() === "set-cookie";
          })];
          !sch && input.headers.cookie && !options.silent && console.warn(
            "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
          ), input = sch;
        }
      if (Array.isArray(input) || (input = [input]), options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions, options.map) {
        var cookies = {};
        return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
          var cookie = parseString(str, options);
          return cookies2[cookie.name] = cookie, cookies2;
        }, cookies);
      } else
        return input.filter(isNonEmptyString).map(function(str) {
          return parseString(str, options);
        });
    }
    function splitCookiesString(cookiesString) {
      if (Array.isArray(cookiesString))
        return cookiesString;
      if (typeof cookiesString != "string")
        return [];
      var cookiesStrings = [], pos = 0, start, ch, lastComma, nextStart, cookiesSeparatorFound;
      function skipWhitespace() {
        for (; pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos)); )
          pos += 1;
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        return ch = cookiesString.charAt(pos), ch !== "=" && ch !== ";" && ch !== ",";
      }
      for (; pos < cookiesString.length; ) {
        for (start = pos, cookiesSeparatorFound = !1; skipWhitespace(); )
          if (ch = cookiesString.charAt(pos), ch === ",") {
            for (lastComma = pos, pos += 1, skipWhitespace(), nextStart = pos; pos < cookiesString.length && notSpecialChar(); )
              pos += 1;
            pos < cookiesString.length && cookiesString.charAt(pos) === "=" ? (cookiesSeparatorFound = !0, pos = nextStart, cookiesStrings.push(cookiesString.substring(start, lastComma)), start = pos) : pos = lastComma + 1;
          } else
            pos += 1;
        (!cookiesSeparatorFound || pos >= cookiesString.length) && cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
      }
      return cookiesStrings;
    }
    module2.exports = parse;
    module2.exports.parse = parse;
    module2.exports.parseString = parseString;
    module2.exports.splitCookiesString = splitCookiesString;
  }
});

// node_modules/@remix-run/server-runtime/dist/headers.js
var require_headers = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/headers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var setCookieParser = require_set_cookie();
    function getDocumentHeadersRR(build, context) {
      let boundaryIdx = context.errors ? context.matches.findIndex((m2) => context.errors[m2.route.id]) : -1, matches = boundaryIdx >= 0 ? context.matches.slice(0, boundaryIdx + 1) : context.matches, errorHeaders;
      if (boundaryIdx >= 0) {
        let {
          actionHeaders,
          actionData,
          loaderHeaders,
          loaderData
        } = context;
        context.matches.slice(boundaryIdx).some((match) => {
          let id = match.route.id;
          return actionHeaders[id] && (!actionData || actionData[id] === void 0) ? errorHeaders = actionHeaders[id] : loaderHeaders[id] && loaderData[id] === void 0 && (errorHeaders = loaderHeaders[id]), errorHeaders != null;
        });
      }
      return matches.reduce((parentHeaders, match, idx) => {
        let {
          id
        } = match.route, routeModule = build.routes[id].module, loaderHeaders = context.loaderHeaders[id] || new Headers(), actionHeaders = context.actionHeaders[id] || new Headers(), includeErrorHeaders = errorHeaders != null && idx === matches.length - 1, includeErrorCookies = includeErrorHeaders && errorHeaders !== loaderHeaders && errorHeaders !== actionHeaders;
        if (routeModule.headers == null && build.future.v2_headers) {
          let headers2 = new Headers(parentHeaders);
          return includeErrorCookies && prependCookies(errorHeaders, headers2), prependCookies(actionHeaders, headers2), prependCookies(loaderHeaders, headers2), headers2;
        }
        let headers = new Headers(routeModule.headers ? typeof routeModule.headers == "function" ? routeModule.headers({
          loaderHeaders,
          parentHeaders,
          actionHeaders,
          errorHeaders: includeErrorHeaders ? errorHeaders : void 0
        }) : routeModule.headers : void 0);
        return includeErrorCookies && prependCookies(errorHeaders, headers), prependCookies(actionHeaders, headers), prependCookies(loaderHeaders, headers), prependCookies(parentHeaders, headers), headers;
      }, new Headers());
    }
    function prependCookies(parentHeaders, childHeaders) {
      let parentSetCookieString = parentHeaders.get("Set-Cookie");
      parentSetCookieString && setCookieParser.splitCookiesString(parentSetCookieString).forEach((cookie) => {
        childHeaders.append("Set-Cookie", cookie);
      });
    }
    exports.getDocumentHeadersRR = getDocumentHeadersRR;
  }
});

// node_modules/@remix-run/server-runtime/dist/invariant.js
var require_invariant = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/invariant.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function invariant(value, message) {
      if (value === !1 || value === null || typeof value > "u")
        throw console.error("The following error is a bug in Remix; please open an issue! https://github.com/remix-run/remix/issues/new"), new Error(message);
    }
    exports.default = invariant;
  }
});

// node_modules/@remix-run/server-runtime/dist/routeMatching.js
var require_routeMatching = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/routeMatching.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var router = require_router_cjs();
    function matchServerRoutes(routes2, pathname) {
      let matches = router.matchRoutes(routes2, pathname);
      return matches ? matches.map((match) => ({
        params: match.params,
        pathname: match.pathname,
        route: match.route
      })) : null;
    }
    exports.matchServerRoutes = matchServerRoutes;
  }
});

// node_modules/@remix-run/server-runtime/dist/data.js
var require_data = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/data.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var responses = require_responses();
    async function callRouteActionRR({
      loadContext,
      action: action3,
      params,
      request,
      routeId
    }) {
      let result = await action3({
        request: stripDataParam(stripIndexParam(request)),
        context: loadContext,
        params
      });
      if (result === void 0)
        throw new Error(`You defined an action for route "${routeId}" but didn't return anything from your \`action\` function. Please return a value or \`null\`.`);
      return responses.isResponse(result) ? result : responses.json(result);
    }
    async function callRouteLoaderRR({
      loadContext,
      loader: loader2,
      params,
      request,
      routeId
    }) {
      let result = await loader2({
        request: stripDataParam(stripIndexParam(request)),
        context: loadContext,
        params
      });
      if (result === void 0)
        throw new Error(`You defined a loader for route "${routeId}" but didn't return anything from your \`loader\` function. Please return a value or \`null\`.`);
      return responses.isDeferredData(result) ? result.init && responses.isRedirectStatusCode(result.init.status || 200) ? responses.redirect(new Headers(result.init.headers).get("Location"), result.init) : result : responses.isResponse(result) ? result : responses.json(result);
    }
    function stripIndexParam(request) {
      let url = new URL(request.url), indexValues = url.searchParams.getAll("index");
      url.searchParams.delete("index");
      let indexValuesToKeep = [];
      for (let indexValue of indexValues)
        indexValue && indexValuesToKeep.push(indexValue);
      for (let toKeep of indexValuesToKeep)
        url.searchParams.append("index", toKeep);
      return new Request(url.href, request);
    }
    function stripDataParam(request) {
      let url = new URL(request.url);
      return url.searchParams.delete("_data"), new Request(url.href, request);
    }
    exports.callRouteActionRR = callRouteActionRR;
    exports.callRouteLoaderRR = callRouteLoaderRR;
  }
});

// node_modules/@remix-run/server-runtime/dist/routes.js
var require_routes = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/routes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var data = require_data();
    function groupRoutesByParentId(manifest) {
      let routes2 = {};
      return Object.values(manifest).forEach((route) => {
        let parentId = route.parentId || "";
        routes2[parentId] || (routes2[parentId] = []), routes2[parentId].push(route);
      }), routes2;
    }
    function createRoutes(manifest, parentId = "", routesByParentId = groupRoutesByParentId(manifest)) {
      return (routesByParentId[parentId] || []).map((route) => ({
        ...route,
        children: createRoutes(manifest, route.id, routesByParentId)
      }));
    }
    function createStaticHandlerDataRoutes(manifest, future2, parentId = "", routesByParentId = groupRoutesByParentId(manifest)) {
      return (routesByParentId[parentId] || []).map((route) => {
        let commonRoute = {
          // Always include root due to default boundaries
          hasErrorBoundary: future2.v2_errorBoundary === !0 ? route.id === "root" || route.module.ErrorBoundary != null : route.id === "root" || route.module.CatchBoundary != null || route.module.ErrorBoundary != null,
          id: route.id,
          path: route.path,
          loader: route.module.loader ? (args) => data.callRouteLoaderRR({
            request: args.request,
            params: args.params,
            loadContext: args.context,
            loader: route.module.loader,
            routeId: route.id
          }) : void 0,
          action: route.module.action ? (args) => data.callRouteActionRR({
            request: args.request,
            params: args.params,
            loadContext: args.context,
            action: route.module.action,
            routeId: route.id
          }) : void 0,
          handle: route.module.handle
        };
        return route.index ? {
          index: !0,
          ...commonRoute
        } : {
          caseSensitive: route.caseSensitive,
          children: createStaticHandlerDataRoutes(manifest, future2, route.id, routesByParentId),
          ...commonRoute
        };
      });
    }
    exports.createRoutes = createRoutes;
    exports.createStaticHandlerDataRoutes = createStaticHandlerDataRoutes;
  }
});

// node_modules/@remix-run/server-runtime/dist/markup.js
var require_markup = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/markup.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var ESCAPE_LOOKUP = {
      "&": "\\u0026",
      ">": "\\u003e",
      "<": "\\u003c",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    }, ESCAPE_REGEX = /[&><\u2028\u2029]/g;
    function escapeHtml(html) {
      return html.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
    }
    exports.escapeHtml = escapeHtml;
  }
});

// node_modules/@remix-run/server-runtime/dist/serverHandoff.js
var require_serverHandoff = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/serverHandoff.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var markup = require_markup();
    function createServerHandoffString(serverHandoff) {
      return markup.escapeHtml(JSON.stringify(serverHandoff));
    }
    exports.createServerHandoffString = createServerHandoffString;
  }
});

// node_modules/@remix-run/server-runtime/dist/server.js
var require_server = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/server.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var router = require_router_cjs(), entry2 = require_entry(), errors = require_errors(), headers = require_headers(), invariant = require_invariant(), mode = require_mode(), routeMatching = require_routeMatching(), routes2 = require_routes(), responses = require_responses(), serverHandoff = require_serverHandoff(), createRequestHandler = (build, mode$1) => {
      let routes$1 = routes2.createRoutes(build.routes), dataRoutes = routes2.createStaticHandlerDataRoutes(build.routes, build.future), serverMode = mode.isServerMode(mode$1) ? mode$1 : mode.ServerMode.Production, staticHandler = router.createStaticHandler(dataRoutes), errorHandler = build.entry.module.handleError || ((error, {
        request
      }) => {
        serverMode !== mode.ServerMode.Test && !request.signal.aborted && console.error(error);
      });
      return async function(request, loadContext = {}) {
        let url = new URL(request.url), matches = routeMatching.matchServerRoutes(routes$1, url.pathname), handleError = (error) => errorHandler(error, {
          context: loadContext,
          params: matches && matches.length > 0 ? matches[0].params : {},
          request
        }), response;
        if (url.searchParams.has("_data")) {
          let routeId = url.searchParams.get("_data");
          if (response = await handleDataRequestRR(serverMode, staticHandler, routeId, request, loadContext, handleError), build.entry.module.handleDataRequest) {
            let match = matches.find((match2) => match2.route.id == routeId);
            response = await build.entry.module.handleDataRequest(response, {
              context: loadContext,
              params: match ? match.params : {},
              request
            });
          }
        } else
          matches && matches[matches.length - 1].route.module.default == null ? response = await handleResourceRequestRR(serverMode, staticHandler, matches.slice(-1)[0].route.id, request, loadContext, handleError) : response = await handleDocumentRequestRR(serverMode, build, staticHandler, request, loadContext, handleError);
        return request.method === "HEAD" ? new Response(null, {
          headers: response.headers,
          status: response.status,
          statusText: response.statusText
        }) : response;
      };
    };
    async function handleDataRequestRR(serverMode, staticHandler, routeId, request, loadContext, handleError) {
      try {
        let response = await staticHandler.queryRoute(request, {
          routeId,
          requestContext: loadContext
        });
        if (responses.isRedirectResponse(response)) {
          let headers2 = new Headers(response.headers);
          return headers2.set("X-Remix-Redirect", headers2.get("Location")), headers2.set("X-Remix-Status", response.status), headers2.delete("Location"), response.headers.get("Set-Cookie") !== null && headers2.set("X-Remix-Revalidate", "yes"), new Response(null, {
            status: 204,
            headers: headers2
          });
        }
        if (router.UNSAFE_DEFERRED_SYMBOL in response) {
          let deferredData = response[router.UNSAFE_DEFERRED_SYMBOL], body = responses.createDeferredReadableStream(deferredData, request.signal, serverMode), init = deferredData.init || {}, headers2 = new Headers(init.headers);
          return headers2.set("Content-Type", "text/remix-deferred"), init.headers = headers2, new Response(body, init);
        }
        return response;
      } catch (error) {
        if (responses.isResponse(error))
          return error.headers.set("X-Remix-Catch", "yes"), error;
        if (router.isRouteErrorResponse(error))
          return error.error && handleError(error.error), errorResponseToJson(error, serverMode);
        let errorInstance = error instanceof Error ? error : new Error("Unexpected Server Error");
        return handleError(errorInstance), router.json(errors.serializeError(errorInstance, serverMode), {
          status: 500,
          headers: {
            "X-Remix-Error": "yes"
          }
        });
      }
    }
    function findParentBoundary(routes3, routeId, error) {
      let route = routes3[routeId] || routes3.root, isCatch = router.isRouteErrorResponse(error) && (!error.error || error.status === 404);
      return isCatch && route.module.CatchBoundary || !isCatch && route.module.ErrorBoundary || !route.parentId ? route.id : findParentBoundary(routes3, route.parentId, error);
    }
    function differentiateCatchVersusErrorBoundaries(build, context) {
      if (!context.errors)
        return;
      let errors2 = {};
      for (let routeId of Object.keys(context.errors)) {
        let error = context.errors[routeId], handlingRouteId = findParentBoundary(build.routes, routeId, error);
        errors2[handlingRouteId] = error;
      }
      context.errors = errors2;
    }
    async function handleDocumentRequestRR(serverMode, build, staticHandler, request, loadContext, handleError) {
      let context;
      try {
        context = await staticHandler.query(request, {
          requestContext: loadContext
        });
      } catch (error) {
        return handleError(error), new Response(null, {
          status: 500
        });
      }
      if (responses.isResponse(context))
        return context;
      context.errors && (Object.values(context.errors).forEach((err) => {
        (!router.isRouteErrorResponse(err) || err.error) && handleError(err);
      }), context.errors = errors.sanitizeErrors(context.errors, serverMode)), build.future.v2_errorBoundary !== !0 && differentiateCatchVersusErrorBoundaries(build, context);
      let headers$1 = headers.getDocumentHeadersRR(build, context), entryContext = {
        manifest: build.assets,
        routeModules: entry2.createEntryRouteModules(build.routes),
        staticHandlerContext: context,
        serverHandoffString: serverHandoff.createServerHandoffString({
          state: {
            loaderData: context.loaderData,
            actionData: context.actionData,
            errors: errors.serializeErrors(context.errors, serverMode)
          },
          future: build.future,
          dev: build.dev
        }),
        future: build.future
      }, handleDocumentRequestFunction = build.entry.module.default;
      try {
        return await handleDocumentRequestFunction(request, context.statusCode, headers$1, entryContext, loadContext);
      } catch (error) {
        handleError(error), context = router.getStaticContextFromError(staticHandler.dataRoutes, context, error), context.errors && (context.errors = errors.sanitizeErrors(context.errors, serverMode)), build.future.v2_errorBoundary !== !0 && differentiateCatchVersusErrorBoundaries(build, context), entryContext = {
          ...entryContext,
          staticHandlerContext: context,
          serverHandoffString: serverHandoff.createServerHandoffString({
            state: {
              loaderData: context.loaderData,
              actionData: context.actionData,
              errors: errors.serializeErrors(context.errors, serverMode)
            },
            future: build.future
          })
        };
        try {
          return await handleDocumentRequestFunction(request, context.statusCode, headers$1, entryContext, loadContext);
        } catch (error2) {
          return handleError(error2), returnLastResortErrorResponse(error2, serverMode);
        }
      }
    }
    async function handleResourceRequestRR(serverMode, staticHandler, routeId, request, loadContext, handleError) {
      try {
        let response = await staticHandler.queryRoute(request, {
          routeId,
          requestContext: loadContext
        });
        return invariant.default(responses.isResponse(response), "Expected a Response to be returned from queryRoute"), response;
      } catch (error) {
        return responses.isResponse(error) ? (error.headers.set("X-Remix-Catch", "yes"), error) : router.isRouteErrorResponse(error) ? (error.error && handleError(error.error), errorResponseToJson(error, serverMode)) : (handleError(error), returnLastResortErrorResponse(error, serverMode));
      }
    }
    function errorResponseToJson(errorResponse, serverMode) {
      return router.json(errors.serializeError(errorResponse.error || new Error("Unexpected Server Error"), serverMode), {
        status: errorResponse.status,
        statusText: errorResponse.statusText,
        headers: {
          "X-Remix-Error": "yes"
        }
      });
    }
    function returnLastResortErrorResponse(error, serverMode) {
      let message = "Unexpected Server Error";
      return serverMode !== mode.ServerMode.Production && (message += `

${String(error)}`), new Response(message, {
        status: 500,
        headers: {
          "Content-Type": "text/plain"
        }
      });
    }
    exports.createRequestHandler = createRequestHandler;
    exports.differentiateCatchVersusErrorBoundaries = differentiateCatchVersusErrorBoundaries;
  }
});

// node_modules/@remix-run/server-runtime/dist/sessions.js
var require_sessions = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/sessions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var cookies = require_cookies(), warnings = require_warnings();
    function flash(name) {
      return `__flash_${name}__`;
    }
    var createSession = (initialData = {}, id = "") => {
      let map = new Map(Object.entries(initialData));
      return {
        get id() {
          return id;
        },
        get data() {
          return Object.fromEntries(map);
        },
        has(name) {
          return map.has(name) || map.has(flash(name));
        },
        get(name) {
          if (map.has(name))
            return map.get(name);
          let flashName = flash(name);
          if (map.has(flashName)) {
            let value = map.get(flashName);
            return map.delete(flashName), value;
          }
        },
        set(name, value) {
          map.set(name, value);
        },
        flash(name, value) {
          map.set(flash(name), value);
        },
        unset(name) {
          map.delete(name);
        }
      };
    }, isSession = (object) => object != null && typeof object.id == "string" && typeof object.data < "u" && typeof object.has == "function" && typeof object.get == "function" && typeof object.set == "function" && typeof object.flash == "function" && typeof object.unset == "function", createSessionStorageFactory = (createCookie) => ({
      cookie: cookieArg,
      createData,
      readData,
      updateData,
      deleteData
    }) => {
      let cookie = cookies.isCookie(cookieArg) ? cookieArg : createCookie((cookieArg == null ? void 0 : cookieArg.name) || "__session", cookieArg);
      return warnOnceAboutSigningSessionCookie(cookie), {
        async getSession(cookieHeader, options) {
          let id = cookieHeader && await cookie.parse(cookieHeader, options), data = id && await readData(id);
          return createSession(data || {}, id || "");
        },
        async commitSession(session, options) {
          let {
            id,
            data
          } = session;
          return id ? await updateData(id, data, cookie.expires) : id = await createData(data, cookie.expires), cookie.serialize(id, options);
        },
        async destroySession(session, options) {
          return await deleteData(session.id), cookie.serialize("", {
            ...options,
            expires: /* @__PURE__ */ new Date(0)
          });
        }
      };
    };
    function warnOnceAboutSigningSessionCookie(cookie) {
      warnings.warnOnce(cookie.isSigned, `The "${cookie.name}" cookie is not signed, but session cookies should be signed to prevent tampering on the client before they are sent back to the server. See https://remix.run/utils/cookies#signing-cookies for more information.`);
    }
    exports.createSession = createSession;
    exports.createSessionStorageFactory = createSessionStorageFactory;
    exports.isSession = isSession;
    exports.warnOnceAboutSigningSessionCookie = warnOnceAboutSigningSessionCookie;
  }
});

// node_modules/@remix-run/server-runtime/dist/sessions/cookieStorage.js
var require_cookieStorage = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/sessions/cookieStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var cookies = require_cookies(), sessions = require_sessions(), createCookieSessionStorageFactory = (createCookie) => ({
      cookie: cookieArg
    } = {}) => {
      let cookie = cookies.isCookie(cookieArg) ? cookieArg : createCookie((cookieArg == null ? void 0 : cookieArg.name) || "__session", cookieArg);
      return sessions.warnOnceAboutSigningSessionCookie(cookie), {
        async getSession(cookieHeader, options) {
          return sessions.createSession(cookieHeader && await cookie.parse(cookieHeader, options) || {});
        },
        async commitSession(session, options) {
          let serializedCookie = await cookie.serialize(session.data, options);
          if (serializedCookie.length > 4096)
            throw new Error("Cookie length will exceed browser maximum. Length: " + serializedCookie.length);
          return serializedCookie;
        },
        async destroySession(_session, options) {
          return cookie.serialize("", {
            ...options,
            expires: /* @__PURE__ */ new Date(0)
          });
        }
      };
    };
    exports.createCookieSessionStorageFactory = createCookieSessionStorageFactory;
  }
});

// node_modules/@remix-run/server-runtime/dist/sessions/memoryStorage.js
var require_memoryStorage = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/sessions/memoryStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var createMemorySessionStorageFactory = (createSessionStorage) => ({
      cookie
    } = {}) => {
      let uniqueId = 0, map = /* @__PURE__ */ new Map();
      return createSessionStorage({
        cookie,
        async createData(data, expires) {
          let id = (++uniqueId).toString();
          return map.set(id, {
            data,
            expires
          }), id;
        },
        async readData(id) {
          if (map.has(id)) {
            let {
              data,
              expires
            } = map.get(id);
            if (!expires || expires > /* @__PURE__ */ new Date())
              return data;
            expires && map.delete(id);
          }
          return null;
        },
        async updateData(id, data, expires) {
          map.set(id, {
            data,
            expires
          });
        },
        async deleteData(id) {
          map.delete(id);
        }
      });
    };
    exports.createMemorySessionStorageFactory = createMemorySessionStorageFactory;
  }
});

// node_modules/@remix-run/server-runtime/dist/upload/errors.js
var require_errors2 = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/upload/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var MaxPartSizeExceededError = class extends Error {
      constructor(field, maxBytes) {
        super(`Field "${field}" exceeded upload size of ${maxBytes} bytes.`), this.field = field, this.maxBytes = maxBytes;
      }
    };
    exports.MaxPartSizeExceededError = MaxPartSizeExceededError;
  }
});

// node_modules/@remix-run/server-runtime/dist/upload/memoryUploadHandler.js
var require_memoryUploadHandler = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/upload/memoryUploadHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var errors = require_errors2();
    function createMemoryUploadHandler({
      filter,
      maxPartSize = 3e6
    } = {}) {
      return async ({
        filename,
        contentType,
        name,
        data
      }) => {
        if (filter && !await filter({
          filename,
          contentType,
          name
        }))
          return;
        let size = 0, chunks = [];
        for await (let chunk of data) {
          if (size += chunk.byteLength, size > maxPartSize)
            throw new errors.MaxPartSizeExceededError(name, maxPartSize);
          chunks.push(chunk);
        }
        return typeof filename == "string" ? new File(chunks, filename, {
          type: contentType
        }) : await new Blob(chunks, {
          type: contentType
        }).text();
      };
    }
    exports.createMemoryUploadHandler = createMemoryUploadHandler;
  }
});

// node_modules/@remix-run/server-runtime/dist/dev.js
var require_dev = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function broadcastDevReady(build, origin) {
      if (origin ?? (origin = ""), !origin)
        throw Error("Dev server origin not set");
      fetch(`${origin}/ping`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          buildHash: build.assets.version
        })
      }).catch((error) => {
        console.error(`Could not reach Remix dev server at ${origin}`);
      });
    }
    function logDevReady(build) {
      console.log(`[REMIX DEV] ${build.assets.version} ready`);
    }
    exports.broadcastDevReady = broadcastDevReady;
    exports.logDevReady = logDevReady;
  }
});

// node_modules/@remix-run/server-runtime/dist/index.js
var require_dist = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var cookies = require_cookies(), formData = require_formData(), responses = require_responses(), server = require_server(), sessions = require_sessions(), cookieStorage = require_cookieStorage(), memoryStorage = require_memoryStorage(), memoryUploadHandler = require_memoryUploadHandler(), errors = require_errors2(), dev = require_dev();
    exports.createCookieFactory = cookies.createCookieFactory;
    exports.isCookie = cookies.isCookie;
    exports.unstable_composeUploadHandlers = formData.composeUploadHandlers;
    exports.unstable_parseMultipartFormData = formData.parseMultipartFormData;
    exports.defer = responses.defer;
    exports.json = responses.json;
    exports.redirect = responses.redirect;
    exports.createRequestHandler = server.createRequestHandler;
    exports.createSession = sessions.createSession;
    exports.createSessionStorageFactory = sessions.createSessionStorageFactory;
    exports.isSession = sessions.isSession;
    exports.createCookieSessionStorageFactory = cookieStorage.createCookieSessionStorageFactory;
    exports.createMemorySessionStorageFactory = memoryStorage.createMemorySessionStorageFactory;
    exports.unstable_createMemoryUploadHandler = memoryUploadHandler.createMemoryUploadHandler;
    exports.MaxPartSizeExceededError = errors.MaxPartSizeExceededError;
    exports.broadcastDevReady = dev.broadcastDevReady;
    exports.logDevReady = dev.logDevReady;
  }
});

// node_modules/cookie-signature/index.js
var require_cookie_signature = __commonJS({
  "node_modules/cookie-signature/index.js"(exports) {
    var crypto = require("crypto");
    exports.sign = function(val, secret) {
      if (typeof val != "string")
        throw new TypeError("Cookie value must be provided as a string.");
      if (secret == null)
        throw new TypeError("Secret key must be provided.");
      return val + "." + crypto.createHmac("sha256", secret).update(val).digest("base64").replace(/\=+$/, "");
    };
    exports.unsign = function(input, secret) {
      if (typeof input != "string")
        throw new TypeError("Signed cookie string must be provided.");
      if (secret == null)
        throw new TypeError("Secret key must be provided.");
      var tentativeValue = input.slice(0, input.lastIndexOf(".")), expectedInput = exports.sign(tentativeValue, secret), expectedBuffer = Buffer.from(expectedInput), inputBuffer = Buffer.from(input);
      return expectedBuffer.length === inputBuffer.length && crypto.timingSafeEqual(expectedBuffer, inputBuffer) ? tentativeValue : !1;
    };
  }
});

// node_modules/@remix-run/node/dist/crypto.js
var require_crypto = __commonJS({
  "node_modules/@remix-run/node/dist/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var cookieSignature = require_cookie_signature();
    function _interopDefaultLegacy(e2) {
      return e2 && typeof e2 == "object" && "default" in e2 ? e2 : { default: e2 };
    }
    var cookieSignature__default = /* @__PURE__ */ _interopDefaultLegacy(cookieSignature), sign = async (value, secret) => cookieSignature__default.default.sign(value, secret), unsign = async (signed, secret) => cookieSignature__default.default.unsign(signed, secret);
    exports.sign = sign;
    exports.unsign = unsign;
  }
});

// node_modules/@remix-run/node/dist/implementations.js
var require_implementations = __commonJS({
  "node_modules/@remix-run/node/dist/implementations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var serverRuntime = require_dist(), crypto = require_crypto(), createCookie = serverRuntime.createCookieFactory({
      sign: crypto.sign,
      unsign: crypto.unsign
    }), createCookieSessionStorage = serverRuntime.createCookieSessionStorageFactory(createCookie), createSessionStorage = serverRuntime.createSessionStorageFactory(createCookie), createMemorySessionStorage = serverRuntime.createMemorySessionStorageFactory(createSessionStorage);
    exports.createCookie = createCookie;
    exports.createCookieSessionStorage = createCookieSessionStorage;
    exports.createMemorySessionStorage = createMemorySessionStorage;
    exports.createSessionStorage = createSessionStorage;
  }
});

// node_modules/@remix-run/node/dist/sessions/fileStorage.js
var require_fileStorage = __commonJS({
  "node_modules/@remix-run/node/dist/sessions/fileStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var crypto = require("crypto"), fs2 = require("fs"), path = require("path"), implementations = require_implementations();
    function _interopNamespace(e2) {
      if (e2 && e2.__esModule)
        return e2;
      var n = /* @__PURE__ */ Object.create(null);
      return e2 && Object.keys(e2).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e2, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e2[k];
            }
          });
        }
      }), n.default = e2, Object.freeze(n);
    }
    var crypto__namespace = /* @__PURE__ */ _interopNamespace(crypto), path__namespace = /* @__PURE__ */ _interopNamespace(path);
    function createFileSessionStorage({
      cookie,
      dir
    }) {
      return implementations.createSessionStorage({
        cookie,
        async createData(data, expires) {
          let content = JSON.stringify({
            data,
            expires
          });
          for (; ; ) {
            let randomBytes = crypto__namespace.randomBytes(8), id = Buffer.from(randomBytes).toString("hex");
            try {
              let file = getFile(dir, id);
              return await fs2.promises.mkdir(path__namespace.dirname(file), {
                recursive: !0
              }), await fs2.promises.writeFile(file, content, {
                encoding: "utf-8",
                flag: "wx"
              }), id;
            } catch (error) {
              if (error.code !== "EEXIST")
                throw error;
            }
          }
        },
        async readData(id) {
          try {
            let file = getFile(dir, id), content = JSON.parse(await fs2.promises.readFile(file, "utf-8")), data = content.data, expires = typeof content.expires == "string" ? new Date(content.expires) : null;
            return !expires || expires > /* @__PURE__ */ new Date() ? data : (expires && await fs2.promises.unlink(file), null);
          } catch (error) {
            if (error.code !== "ENOENT")
              throw error;
            return null;
          }
        },
        async updateData(id, data, expires) {
          let content = JSON.stringify({
            data,
            expires
          }), file = getFile(dir, id);
          await fs2.promises.mkdir(path__namespace.dirname(file), {
            recursive: !0
          }), await fs2.promises.writeFile(file, content, "utf-8");
        },
        async deleteData(id) {
          if (id)
            try {
              await fs2.promises.unlink(getFile(dir, id));
            } catch (error) {
              if (error.code !== "ENOENT")
                throw error;
            }
        }
      });
    }
    function getFile(dir, id) {
      return path__namespace.join(dir, id.slice(0, 4), id.slice(4));
    }
    exports.createFileSessionStorage = createFileSessionStorage;
  }
});

// node_modules/stream-slice/index.js
var require_stream_slice = __commonJS({
  "node_modules/stream-slice/index.js"(exports) {
    var util = require("util"), Transform = require("stream").Transform;
    util.inherits(SliceStream, Transform);
    function SliceStream(start, end) {
      if (!(this instanceof SliceStream))
        return new SliceStream();
      Transform.call(this), this._start = start || 0, this._end = end || 1 / 0, this._offset = 0, this._state = 0, this._emitUp = !1, this._emitDown = !1;
    }
    SliceStream.prototype._transform = function(chunk, encoding, done) {
      if (this._offset += chunk.length, !this._emitUp && this._offset >= this._start) {
        this._emitUp = !0;
        var start = chunk.length - (this._offset - this._start);
        if (this._offset > this._end) {
          var end = chunk.length - (this._offset - this._end);
          this._emitDown = !0, this.push(chunk.slice(start, end));
        } else
          this.push(chunk.slice(start, chunk.length));
        return done();
      }
      return this._emitUp && !this._emitDown && (this._offset >= this._end ? (this._emitDown = !0, this.push(chunk.slice(0, chunk.length - (this._offset - this._end)))) : this.push(chunk)), done();
    };
    exports.slice = function(start, end) {
      return new SliceStream(start, end);
    };
  }
});

// node_modules/@remix-run/node/dist/stream.js
var require_stream2 = __commonJS({
  "node_modules/@remix-run/node/dist/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var stream = require("stream");
    async function writeReadableStreamToWritable(stream2, writable) {
      let reader = stream2.getReader();
      async function read() {
        let {
          done,
          value
        } = await reader.read();
        if (done) {
          writable.end();
          return;
        }
        writable.write(value);
        let flushable = writable;
        typeof flushable.flush == "function" && flushable.flush(), await read();
      }
      try {
        await read();
      } catch (error) {
        throw writable.destroy(error), error;
      }
    }
    async function writeAsyncIterableToWritable(iterable, writable) {
      try {
        for await (let chunk of iterable)
          writable.write(chunk);
        writable.end();
      } catch (error) {
        throw writable.destroy(error), error;
      }
    }
    async function readableStreamToString(stream2, encoding) {
      let reader = stream2.getReader(), chunks = [];
      async function read() {
        let {
          done,
          value
        } = await reader.read();
        done || (value && chunks.push(value), await read());
      }
      return await read(), Buffer.concat(chunks).toString(encoding);
    }
    var createReadableStreamFromReadable = (source) => {
      let pump2 = new StreamPump(source);
      return new ReadableStream(pump2, pump2);
    }, StreamPump = class {
      constructor(stream$1) {
        this.highWaterMark = stream$1.readableHighWaterMark || new stream.Stream.Readable().readableHighWaterMark, this.accumalatedSize = 0, this.stream = stream$1, this.enqueue = this.enqueue.bind(this), this.error = this.error.bind(this), this.close = this.close.bind(this);
      }
      size(chunk) {
        return (chunk == null ? void 0 : chunk.byteLength) || 0;
      }
      start(controller) {
        this.controller = controller, this.stream.on("data", this.enqueue), this.stream.once("error", this.error), this.stream.once("end", this.close), this.stream.once("close", this.close);
      }
      pull() {
        this.resume();
      }
      cancel(reason) {
        this.stream.destroy && this.stream.destroy(reason), this.stream.off("data", this.enqueue), this.stream.off("error", this.error), this.stream.off("end", this.close), this.stream.off("close", this.close);
      }
      enqueue(chunk) {
        if (this.controller)
          try {
            let bytes = chunk instanceof Uint8Array ? chunk : Buffer.from(chunk), available = (this.controller.desiredSize || 0) - bytes.byteLength;
            this.controller.enqueue(bytes), available <= 0 && this.pause();
          } catch {
            this.controller.error(new Error("Could not create Buffer, chunk must be of type string or an instance of Buffer, ArrayBuffer, or Array or an Array-like Object")), this.cancel();
          }
      }
      pause() {
        this.stream.pause && this.stream.pause();
      }
      resume() {
        this.stream.readable && this.stream.resume && this.stream.resume();
      }
      close() {
        this.controller && (this.controller.close(), delete this.controller);
      }
      error(error) {
        this.controller && (this.controller.error(error), delete this.controller);
      }
    };
    exports.createReadableStreamFromReadable = createReadableStreamFromReadable;
    exports.readableStreamToString = readableStreamToString;
    exports.writeAsyncIterableToWritable = writeAsyncIterableToWritable;
    exports.writeReadableStreamToWritable = writeReadableStreamToWritable;
  }
});

// node_modules/@remix-run/node/dist/upload/fileUploadHandler.js
var require_fileUploadHandler = __commonJS({
  "node_modules/@remix-run/node/dist/upload/fileUploadHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var crypto = require("crypto"), fs2 = require("fs"), promises = require("fs/promises"), os = require("os"), path = require("path"), stream = require("stream"), util = require("util"), serverRuntime = require_dist(), streamSlice = require_stream_slice(), stream$1 = require_stream2();
    function _interopNamespace(e2) {
      if (e2 && e2.__esModule)
        return e2;
      var n = /* @__PURE__ */ Object.create(null);
      return e2 && Object.keys(e2).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e2, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e2[k];
            }
          });
        }
      }), n.default = e2, Object.freeze(n);
    }
    var streamSlice__namespace = /* @__PURE__ */ _interopNamespace(streamSlice), defaultFilePathResolver = ({
      filename
    }) => {
      let ext = filename ? path.extname(filename) : "";
      return "upload_" + crypto.randomBytes(4).readUInt32LE(0) + ext;
    };
    async function uniqueFile(filepath) {
      let ext = path.extname(filepath), uniqueFilepath = filepath;
      for (let i2 = 1; await promises.stat(uniqueFilepath).then(() => !0).catch(() => !1); i2++)
        uniqueFilepath = (ext ? filepath.slice(0, -ext.length) : filepath) + `-${(/* @__PURE__ */ new Date()).getTime()}${ext}`;
      return uniqueFilepath;
    }
    function createFileUploadHandler({
      directory = os.tmpdir(),
      avoidFileConflicts = !0,
      file = defaultFilePathResolver,
      filter,
      maxPartSize = 3e6
    } = {}) {
      return async ({
        name,
        filename,
        contentType,
        data
      }) => {
        if (!filename || filter && !await filter({
          name,
          filename,
          contentType
        }))
          return;
        let dir = typeof directory == "string" ? directory : directory({
          name,
          filename,
          contentType
        });
        if (!dir)
          return;
        let filedir = path.resolve(dir), path$1 = typeof file == "string" ? file : file({
          name,
          filename,
          contentType
        });
        if (!path$1)
          return;
        let filepath = path.resolve(filedir, path$1);
        avoidFileConflicts && (filepath = await uniqueFile(filepath)), await promises.mkdir(path.dirname(filepath), {
          recursive: !0
        }).catch(() => {
        });
        let writeFileStream = fs2.createWriteStream(filepath), size = 0, deleteFile = !1;
        try {
          for await (let chunk of data) {
            if (size += chunk.byteLength, size > maxPartSize)
              throw deleteFile = !0, new serverRuntime.MaxPartSizeExceededError(name, maxPartSize);
            writeFileStream.write(chunk);
          }
        } finally {
          writeFileStream.end(), await util.promisify(stream.finished)(writeFileStream), deleteFile && await promises.rm(filepath).catch(() => {
          });
        }
        return new NodeOnDiskFile(filepath, contentType);
      };
    }
    var NodeOnDiskFile = class {
      lastModified = 0;
      webkitRelativePath = "";
      constructor(filepath, type, slicer) {
        this.filepath = filepath, this.type = type, this.slicer = slicer, this.name = path.basename(filepath);
      }
      get size() {
        let stats = fs2.statSync(this.filepath);
        if (this.slicer) {
          let slice = this.slicer.end - this.slicer.start;
          return slice < 0 ? 0 : slice > stats.size ? stats.size : slice;
        }
        return stats.size;
      }
      slice(start, end, type) {
        var _this$slicer;
        typeof start == "number" && start < 0 && (start = this.size + start), typeof end == "number" && end < 0 && (end = this.size + end);
        let startOffset = ((_this$slicer = this.slicer) === null || _this$slicer === void 0 ? void 0 : _this$slicer.start) || 0;
        return start = startOffset + (start || 0), end = startOffset + (end || this.size), new NodeOnDiskFile(this.filepath, typeof type == "string" ? type : this.type, {
          start,
          end
        });
      }
      async arrayBuffer() {
        let stream2 = fs2.createReadStream(this.filepath);
        return this.slicer && (stream2 = stream2.pipe(streamSlice__namespace.slice(this.slicer.start, this.slicer.end))), new Promise((resolve, reject) => {
          let buf = [];
          stream2.on("data", (chunk) => buf.push(chunk)), stream2.on("end", () => resolve(Buffer.concat(buf))), stream2.on("error", (err) => reject(err));
        });
      }
      stream() {
        let stream2 = fs2.createReadStream(this.filepath);
        return this.slicer && (stream2 = stream2.pipe(streamSlice__namespace.slice(this.slicer.start, this.slicer.end))), stream$1.createReadableStreamFromReadable(stream2);
      }
      async text() {
        return stream$1.readableStreamToString(this.stream());
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
      remove() {
        return promises.unlink(this.filepath);
      }
      getFilePath() {
        return this.filepath;
      }
    };
    exports.NodeOnDiskFile = NodeOnDiskFile;
    exports.createFileUploadHandler = createFileUploadHandler;
  }
});

// node_modules/@remix-run/node/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@remix-run/node/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var sourceMapSupport = require_source_map_support(), abortController = require_abort_controller(), fetch4 = require_fetch(), globals = require_globals(), fileStorage = require_fileStorage(), fileUploadHandler = require_fileUploadHandler(), implementations = require_implementations(), stream = require_stream2(), serverRuntime = require_dist(), webFetch = require_lib_node3();
    function _interopDefaultLegacy(e2) {
      return e2 && typeof e2 == "object" && "default" in e2 ? e2 : { default: e2 };
    }
    var sourceMapSupport__default = /* @__PURE__ */ _interopDefaultLegacy(sourceMapSupport);
    sourceMapSupport__default.default.install();
    Object.defineProperty(exports, "AbortController", {
      enumerable: !0,
      get: function() {
        return abortController.AbortController;
      }
    });
    exports.Request = fetch4.Request;
    exports.Response = fetch4.Response;
    exports.fetch = fetch4.fetch;
    exports.installGlobals = globals.installGlobals;
    exports.createFileSessionStorage = fileStorage.createFileSessionStorage;
    exports.NodeOnDiskFile = fileUploadHandler.NodeOnDiskFile;
    exports.unstable_createFileUploadHandler = fileUploadHandler.createFileUploadHandler;
    exports.createCookie = implementations.createCookie;
    exports.createCookieSessionStorage = implementations.createCookieSessionStorage;
    exports.createMemorySessionStorage = implementations.createMemorySessionStorage;
    exports.createSessionStorage = implementations.createSessionStorage;
    exports.createReadableStreamFromReadable = stream.createReadableStreamFromReadable;
    exports.readableStreamToString = stream.readableStreamToString;
    exports.writeAsyncIterableToWritable = stream.writeAsyncIterableToWritable;
    exports.writeReadableStreamToWritable = stream.writeReadableStreamToWritable;
    Object.defineProperty(exports, "MaxPartSizeExceededError", {
      enumerable: !0,
      get: function() {
        return serverRuntime.MaxPartSizeExceededError;
      }
    });
    Object.defineProperty(exports, "broadcastDevReady", {
      enumerable: !0,
      get: function() {
        return serverRuntime.broadcastDevReady;
      }
    });
    Object.defineProperty(exports, "createRequestHandler", {
      enumerable: !0,
      get: function() {
        return serverRuntime.createRequestHandler;
      }
    });
    Object.defineProperty(exports, "createSession", {
      enumerable: !0,
      get: function() {
        return serverRuntime.createSession;
      }
    });
    Object.defineProperty(exports, "defer", {
      enumerable: !0,
      get: function() {
        return serverRuntime.defer;
      }
    });
    Object.defineProperty(exports, "isCookie", {
      enumerable: !0,
      get: function() {
        return serverRuntime.isCookie;
      }
    });
    Object.defineProperty(exports, "isSession", {
      enumerable: !0,
      get: function() {
        return serverRuntime.isSession;
      }
    });
    Object.defineProperty(exports, "json", {
      enumerable: !0,
      get: function() {
        return serverRuntime.json;
      }
    });
    Object.defineProperty(exports, "logDevReady", {
      enumerable: !0,
      get: function() {
        return serverRuntime.logDevReady;
      }
    });
    Object.defineProperty(exports, "redirect", {
      enumerable: !0,
      get: function() {
        return serverRuntime.redirect;
      }
    });
    Object.defineProperty(exports, "unstable_composeUploadHandlers", {
      enumerable: !0,
      get: function() {
        return serverRuntime.unstable_composeUploadHandlers;
      }
    });
    Object.defineProperty(exports, "unstable_createMemoryUploadHandler", {
      enumerable: !0,
      get: function() {
        return serverRuntime.unstable_createMemoryUploadHandler;
      }
    });
    Object.defineProperty(exports, "unstable_parseMultipartFormData", {
      enumerable: !0,
      get: function() {
        return serverRuntime.unstable_parseMultipartFormData;
      }
    });
    Object.defineProperty(exports, "FormData", {
      enumerable: !0,
      get: function() {
        return webFetch.FormData;
      }
    });
    Object.defineProperty(exports, "Headers", {
      enumerable: !0,
      get: function() {
        return webFetch.Headers;
      }
    });
  }
});

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/react/cjs/react.development.js"(exports, module2) {
    "use strict";
    (function() {
      "use strict";
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var ReactVersion = "18.2.0", REACT_ELEMENT_TYPE = Symbol.for("react.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable != "object")
          return null;
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        return typeof maybeIterator == "function" ? maybeIterator : null;
      }
      var ReactCurrentDispatcher = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, ReactCurrentBatchConfig = {
        transition: null
      }, ReactCurrentActQueue = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, ReactCurrentOwner = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, ReactDebugCurrentFrame = {}, currentExtraStackFrame = null;
      function setExtraStackFrame(stack) {
        currentExtraStackFrame = stack;
      }
      ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
        currentExtraStackFrame = stack;
      }, ReactDebugCurrentFrame.getCurrentStack = null, ReactDebugCurrentFrame.getStackAddendum = function() {
        var stack = "";
        currentExtraStackFrame && (stack += currentExtraStackFrame);
        var impl = ReactDebugCurrentFrame.getCurrentStack;
        return impl && (stack += impl() || ""), stack;
      };
      var enableScopeAPI = !1, enableCacheElement = !1, enableTransitionTracing = !1, enableLegacyHidden = !1, enableDebugTracing = !1, ReactSharedInternals = {
        ReactCurrentDispatcher,
        ReactCurrentBatchConfig,
        ReactCurrentOwner
      };
      ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame, ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
      function warn(format) {
        {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
            args[_key - 1] = arguments[_key];
          printWarning("warn", format, args);
        }
      }
      function error(format) {
        {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
            args[_key2 - 1] = arguments[_key2];
          printWarning("error", format, args);
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame, stack = ReactDebugCurrentFrame2.getStackAddendum();
          stack !== "" && (format += "%s", args = args.concat([stack]));
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format), Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var didWarnStateUpdateForUnmountedComponent = {};
      function warnNoop(publicInstance, callerName) {
        {
          var _constructor = publicInstance.constructor, componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass", warningKey = componentName + "." + callerName;
          if (didWarnStateUpdateForUnmountedComponent[warningKey])
            return;
          error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName), didWarnStateUpdateForUnmountedComponent[warningKey] = !0;
        }
      }
      var ReactNoopUpdateQueue = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function(publicInstance) {
          return !1;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function(publicInstance, callback, callerName) {
          warnNoop(publicInstance, "forceUpdate");
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
          warnNoop(publicInstance, "replaceState");
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function(publicInstance, partialState, callback, callerName) {
          warnNoop(publicInstance, "setState");
        }
      }, assign = Object.assign, emptyObject = {};
      Object.freeze(emptyObject);
      function Component(props, context, updater) {
        this.props = props, this.context = context, this.refs = emptyObject, this.updater = updater || ReactNoopUpdateQueue;
      }
      Component.prototype.isReactComponent = {}, Component.prototype.setState = function(partialState, callback) {
        if (typeof partialState != "object" && typeof partialState != "function" && partialState != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      }, Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      {
        var deprecatedAPIs = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, defineDeprecationWarning = function(methodName, info) {
          Object.defineProperty(Component.prototype, methodName, {
            get: function() {
              warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
            }
          });
        };
        for (var fnName in deprecatedAPIs)
          deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
      }
      function ComponentDummy() {
      }
      ComponentDummy.prototype = Component.prototype;
      function PureComponent(props, context, updater) {
        this.props = props, this.context = context, this.refs = emptyObject, this.updater = updater || ReactNoopUpdateQueue;
      }
      var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
      pureComponentPrototype.constructor = PureComponent, assign(pureComponentPrototype, Component.prototype), pureComponentPrototype.isPureReactComponent = !0;
      function createRef() {
        var refObject = {
          current: null
        };
        return Object.seal(refObject), refObject;
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol == "function" && Symbol.toStringTag, type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        try {
          return testStringCoercion(value), !1;
        } catch {
          return !0;
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        if (willCoercionThrow(value))
          return error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value)), testStringCoercion(value);
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName)
          return displayName;
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null)
          return null;
        if (typeof type.tag == "number" && error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof type == "function")
          return type.displayName || type.name || null;
        if (typeof type == "string")
          return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type == "object")
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              return outerName !== null ? outerName : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type, payload = lazyComponent._payload, init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty, RESERVED_PROPS = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
      didWarnAboutStringRefs = {};
      function hasValidRef(config) {
        if (hasOwnProperty.call(config, "ref")) {
          var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
          if (getter && getter.isReactWarning)
            return !1;
        }
        return config.ref !== void 0;
      }
      function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config, "key").get;
          if (getter && getter.isReactWarning)
            return !1;
        }
        return config.key !== void 0;
      }
      function defineKeyPropWarningGetter(props, displayName) {
        var warnAboutAccessingKey = function() {
          specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName));
        };
        warnAboutAccessingKey.isReactWarning = !0, Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: !0
        });
      }
      function defineRefPropWarningGetter(props, displayName) {
        var warnAboutAccessingRef = function() {
          specialPropRefWarningShown || (specialPropRefWarningShown = !0, error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName));
        };
        warnAboutAccessingRef.isReactWarning = !0, Object.defineProperty(props, "ref", {
          get: warnAboutAccessingRef,
          configurable: !0
        });
      }
      function warnIfStringRefCannotBeAutoConverted(config) {
        if (typeof config.ref == "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
          var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
          didWarnAboutStringRefs[componentName] || (error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref), didWarnAboutStringRefs[componentName] = !0);
        }
      }
      var ReactElement = function(type, key, ref, self2, source, owner, props) {
        var element = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: REACT_ELEMENT_TYPE,
          // Built-in properties that belong on the element
          type,
          key,
          ref,
          props,
          // Record the component responsible for creating this element.
          _owner: owner
        };
        return element._store = {}, Object.defineProperty(element._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(element, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: self2
        }), Object.defineProperty(element, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: source
        }), Object.freeze && (Object.freeze(element.props), Object.freeze(element)), element;
      };
      function createElement(type, config, children) {
        var propName, props = {}, key = null, ref = null, self2 = null, source = null;
        if (config != null) {
          hasValidRef(config) && (ref = config.ref, warnIfStringRefCannotBeAutoConverted(config)), hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key), self2 = config.__self === void 0 ? null : config.__self, source = config.__source === void 0 ? null : config.__source;
          for (propName in config)
            hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName) && (props[propName] = config[propName]);
        }
        var childrenLength = arguments.length - 2;
        if (childrenLength === 1)
          props.children = children;
        else if (childrenLength > 1) {
          for (var childArray = Array(childrenLength), i2 = 0; i2 < childrenLength; i2++)
            childArray[i2] = arguments[i2 + 2];
          Object.freeze && Object.freeze(childArray), props.children = childArray;
        }
        if (type && type.defaultProps) {
          var defaultProps = type.defaultProps;
          for (propName in defaultProps)
            props[propName] === void 0 && (props[propName] = defaultProps[propName]);
        }
        if (key || ref) {
          var displayName = typeof type == "function" ? type.displayName || type.name || "Unknown" : type;
          key && defineKeyPropWarningGetter(props, displayName), ref && defineRefPropWarningGetter(props, displayName);
        }
        return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
        return newElement;
      }
      function cloneElement(element, config, children) {
        if (element == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
        var propName, props = assign({}, element.props), key = element.key, ref = element.ref, self2 = element._self, source = element._source, owner = element._owner;
        if (config != null) {
          hasValidRef(config) && (ref = config.ref, owner = ReactCurrentOwner.current), hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
          var defaultProps;
          element.type && element.type.defaultProps && (defaultProps = element.type.defaultProps);
          for (propName in config)
            hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName) && (config[propName] === void 0 && defaultProps !== void 0 ? props[propName] = defaultProps[propName] : props[propName] = config[propName]);
        }
        var childrenLength = arguments.length - 2;
        if (childrenLength === 1)
          props.children = children;
        else if (childrenLength > 1) {
          for (var childArray = Array(childrenLength), i2 = 0; i2 < childrenLength; i2++)
            childArray[i2] = arguments[i2 + 2];
          props.children = childArray;
        }
        return ReactElement(element.type, key, ref, self2, source, owner, props);
      }
      function isValidElement(object) {
        return typeof object == "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      var SEPARATOR = ".", SUBSEPARATOR = ":";
      function escape2(key) {
        var escapeRegex = /[=:]/g, escaperLookup = {
          "=": "=0",
          ":": "=2"
        }, escapedString = key.replace(escapeRegex, function(match) {
          return escaperLookup[match];
        });
        return "$" + escapedString;
      }
      var didWarnAboutMaps = !1, userProvidedKeyEscapeRegex = /\/+/g;
      function escapeUserProvidedKey(text) {
        return text.replace(userProvidedKeyEscapeRegex, "$&/");
      }
      function getElementKey(element, index) {
        return typeof element == "object" && element !== null && element.key != null ? (checkKeyStringCoercion(element.key), escape2("" + element.key)) : index.toString(36);
      }
      function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        (type === "undefined" || type === "boolean") && (children = null);
        var invokeCallback = !1;
        if (children === null)
          invokeCallback = !0;
        else
          switch (type) {
            case "string":
            case "number":
              invokeCallback = !0;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = !0;
              }
          }
        if (invokeCallback) {
          var _child = children, mappedChild = callback(_child), childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
          if (isArray(mappedChild)) {
            var escapedChildKey = "";
            childKey != null && (escapedChildKey = escapeUserProvidedKey(childKey) + "/"), mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
              return c;
            });
          } else
            mappedChild != null && (isValidElement(mappedChild) && (mappedChild.key && (!_child || _child.key !== mappedChild.key) && checkKeyStringCoercion(mappedChild.key), mappedChild = cloneAndReplaceKey(
              mappedChild,
              // Keep both the (mapped) and old keys if they differ, just as
              // traverseAllChildren used to do for objects as children
              escapedPrefix + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
              (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? (
                // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                // eslint-disable-next-line react-internal/safe-string-coercion
                escapeUserProvidedKey("" + mappedChild.key) + "/"
              ) : "") + childKey
            )), array.push(mappedChild));
          return 1;
        }
        var child, nextName, subtreeCount = 0, nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
        if (isArray(children))
          for (var i2 = 0; i2 < children.length; i2++)
            child = children[i2], nextName = nextNamePrefix + getElementKey(child, i2), subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
        else {
          var iteratorFn = getIteratorFn(children);
          if (typeof iteratorFn == "function") {
            var iterableChildren = children;
            iteratorFn === iterableChildren.entries && (didWarnAboutMaps || warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = !0);
            for (var iterator = iteratorFn.call(iterableChildren), step, ii = 0; !(step = iterator.next()).done; )
              child = step.value, nextName = nextNamePrefix + getElementKey(child, ii++), subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
          } else if (type === "object") {
            var childrenString = String(children);
            throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return subtreeCount;
      }
      function mapChildren(children, func, context) {
        if (children == null)
          return children;
        var result = [], count = 0;
        return mapIntoArray(children, result, "", "", function(child) {
          return func.call(context, child, count++);
        }), result;
      }
      function countChildren(children) {
        var n = 0;
        return mapChildren(children, function() {
          n++;
        }), n;
      }
      function forEachChildren(children, forEachFunc, forEachContext) {
        mapChildren(children, function() {
          forEachFunc.apply(this, arguments);
        }, forEachContext);
      }
      function toArray(children) {
        return mapChildren(children, function(child) {
          return child;
        }) || [];
      }
      function onlyChild(children) {
        if (!isValidElement(children))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return children;
      }
      function createContext(defaultValue) {
        var context = {
          $$typeof: REACT_CONTEXT_TYPE,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null,
          // Add these to use same hidden class in VM as ServerContext
          _defaultValue: null,
          _globalName: null
        };
        context.Provider = {
          $$typeof: REACT_PROVIDER_TYPE,
          _context: context
        };
        var hasWarnedAboutUsingNestedContextConsumers = !1, hasWarnedAboutUsingConsumerProvider = !1, hasWarnedAboutDisplayNameOnConsumer = !1;
        {
          var Consumer = {
            $$typeof: REACT_CONTEXT_TYPE,
            _context: context
          };
          Object.defineProperties(Consumer, {
            Provider: {
              get: function() {
                return hasWarnedAboutUsingConsumerProvider || (hasWarnedAboutUsingConsumerProvider = !0, error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), context.Provider;
              },
              set: function(_Provider) {
                context.Provider = _Provider;
              }
            },
            _currentValue: {
              get: function() {
                return context._currentValue;
              },
              set: function(_currentValue) {
                context._currentValue = _currentValue;
              }
            },
            _currentValue2: {
              get: function() {
                return context._currentValue2;
              },
              set: function(_currentValue2) {
                context._currentValue2 = _currentValue2;
              }
            },
            _threadCount: {
              get: function() {
                return context._threadCount;
              },
              set: function(_threadCount) {
                context._threadCount = _threadCount;
              }
            },
            Consumer: {
              get: function() {
                return hasWarnedAboutUsingNestedContextConsumers || (hasWarnedAboutUsingNestedContextConsumers = !0, error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), context.Consumer;
              }
            },
            displayName: {
              get: function() {
                return context.displayName;
              },
              set: function(displayName) {
                hasWarnedAboutDisplayNameOnConsumer || (warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName), hasWarnedAboutDisplayNameOnConsumer = !0);
              }
            }
          }), context.Consumer = Consumer;
        }
        return context._currentRenderer = null, context._currentRenderer2 = null, context;
      }
      var Uninitialized = -1, Pending = 0, Resolved = 1, Rejected = 2;
      function lazyInitializer(payload) {
        if (payload._status === Uninitialized) {
          var ctor = payload._result, thenable = ctor();
          if (thenable.then(function(moduleObject2) {
            if (payload._status === Pending || payload._status === Uninitialized) {
              var resolved = payload;
              resolved._status = Resolved, resolved._result = moduleObject2;
            }
          }, function(error2) {
            if (payload._status === Pending || payload._status === Uninitialized) {
              var rejected = payload;
              rejected._status = Rejected, rejected._result = error2;
            }
          }), payload._status === Uninitialized) {
            var pending = payload;
            pending._status = Pending, pending._result = thenable;
          }
        }
        if (payload._status === Resolved) {
          var moduleObject = payload._result;
          return moduleObject === void 0 && error(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, moduleObject), "default" in moduleObject || error(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, moduleObject), moduleObject.default;
        } else
          throw payload._result;
      }
      function lazy(ctor) {
        var payload = {
          // We use these fields to store the result.
          _status: Uninitialized,
          _result: ctor
        }, lazyType = {
          $$typeof: REACT_LAZY_TYPE,
          _payload: payload,
          _init: lazyInitializer
        };
        {
          var defaultProps, propTypes;
          Object.defineProperties(lazyType, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return defaultProps;
              },
              set: function(newDefaultProps) {
                error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), defaultProps = newDefaultProps, Object.defineProperty(lazyType, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return propTypes;
              },
              set: function(newPropTypes) {
                error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), propTypes = newPropTypes, Object.defineProperty(lazyType, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return lazyType;
      }
      function forwardRef(render) {
        render != null && render.$$typeof === REACT_MEMO_TYPE ? error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof render != "function" ? error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render) : render.length !== 0 && render.length !== 2 && error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), render != null && (render.defaultProps != null || render.propTypes != null) && error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var elementType = {
          $$typeof: REACT_FORWARD_REF_TYPE,
          render
        };
        {
          var ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name, !render.name && !render.displayName && (render.displayName = name);
            }
          });
        }
        return elementType;
      }
      var REACT_MODULE_REFERENCE;
      REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      function isValidElementType(type) {
        return !!(typeof type == "string" || typeof type == "function" || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing || typeof type == "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0));
      }
      function memo2(type, compare) {
        isValidElementType(type) || error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
        var elementType = {
          $$typeof: REACT_MEMO_TYPE,
          type,
          compare: compare === void 0 ? null : compare
        };
        {
          var ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name, !type.name && !type.displayName && (type.displayName = name);
            }
          });
        }
        return elementType;
      }
      function resolveDispatcher() {
        var dispatcher = ReactCurrentDispatcher.current;
        return dispatcher === null && error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), dispatcher;
      }
      function useContext(Context) {
        var dispatcher = resolveDispatcher();
        if (Context._context !== void 0) {
          var realContext = Context._context;
          realContext.Consumer === Context ? error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : realContext.Provider === Context && error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return dispatcher.useContext(Context);
      }
      function useState(initialState) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useState(initialState);
      }
      function useReducer(reducer, initialArg, init) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useReducer(reducer, initialArg, init);
      }
      function useRef(initialValue) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useRef(initialValue);
      }
      function useEffect(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useEffect(create, deps);
      }
      function useInsertionEffect(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useInsertionEffect(create, deps);
      }
      function useLayoutEffect(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useLayoutEffect(create, deps);
      }
      function useCallback(callback, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useCallback(callback, deps);
      }
      function useMemo(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useMemo(create, deps);
      }
      function useImperativeHandle(ref, create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useImperativeHandle(ref, create, deps);
      }
      function useDebugValue(value, formatterFn) {
        {
          var dispatcher = resolveDispatcher();
          return dispatcher.useDebugValue(value, formatterFn);
        }
      }
      function useTransition() {
        var dispatcher = resolveDispatcher();
        return dispatcher.useTransition();
      }
      function useDeferredValue(value) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useDeferredValue(value);
      }
      function useId() {
        var dispatcher = resolveDispatcher();
        return dispatcher.useId();
      }
      function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      }
      var disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = !0;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log, prevInfo = console.info, prevWarn = console.warn, prevError = console.error, prevGroup = console.group, prevGroupCollapsed = console.groupCollapsed, prevGroupEnd = console.groupEnd;
            var props = {
              configurable: !0,
              enumerable: !0,
              value: disabledLog,
              writable: !0
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          if (disabledDepth--, disabledDepth === 0) {
            var props = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          disabledDepth < 0 && error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === void 0)
            try {
              throw Error();
            } catch (x2) {
              var match = x2.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          return `
` + prefix + name;
        }
      }
      var reentry = !1, componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap == "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry)
          return "";
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0)
            return frame;
        }
        var control;
        reentry = !0;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        previousDispatcher = ReactCurrentDispatcher$1.current, ReactCurrentDispatcher$1.current = null, disableLogs();
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            if (Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x2) {
                control = x2;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x2) {
                control = x2;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x2) {
              control = x2;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack == "string") {
            for (var sampleLines = sample.stack.split(`
`), controlLines = control.stack.split(`
`), s2 = sampleLines.length - 1, c = controlLines.length - 1; s2 >= 1 && c >= 0 && sampleLines[s2] !== controlLines[c]; )
              c--;
            for (; s2 >= 1 && c >= 0; s2--, c--)
              if (sampleLines[s2] !== controlLines[c]) {
                if (s2 !== 1 || c !== 1)
                  do
                    if (s2--, c--, c < 0 || sampleLines[s2] !== controlLines[c]) {
                      var _frame = `
` + sampleLines[s2].replace(" at new ", " at ");
                      return fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName)), typeof fn == "function" && componentFrameCache.set(fn, _frame), _frame;
                    }
                  while (s2 >= 1 && c >= 0);
                break;
              }
          }
        } finally {
          reentry = !1, ReactCurrentDispatcher$1.current = previousDispatcher, reenableLogs(), Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "", syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        return typeof fn == "function" && componentFrameCache.set(fn, syntheticFrame), syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        return describeNativeComponentFrame(fn, !1);
      }
      function shouldConstruct(Component2) {
        var prototype = Component2.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null)
          return "";
        if (typeof type == "function")
          return describeNativeComponentFrame(type, shouldConstruct(type));
        if (typeof type == "string")
          return describeBuiltInComponentFrame(type);
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type == "object")
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type, payload = lazyComponent._payload, init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch {
              }
            }
          }
        return "";
      }
      var loggedTypeFailures = {}, ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        if (element) {
          var owner = element._owner, stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
        } else
          ReactDebugCurrentFrame$1.setExtraStackFrame(null);
      }
      function checkPropTypes(typeSpecs, values, location, componentName, element) {
        {
          var has2 = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs)
            if (has2(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] != "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw err.name = "Invariant Violation", err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              error$1 && !(error$1 instanceof Error) && (setCurrentlyValidatingElement(element), error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1), setCurrentlyValidatingElement(null)), error$1 instanceof Error && !(error$1.message in loggedTypeFailures) && (loggedTypeFailures[error$1.message] = !0, setCurrentlyValidatingElement(element), error("Failed %s type: %s", location, error$1.message), setCurrentlyValidatingElement(null));
            }
        }
      }
      function setCurrentlyValidatingElement$1(element) {
        if (element) {
          var owner = element._owner, stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          setExtraStackFrame(stack);
        } else
          setExtraStackFrame(null);
      }
      var propTypesMisspellWarningShown;
      propTypesMisspellWarningShown = !1;
      function getDeclarationErrorAddendum() {
        if (ReactCurrentOwner.current) {
          var name = getComponentNameFromType(ReactCurrentOwner.current.type);
          if (name)
            return `

Check the render method of \`` + name + "`.";
        }
        return "";
      }
      function getSourceInfoErrorAddendum(source) {
        if (source !== void 0) {
          var fileName = source.fileName.replace(/^.*[\\\/]/, ""), lineNumber = source.lineNumber;
          return `

Check your code at ` + fileName + ":" + lineNumber + ".";
        }
        return "";
      }
      function getSourceInfoErrorAddendumForProps(elementProps) {
        return elementProps != null ? getSourceInfoErrorAddendum(elementProps.__source) : "";
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        var info = getDeclarationErrorAddendum();
        if (!info) {
          var parentName = typeof parentType == "string" ? parentType : parentType.displayName || parentType.name;
          parentName && (info = `

Check the top-level render call using <` + parentName + ">.");
        }
        return info;
      }
      function validateExplicitKey(element, parentType) {
        if (!(!element._store || element._store.validated || element.key != null)) {
          element._store.validated = !0;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (!ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            ownerHasKeyUseWarning[currentComponentErrorInfo] = !0;
            var childOwner = "";
            element && element._owner && element._owner !== ReactCurrentOwner.current && (childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + "."), setCurrentlyValidatingElement$1(element), error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner), setCurrentlyValidatingElement$1(null);
          }
        }
      }
      function validateChildKeys(node, parentType) {
        if (typeof node == "object") {
          if (isArray(node))
            for (var i2 = 0; i2 < node.length; i2++) {
              var child = node[i2];
              isValidElement(child) && validateExplicitKey(child, parentType);
            }
          else if (isValidElement(node))
            node._store && (node._store.validated = !0);
          else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn == "function" && iteratorFn !== node.entries)
              for (var iterator = iteratorFn.call(node), step; !(step = iterator.next()).done; )
                isValidElement(step.value) && validateExplicitKey(step.value, parentType);
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type = element.type;
          if (type == null || typeof type == "string")
            return;
          var propTypes;
          if (typeof type == "function")
            propTypes = type.propTypes;
          else if (typeof type == "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          type.$$typeof === REACT_MEMO_TYPE))
            propTypes = type.propTypes;
          else
            return;
          if (propTypes) {
            var name = getComponentNameFromType(type);
            checkPropTypes(propTypes, element.props, "prop", name, element);
          } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = !0;
            var _name2 = getComponentNameFromType(type);
            error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name2 || "Unknown");
          }
          typeof type.getDefaultProps == "function" && !type.getDefaultProps.isReactClassApproved && error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function validateFragmentProps(fragment) {
        {
          for (var keys = Object.keys(fragment.props), i2 = 0; i2 < keys.length; i2++) {
            var key = keys[i2];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment), error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key), setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          fragment.ref !== null && (setCurrentlyValidatingElement$1(fragment), error("Invalid attribute `ref` supplied to `React.Fragment`."), setCurrentlyValidatingElement$1(null));
        }
      }
      function createElementWithValidation(type, props, children) {
        var validType = isValidElementType(type);
        if (!validType) {
          var info = "";
          (type === void 0 || typeof type == "object" && type !== null && Object.keys(type).length === 0) && (info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var sourceInfo = getSourceInfoErrorAddendumForProps(props);
          sourceInfo ? info += sourceInfo : info += getDeclarationErrorAddendum();
          var typeString;
          type === null ? typeString = "null" : isArray(type) ? typeString = "array" : type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE ? (typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", info = " Did you accidentally export a JSX literal instead of a component?") : typeString = typeof type, error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
        }
        var element = createElement.apply(this, arguments);
        if (element == null)
          return element;
        if (validType)
          for (var i2 = 2; i2 < arguments.length; i2++)
            validateChildKeys(arguments[i2], type);
        return type === REACT_FRAGMENT_TYPE ? validateFragmentProps(element) : validatePropTypes(element), element;
      }
      var didWarnAboutDeprecatedCreateFactory = !1;
      function createFactoryWithValidation(type) {
        var validatedFactory = createElementWithValidation.bind(null, type);
        return validatedFactory.type = type, didWarnAboutDeprecatedCreateFactory || (didWarnAboutDeprecatedCreateFactory = !0, warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(validatedFactory, "type", {
          enumerable: !1,
          get: function() {
            return warn("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: type
            }), type;
          }
        }), validatedFactory;
      }
      function cloneElementWithValidation(element, props, children) {
        for (var newElement = cloneElement.apply(this, arguments), i2 = 2; i2 < arguments.length; i2++)
          validateChildKeys(arguments[i2], newElement.type);
        return validatePropTypes(newElement), newElement;
      }
      function startTransition(scope, options) {
        var prevTransition = ReactCurrentBatchConfig.transition;
        ReactCurrentBatchConfig.transition = {};
        var currentTransition = ReactCurrentBatchConfig.transition;
        ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          scope();
        } finally {
          if (ReactCurrentBatchConfig.transition = prevTransition, prevTransition === null && currentTransition._updatedFibers) {
            var updatedFibersCount = currentTransition._updatedFibers.size;
            updatedFibersCount > 10 && warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), currentTransition._updatedFibers.clear();
          }
        }
      }
      var didWarnAboutMessageChannel = !1, enqueueTaskImpl = null;
      function enqueueTask(task) {
        if (enqueueTaskImpl === null)
          try {
            var requireString = ("require" + Math.random()).slice(0, 7), nodeRequire = module2 && module2[requireString];
            enqueueTaskImpl = nodeRequire.call(module2, "timers").setImmediate;
          } catch {
            enqueueTaskImpl = function(callback) {
              didWarnAboutMessageChannel === !1 && (didWarnAboutMessageChannel = !0, typeof MessageChannel > "u" && error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var channel = new MessageChannel();
              channel.port1.onmessage = callback, channel.port2.postMessage(void 0);
            };
          }
        return enqueueTaskImpl(task);
      }
      var actScopeDepth = 0, didWarnNoAwaitAct = !1;
      function act(callback) {
        {
          var prevActScopeDepth = actScopeDepth;
          actScopeDepth++, ReactCurrentActQueue.current === null && (ReactCurrentActQueue.current = []);
          var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy, result;
          try {
            if (ReactCurrentActQueue.isBatchingLegacy = !0, result = callback(), !prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
              var queue = ReactCurrentActQueue.current;
              queue !== null && (ReactCurrentActQueue.didScheduleLegacyUpdate = !1, flushActQueue(queue));
            }
          } catch (error2) {
            throw popActScope(prevActScopeDepth), error2;
          } finally {
            ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
          }
          if (result !== null && typeof result == "object" && typeof result.then == "function") {
            var thenableResult = result, wasAwaited = !1, thenable = {
              then: function(resolve, reject) {
                wasAwaited = !0, thenableResult.then(function(returnValue2) {
                  popActScope(prevActScopeDepth), actScopeDepth === 0 ? recursivelyFlushAsyncActWork(returnValue2, resolve, reject) : resolve(returnValue2);
                }, function(error2) {
                  popActScope(prevActScopeDepth), reject(error2);
                });
              }
            };
            return !didWarnNoAwaitAct && typeof Promise < "u" && Promise.resolve().then(function() {
            }).then(function() {
              wasAwaited || (didWarnNoAwaitAct = !0, error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), thenable;
          } else {
            var returnValue = result;
            if (popActScope(prevActScopeDepth), actScopeDepth === 0) {
              var _queue = ReactCurrentActQueue.current;
              _queue !== null && (flushActQueue(_queue), ReactCurrentActQueue.current = null);
              var _thenable = {
                then: function(resolve, reject) {
                  ReactCurrentActQueue.current === null ? (ReactCurrentActQueue.current = [], recursivelyFlushAsyncActWork(returnValue, resolve, reject)) : resolve(returnValue);
                }
              };
              return _thenable;
            } else {
              var _thenable2 = {
                then: function(resolve, reject) {
                  resolve(returnValue);
                }
              };
              return _thenable2;
            }
          }
        }
      }
      function popActScope(prevActScopeDepth) {
        prevActScopeDepth !== actScopeDepth - 1 && error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), actScopeDepth = prevActScopeDepth;
      }
      function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
        {
          var queue = ReactCurrentActQueue.current;
          if (queue !== null)
            try {
              flushActQueue(queue), enqueueTask(function() {
                queue.length === 0 ? (ReactCurrentActQueue.current = null, resolve(returnValue)) : recursivelyFlushAsyncActWork(returnValue, resolve, reject);
              });
            } catch (error2) {
              reject(error2);
            }
          else
            resolve(returnValue);
        }
      }
      var isFlushing = !1;
      function flushActQueue(queue) {
        if (!isFlushing) {
          isFlushing = !0;
          var i2 = 0;
          try {
            for (; i2 < queue.length; i2++) {
              var callback = queue[i2];
              do
                callback = callback(!0);
              while (callback !== null);
            }
            queue.length = 0;
          } catch (error2) {
            throw queue = queue.slice(i2 + 1), error2;
          } finally {
            isFlushing = !1;
          }
        }
      }
      var createElement$1 = createElementWithValidation, cloneElement$1 = cloneElementWithValidation, createFactory = createFactoryWithValidation, Children = {
        map: mapChildren,
        forEach: forEachChildren,
        count: countChildren,
        toArray,
        only: onlyChild
      };
      exports.Children = Children, exports.Component = Component, exports.Fragment = REACT_FRAGMENT_TYPE, exports.Profiler = REACT_PROFILER_TYPE, exports.PureComponent = PureComponent, exports.StrictMode = REACT_STRICT_MODE_TYPE, exports.Suspense = REACT_SUSPENSE_TYPE, exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals, exports.cloneElement = cloneElement$1, exports.createContext = createContext, exports.createElement = createElement$1, exports.createFactory = createFactory, exports.createRef = createRef, exports.forwardRef = forwardRef, exports.isValidElement = isValidElement, exports.lazy = lazy, exports.memo = memo2, exports.startTransition = startTransition, exports.unstable_act = act, exports.useCallback = useCallback, exports.useContext = useContext, exports.useDebugValue = useDebugValue, exports.useDeferredValue = useDeferredValue, exports.useEffect = useEffect, exports.useId = useId, exports.useImperativeHandle = useImperativeHandle, exports.useInsertionEffect = useInsertionEffect, exports.useLayoutEffect = useLayoutEffect, exports.useMemo = useMemo, exports.useReducer = useReducer, exports.useRef = useRef, exports.useState = useState, exports.useSyncExternalStore = useSyncExternalStore, exports.useTransition = useTransition, exports.version = ReactVersion, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    })();
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_react_development();
  }
});

// node_modules/react-router/dist/umd/react-router.development.js
var require_react_router_development = __commonJS({
  "node_modules/react-router/dist/umd/react-router.development.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports == "object" && typeof module2 < "u" ? factory(exports, require_react(), require_router_cjs()) : typeof define == "function" && define.amd ? define(["exports", "react", "@remix-run/router"], factory) : (global2 = typeof globalThis < "u" ? globalThis : global2 || self, factory(global2.ReactRouter = {}, global2.React, global2.RemixRouter));
    })(exports, function(exports2, React5, router) {
      "use strict";
      function _interopNamespace(e2) {
        if (e2 && e2.__esModule)
          return e2;
        var n = /* @__PURE__ */ Object.create(null);
        return e2 && Object.keys(e2).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e2, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: !0,
              get: function() {
                return e2[k];
              }
            });
          }
        }), n.default = e2, Object.freeze(n);
      }
      var React__namespace = /* @__PURE__ */ _interopNamespace(React5);
      function _extends() {
        return _extends = Object.assign ? Object.assign.bind() : function(target) {
          for (var i2 = 1; i2 < arguments.length; i2++) {
            var source = arguments[i2];
            for (var key in source)
              Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
          }
          return target;
        }, _extends.apply(this, arguments);
      }
      let DataRouterContext = /* @__PURE__ */ React__namespace.createContext(null);
      DataRouterContext.displayName = "DataRouter";
      let DataRouterStateContext = /* @__PURE__ */ React__namespace.createContext(null);
      DataRouterStateContext.displayName = "DataRouterState";
      let AwaitContext = /* @__PURE__ */ React__namespace.createContext(null);
      AwaitContext.displayName = "Await";
      let NavigationContext = /* @__PURE__ */ React__namespace.createContext(null);
      NavigationContext.displayName = "Navigation";
      let LocationContext = /* @__PURE__ */ React__namespace.createContext(null);
      LocationContext.displayName = "Location";
      let RouteContext = /* @__PURE__ */ React__namespace.createContext({
        outlet: null,
        matches: [],
        isDataRoute: !1
      });
      RouteContext.displayName = "Route";
      let RouteErrorContext = /* @__PURE__ */ React__namespace.createContext(null);
      RouteErrorContext.displayName = "RouteError";
      function useHref(to, _temp) {
        let {
          relative
        } = _temp === void 0 ? {} : _temp;
        useInRouterContext() || router.UNSAFE_invariant(
          !1,
          // TODO: This error is probably because they somehow have 2 versions of the
          // router loaded. We can help them understand how to avoid that.
          "useHref() may be used only in the context of a <Router> component."
        );
        let {
          basename,
          navigator
        } = React__namespace.useContext(NavigationContext), {
          hash,
          pathname,
          search
        } = useResolvedPath(to, {
          relative
        }), joinedPathname = pathname;
        return basename !== "/" && (joinedPathname = pathname === "/" ? basename : router.joinPaths([basename, pathname])), navigator.createHref({
          pathname: joinedPathname,
          search,
          hash
        });
      }
      function useInRouterContext() {
        return React__namespace.useContext(LocationContext) != null;
      }
      function useLocation() {
        return useInRouterContext() || router.UNSAFE_invariant(
          !1,
          // TODO: This error is probably because they somehow have 2 versions of the
          // router loaded. We can help them understand how to avoid that.
          "useLocation() may be used only in the context of a <Router> component."
        ), React__namespace.useContext(LocationContext).location;
      }
      function useNavigationType() {
        return React__namespace.useContext(LocationContext).navigationType;
      }
      function useMatch(pattern) {
        useInRouterContext() || router.UNSAFE_invariant(
          !1,
          // TODO: This error is probably because they somehow have 2 versions of the
          // router loaded. We can help them understand how to avoid that.
          "useMatch() may be used only in the context of a <Router> component."
        );
        let {
          pathname
        } = useLocation();
        return React__namespace.useMemo(() => router.matchPath(pattern, pathname), [pathname, pattern]);
      }
      let navigateEffectWarning = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
      function useIsomorphicLayoutEffect(cb) {
        React__namespace.useContext(NavigationContext).static || React__namespace.useLayoutEffect(cb);
      }
      function useNavigate() {
        let {
          isDataRoute
        } = React__namespace.useContext(RouteContext);
        return isDataRoute ? useNavigateStable() : useNavigateUnstable();
      }
      function useNavigateUnstable() {
        useInRouterContext() || router.UNSAFE_invariant(
          !1,
          // TODO: This error is probably because they somehow have 2 versions of the
          // router loaded. We can help them understand how to avoid that.
          "useNavigate() may be used only in the context of a <Router> component."
        );
        let dataRouterContext = React__namespace.useContext(DataRouterContext), {
          basename,
          navigator
        } = React__namespace.useContext(NavigationContext), {
          matches
        } = React__namespace.useContext(RouteContext), {
          pathname: locationPathname
        } = useLocation(), routePathnamesJson = JSON.stringify(router.UNSAFE_getPathContributingMatches(matches).map((match) => match.pathnameBase)), activeRef = React__namespace.useRef(!1);
        return useIsomorphicLayoutEffect(() => {
          activeRef.current = !0;
        }), React__namespace.useCallback(function(to, options) {
          if (options === void 0 && (options = {}), router.UNSAFE_warning(activeRef.current, navigateEffectWarning), !activeRef.current)
            return;
          if (typeof to == "number") {
            navigator.go(to);
            return;
          }
          let path = router.resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
          dataRouterContext == null && basename !== "/" && (path.pathname = path.pathname === "/" ? basename : router.joinPaths([basename, path.pathname])), (options.replace ? navigator.replace : navigator.push)(path, options.state, options);
        }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);
      }
      let OutletContext = /* @__PURE__ */ React__namespace.createContext(null);
      function useOutletContext() {
        return React__namespace.useContext(OutletContext);
      }
      function useOutlet(context) {
        let outlet = React__namespace.useContext(RouteContext).outlet;
        return outlet && /* @__PURE__ */ React__namespace.createElement(OutletContext.Provider, {
          value: context
        }, outlet);
      }
      function useParams() {
        let {
          matches
        } = React__namespace.useContext(RouteContext), routeMatch = matches[matches.length - 1];
        return routeMatch ? routeMatch.params : {};
      }
      function useResolvedPath(to, _temp2) {
        let {
          relative
        } = _temp2 === void 0 ? {} : _temp2, {
          matches
        } = React__namespace.useContext(RouteContext), {
          pathname: locationPathname
        } = useLocation(), routePathnamesJson = JSON.stringify(router.UNSAFE_getPathContributingMatches(matches).map((match) => match.pathnameBase));
        return React__namespace.useMemo(() => router.resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
      }
      function useRoutes(routes2, locationArg) {
        return useRoutesImpl(routes2, locationArg);
      }
      function useRoutesImpl(routes2, locationArg, dataRouterState) {
        useInRouterContext() || router.UNSAFE_invariant(
          !1,
          // TODO: This error is probably because they somehow have 2 versions of the
          // router loaded. We can help them understand how to avoid that.
          "useRoutes() may be used only in the context of a <Router> component."
        );
        let {
          navigator
        } = React__namespace.useContext(NavigationContext), {
          matches: parentMatches
        } = React__namespace.useContext(RouteContext), routeMatch = parentMatches[parentMatches.length - 1], parentParams = routeMatch ? routeMatch.params : {}, parentPathname = routeMatch ? routeMatch.pathname : "/", parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/", parentRoute = routeMatch && routeMatch.route;
        {
          let parentPath = parentRoute && parentRoute.path || "";
          warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + parentPathname + '" (under <Route path="' + parentPath + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + parentPath + '"> to <Route ') + ('path="' + (parentPath === "/" ? "*" : parentPath + "/*") + '">.'));
        }
        let locationFromContext = useLocation(), location;
        if (locationArg) {
          var _parsedLocationArg$pa;
          let parsedLocationArg = typeof locationArg == "string" ? router.parsePath(locationArg) : locationArg;
          parentPathnameBase === "/" || (_parsedLocationArg$pa = parsedLocationArg.pathname) != null && _parsedLocationArg$pa.startsWith(parentPathnameBase) || router.UNSAFE_invariant(!1, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + parentPathnameBase + '" ') + ('but pathname "' + parsedLocationArg.pathname + '" was given in the `location` prop.')), location = parsedLocationArg;
        } else
          location = locationFromContext;
        let pathname = location.pathname || "/", remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/", matches = router.matchRoutes(routes2, {
          pathname: remainingPathname
        });
        router.UNSAFE_warning(parentRoute || matches != null, 'No routes matched location "' + location.pathname + location.search + location.hash + '" '), router.UNSAFE_warning(matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0, 'Matched leaf route at location "' + location.pathname + location.search + location.hash + '" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.');
        let renderedMatches = _renderMatches(matches && matches.map((match) => Object.assign({}, match, {
          params: Object.assign({}, parentParams, match.params),
          pathname: router.joinPaths([
            parentPathnameBase,
            // Re-encode pathnames that were decoded inside matchRoutes
            navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname
          ]),
          pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : router.joinPaths([
            parentPathnameBase,
            // Re-encode pathnames that were decoded inside matchRoutes
            navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase
          ])
        })), parentMatches, dataRouterState);
        return locationArg && renderedMatches ? /* @__PURE__ */ React__namespace.createElement(LocationContext.Provider, {
          value: {
            location: _extends({
              pathname: "/",
              search: "",
              hash: "",
              state: null,
              key: "default"
            }, location),
            navigationType: router.Action.Pop
          }
        }, renderedMatches) : renderedMatches;
      }
      function DefaultErrorComponent() {
        let error = useRouteError2(), message = router.isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error), stack = error instanceof Error ? error.stack : null, lightgrey = "rgba(200,200,200, 0.5)", preStyles = {
          padding: "0.5rem",
          backgroundColor: lightgrey
        }, codeStyles = {
          padding: "2px 4px",
          backgroundColor: lightgrey
        }, devInfo = null;
        return console.error("Error handled by React Router default ErrorBoundary:", error), devInfo = /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement("p", null, "\u{1F4BF} Hey developer \u{1F44B}"), /* @__PURE__ */ React__namespace.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ React__namespace.createElement("code", {
          style: codeStyles
        }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ React__namespace.createElement("code", {
          style: codeStyles
        }, "errorElement"), " prop on your route.")), /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ React__namespace.createElement("h3", {
          style: {
            fontStyle: "italic"
          }
        }, message), stack ? /* @__PURE__ */ React__namespace.createElement("pre", {
          style: preStyles
        }, stack) : null, devInfo);
      }
      let defaultErrorElement = /* @__PURE__ */ React__namespace.createElement(DefaultErrorComponent, null);
      class RenderErrorBoundary extends React__namespace.Component {
        constructor(props) {
          super(props), this.state = {
            location: props.location,
            revalidation: props.revalidation,
            error: props.error
          };
        }
        static getDerivedStateFromError(error) {
          return {
            error
          };
        }
        static getDerivedStateFromProps(props, state) {
          return state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle" ? {
            error: props.error,
            location: props.location,
            revalidation: props.revalidation
          } : {
            error: props.error || state.error,
            location: state.location,
            revalidation: props.revalidation || state.revalidation
          };
        }
        componentDidCatch(error, errorInfo) {
          console.error("React Router caught the following error during render", error, errorInfo);
        }
        render() {
          return this.state.error ? /* @__PURE__ */ React__namespace.createElement(RouteContext.Provider, {
            value: this.props.routeContext
          }, /* @__PURE__ */ React__namespace.createElement(RouteErrorContext.Provider, {
            value: this.state.error,
            children: this.props.component
          })) : this.props.children;
        }
      }
      function RenderedRoute(_ref) {
        let {
          routeContext,
          match,
          children
        } = _ref, dataRouterContext = React__namespace.useContext(DataRouterContext);
        return dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary) && (dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id), /* @__PURE__ */ React__namespace.createElement(RouteContext.Provider, {
          value: routeContext
        }, children);
      }
      function _renderMatches(matches, parentMatches, dataRouterState) {
        var _dataRouterState2;
        if (parentMatches === void 0 && (parentMatches = []), dataRouterState === void 0 && (dataRouterState = null), matches == null) {
          var _dataRouterState;
          if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors)
            matches = dataRouterState.matches;
          else
            return null;
        }
        let renderedMatches = matches, errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;
        if (errors != null) {
          let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]));
          errorIndex >= 0 || router.UNSAFE_invariant(!1, "Could not find a matching route for errors on route IDs: " + Object.keys(errors).join(",")), renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
        }
        return renderedMatches.reduceRight((outlet, match, index) => {
          let error = match.route.id ? errors == null ? void 0 : errors[match.route.id] : null, errorElement = null;
          dataRouterState && (errorElement = match.route.errorElement || defaultErrorElement);
          let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1)), getChildren = () => {
            let children;
            return error ? children = errorElement : match.route.Component ? children = /* @__PURE__ */ React__namespace.createElement(match.route.Component, null) : match.route.element ? children = match.route.element : children = outlet, /* @__PURE__ */ React__namespace.createElement(RenderedRoute, {
              match,
              routeContext: {
                outlet,
                matches: matches2,
                isDataRoute: dataRouterState != null
              },
              children
            });
          };
          return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /* @__PURE__ */ React__namespace.createElement(RenderErrorBoundary, {
            location: dataRouterState.location,
            revalidation: dataRouterState.revalidation,
            component: errorElement,
            error,
            children: getChildren(),
            routeContext: {
              outlet: null,
              matches: matches2,
              isDataRoute: !0
            }
          }) : getChildren();
        }, null);
      }
      var DataRouterHook;
      (function(DataRouterHook2) {
        DataRouterHook2.UseBlocker = "useBlocker", DataRouterHook2.UseRevalidator = "useRevalidator", DataRouterHook2.UseNavigateStable = "useNavigate";
      })(DataRouterHook || (DataRouterHook = {}));
      var DataRouterStateHook;
      (function(DataRouterStateHook2) {
        DataRouterStateHook2.UseBlocker = "useBlocker", DataRouterStateHook2.UseLoaderData = "useLoaderData", DataRouterStateHook2.UseActionData = "useActionData", DataRouterStateHook2.UseRouteError = "useRouteError", DataRouterStateHook2.UseNavigation = "useNavigation", DataRouterStateHook2.UseRouteLoaderData = "useRouteLoaderData", DataRouterStateHook2.UseMatches = "useMatches", DataRouterStateHook2.UseRevalidator = "useRevalidator", DataRouterStateHook2.UseNavigateStable = "useNavigate", DataRouterStateHook2.UseRouteId = "useRouteId";
      })(DataRouterStateHook || (DataRouterStateHook = {}));
      function getDataRouterConsoleError(hookName) {
        return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
      }
      function useDataRouterContext(hookName) {
        let ctx = React__namespace.useContext(DataRouterContext);
        return ctx || router.UNSAFE_invariant(!1, getDataRouterConsoleError(hookName)), ctx;
      }
      function useDataRouterState(hookName) {
        let state = React__namespace.useContext(DataRouterStateContext);
        return state || router.UNSAFE_invariant(!1, getDataRouterConsoleError(hookName)), state;
      }
      function useRouteContext(hookName) {
        let route = React__namespace.useContext(RouteContext);
        return route || router.UNSAFE_invariant(!1, getDataRouterConsoleError(hookName)), route;
      }
      function useCurrentRouteId(hookName) {
        let route = useRouteContext(hookName), thisRoute = route.matches[route.matches.length - 1];
        return thisRoute.route.id || router.UNSAFE_invariant(!1, hookName + ' can only be used on routes that contain a unique "id"'), thisRoute.route.id;
      }
      function useRouteId() {
        return useCurrentRouteId(DataRouterStateHook.UseRouteId);
      }
      function useNavigation() {
        return useDataRouterState(DataRouterStateHook.UseNavigation).navigation;
      }
      function useRevalidator() {
        let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator), state = useDataRouterState(DataRouterStateHook.UseRevalidator);
        return {
          revalidate: dataRouterContext.router.revalidate,
          state: state.revalidation
        };
      }
      function useMatches() {
        let {
          matches,
          loaderData
        } = useDataRouterState(DataRouterStateHook.UseMatches);
        return React__namespace.useMemo(() => matches.map((match) => {
          let {
            pathname,
            params
          } = match;
          return {
            id: match.route.id,
            pathname,
            params,
            data: loaderData[match.route.id],
            handle: match.route.handle
          };
        }), [matches, loaderData]);
      }
      function useLoaderData3() {
        let state = useDataRouterState(DataRouterStateHook.UseLoaderData), routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);
        if (state.errors && state.errors[routeId] != null) {
          console.error("You cannot `useLoaderData` in an errorElement (routeId: " + routeId + ")");
          return;
        }
        return state.loaderData[routeId];
      }
      function useRouteLoaderData(routeId) {
        return useDataRouterState(DataRouterStateHook.UseRouteLoaderData).loaderData[routeId];
      }
      function useActionData3() {
        let state = useDataRouterState(DataRouterStateHook.UseActionData);
        return React__namespace.useContext(RouteContext) || router.UNSAFE_invariant(!1, "useActionData must be used inside a RouteContext"), Object.values((state == null ? void 0 : state.actionData) || {})[0];
      }
      function useRouteError2() {
        var _state$errors;
        let error = React__namespace.useContext(RouteErrorContext), state = useDataRouterState(DataRouterStateHook.UseRouteError), routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);
        return error || ((_state$errors = state.errors) == null ? void 0 : _state$errors[routeId]);
      }
      function useAsyncValue() {
        let value = React__namespace.useContext(AwaitContext);
        return value == null ? void 0 : value._data;
      }
      function useAsyncError() {
        let value = React__namespace.useContext(AwaitContext);
        return value == null ? void 0 : value._error;
      }
      let blockerId = 0;
      function useBlocker(shouldBlock) {
        let {
          router: router2
        } = useDataRouterContext(DataRouterHook.UseBlocker), state = useDataRouterState(DataRouterStateHook.UseBlocker), [blockerKey] = React__namespace.useState(() => String(++blockerId)), blockerFunction = React__namespace.useCallback((args) => typeof shouldBlock == "function" ? !!shouldBlock(args) : !!shouldBlock, [shouldBlock]), blocker = router2.getBlocker(blockerKey, blockerFunction);
        return React__namespace.useEffect(() => () => router2.deleteBlocker(blockerKey), [router2, blockerKey]), state.blockers.get(blockerKey) || blocker;
      }
      function useNavigateStable() {
        let {
          router: router$1
        } = useDataRouterContext(DataRouterHook.UseNavigateStable), id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable), activeRef = React__namespace.useRef(!1);
        return useIsomorphicLayoutEffect(() => {
          activeRef.current = !0;
        }), React__namespace.useCallback(function(to, options) {
          options === void 0 && (options = {}), router.UNSAFE_warning(activeRef.current, navigateEffectWarning), activeRef.current && (typeof to == "number" ? router$1.navigate(to) : router$1.navigate(to, _extends({
            fromRouteId: id
          }, options)));
        }, [router$1, id]);
      }
      let alreadyWarned = {};
      function warningOnce(key, cond, message) {
        !cond && !alreadyWarned[key] && (alreadyWarned[key] = !0, router.UNSAFE_warning(!1, message));
      }
      function RouterProvider(_ref) {
        let {
          fallbackElement,
          router: router2
        } = _ref, [state, setStateImpl] = React__namespace.useState(router2.state), setState = React__namespace.useCallback((newState) => {
          "startTransition" in React__namespace ? React__namespace.startTransition(() => setStateImpl(newState)) : setStateImpl(newState);
        }, [setStateImpl]);
        React__namespace.useLayoutEffect(() => router2.subscribe(setState), [router2, setState]);
        let navigator = React__namespace.useMemo(() => ({
          createHref: router2.createHref,
          encodeLocation: router2.encodeLocation,
          go: (n) => router2.navigate(n),
          push: (to, state2, opts) => router2.navigate(to, {
            state: state2,
            preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
          }),
          replace: (to, state2, opts) => router2.navigate(to, {
            replace: !0,
            state: state2,
            preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
          })
        }), [router2]), basename = router2.basename || "/", dataRouterContext = React__namespace.useMemo(() => ({
          router: router2,
          navigator,
          static: !1,
          basename
        }), [router2, navigator, basename]);
        return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(DataRouterContext.Provider, {
          value: dataRouterContext
        }, /* @__PURE__ */ React__namespace.createElement(DataRouterStateContext.Provider, {
          value: state
        }, /* @__PURE__ */ React__namespace.createElement(Router, {
          basename,
          location: state.location,
          navigationType: state.historyAction,
          navigator
        }, state.initialized ? /* @__PURE__ */ React__namespace.createElement(DataRoutes, {
          routes: router2.routes,
          state
        }) : fallbackElement))), null);
      }
      function DataRoutes(_ref2) {
        let {
          routes: routes2,
          state
        } = _ref2;
        return useRoutesImpl(routes2, void 0, state);
      }
      function MemoryRouter(_ref3) {
        let {
          basename,
          children,
          initialEntries,
          initialIndex
        } = _ref3, historyRef = React__namespace.useRef();
        historyRef.current == null && (historyRef.current = router.createMemoryHistory({
          initialEntries,
          initialIndex,
          v5Compat: !0
        }));
        let history = historyRef.current, [state, setStateImpl] = React__namespace.useState({
          action: history.action,
          location: history.location
        }), setState = React__namespace.useCallback((newState) => {
          "startTransition" in React__namespace ? React__namespace.startTransition(() => setStateImpl(newState)) : setStateImpl(newState);
        }, [setStateImpl]);
        return React__namespace.useLayoutEffect(() => history.listen(setState), [history, setState]), /* @__PURE__ */ React__namespace.createElement(Router, {
          basename,
          children,
          location: state.location,
          navigationType: state.action,
          navigator: history
        });
      }
      function Navigate(_ref4) {
        let {
          to,
          replace,
          state,
          relative
        } = _ref4;
        useInRouterContext() || router.UNSAFE_invariant(
          !1,
          // TODO: This error is probably because they somehow have 2 versions of
          // the router loaded. We can help them understand how to avoid that.
          "<Navigate> may be used only in the context of a <Router> component."
        ), router.UNSAFE_warning(!React__namespace.useContext(NavigationContext).static, "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");
        let {
          matches
        } = React__namespace.useContext(RouteContext), {
          pathname: locationPathname
        } = useLocation(), navigate = useNavigate(), path = router.resolveTo(to, router.UNSAFE_getPathContributingMatches(matches).map((match) => match.pathnameBase), locationPathname, relative === "path"), jsonPath = JSON.stringify(path);
        return React__namespace.useEffect(() => navigate(JSON.parse(jsonPath), {
          replace,
          state,
          relative
        }), [navigate, jsonPath, relative, replace, state]), null;
      }
      function Outlet3(props) {
        return useOutlet(props.context);
      }
      function Route(_props) {
        router.UNSAFE_invariant(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.");
      }
      function Router(_ref5) {
        let {
          basename: basenameProp = "/",
          children = null,
          location: locationProp,
          navigationType = router.Action.Pop,
          navigator,
          static: staticProp = !1
        } = _ref5;
        useInRouterContext() && router.UNSAFE_invariant(!1, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");
        let basename = basenameProp.replace(/^\/*/, "/"), navigationContext = React__namespace.useMemo(() => ({
          basename,
          navigator,
          static: staticProp
        }), [basename, navigator, staticProp]);
        typeof locationProp == "string" && (locationProp = router.parsePath(locationProp));
        let {
          pathname = "/",
          search = "",
          hash = "",
          state = null,
          key = "default"
        } = locationProp, locationContext = React__namespace.useMemo(() => {
          let trailingPathname = router.stripBasename(pathname, basename);
          return trailingPathname == null ? null : {
            location: {
              pathname: trailingPathname,
              search,
              hash,
              state,
              key
            },
            navigationType
          };
        }, [basename, pathname, search, hash, state, key, navigationType]);
        return router.UNSAFE_warning(locationContext != null, '<Router basename="' + basename + '"> is not able to match the URL ' + ('"' + pathname + search + hash + '" because it does not start with the ') + "basename, so the <Router> won't render anything."), locationContext == null ? null : /* @__PURE__ */ React__namespace.createElement(NavigationContext.Provider, {
          value: navigationContext
        }, /* @__PURE__ */ React__namespace.createElement(LocationContext.Provider, {
          children,
          value: locationContext
        }));
      }
      function Routes(_ref6) {
        let {
          children,
          location
        } = _ref6;
        return useRoutes(createRoutesFromChildren(children), location);
      }
      function Await(_ref7) {
        let {
          children,
          errorElement,
          resolve
        } = _ref7;
        return /* @__PURE__ */ React__namespace.createElement(AwaitErrorBoundary, {
          resolve,
          errorElement
        }, /* @__PURE__ */ React__namespace.createElement(ResolveAwait, null, children));
      }
      var AwaitRenderStatus;
      (function(AwaitRenderStatus2) {
        AwaitRenderStatus2[AwaitRenderStatus2.pending = 0] = "pending", AwaitRenderStatus2[AwaitRenderStatus2.success = 1] = "success", AwaitRenderStatus2[AwaitRenderStatus2.error = 2] = "error";
      })(AwaitRenderStatus || (AwaitRenderStatus = {}));
      let neverSettledPromise = new Promise(() => {
      });
      class AwaitErrorBoundary extends React__namespace.Component {
        constructor(props) {
          super(props), this.state = {
            error: null
          };
        }
        static getDerivedStateFromError(error) {
          return {
            error
          };
        }
        componentDidCatch(error, errorInfo) {
          console.error("<Await> caught the following error during render", error, errorInfo);
        }
        render() {
          let {
            children,
            errorElement,
            resolve
          } = this.props, promise = null, status = AwaitRenderStatus.pending;
          if (!(resolve instanceof Promise))
            status = AwaitRenderStatus.success, promise = Promise.resolve(), Object.defineProperty(promise, "_tracked", {
              get: () => !0
            }), Object.defineProperty(promise, "_data", {
              get: () => resolve
            });
          else if (this.state.error) {
            status = AwaitRenderStatus.error;
            let renderError = this.state.error;
            promise = Promise.reject().catch(() => {
            }), Object.defineProperty(promise, "_tracked", {
              get: () => !0
            }), Object.defineProperty(promise, "_error", {
              get: () => renderError
            });
          } else
            resolve._tracked ? (promise = resolve, status = promise._error !== void 0 ? AwaitRenderStatus.error : promise._data !== void 0 ? AwaitRenderStatus.success : AwaitRenderStatus.pending) : (status = AwaitRenderStatus.pending, Object.defineProperty(resolve, "_tracked", {
              get: () => !0
            }), promise = resolve.then((data) => Object.defineProperty(resolve, "_data", {
              get: () => data
            }), (error) => Object.defineProperty(resolve, "_error", {
              get: () => error
            })));
          if (status === AwaitRenderStatus.error && promise._error instanceof router.AbortedDeferredError)
            throw neverSettledPromise;
          if (status === AwaitRenderStatus.error && !errorElement)
            throw promise._error;
          if (status === AwaitRenderStatus.error)
            return /* @__PURE__ */ React__namespace.createElement(AwaitContext.Provider, {
              value: promise,
              children: errorElement
            });
          if (status === AwaitRenderStatus.success)
            return /* @__PURE__ */ React__namespace.createElement(AwaitContext.Provider, {
              value: promise,
              children
            });
          throw promise;
        }
      }
      function ResolveAwait(_ref8) {
        let {
          children
        } = _ref8, data = useAsyncValue(), toRender = typeof children == "function" ? children(data) : children;
        return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, toRender);
      }
      function createRoutesFromChildren(children, parentPath) {
        parentPath === void 0 && (parentPath = []);
        let routes2 = [];
        return React__namespace.Children.forEach(children, (element, index) => {
          if (!/* @__PURE__ */ React__namespace.isValidElement(element))
            return;
          let treePath = [...parentPath, index];
          if (element.type === React__namespace.Fragment) {
            routes2.push.apply(routes2, createRoutesFromChildren(element.props.children, treePath));
            return;
          }
          element.type !== Route && router.UNSAFE_invariant(!1, "[" + (typeof element.type == "string" ? element.type : element.type.name) + "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>"), !element.props.index || !element.props.children || router.UNSAFE_invariant(!1, "An index route cannot have child routes.");
          let route = {
            id: element.props.id || treePath.join("-"),
            caseSensitive: element.props.caseSensitive,
            element: element.props.element,
            Component: element.props.Component,
            index: element.props.index,
            path: element.props.path,
            loader: element.props.loader,
            action: element.props.action,
            errorElement: element.props.errorElement,
            ErrorBoundary: element.props.ErrorBoundary,
            hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
            shouldRevalidate: element.props.shouldRevalidate,
            handle: element.props.handle,
            lazy: element.props.lazy
          };
          element.props.children && (route.children = createRoutesFromChildren(element.props.children, treePath)), routes2.push(route);
        }), routes2;
      }
      function renderMatches(matches) {
        return _renderMatches(matches);
      }
      function mapRouteProperties(route) {
        let updates = {
          // Note: this check also occurs in createRoutesFromChildren so update
          // there if you change this -- please and thank you!
          hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null
        };
        return route.Component && (route.element && router.UNSAFE_warning(!1, "You should not include both `Component` and `element` on your route - `Component` will be used."), Object.assign(updates, {
          element: /* @__PURE__ */ React__namespace.createElement(route.Component),
          Component: void 0
        })), route.ErrorBoundary && (route.errorElement && router.UNSAFE_warning(!1, "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."), Object.assign(updates, {
          errorElement: /* @__PURE__ */ React__namespace.createElement(route.ErrorBoundary),
          ErrorBoundary: void 0
        })), updates;
      }
      function createMemoryRouter(routes2, opts) {
        return router.createRouter({
          basename: opts == null ? void 0 : opts.basename,
          future: _extends({}, opts == null ? void 0 : opts.future, {
            v7_prependBasename: !0
          }),
          history: router.createMemoryHistory({
            initialEntries: opts == null ? void 0 : opts.initialEntries,
            initialIndex: opts == null ? void 0 : opts.initialIndex
          }),
          hydrationData: opts == null ? void 0 : opts.hydrationData,
          routes: routes2,
          mapRouteProperties
        }).initialize();
      }
      Object.defineProperty(exports2, "AbortedDeferredError", {
        enumerable: !0,
        get: function() {
          return router.AbortedDeferredError;
        }
      }), Object.defineProperty(exports2, "NavigationType", {
        enumerable: !0,
        get: function() {
          return router.Action;
        }
      }), Object.defineProperty(exports2, "createPath", {
        enumerable: !0,
        get: function() {
          return router.createPath;
        }
      }), Object.defineProperty(exports2, "defer", {
        enumerable: !0,
        get: function() {
          return router.defer;
        }
      }), Object.defineProperty(exports2, "generatePath", {
        enumerable: !0,
        get: function() {
          return router.generatePath;
        }
      }), Object.defineProperty(exports2, "isRouteErrorResponse", {
        enumerable: !0,
        get: function() {
          return router.isRouteErrorResponse;
        }
      }), Object.defineProperty(exports2, "json", {
        enumerable: !0,
        get: function() {
          return router.json;
        }
      }), Object.defineProperty(exports2, "matchPath", {
        enumerable: !0,
        get: function() {
          return router.matchPath;
        }
      }), Object.defineProperty(exports2, "matchRoutes", {
        enumerable: !0,
        get: function() {
          return router.matchRoutes;
        }
      }), Object.defineProperty(exports2, "parsePath", {
        enumerable: !0,
        get: function() {
          return router.parsePath;
        }
      }), Object.defineProperty(exports2, "redirect", {
        enumerable: !0,
        get: function() {
          return router.redirect;
        }
      }), Object.defineProperty(exports2, "resolvePath", {
        enumerable: !0,
        get: function() {
          return router.resolvePath;
        }
      }), exports2.Await = Await, exports2.MemoryRouter = MemoryRouter, exports2.Navigate = Navigate, exports2.Outlet = Outlet3, exports2.Route = Route, exports2.Router = Router, exports2.RouterProvider = RouterProvider, exports2.Routes = Routes, exports2.UNSAFE_DataRouterContext = DataRouterContext, exports2.UNSAFE_DataRouterStateContext = DataRouterStateContext, exports2.UNSAFE_LocationContext = LocationContext, exports2.UNSAFE_NavigationContext = NavigationContext, exports2.UNSAFE_RouteContext = RouteContext, exports2.UNSAFE_mapRouteProperties = mapRouteProperties, exports2.UNSAFE_useRouteId = useRouteId, exports2.UNSAFE_useRoutesImpl = useRoutesImpl, exports2.createMemoryRouter = createMemoryRouter, exports2.createRoutesFromChildren = createRoutesFromChildren, exports2.createRoutesFromElements = createRoutesFromChildren, exports2.renderMatches = renderMatches, exports2.unstable_useBlocker = useBlocker, exports2.useActionData = useActionData3, exports2.useAsyncError = useAsyncError, exports2.useAsyncValue = useAsyncValue, exports2.useHref = useHref, exports2.useInRouterContext = useInRouterContext, exports2.useLoaderData = useLoaderData3, exports2.useLocation = useLocation, exports2.useMatch = useMatch, exports2.useMatches = useMatches, exports2.useNavigate = useNavigate, exports2.useNavigation = useNavigation, exports2.useNavigationType = useNavigationType, exports2.useOutlet = useOutlet, exports2.useOutletContext = useOutletContext, exports2.useParams = useParams, exports2.useResolvedPath = useResolvedPath, exports2.useRevalidator = useRevalidator, exports2.useRouteError = useRouteError2, exports2.useRouteLoaderData = useRouteLoaderData, exports2.useRoutes = useRoutes, Object.defineProperty(exports2, "__esModule", { value: !0 });
    });
  }
});

// node_modules/react-router/dist/main.js
var require_main = __commonJS({
  "node_modules/react-router/dist/main.js"(exports, module2) {
    "use strict";
    module2.exports = require_react_router_development();
  }
});

// node_modules/react-router-dom/dist/umd/react-router-dom.development.js
var require_react_router_dom_development = __commonJS({
  "node_modules/react-router-dom/dist/umd/react-router-dom.development.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports == "object" && typeof module2 < "u" ? factory(exports, require_react(), require_main(), require_router_cjs()) : typeof define == "function" && define.amd ? define(["exports", "react", "react-router", "@remix-run/router"], factory) : (global2 = typeof globalThis < "u" ? globalThis : global2 || self, factory(global2.ReactRouterDOM = {}, global2.React, global2.ReactRouter, global2.RemixRouter));
    })(exports, function(exports2, React5, reactRouter, router) {
      "use strict";
      function _interopNamespace(e2) {
        if (e2 && e2.__esModule)
          return e2;
        var n = /* @__PURE__ */ Object.create(null);
        return e2 && Object.keys(e2).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e2, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: !0,
              get: function() {
                return e2[k];
              }
            });
          }
        }), n.default = e2, Object.freeze(n);
      }
      var React__namespace = /* @__PURE__ */ _interopNamespace(React5);
      function _extends() {
        return _extends = Object.assign ? Object.assign.bind() : function(target) {
          for (var i2 = 1; i2 < arguments.length; i2++) {
            var source = arguments[i2];
            for (var key in source)
              Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
          }
          return target;
        }, _extends.apply(this, arguments);
      }
      function _objectWithoutPropertiesLoose(source, excluded) {
        if (source == null)
          return {};
        var target = {}, sourceKeys = Object.keys(source), key, i2;
        for (i2 = 0; i2 < sourceKeys.length; i2++)
          key = sourceKeys[i2], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
        return target;
      }
      let defaultMethod = "get", defaultEncType = "application/x-www-form-urlencoded";
      function isHtmlElement(object) {
        return object != null && typeof object.tagName == "string";
      }
      function isButtonElement(object) {
        return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
      }
      function isFormElement(object) {
        return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
      }
      function isInputElement(object) {
        return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
      }
      function isModifiedEvent(event) {
        return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
      }
      function shouldProcessLinkClick(event, target) {
        return event.button === 0 && // Ignore everything but left clicks
        (!target || target === "_self") && // Let browser handle "target=_blank" etc.
        !isModifiedEvent(event);
      }
      function createSearchParams(init) {
        return init === void 0 && (init = ""), new URLSearchParams(typeof init == "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo2, key) => {
          let value = init[key];
          return memo2.concat(Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]]);
        }, []));
      }
      function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
        let searchParams = createSearchParams(locationSearch);
        if (defaultSearchParams)
          for (let key of defaultSearchParams.keys())
            searchParams.has(key) || defaultSearchParams.getAll(key).forEach((value) => {
              searchParams.append(key, value);
            });
        return searchParams;
      }
      function getFormSubmissionInfo(target, options, basename) {
        let method, action3 = null, encType, formData;
        if (isFormElement(target)) {
          let submissionTrigger = options.submissionTrigger;
          if (options.action)
            action3 = options.action;
          else {
            let attr = target.getAttribute("action");
            action3 = attr ? router.stripBasename(attr, basename) : null;
          }
          method = options.method || target.getAttribute("method") || defaultMethod, encType = options.encType || target.getAttribute("enctype") || defaultEncType, formData = new FormData(target), submissionTrigger && submissionTrigger.name && formData.append(submissionTrigger.name, submissionTrigger.value);
        } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
          let form = target.form;
          if (form == null)
            throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
          if (options.action)
            action3 = options.action;
          else {
            let attr = target.getAttribute("formaction") || form.getAttribute("action");
            action3 = attr ? router.stripBasename(attr, basename) : null;
          }
          method = options.method || target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod, encType = options.encType || target.getAttribute("formenctype") || form.getAttribute("enctype") || defaultEncType, formData = new FormData(form), target.name && formData.append(target.name, target.value);
        } else {
          if (isHtmlElement(target))
            throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
          if (method = options.method || defaultMethod, action3 = options.action || null, encType = options.encType || defaultEncType, target instanceof FormData)
            formData = target;
          else if (formData = new FormData(), target instanceof URLSearchParams)
            for (let [name, value] of target)
              formData.append(name, value);
          else if (target != null)
            for (let name of Object.keys(target))
              formData.append(name, target[name]);
        }
        return {
          action: action3,
          method: method.toLowerCase(),
          encType,
          formData
        };
      }
      let _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"], _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"], _excluded3 = ["reloadDocument", "replace", "method", "action", "onSubmit", "fetcherKey", "routeId", "relative", "preventScrollReset"];
      function createBrowserRouter(routes2, opts) {
        return router.createRouter({
          basename: opts == null ? void 0 : opts.basename,
          future: _extends({}, opts == null ? void 0 : opts.future, {
            v7_prependBasename: !0
          }),
          history: router.createBrowserHistory({
            window: opts == null ? void 0 : opts.window
          }),
          hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
          routes: routes2,
          mapRouteProperties: reactRouter.UNSAFE_mapRouteProperties
        }).initialize();
      }
      function createHashRouter(routes2, opts) {
        return router.createRouter({
          basename: opts == null ? void 0 : opts.basename,
          future: _extends({}, opts == null ? void 0 : opts.future, {
            v7_prependBasename: !0
          }),
          history: router.createHashHistory({
            window: opts == null ? void 0 : opts.window
          }),
          hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
          routes: routes2,
          mapRouteProperties: reactRouter.UNSAFE_mapRouteProperties
        }).initialize();
      }
      function parseHydrationData() {
        var _window;
        let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;
        return state && state.errors && (state = _extends({}, state, {
          errors: deserializeErrors(state.errors)
        })), state;
      }
      function deserializeErrors(errors) {
        if (!errors)
          return null;
        let entries = Object.entries(errors), serialized = {};
        for (let [key, val] of entries)
          if (val && val.__type === "RouteErrorResponse")
            serialized[key] = new router.ErrorResponse(val.status, val.statusText, val.data, val.internal === !0);
          else if (val && val.__type === "Error") {
            let error = new Error(val.message);
            error.stack = "", serialized[key] = error;
          } else
            serialized[key] = val;
        return serialized;
      }
      function BrowserRouter(_ref) {
        let {
          basename,
          children,
          window: window2
        } = _ref, historyRef = React__namespace.useRef();
        historyRef.current == null && (historyRef.current = router.createBrowserHistory({
          window: window2,
          v5Compat: !0
        }));
        let history = historyRef.current, [state, setStateImpl] = React__namespace.useState({
          action: history.action,
          location: history.location
        }), setState = React__namespace.useCallback((newState) => {
          "startTransition" in React__namespace ? React__namespace.startTransition(() => setStateImpl(newState)) : setStateImpl(newState);
        }, [setStateImpl]);
        return React__namespace.useLayoutEffect(() => history.listen(setState), [history, setState]), /* @__PURE__ */ React__namespace.createElement(reactRouter.Router, {
          basename,
          children,
          location: state.location,
          navigationType: state.action,
          navigator: history
        });
      }
      function HashRouter(_ref2) {
        let {
          basename,
          children,
          window: window2
        } = _ref2, historyRef = React__namespace.useRef();
        historyRef.current == null && (historyRef.current = router.createHashHistory({
          window: window2,
          v5Compat: !0
        }));
        let history = historyRef.current, [state, setStateImpl] = React__namespace.useState({
          action: history.action,
          location: history.location
        }), setState = React__namespace.useCallback((newState) => {
          "startTransition" in React__namespace ? React__namespace.startTransition(() => setStateImpl(newState)) : setStateImpl(newState);
        }, [setStateImpl]);
        return React__namespace.useLayoutEffect(() => history.listen(setState), [history, setState]), /* @__PURE__ */ React__namespace.createElement(reactRouter.Router, {
          basename,
          children,
          location: state.location,
          navigationType: state.action,
          navigator: history
        });
      }
      function HistoryRouter(_ref3) {
        let {
          basename,
          children,
          history
        } = _ref3, [state, setStateImpl] = React__namespace.useState({
          action: history.action,
          location: history.location
        }), setState = React__namespace.useCallback((newState) => {
          "startTransition" in React__namespace ? React__namespace.startTransition(() => setStateImpl(newState)) : setStateImpl(newState);
        }, [setStateImpl]);
        return React__namespace.useLayoutEffect(() => history.listen(setState), [history, setState]), /* @__PURE__ */ React__namespace.createElement(reactRouter.Router, {
          basename,
          children,
          location: state.location,
          navigationType: state.action,
          navigator: history
        });
      }
      HistoryRouter.displayName = "unstable_HistoryRouter";
      let isBrowser = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Link2 = /* @__PURE__ */ React__namespace.forwardRef(function(_ref4, ref) {
        let {
          onClick,
          relative,
          reloadDocument,
          replace,
          state,
          target,
          to,
          preventScrollReset
        } = _ref4, rest = _objectWithoutPropertiesLoose(_ref4, _excluded), {
          basename
        } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext), absoluteHref, isExternal = !1;
        if (typeof to == "string" && ABSOLUTE_URL_REGEX.test(to) && (absoluteHref = to, isBrowser))
          try {
            let currentUrl = new URL(window.location.href), targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to), path = router.stripBasename(targetUrl.pathname, basename);
            targetUrl.origin === currentUrl.origin && path != null ? to = path + targetUrl.search + targetUrl.hash : isExternal = !0;
          } catch {
            router.UNSAFE_warning(!1, '<Link to="' + to + '"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.');
          }
        let href = reactRouter.useHref(to, {
          relative
        }), internalOnClick = useLinkClickHandler(to, {
          replace,
          state,
          target,
          preventScrollReset,
          relative
        });
        function handleClick(event) {
          onClick && onClick(event), event.defaultPrevented || internalOnClick(event);
        }
        return (
          // eslint-disable-next-line jsx-a11y/anchor-has-content
          /* @__PURE__ */ React__namespace.createElement("a", _extends({}, rest, {
            href: absoluteHref || href,
            onClick: isExternal || reloadDocument ? onClick : handleClick,
            ref,
            target
          }))
        );
      });
      Link2.displayName = "Link";
      let NavLink = /* @__PURE__ */ React__namespace.forwardRef(function(_ref5, ref) {
        let {
          "aria-current": ariaCurrentProp = "page",
          caseSensitive = !1,
          className: classNameProp = "",
          end = !1,
          style: styleProp,
          to,
          children
        } = _ref5, rest = _objectWithoutPropertiesLoose(_ref5, _excluded2), path = reactRouter.useResolvedPath(to, {
          relative: rest.relative
        }), location = reactRouter.useLocation(), routerState = React__namespace.useContext(reactRouter.UNSAFE_DataRouterStateContext), {
          navigator
        } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext), toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname, locationPathname = location.pathname, nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
        caseSensitive || (locationPathname = locationPathname.toLowerCase(), nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null, toPathname = toPathname.toLowerCase());
        let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/", isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/"), ariaCurrent = isActive ? ariaCurrentProp : void 0, className;
        typeof classNameProp == "function" ? className = classNameProp({
          isActive,
          isPending
        }) : className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null].filter(Boolean).join(" ");
        let style = typeof styleProp == "function" ? styleProp({
          isActive,
          isPending
        }) : styleProp;
        return /* @__PURE__ */ React__namespace.createElement(Link2, _extends({}, rest, {
          "aria-current": ariaCurrent,
          className,
          ref,
          style,
          to
        }), typeof children == "function" ? children({
          isActive,
          isPending
        }) : children);
      });
      NavLink.displayName = "NavLink";
      let Form3 = /* @__PURE__ */ React__namespace.forwardRef((props, ref) => /* @__PURE__ */ React__namespace.createElement(FormImpl, _extends({}, props, {
        ref
      })));
      Form3.displayName = "Form";
      let FormImpl = /* @__PURE__ */ React__namespace.forwardRef((_ref6, forwardedRef) => {
        let {
          reloadDocument,
          replace,
          method = defaultMethod,
          action: action3,
          onSubmit,
          fetcherKey,
          routeId,
          relative,
          preventScrollReset
        } = _ref6, props = _objectWithoutPropertiesLoose(_ref6, _excluded3), submit = useSubmitImpl(fetcherKey, routeId), formMethod = method.toLowerCase() === "get" ? "get" : "post", formAction = useFormAction(action3, {
          relative
        }), submitHandler = (event) => {
          if (onSubmit && onSubmit(event), event.defaultPrevented)
            return;
          event.preventDefault();
          let submitter = event.nativeEvent.submitter, submitMethod = (submitter == null ? void 0 : submitter.getAttribute("formmethod")) || method;
          submit(submitter || event.currentTarget, {
            method: submitMethod,
            replace,
            relative,
            preventScrollReset
          });
        };
        return /* @__PURE__ */ React__namespace.createElement("form", _extends({
          ref: forwardedRef,
          method: formMethod,
          action: formAction,
          onSubmit: reloadDocument ? onSubmit : submitHandler
        }, props));
      });
      FormImpl.displayName = "FormImpl";
      function ScrollRestoration(_ref7) {
        let {
          getKey,
          storageKey
        } = _ref7;
        return useScrollRestoration({
          getKey,
          storageKey
        }), null;
      }
      ScrollRestoration.displayName = "ScrollRestoration";
      var DataRouterHook;
      (function(DataRouterHook2) {
        DataRouterHook2.UseScrollRestoration = "useScrollRestoration", DataRouterHook2.UseSubmitImpl = "useSubmitImpl", DataRouterHook2.UseFetcher = "useFetcher";
      })(DataRouterHook || (DataRouterHook = {}));
      var DataRouterStateHook;
      (function(DataRouterStateHook2) {
        DataRouterStateHook2.UseFetchers = "useFetchers", DataRouterStateHook2.UseScrollRestoration = "useScrollRestoration";
      })(DataRouterStateHook || (DataRouterStateHook = {}));
      function getDataRouterConsoleError(hookName) {
        return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
      }
      function useDataRouterContext(hookName) {
        let ctx = React__namespace.useContext(reactRouter.UNSAFE_DataRouterContext);
        return ctx || router.UNSAFE_invariant(!1, getDataRouterConsoleError(hookName)), ctx;
      }
      function useDataRouterState(hookName) {
        let state = React__namespace.useContext(reactRouter.UNSAFE_DataRouterStateContext);
        return state || router.UNSAFE_invariant(!1, getDataRouterConsoleError(hookName)), state;
      }
      function useLinkClickHandler(to, _temp) {
        let {
          target,
          replace: replaceProp,
          state,
          preventScrollReset,
          relative
        } = _temp === void 0 ? {} : _temp, navigate = reactRouter.useNavigate(), location = reactRouter.useLocation(), path = reactRouter.useResolvedPath(to, {
          relative
        });
        return React__namespace.useCallback((event) => {
          if (shouldProcessLinkClick(event, target)) {
            event.preventDefault();
            let replace = replaceProp !== void 0 ? replaceProp : reactRouter.createPath(location) === reactRouter.createPath(path);
            navigate(to, {
              replace,
              state,
              preventScrollReset,
              relative
            });
          }
        }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative]);
      }
      function useSearchParams(defaultInit) {
        router.UNSAFE_warning(typeof URLSearchParams < "u", "You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params\n\nIf you're unsure how to load polyfills, we recommend you check out https://polyfill.io/v3/ which provides some recommendations about how to load polyfills only for users that need them, instead of for every user.");
        let defaultSearchParamsRef = React__namespace.useRef(createSearchParams(defaultInit)), hasSetSearchParamsRef = React__namespace.useRef(!1), location = reactRouter.useLocation(), searchParams = React__namespace.useMemo(() => (
          // Only merge in the defaults if we haven't yet called setSearchParams.
          // Once we call that we want those to take precedence, otherwise you can't
          // remove a param with setSearchParams({}) if it has an initial value
          getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current)
        ), [location.search]), navigate = reactRouter.useNavigate(), setSearchParams = React__namespace.useCallback((nextInit, navigateOptions) => {
          let newSearchParams = createSearchParams(typeof nextInit == "function" ? nextInit(searchParams) : nextInit);
          hasSetSearchParamsRef.current = !0, navigate("?" + newSearchParams, navigateOptions);
        }, [navigate, searchParams]);
        return [searchParams, setSearchParams];
      }
      function useSubmit2() {
        return useSubmitImpl();
      }
      function useSubmitImpl(fetcherKey, fetcherRouteId) {
        let {
          router: router$1
        } = useDataRouterContext(DataRouterHook.UseSubmitImpl), {
          basename
        } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext), currentRouteId = reactRouter.UNSAFE_useRouteId();
        return React__namespace.useCallback(function(target, options) {
          if (options === void 0 && (options = {}), typeof document > "u")
            throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
          let {
            action: action3,
            method,
            encType,
            formData
          } = getFormSubmissionInfo(target, options, basename), opts = {
            preventScrollReset: options.preventScrollReset,
            formData,
            formMethod: method,
            formEncType: encType
          };
          fetcherKey ? (fetcherRouteId == null && router.UNSAFE_invariant(!1, "No routeId available for useFetcher()"), router$1.fetch(fetcherKey, fetcherRouteId, action3, opts)) : router$1.navigate(action3, _extends({}, opts, {
            replace: options.replace,
            fromRouteId: currentRouteId
          }));
        }, [router$1, basename, fetcherKey, fetcherRouteId, currentRouteId]);
      }
      function useFormAction(action3, _temp2) {
        let {
          relative
        } = _temp2 === void 0 ? {} : _temp2, {
          basename
        } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext), routeContext = React__namespace.useContext(reactRouter.UNSAFE_RouteContext);
        routeContext || router.UNSAFE_invariant(!1, "useFormAction must be used inside a RouteContext");
        let [match] = routeContext.matches.slice(-1), path = _extends({}, reactRouter.useResolvedPath(action3 || ".", {
          relative
        })), location = reactRouter.useLocation();
        if (action3 == null && (path.search = location.search, path.hash = location.hash, match.route.index)) {
          let params = new URLSearchParams(path.search);
          params.delete("index"), path.search = params.toString() ? "?" + params.toString() : "";
        }
        return (!action3 || action3 === ".") && match.route.index && (path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index"), basename !== "/" && (path.pathname = path.pathname === "/" ? basename : router.joinPaths([basename, path.pathname])), reactRouter.createPath(path);
      }
      function createFetcherForm(fetcherKey, routeId) {
        let FetcherForm = /* @__PURE__ */ React__namespace.forwardRef((props, ref) => /* @__PURE__ */ React__namespace.createElement(FormImpl, _extends({}, props, {
          ref,
          fetcherKey,
          routeId
        })));
        return FetcherForm.displayName = "fetcher.Form", FetcherForm;
      }
      let fetcherId = 0;
      function useFetcher2() {
        var _route$matches;
        let {
          router: router$1
        } = useDataRouterContext(DataRouterHook.UseFetcher), route = React__namespace.useContext(reactRouter.UNSAFE_RouteContext);
        route || router.UNSAFE_invariant(!1, "useFetcher must be used inside a RouteContext");
        let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;
        routeId == null && router.UNSAFE_invariant(!1, 'useFetcher can only be used on routes that contain a unique "id"');
        let [fetcherKey] = React__namespace.useState(() => String(++fetcherId)), [Form4] = React__namespace.useState(() => (routeId || router.UNSAFE_invariant(!1, "No routeId available for fetcher.Form()"), createFetcherForm(fetcherKey, routeId))), [load] = React__namespace.useState(() => (href) => {
          router$1 || router.UNSAFE_invariant(!1, "No router available for fetcher.load()"), routeId || router.UNSAFE_invariant(!1, "No routeId available for fetcher.load()"), router$1.fetch(fetcherKey, routeId, href);
        }), submit = useSubmitImpl(fetcherKey, routeId), fetcher2 = router$1.getFetcher(fetcherKey), fetcherWithComponents = React__namespace.useMemo(() => _extends({
          Form: Form4,
          submit,
          load
        }, fetcher2), [fetcher2, Form4, submit, load]);
        return React__namespace.useEffect(() => () => {
          if (!router$1) {
            console.warn("No router available to clean up from useFetcher()");
            return;
          }
          router$1.deleteFetcher(fetcherKey);
        }, [router$1, fetcherKey]), fetcherWithComponents;
      }
      function useFetchers() {
        return [...useDataRouterState(DataRouterStateHook.UseFetchers).fetchers.values()];
      }
      let SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions", savedScrollPositions = {};
      function useScrollRestoration(_temp3) {
        let {
          getKey,
          storageKey
        } = _temp3 === void 0 ? {} : _temp3, {
          router: router2
        } = useDataRouterContext(DataRouterHook.UseScrollRestoration), {
          restoreScrollPosition,
          preventScrollReset
        } = useDataRouterState(DataRouterStateHook.UseScrollRestoration), location = reactRouter.useLocation(), matches = reactRouter.useMatches(), navigation = reactRouter.useNavigation();
        React__namespace.useEffect(() => (window.history.scrollRestoration = "manual", () => {
          window.history.scrollRestoration = "auto";
        }), []), usePageHide(React__namespace.useCallback(() => {
          if (navigation.state === "idle") {
            let key = (getKey ? getKey(location, matches) : null) || location.key;
            savedScrollPositions[key] = window.scrollY;
          }
          sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions)), window.history.scrollRestoration = "auto";
        }, [storageKey, getKey, navigation.state, location, matches])), typeof document < "u" && (React__namespace.useLayoutEffect(() => {
          try {
            let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);
            sessionPositions && (savedScrollPositions = JSON.parse(sessionPositions));
          } catch {
          }
        }, [storageKey]), React__namespace.useLayoutEffect(() => {
          let disableScrollRestoration = router2 == null ? void 0 : router2.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKey);
          return () => disableScrollRestoration && disableScrollRestoration();
        }, [router2, getKey]), React__namespace.useLayoutEffect(() => {
          if (restoreScrollPosition !== !1) {
            if (typeof restoreScrollPosition == "number") {
              window.scrollTo(0, restoreScrollPosition);
              return;
            }
            if (location.hash) {
              let el = document.getElementById(location.hash.slice(1));
              if (el) {
                el.scrollIntoView();
                return;
              }
            }
            preventScrollReset !== !0 && window.scrollTo(0, 0);
          }
        }, [location, restoreScrollPosition, preventScrollReset]));
      }
      function useBeforeUnload(callback, options) {
        let {
          capture
        } = options || {};
        React__namespace.useEffect(() => {
          let opts = capture != null ? {
            capture
          } : void 0;
          return window.addEventListener("beforeunload", callback, opts), () => {
            window.removeEventListener("beforeunload", callback, opts);
          };
        }, [callback, capture]);
      }
      function usePageHide(callback, options) {
        let {
          capture
        } = options || {};
        React__namespace.useEffect(() => {
          let opts = capture != null ? {
            capture
          } : void 0;
          return window.addEventListener("pagehide", callback, opts), () => {
            window.removeEventListener("pagehide", callback, opts);
          };
        }, [callback, capture]);
      }
      function usePrompt(_ref8) {
        let {
          when,
          message
        } = _ref8, blocker = reactRouter.unstable_useBlocker(when);
        React__namespace.useEffect(() => {
          blocker.state === "blocked" && !when && blocker.reset();
        }, [blocker, when]), React__namespace.useEffect(() => {
          blocker.state === "blocked" && (window.confirm(message) ? setTimeout(blocker.proceed, 0) : blocker.reset());
        }, [blocker, message]);
      }
      Object.defineProperty(exports2, "AbortedDeferredError", {
        enumerable: !0,
        get: function() {
          return reactRouter.AbortedDeferredError;
        }
      }), Object.defineProperty(exports2, "Await", {
        enumerable: !0,
        get: function() {
          return reactRouter.Await;
        }
      }), Object.defineProperty(exports2, "MemoryRouter", {
        enumerable: !0,
        get: function() {
          return reactRouter.MemoryRouter;
        }
      }), Object.defineProperty(exports2, "Navigate", {
        enumerable: !0,
        get: function() {
          return reactRouter.Navigate;
        }
      }), Object.defineProperty(exports2, "NavigationType", {
        enumerable: !0,
        get: function() {
          return reactRouter.NavigationType;
        }
      }), Object.defineProperty(exports2, "Outlet", {
        enumerable: !0,
        get: function() {
          return reactRouter.Outlet;
        }
      }), Object.defineProperty(exports2, "Route", {
        enumerable: !0,
        get: function() {
          return reactRouter.Route;
        }
      }), Object.defineProperty(exports2, "Router", {
        enumerable: !0,
        get: function() {
          return reactRouter.Router;
        }
      }), Object.defineProperty(exports2, "RouterProvider", {
        enumerable: !0,
        get: function() {
          return reactRouter.RouterProvider;
        }
      }), Object.defineProperty(exports2, "Routes", {
        enumerable: !0,
        get: function() {
          return reactRouter.Routes;
        }
      }), Object.defineProperty(exports2, "UNSAFE_DataRouterContext", {
        enumerable: !0,
        get: function() {
          return reactRouter.UNSAFE_DataRouterContext;
        }
      }), Object.defineProperty(exports2, "UNSAFE_DataRouterStateContext", {
        enumerable: !0,
        get: function() {
          return reactRouter.UNSAFE_DataRouterStateContext;
        }
      }), Object.defineProperty(exports2, "UNSAFE_LocationContext", {
        enumerable: !0,
        get: function() {
          return reactRouter.UNSAFE_LocationContext;
        }
      }), Object.defineProperty(exports2, "UNSAFE_NavigationContext", {
        enumerable: !0,
        get: function() {
          return reactRouter.UNSAFE_NavigationContext;
        }
      }), Object.defineProperty(exports2, "UNSAFE_RouteContext", {
        enumerable: !0,
        get: function() {
          return reactRouter.UNSAFE_RouteContext;
        }
      }), Object.defineProperty(exports2, "UNSAFE_useRouteId", {
        enumerable: !0,
        get: function() {
          return reactRouter.UNSAFE_useRouteId;
        }
      }), Object.defineProperty(exports2, "createMemoryRouter", {
        enumerable: !0,
        get: function() {
          return reactRouter.createMemoryRouter;
        }
      }), Object.defineProperty(exports2, "createPath", {
        enumerable: !0,
        get: function() {
          return reactRouter.createPath;
        }
      }), Object.defineProperty(exports2, "createRoutesFromChildren", {
        enumerable: !0,
        get: function() {
          return reactRouter.createRoutesFromChildren;
        }
      }), Object.defineProperty(exports2, "createRoutesFromElements", {
        enumerable: !0,
        get: function() {
          return reactRouter.createRoutesFromElements;
        }
      }), Object.defineProperty(exports2, "defer", {
        enumerable: !0,
        get: function() {
          return reactRouter.defer;
        }
      }), Object.defineProperty(exports2, "generatePath", {
        enumerable: !0,
        get: function() {
          return reactRouter.generatePath;
        }
      }), Object.defineProperty(exports2, "isRouteErrorResponse", {
        enumerable: !0,
        get: function() {
          return reactRouter.isRouteErrorResponse;
        }
      }), Object.defineProperty(exports2, "json", {
        enumerable: !0,
        get: function() {
          return reactRouter.json;
        }
      }), Object.defineProperty(exports2, "matchPath", {
        enumerable: !0,
        get: function() {
          return reactRouter.matchPath;
        }
      }), Object.defineProperty(exports2, "matchRoutes", {
        enumerable: !0,
        get: function() {
          return reactRouter.matchRoutes;
        }
      }), Object.defineProperty(exports2, "parsePath", {
        enumerable: !0,
        get: function() {
          return reactRouter.parsePath;
        }
      }), Object.defineProperty(exports2, "redirect", {
        enumerable: !0,
        get: function() {
          return reactRouter.redirect;
        }
      }), Object.defineProperty(exports2, "renderMatches", {
        enumerable: !0,
        get: function() {
          return reactRouter.renderMatches;
        }
      }), Object.defineProperty(exports2, "resolvePath", {
        enumerable: !0,
        get: function() {
          return reactRouter.resolvePath;
        }
      }), Object.defineProperty(exports2, "unstable_useBlocker", {
        enumerable: !0,
        get: function() {
          return reactRouter.unstable_useBlocker;
        }
      }), Object.defineProperty(exports2, "useActionData", {
        enumerable: !0,
        get: function() {
          return reactRouter.useActionData;
        }
      }), Object.defineProperty(exports2, "useAsyncError", {
        enumerable: !0,
        get: function() {
          return reactRouter.useAsyncError;
        }
      }), Object.defineProperty(exports2, "useAsyncValue", {
        enumerable: !0,
        get: function() {
          return reactRouter.useAsyncValue;
        }
      }), Object.defineProperty(exports2, "useHref", {
        enumerable: !0,
        get: function() {
          return reactRouter.useHref;
        }
      }), Object.defineProperty(exports2, "useInRouterContext", {
        enumerable: !0,
        get: function() {
          return reactRouter.useInRouterContext;
        }
      }), Object.defineProperty(exports2, "useLoaderData", {
        enumerable: !0,
        get: function() {
          return reactRouter.useLoaderData;
        }
      }), Object.defineProperty(exports2, "useLocation", {
        enumerable: !0,
        get: function() {
          return reactRouter.useLocation;
        }
      }), Object.defineProperty(exports2, "useMatch", {
        enumerable: !0,
        get: function() {
          return reactRouter.useMatch;
        }
      }), Object.defineProperty(exports2, "useMatches", {
        enumerable: !0,
        get: function() {
          return reactRouter.useMatches;
        }
      }), Object.defineProperty(exports2, "useNavigate", {
        enumerable: !0,
        get: function() {
          return reactRouter.useNavigate;
        }
      }), Object.defineProperty(exports2, "useNavigation", {
        enumerable: !0,
        get: function() {
          return reactRouter.useNavigation;
        }
      }), Object.defineProperty(exports2, "useNavigationType", {
        enumerable: !0,
        get: function() {
          return reactRouter.useNavigationType;
        }
      }), Object.defineProperty(exports2, "useOutlet", {
        enumerable: !0,
        get: function() {
          return reactRouter.useOutlet;
        }
      }), Object.defineProperty(exports2, "useOutletContext", {
        enumerable: !0,
        get: function() {
          return reactRouter.useOutletContext;
        }
      }), Object.defineProperty(exports2, "useParams", {
        enumerable: !0,
        get: function() {
          return reactRouter.useParams;
        }
      }), Object.defineProperty(exports2, "useResolvedPath", {
        enumerable: !0,
        get: function() {
          return reactRouter.useResolvedPath;
        }
      }), Object.defineProperty(exports2, "useRevalidator", {
        enumerable: !0,
        get: function() {
          return reactRouter.useRevalidator;
        }
      }), Object.defineProperty(exports2, "useRouteError", {
        enumerable: !0,
        get: function() {
          return reactRouter.useRouteError;
        }
      }), Object.defineProperty(exports2, "useRouteLoaderData", {
        enumerable: !0,
        get: function() {
          return reactRouter.useRouteLoaderData;
        }
      }), Object.defineProperty(exports2, "useRoutes", {
        enumerable: !0,
        get: function() {
          return reactRouter.useRoutes;
        }
      }), exports2.BrowserRouter = BrowserRouter, exports2.Form = Form3, exports2.HashRouter = HashRouter, exports2.Link = Link2, exports2.NavLink = NavLink, exports2.ScrollRestoration = ScrollRestoration, exports2.UNSAFE_useScrollRestoration = useScrollRestoration, exports2.createBrowserRouter = createBrowserRouter, exports2.createHashRouter = createHashRouter, exports2.createSearchParams = createSearchParams, exports2.unstable_HistoryRouter = HistoryRouter, exports2.unstable_usePrompt = usePrompt, exports2.useBeforeUnload = useBeforeUnload, exports2.useFetcher = useFetcher2, exports2.useFetchers = useFetchers, exports2.useFormAction = useFormAction, exports2.useLinkClickHandler = useLinkClickHandler, exports2.useSearchParams = useSearchParams, exports2.useSubmit = useSubmit2, Object.defineProperty(exports2, "__esModule", { value: !0 });
    });
  }
});

// node_modules/react-router-dom/dist/main.js
var require_main2 = __commonJS({
  "node_modules/react-router-dom/dist/main.js"(exports, module2) {
    "use strict";
    module2.exports = require_react_router_dom_development();
  }
});

// node_modules/@remix-run/react/dist/_virtual/_rollupPluginBabelHelpers.js
var require_rollupPluginBabelHelpers = __commonJS({
  "node_modules/@remix-run/react/dist/_virtual/_rollupPluginBabelHelpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function _extends() {
      return _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    exports.extends = _extends;
  }
});

// node_modules/@remix-run/react/dist/errorBoundaries.js
var require_errorBoundaries = __commonJS({
  "node_modules/@remix-run/react/dist/errorBoundaries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var React5 = require_react(), reactRouterDom = require_main2();
    function _interopDefaultLegacy(e2) {
      return e2 && typeof e2 == "object" && "default" in e2 ? e2 : { default: e2 };
    }
    var React__default = /* @__PURE__ */ _interopDefaultLegacy(React5), RemixErrorBoundary = class extends React__default.default.Component {
      constructor(props) {
        super(props), this.state = {
          error: props.error || null,
          location: props.location
        };
      }
      static getDerivedStateFromError(error) {
        return {
          error
        };
      }
      static getDerivedStateFromProps(props, state) {
        return state.location !== props.location ? {
          error: props.error || null,
          location: props.location
        } : {
          error: props.error || state.error,
          location: state.location
        };
      }
      render() {
        return this.state.error ? /* @__PURE__ */ React__default.default.createElement(this.props.component, {
          error: this.state.error
        }) : this.props.children;
      }
    };
    function RemixRootDefaultErrorBoundary({
      error
    }) {
      return React__default.default.useEffect(() => {
        console.error(error);
      }, [error]), /* @__PURE__ */ React__default.default.createElement("html", {
        lang: "en"
      }, /* @__PURE__ */ React__default.default.createElement("head", null, /* @__PURE__ */ React__default.default.createElement("meta", {
        charSet: "utf-8"
      }), /* @__PURE__ */ React__default.default.createElement("meta", {
        name: "viewport",
        content: "width=device-width, initial-scale=1, viewport-fit=cover"
      }), /* @__PURE__ */ React__default.default.createElement("title", null, "Application Error!")), /* @__PURE__ */ React__default.default.createElement("body", null, /* @__PURE__ */ React__default.default.createElement("main", {
        style: {
          fontFamily: "system-ui, sans-serif",
          padding: "2rem"
        }
      }, /* @__PURE__ */ React__default.default.createElement("h1", {
        style: {
          fontSize: "24px"
        }
      }, "Application Error"), error.stack ? /* @__PURE__ */ React__default.default.createElement("pre", {
        style: {
          padding: "2rem",
          background: "hsla(10, 50%, 50%, 0.1)",
          color: "red",
          overflow: "auto"
        }
      }, error.stack) : null), /* @__PURE__ */ React__default.default.createElement("script", {
        dangerouslySetInnerHTML: {
          __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://remix.run/guides/errors for more information."
              );
            `
        }
      })));
    }
    function V2_RemixRootDefaultErrorBoundary() {
      let error = reactRouterDom.useRouteError();
      if (reactRouterDom.isRouteErrorResponse(error))
        return /* @__PURE__ */ React__default.default.createElement(RemixRootDefaultCatchBoundaryImpl, {
          caught: error
        });
      if (error instanceof Error)
        return /* @__PURE__ */ React__default.default.createElement(RemixRootDefaultErrorBoundary, {
          error
        });
      {
        let errorString = error == null ? "Unknown Error" : typeof error == "object" && "toString" in error ? error.toString() : JSON.stringify(error);
        return /* @__PURE__ */ React__default.default.createElement(RemixRootDefaultErrorBoundary, {
          error: new Error(errorString)
        });
      }
    }
    var RemixCatchContext = /* @__PURE__ */ React__default.default.createContext(void 0);
    function useCatch() {
      return React5.useContext(RemixCatchContext);
    }
    function RemixCatchBoundary({
      catch: catchVal,
      component: Component,
      children
    }) {
      return catchVal ? /* @__PURE__ */ React__default.default.createElement(RemixCatchContext.Provider, {
        value: catchVal
      }, /* @__PURE__ */ React__default.default.createElement(Component, null)) : /* @__PURE__ */ React__default.default.createElement(React__default.default.Fragment, null, children);
    }
    function RemixRootDefaultCatchBoundary() {
      let caught = useCatch();
      return /* @__PURE__ */ React__default.default.createElement(RemixRootDefaultCatchBoundaryImpl, {
        caught
      });
    }
    function RemixRootDefaultCatchBoundaryImpl({
      caught
    }) {
      return /* @__PURE__ */ React__default.default.createElement("html", {
        lang: "en"
      }, /* @__PURE__ */ React__default.default.createElement("head", null, /* @__PURE__ */ React__default.default.createElement("meta", {
        charSet: "utf-8"
      }), /* @__PURE__ */ React__default.default.createElement("meta", {
        name: "viewport",
        content: "width=device-width, initial-scale=1, viewport-fit=cover"
      }), /* @__PURE__ */ React__default.default.createElement("title", null, "Unhandled Thrown Response!")), /* @__PURE__ */ React__default.default.createElement("body", null, /* @__PURE__ */ React__default.default.createElement("h1", {
        style: {
          fontFamily: "system-ui, sans-serif",
          padding: "2rem"
        }
      }, caught.status, " ", caught.statusText), /* @__PURE__ */ React__default.default.createElement("script", {
        dangerouslySetInnerHTML: {
          __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX than this when your app throws 404s (and other responses). Check out https://remix.run/guides/not-found for more information."
              );
            `
        }
      })));
    }
    exports.RemixCatchBoundary = RemixCatchBoundary;
    exports.RemixErrorBoundary = RemixErrorBoundary;
    exports.RemixRootDefaultCatchBoundary = RemixRootDefaultCatchBoundary;
    exports.RemixRootDefaultErrorBoundary = RemixRootDefaultErrorBoundary;
    exports.V2_RemixRootDefaultErrorBoundary = V2_RemixRootDefaultErrorBoundary;
    exports.useCatch = useCatch;
  }
});

// node_modules/@remix-run/react/dist/invariant.js
var require_invariant2 = __commonJS({
  "node_modules/@remix-run/react/dist/invariant.js"(exports, module2) {
    "use strict";
    function invariant(value, message) {
      if (value === !1 || value === null || typeof value > "u")
        throw new Error(message);
    }
    module2.exports = invariant;
  }
});

// node_modules/@remix-run/react/dist/routeModules.js
var require_routeModules = __commonJS({
  "node_modules/@remix-run/react/dist/routeModules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function _interopNamespace(e2) {
      if (e2 && e2.__esModule)
        return e2;
      var n = /* @__PURE__ */ Object.create(null);
      return e2 && Object.keys(e2).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e2, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e2[k];
            }
          });
        }
      }), n.default = e2, Object.freeze(n);
    }
    async function loadRouteModule(route, routeModulesCache) {
      if (route.id in routeModulesCache)
        return routeModulesCache[route.id];
      try {
        let routeModule = await function(t2) {
          return Promise.resolve().then(function() {
            return /* @__PURE__ */ _interopNamespace(require(t2));
          });
        }(
          /* webpackIgnore: true */
          route.module
        );
        return routeModulesCache[route.id] = routeModule, routeModule;
      } catch {
        return window.location.reload(), new Promise(() => {
        });
      }
    }
    exports.loadRouteModule = loadRouteModule;
  }
});

// node_modules/@remix-run/react/dist/links.js
var require_links = __commonJS({
  "node_modules/@remix-run/react/dist/links.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var reactRouterDom = require_main2(), routeModules = require_routeModules();
    function getLinksForMatches(matches, routeModules2, manifest) {
      let descriptors = matches.map((match) => {
        var _module$links;
        let module3 = routeModules2[match.route.id];
        return ((_module$links = module3.links) === null || _module$links === void 0 ? void 0 : _module$links.call(module3)) || [];
      }).flat(1), preloads = getCurrentPageModulePreloadHrefs(matches, manifest);
      return dedupe(descriptors, preloads);
    }
    async function prefetchStyleLinks(routeModule) {
      if (!routeModule.links)
        return;
      let descriptors = routeModule.links();
      if (!descriptors)
        return;
      let styleLinks = [];
      for (let descriptor of descriptors)
        !isPageLinkDescriptor(descriptor) && descriptor.rel === "stylesheet" && styleLinks.push({
          ...descriptor,
          rel: "preload",
          as: "style"
        });
      let matchingLinks = styleLinks.filter((link) => !link.media || window.matchMedia(link.media).matches);
      await Promise.all(matchingLinks.map(prefetchStyleLink));
    }
    async function prefetchStyleLink(descriptor) {
      return new Promise((resolve) => {
        let link = document.createElement("link");
        Object.assign(link, descriptor);
        function removeLink() {
          document.head.contains(link) && document.head.removeChild(link);
        }
        link.onload = () => {
          removeLink(), resolve();
        }, link.onerror = () => {
          removeLink(), resolve();
        }, document.head.appendChild(link);
      });
    }
    function isPageLinkDescriptor(object) {
      return object != null && typeof object.page == "string";
    }
    function isHtmlLinkDescriptor(object) {
      return object == null ? !1 : object.href == null ? object.rel === "preload" && (typeof object.imageSrcSet == "string" || typeof object.imagesrcset == "string") && (typeof object.imageSizes == "string" || typeof object.imagesizes == "string") : typeof object.rel == "string" && typeof object.href == "string";
    }
    async function getStylesheetPrefetchLinks(matches, manifest, routeModules$1) {
      return (await Promise.all(matches.map(async (match) => {
        let mod = await routeModules.loadRouteModule(manifest.routes[match.route.id], routeModules$1);
        return mod.links ? mod.links() : [];
      }))).flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map((link) => link.rel === "preload" ? {
        ...link,
        rel: "prefetch"
      } : {
        ...link,
        rel: "prefetch",
        as: "style"
      });
    }
    function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {
      let path = parsePathPatch(page), isNew = (match, index) => currentMatches[index] ? match.route.id !== currentMatches[index].route.id : !0, matchPathChanged = (match, index) => {
        var _currentMatches$index;
        return (
          // param change, /users/123 -> /users/456
          currentMatches[index].pathname !== match.pathname || // splat param changed, which is not present in match.path
          // e.g. /files/images/avatar.jpg -> files/finances.xls
          ((_currentMatches$index = currentMatches[index].route.path) === null || _currentMatches$index === void 0 ? void 0 : _currentMatches$index.endsWith("*")) && currentMatches[index].params["*"] !== match.params["*"]
        );
      };
      return mode === "data" && location.search !== path.search ? (
        // this is really similar to stuff in transition.ts, maybe somebody smarter
        // than me (or in less of a hurry) can share some of it. You're the best.
        nextMatches.filter((match, index) => {
          if (!manifest.routes[match.route.id].hasLoader)
            return !1;
          if (isNew(match, index) || matchPathChanged(match, index))
            return !0;
          if (match.route.shouldRevalidate) {
            var _currentMatches$;
            let routeChoice = match.route.shouldRevalidate({
              currentUrl: new URL(location.pathname + location.search + location.hash, window.origin),
              currentParams: ((_currentMatches$ = currentMatches[0]) === null || _currentMatches$ === void 0 ? void 0 : _currentMatches$.params) || {},
              nextUrl: new URL(page, window.origin),
              nextParams: match.params,
              defaultShouldRevalidate: !0
            });
            if (typeof routeChoice == "boolean")
              return routeChoice;
          }
          return !0;
        })
      ) : nextMatches.filter((match, index) => {
        let manifestRoute = manifest.routes[match.route.id];
        return (mode === "assets" || manifestRoute.hasLoader) && (isNew(match, index) || matchPathChanged(match, index));
      });
    }
    function getDataLinkHrefs(page, matches, manifest) {
      let path = parsePathPatch(page);
      return dedupeHrefs(matches.filter((match) => manifest.routes[match.route.id].hasLoader).map((match) => {
        let {
          pathname,
          search
        } = path, searchParams = new URLSearchParams(search);
        return searchParams.set("_data", match.route.id), `${pathname}?${searchParams}`;
      }));
    }
    function getModuleLinkHrefs(matches, manifestPatch) {
      return dedupeHrefs(matches.map((match) => {
        let route = manifestPatch.routes[match.route.id], hrefs = [route.module];
        return route.imports && (hrefs = hrefs.concat(route.imports)), hrefs;
      }).flat(1));
    }
    function getCurrentPageModulePreloadHrefs(matches, manifest) {
      return dedupeHrefs(matches.map((match) => {
        let route = manifest.routes[match.route.id], hrefs = [route.module];
        return route.imports && (hrefs = hrefs.concat(route.imports)), hrefs;
      }).flat(1));
    }
    function dedupeHrefs(hrefs) {
      return [...new Set(hrefs)];
    }
    function dedupe(descriptors, preloads) {
      let set = /* @__PURE__ */ new Set(), preloadsSet = new Set(preloads);
      return descriptors.reduce((deduped, descriptor) => {
        if (!isPageLinkDescriptor(descriptor) && descriptor.as === "script" && descriptor.href && preloadsSet.has(descriptor.href))
          return deduped;
        let str = JSON.stringify(descriptor);
        return set.has(str) || (set.add(str), deduped.push(descriptor)), deduped;
      }, []);
    }
    function parsePathPatch(href) {
      let path = reactRouterDom.parsePath(href);
      return path.search === void 0 && (path.search = ""), path;
    }
    exports.dedupe = dedupe;
    exports.getDataLinkHrefs = getDataLinkHrefs;
    exports.getLinksForMatches = getLinksForMatches;
    exports.getModuleLinkHrefs = getModuleLinkHrefs;
    exports.getNewMatchesForLinks = getNewMatchesForLinks;
    exports.getStylesheetPrefetchLinks = getStylesheetPrefetchLinks;
    exports.isHtmlLinkDescriptor = isHtmlLinkDescriptor;
    exports.isPageLinkDescriptor = isPageLinkDescriptor;
    exports.prefetchStyleLinks = prefetchStyleLinks;
  }
});

// node_modules/@remix-run/react/dist/markup.js
var require_markup2 = __commonJS({
  "node_modules/@remix-run/react/dist/markup.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var ESCAPE_LOOKUP = {
      "&": "\\u0026",
      ">": "\\u003e",
      "<": "\\u003c",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    }, ESCAPE_REGEX = /[&><\u2028\u2029]/g;
    function escapeHtml(html) {
      return html.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
    }
    function createHtml(html) {
      return {
        __html: html
      };
    }
    exports.createHtml = createHtml;
    exports.escapeHtml = escapeHtml;
  }
});

// node_modules/@remix-run/react/dist/transition.js
var require_transition = __commonJS({
  "node_modules/@remix-run/react/dist/transition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var IDLE_TRANSITION = {
      state: "idle",
      submission: void 0,
      location: void 0,
      type: "idle"
    }, IDLE_FETCHER = {
      state: "idle",
      type: "init",
      data: void 0,
      formMethod: void 0,
      formAction: void 0,
      formData: void 0,
      formEncType: void 0,
      submission: void 0
    };
    exports.IDLE_FETCHER = IDLE_FETCHER;
    exports.IDLE_TRANSITION = IDLE_TRANSITION;
  }
});

// node_modules/@remix-run/react/dist/warnings.js
var require_warnings2 = __commonJS({
  "node_modules/@remix-run/react/dist/warnings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var alreadyWarned = {};
    function logDeprecationOnce(message, key = message) {
      alreadyWarned[key] || (alreadyWarned[key] = !0, console.warn(message));
    }
    exports.logDeprecationOnce = logDeprecationOnce;
  }
});

// node_modules/@remix-run/react/dist/components.js
var require_components = __commonJS({
  "node_modules/@remix-run/react/dist/components.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var _rollupPluginBabelHelpers = require_rollupPluginBabelHelpers(), React5 = require_react(), reactRouterDom = require_main2(), errorBoundaries = require_errorBoundaries(), invariant = require_invariant2(), links2 = require_links(), markup = require_markup2(), transition = require_transition(), warnings = require_warnings2();
    function _interopNamespace(e2) {
      if (e2 && e2.__esModule)
        return e2;
      var n = /* @__PURE__ */ Object.create(null);
      return e2 && Object.keys(e2).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e2, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e2[k];
            }
          });
        }
      }), n.default = e2, Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React5);
    function useDataRouterContext() {
      let context = React__namespace.useContext(reactRouterDom.UNSAFE_DataRouterContext);
      return invariant(context, "You must render this element inside a <DataRouterContext.Provider> element"), context;
    }
    function useDataRouterStateContext() {
      let context = React__namespace.useContext(reactRouterDom.UNSAFE_DataRouterStateContext);
      return invariant(context, "You must render this element inside a <DataRouterStateContext.Provider> element"), context;
    }
    var RemixContext = /* @__PURE__ */ React__namespace.createContext(void 0);
    RemixContext.displayName = "Remix";
    function useRemixContext() {
      let context = React__namespace.useContext(RemixContext);
      return invariant(context, "You must render this element inside a <Remix> element"), context;
    }
    function RemixRoute({
      id
    }) {
      let {
        routeModules,
        future: future2
      } = useRemixContext();
      invariant(routeModules, `Cannot initialize 'routeModules'. This normally occurs when you have server code in your client modules.
Check this link for more details:
https://remix.run/pages/gotchas#server-code-in-client-bundles`);
      let {
        default: Component,
        ErrorBoundary: ErrorBoundary2,
        CatchBoundary
      } = routeModules[id];
      return !Component && (ErrorBoundary2 || !future2.v2_errorBoundary && CatchBoundary) && (Component = reactRouterDom.Outlet), invariant(Component, `Route "${id}" has no component! Please go add a \`default\` export in the route module file.
If you were trying to navigate or submit to a resource route, use \`<a>\` instead of \`<Link>\` or \`<Form reloadDocument>\`.`), /* @__PURE__ */ React__namespace.createElement(Component, null);
    }
    function RemixRouteError({
      id
    }) {
      let {
        future: future2,
        routeModules
      } = useRemixContext();
      invariant(routeModules, `Cannot initialize 'routeModules'. This normally occurs when you have server code in your client modules.
Check this link for more details:
https://remix.run/pages/gotchas#server-code-in-client-bundles`);
      let error = reactRouterDom.useRouteError(), {
        CatchBoundary,
        ErrorBoundary: ErrorBoundary2
      } = routeModules[id];
      if (future2.v2_errorBoundary) {
        if (id === "root" && (ErrorBoundary2 || (ErrorBoundary2 = errorBoundaries.V2_RemixRootDefaultErrorBoundary)), ErrorBoundary2)
          return /* @__PURE__ */ React__namespace.createElement(ErrorBoundary2, null);
        throw error;
      }
      if (id === "root" && (CatchBoundary || (CatchBoundary = errorBoundaries.RemixRootDefaultCatchBoundary), ErrorBoundary2 || (ErrorBoundary2 = errorBoundaries.RemixRootDefaultErrorBoundary)), reactRouterDom.isRouteErrorResponse(error)) {
        let tError = error;
        if (tError != null && tError.error && tError.status !== 404 && ErrorBoundary2)
          return /* @__PURE__ */ React__namespace.createElement(ErrorBoundary2, {
            error: tError.error
          });
        if (CatchBoundary)
          return /* @__PURE__ */ React__namespace.createElement(errorBoundaries.RemixCatchBoundary, {
            catch: error,
            component: CatchBoundary
          });
      }
      if (error instanceof Error && ErrorBoundary2)
        return /* @__PURE__ */ React__namespace.createElement(ErrorBoundary2, {
          error
        });
      throw error;
    }
    function usePrefetchBehavior(prefetch, theirElementProps) {
      let [maybePrefetch, setMaybePrefetch] = React__namespace.useState(!1), [shouldPrefetch, setShouldPrefetch] = React__namespace.useState(!1), {
        onFocus,
        onBlur,
        onMouseEnter,
        onMouseLeave,
        onTouchStart
      } = theirElementProps;
      React__namespace.useEffect(() => {
        prefetch === "render" && setShouldPrefetch(!0);
      }, [prefetch]);
      let setIntent = () => {
        prefetch === "intent" && setMaybePrefetch(!0);
      }, cancelIntent = () => {
        prefetch === "intent" && (setMaybePrefetch(!1), setShouldPrefetch(!1));
      };
      return React__namespace.useEffect(() => {
        if (maybePrefetch) {
          let id = setTimeout(() => {
            setShouldPrefetch(!0);
          }, 100);
          return () => {
            clearTimeout(id);
          };
        }
      }, [maybePrefetch]), [shouldPrefetch, {
        onFocus: composeEventHandlers(onFocus, setIntent),
        onBlur: composeEventHandlers(onBlur, cancelIntent),
        onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
        onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
        onTouchStart: composeEventHandlers(onTouchStart, setIntent)
      }];
    }
    var ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, NavLink = /* @__PURE__ */ React__namespace.forwardRef(({
      to,
      prefetch = "none",
      ...props
    }, forwardedRef) => {
      let isAbsolute = typeof to == "string" && ABSOLUTE_URL_REGEX.test(to), href = reactRouterDom.useHref(to), [shouldPrefetch, prefetchHandlers] = usePrefetchBehavior(prefetch, props);
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.NavLink, _rollupPluginBabelHelpers.extends({
        ref: forwardedRef,
        to
      }, props, prefetchHandlers)), shouldPrefetch && !isAbsolute ? /* @__PURE__ */ React__namespace.createElement(PrefetchPageLinks, {
        page: href
      }) : null);
    });
    NavLink.displayName = "NavLink";
    var Link2 = /* @__PURE__ */ React__namespace.forwardRef(({
      to,
      prefetch = "none",
      ...props
    }, forwardedRef) => {
      let isAbsolute = typeof to == "string" && ABSOLUTE_URL_REGEX.test(to), href = reactRouterDom.useHref(to), [shouldPrefetch, prefetchHandlers] = usePrefetchBehavior(prefetch, props);
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.Link, _rollupPluginBabelHelpers.extends({
        ref: forwardedRef,
        to
      }, props, prefetchHandlers)), shouldPrefetch && !isAbsolute ? /* @__PURE__ */ React__namespace.createElement(PrefetchPageLinks, {
        page: href
      }) : null);
    });
    Link2.displayName = "Link";
    function composeEventHandlers(theirHandler, ourHandler) {
      return (event) => {
        theirHandler && theirHandler(event), event.defaultPrevented || ourHandler(event);
      };
    }
    var linksWarning = "\u26A0\uFE0F REMIX FUTURE CHANGE: The behavior of links `imagesizes` and `imagesrcset` will be changing in v2. Only the React camel case versions will be valid. Please change to `imageSizes` and `imageSrcSet`. For instructions on making this change see https://remix.run/docs/en/v1.15.0/pages/v2#links-imagesizes-and-imagesrcset", useTransitionWarning = "\u26A0\uFE0F REMIX FUTURE CHANGE: `useTransition` will be removed in v2 in favor of `useNavigation`. You can prepare for this change at your convenience by updating to `useNavigation`. For instructions on making this change see https://remix.run/docs/en/v1.15.0/pages/v2#usetransition", fetcherTypeWarning = "\u26A0\uFE0F REMIX FUTURE CHANGE: `fetcher.type` will be removed in v2. Please use `fetcher.state`, `fetcher.formData`, and `fetcher.data` to achieve the same UX. For instructions on making this change see https://remix.run/docs/en/v1.15.0/pages/v2#usefetcher", fetcherSubmissionWarning = "\u26A0\uFE0F REMIX FUTURE CHANGE : `fetcher.submission` will be removed in v2. The submission fields are now part of the fetcher object itself (`fetcher.formData`). For instructions on making this change see https://remix.run/docs/en/v1.15.0/pages/v2#usefetcher";
    function Links2() {
      let {
        manifest,
        routeModules
      } = useRemixContext(), {
        errors,
        matches: routerMatches
      } = useDataRouterStateContext(), matches = errors ? routerMatches.slice(0, routerMatches.findIndex((m2) => errors[m2.route.id]) + 1) : routerMatches, links$1 = React__namespace.useMemo(() => links2.getLinksForMatches(matches, routeModules, manifest), [matches, routeModules, manifest]);
      return React__namespace.useEffect(() => {
        links$1.some((link) => "imagesizes" in link || "imagesrcset" in link) && warnings.logDeprecationOnce(linksWarning);
      }, [links$1]), /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, links$1.map((link) => {
        if (links2.isPageLinkDescriptor(link))
          return /* @__PURE__ */ React__namespace.createElement(PrefetchPageLinks, _rollupPluginBabelHelpers.extends({
            key: link.page
          }, link));
        let imageSrcSet = null;
        return "useId" in React__namespace ? (link.imagesrcset && (link.imageSrcSet = imageSrcSet = link.imagesrcset, delete link.imagesrcset), link.imagesizes && (link.imageSizes = link.imagesizes, delete link.imagesizes)) : (link.imageSrcSet && (link.imagesrcset = imageSrcSet = link.imageSrcSet, delete link.imageSrcSet), link.imageSizes && (link.imagesizes = link.imageSizes, delete link.imageSizes)), /* @__PURE__ */ React__namespace.createElement("link", _rollupPluginBabelHelpers.extends({
          key: link.rel + (link.href || "") + (imageSrcSet || "")
        }, link));
      }));
    }
    function PrefetchPageLinks({
      page,
      ...dataLinkProps
    }) {
      let {
        router
      } = useDataRouterContext(), matches = React__namespace.useMemo(() => reactRouterDom.matchRoutes(router.routes, page), [router.routes, page]);
      return matches ? /* @__PURE__ */ React__namespace.createElement(PrefetchPageLinksImpl, _rollupPluginBabelHelpers.extends({
        page,
        matches
      }, dataLinkProps)) : (console.warn(`Tried to prefetch ${page} but no routes matched.`), null);
    }
    function usePrefetchedStylesheets(matches) {
      let {
        manifest,
        routeModules
      } = useRemixContext(), [styleLinks, setStyleLinks] = React__namespace.useState([]);
      return React__namespace.useEffect(() => {
        let interrupted = !1;
        return links2.getStylesheetPrefetchLinks(matches, manifest, routeModules).then((links3) => {
          interrupted || setStyleLinks(links3);
        }), () => {
          interrupted = !0;
        };
      }, [matches, manifest, routeModules]), styleLinks;
    }
    function PrefetchPageLinksImpl({
      page,
      matches: nextMatches,
      ...linkProps
    }) {
      let location = reactRouterDom.useLocation(), {
        manifest
      } = useRemixContext(), {
        matches
      } = useDataRouterStateContext(), newMatchesForData = React__namespace.useMemo(() => links2.getNewMatchesForLinks(page, nextMatches, matches, manifest, location, "data"), [page, nextMatches, matches, manifest, location]), newMatchesForAssets = React__namespace.useMemo(() => links2.getNewMatchesForLinks(page, nextMatches, matches, manifest, location, "assets"), [page, nextMatches, matches, manifest, location]), dataHrefs = React__namespace.useMemo(() => links2.getDataLinkHrefs(page, newMatchesForData, manifest), [newMatchesForData, page, manifest]), moduleHrefs = React__namespace.useMemo(() => links2.getModuleLinkHrefs(newMatchesForAssets, manifest), [newMatchesForAssets, manifest]), styleLinks = usePrefetchedStylesheets(newMatchesForAssets);
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ React__namespace.createElement("link", _rollupPluginBabelHelpers.extends({
        key: href,
        rel: "prefetch",
        as: "fetch",
        href
      }, linkProps))), moduleHrefs.map((href) => /* @__PURE__ */ React__namespace.createElement("link", _rollupPluginBabelHelpers.extends({
        key: href,
        rel: "modulepreload",
        href
      }, linkProps))), styleLinks.map((link) => (
        // these don't spread `linkProps` because they are full link descriptors
        // already with their own props
        /* @__PURE__ */ React__namespace.createElement("link", _rollupPluginBabelHelpers.extends({
          key: link.href
        }, link))
      )));
    }
    function V1Meta() {
      let {
        routeModules
      } = useRemixContext(), {
        errors,
        matches: routerMatches,
        loaderData
      } = useDataRouterStateContext(), location = reactRouterDom.useLocation(), matches = errors ? routerMatches.slice(0, routerMatches.findIndex((m2) => errors[m2.route.id]) + 1) : routerMatches, meta = {}, parentsData = {};
      for (let match of matches) {
        let routeId = match.route.id, data = loaderData[routeId], params = match.params, routeModule = routeModules[routeId];
        if (routeModule.meta) {
          let routeMeta = typeof routeModule.meta == "function" ? routeModule.meta({
            data,
            parentsData,
            params,
            location
          }) : routeModule.meta;
          if (routeMeta && Array.isArray(routeMeta))
            throw new Error(
              "The route at " + match.route.path + " returns an array. This is only supported with the `v2_meta` future flag in the Remix config. Either set the flag to `true` or update the route's meta function to return an object.\n\nTo reference the v1 meta function API, see https://remix.run/route/meta"
              // TODO: Add link to the docs once they are written
              // + "\n\nTo reference future flags and the v2 meta API, see https://remix.run/file-conventions/remix-config#future-v2-meta."
            );
          Object.assign(meta, routeMeta);
        }
        parentsData[routeId] = data;
      }
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, Object.entries(meta).map(([name, value]) => {
        if (!value)
          return null;
        if (["charset", "charSet"].includes(name))
          return /* @__PURE__ */ React__namespace.createElement("meta", {
            key: "charSet",
            charSet: value
          });
        if (name === "title")
          return /* @__PURE__ */ React__namespace.createElement("title", {
            key: "title"
          }, String(value));
        let isOpenGraphTag = /^(og|music|video|article|book|profile|fb):.+$/.test(name);
        return [value].flat().map((content) => isOpenGraphTag ? /* @__PURE__ */ React__namespace.createElement("meta", {
          property: name,
          content,
          key: name + content
        }) : typeof content == "string" ? /* @__PURE__ */ React__namespace.createElement("meta", {
          name,
          content,
          key: name + content
        }) : /* @__PURE__ */ React__namespace.createElement("meta", _rollupPluginBabelHelpers.extends({
          key: name + JSON.stringify(content)
        }, content)));
      }));
    }
    function V2Meta() {
      let {
        routeModules
      } = useRemixContext(), {
        errors,
        matches: routerMatches,
        loaderData
      } = useDataRouterStateContext(), location = reactRouterDom.useLocation(), _matches = errors ? routerMatches.slice(0, routerMatches.findIndex((m2) => errors[m2.route.id]) + 1) : routerMatches, meta = [], leafMeta = null, matches = [];
      for (let i2 = 0; i2 < _matches.length; i2++) {
        let _match = _matches[i2], routeId = _match.route.id, data = loaderData[routeId], params = _match.params, routeModule = routeModules[routeId], routeMeta = [], match = {
          id: routeId,
          data,
          meta: [],
          params: _match.params,
          pathname: _match.pathname,
          handle: _match.route.handle,
          // TODO: Remove in v2. Only leaving it for now because we used it in
          // examples and there's no reason to crash someone's build for one line.
          // They'll get a TS error from the type updates anyway.
          // @ts-expect-error
          get route() {
            return console.warn("The meta function in " + _match.route.path + " accesses the `route` property on `matches`. This is deprecated and will be removed in Remix version 2. See"), _match.route;
          }
        };
        if (matches[i2] = match, routeModule != null && routeModule.meta ? routeMeta = typeof routeModule.meta == "function" ? routeModule.meta({
          data,
          params,
          location,
          matches
        }) : Array.isArray(routeModule.meta) ? [...routeModule.meta] : routeModule.meta : leafMeta && (routeMeta = [...leafMeta]), routeMeta = routeMeta || [], !Array.isArray(routeMeta))
          throw new Error("The `v2_meta` API is enabled in the Remix config, but the route at " + _match.route.path + ` returns an invalid value. In v2, all route meta functions must return an array of meta objects.

To reference the v1 meta function API, see https://remix.run/route/meta`);
        match.meta = routeMeta, matches[i2] = match, meta = [...routeMeta], leafMeta = meta;
      }
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, meta.flat().map((metaProps) => {
        if (!metaProps)
          return null;
        if ("tagName" in metaProps) {
          let tagName = metaProps.tagName;
          if (delete metaProps.tagName, !isValidMetaTag(tagName))
            return console.warn(`A meta object uses an invalid tagName: ${tagName}. Expected either 'link' or 'meta'`), null;
          let Comp = tagName;
          return /* @__PURE__ */ React__namespace.createElement(Comp, _rollupPluginBabelHelpers.extends({
            key: JSON.stringify(metaProps)
          }, metaProps));
        }
        if ("title" in metaProps)
          return /* @__PURE__ */ React__namespace.createElement("title", {
            key: "title"
          }, String(metaProps.title));
        if ("charset" in metaProps && (metaProps.charSet ?? (metaProps.charSet = metaProps.charset), delete metaProps.charset), "charSet" in metaProps && metaProps.charSet != null)
          return typeof metaProps.charSet == "string" ? /* @__PURE__ */ React__namespace.createElement("meta", {
            key: "charSet",
            charSet: metaProps.charSet
          }) : null;
        if ("script:ld+json" in metaProps) {
          let json2 = null;
          try {
            json2 = JSON.stringify(metaProps["script:ld+json"]);
          } catch {
          }
          return json2 != null && /* @__PURE__ */ React__namespace.createElement("script", {
            key: "script:ld+json",
            type: "application/ld+json",
            dangerouslySetInnerHTML: {
              __html: JSON.stringify(metaProps["script:ld+json"])
            }
          });
        }
        return /* @__PURE__ */ React__namespace.createElement("meta", _rollupPluginBabelHelpers.extends({
          key: JSON.stringify(metaProps)
        }, metaProps));
      }));
    }
    function isValidMetaTag(tagName) {
      return typeof tagName == "string" && /^(meta|link)$/.test(tagName);
    }
    function Meta() {
      let {
        future: future2
      } = useRemixContext();
      return future2 != null && future2.v2_meta ? /* @__PURE__ */ React__namespace.createElement(V2Meta, null) : /* @__PURE__ */ React__namespace.createElement(V1Meta, null);
    }
    function Await(props) {
      return /* @__PURE__ */ React__namespace.createElement(reactRouterDom.Await, props);
    }
    var isHydrated = !1;
    function Scripts2(props) {
      let {
        manifest,
        serverHandoffString,
        abortDelay
      } = useRemixContext(), {
        router,
        static: isStatic,
        staticContext
      } = useDataRouterContext(), {
        matches
      } = useDataRouterStateContext(), navigation = reactRouterDom.useNavigation();
      React__namespace.useEffect(() => {
        isHydrated = !0;
      }, []);
      let deferredScripts = [], initialScripts = React__namespace.useMemo(() => {
        var _manifest$hmr;
        let contextScript = staticContext ? `window.__remixContext = ${serverHandoffString};` : " ", activeDeferreds = staticContext == null ? void 0 : staticContext.activeDeferreds;
        contextScript += activeDeferreds ? ["__remixContext.p = function(v,e,p,x) {", "  if (typeof e !== 'undefined') {", `    x=new Error(e.message);
    x.stack=e.stack;`, "    p=Promise.reject(x);", "  } else {", "    p=Promise.resolve(v);", "  }", "  return p;", "};", "__remixContext.n = function(i,k) {", "  __remixContext.t = __remixContext.t || {};", "  __remixContext.t[i] = __remixContext.t[i] || {};", "  let p = new Promise((r, e) => {__remixContext.t[i][k] = {r:(v)=>{r(v);},e:(v)=>{e(v);}};});", typeof abortDelay == "number" ? `setTimeout(() => {if(typeof p._error !== "undefined" || typeof p._data !== "undefined"){return;} __remixContext.t[i][k].e(new Error("Server timeout."))}, ${abortDelay});` : "", "  return p;", "};", "__remixContext.r = function(i,k,v,e,p,x) {", "  p = __remixContext.t[i][k];", "  if (typeof e !== 'undefined') {", `    x=new Error(e.message);
    x.stack=e.stack;`, "    p.e(x);", "  } else {", "    p.r(v);", "  }", "};"].join(`
`) + Object.entries(activeDeferreds).map(([routeId, deferredData]) => {
          let pendingKeys = new Set(deferredData.pendingKeys), promiseKeyValues = deferredData.deferredKeys.map((key) => {
            if (pendingKeys.has(key))
              return deferredScripts.push(/* @__PURE__ */ React__namespace.createElement(DeferredHydrationScript, {
                key: `${routeId} | ${key}`,
                deferredData,
                routeId,
                dataKey: key
              })), `${JSON.stringify(key)}:__remixContext.n(${JSON.stringify(routeId)}, ${JSON.stringify(key)})`;
            {
              let trackedPromise = deferredData.data[key];
              if (typeof trackedPromise._error < "u") {
                let toSerialize = {
                  message: trackedPromise._error.message,
                  stack: trackedPromise._error.stack
                };
                return `${JSON.stringify(key)}:__remixContext.p(!1, ${markup.escapeHtml(JSON.stringify(toSerialize))})`;
              } else {
                if (typeof trackedPromise._data > "u")
                  throw new Error(`The deferred data for ${key} was not resolved, did you forget to return data from a deferred promise?`);
                return `${JSON.stringify(key)}:__remixContext.p(${markup.escapeHtml(JSON.stringify(trackedPromise._data))})`;
              }
            }
          }).join(`,
`);
          return `Object.assign(__remixContext.state.loaderData[${JSON.stringify(routeId)}], {${promiseKeyValues}});`;
        }).join(`
`) + (deferredScripts.length > 0 ? `__remixContext.a=${deferredScripts.length};` : "") : "";
        let routeModulesScript = isStatic ? `${(_manifest$hmr = manifest.hmr) !== null && _manifest$hmr !== void 0 && _manifest$hmr.runtime ? `import ${JSON.stringify(manifest.hmr.runtime)};` : ""}import ${JSON.stringify(manifest.url)};
${matches.map((match, index) => `import * as route${index} from ${JSON.stringify(manifest.routes[match.route.id].module)};`).join(`
`)}
window.__remixRouteModules = {${matches.map((match, index) => `${JSON.stringify(match.route.id)}:route${index}`).join(",")}};

import(${JSON.stringify(manifest.entry.module)});` : " ";
        return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement("script", _rollupPluginBabelHelpers.extends({}, props, {
          suppressHydrationWarning: !0,
          dangerouslySetInnerHTML: markup.createHtml(contextScript),
          type: void 0
        })), /* @__PURE__ */ React__namespace.createElement("script", _rollupPluginBabelHelpers.extends({}, props, {
          suppressHydrationWarning: !0,
          dangerouslySetInnerHTML: markup.createHtml(routeModulesScript),
          type: "module",
          async: !0
        })));
      }, []);
      if (!isStatic && typeof __remixContext == "object" && __remixContext.a)
        for (let i2 = 0; i2 < __remixContext.a; i2++)
          deferredScripts.push(/* @__PURE__ */ React__namespace.createElement(DeferredHydrationScript, {
            key: i2
          }));
      let nextMatches = React__namespace.useMemo(() => {
        if (navigation.location) {
          let matches2 = reactRouterDom.matchRoutes(router.routes, navigation.location);
          return invariant(matches2, `No routes match path "${navigation.location.pathname}"`), matches2;
        }
        return [];
      }, [navigation.location, router.routes]), routePreloads = matches.concat(nextMatches).map((match) => {
        let route = manifest.routes[match.route.id];
        return (route.imports || []).concat([route.module]);
      }).flat(1), preloads = isHydrated ? [] : manifest.entry.imports.concat(routePreloads);
      return isHydrated ? null : /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement("link", {
        rel: "modulepreload",
        href: manifest.entry.module,
        crossOrigin: props.crossOrigin
      }), dedupe(preloads).map((path) => /* @__PURE__ */ React__namespace.createElement("link", {
        key: path,
        rel: "modulepreload",
        href: path,
        crossOrigin: props.crossOrigin
      })), initialScripts, deferredScripts);
    }
    function DeferredHydrationScript({
      dataKey,
      deferredData,
      routeId
    }) {
      return typeof document > "u" && deferredData && dataKey && routeId && invariant(deferredData.pendingKeys.includes(dataKey), `Deferred data for route ${routeId} with key ${dataKey} was not pending but tried to render a script for it.`), /* @__PURE__ */ React__namespace.createElement(React__namespace.Suspense, {
        fallback: (
          // This makes absolutely no sense. The server renders null as a fallback,
          // but when hydrating, we need to render a script tag to avoid a hydration issue.
          // To reproduce a hydration mismatch, just render null as a fallback.
          typeof document > "u" && deferredData && dataKey && routeId ? null : /* @__PURE__ */ React__namespace.createElement("script", {
            async: !0,
            suppressHydrationWarning: !0,
            dangerouslySetInnerHTML: {
              __html: " "
            }
          })
        )
      }, typeof document > "u" && deferredData && dataKey && routeId ? /* @__PURE__ */ React__namespace.createElement(Await, {
        resolve: deferredData.data[dataKey],
        errorElement: /* @__PURE__ */ React__namespace.createElement(ErrorDeferredHydrationScript, {
          dataKey,
          routeId
        }),
        children: (data) => /* @__PURE__ */ React__namespace.createElement("script", {
          async: !0,
          suppressHydrationWarning: !0,
          dangerouslySetInnerHTML: {
            __html: `__remixContext.r(${JSON.stringify(routeId)}, ${JSON.stringify(dataKey)}, ${markup.escapeHtml(JSON.stringify(data))});`
          }
        })
      }) : /* @__PURE__ */ React__namespace.createElement("script", {
        async: !0,
        suppressHydrationWarning: !0,
        dangerouslySetInnerHTML: {
          __html: " "
        }
      }));
    }
    function ErrorDeferredHydrationScript({
      dataKey,
      routeId
    }) {
      let error = reactRouterDom.useAsyncError(), toSerialize = {
        message: error.message,
        stack: error.stack
      };
      return /* @__PURE__ */ React__namespace.createElement("script", {
        suppressHydrationWarning: !0,
        dangerouslySetInnerHTML: {
          __html: `__remixContext.r(${JSON.stringify(routeId)}, ${JSON.stringify(dataKey)}, !1, ${markup.escapeHtml(JSON.stringify(toSerialize))});`
        }
      });
    }
    function dedupe(array) {
      return [...new Set(array)];
    }
    function useMatches() {
      let {
        routeModules
      } = useRemixContext(), matches = reactRouterDom.useMatches();
      return React__namespace.useMemo(() => matches.map((match) => ({
        id: match.id,
        pathname: match.pathname,
        params: match.params,
        data: match.data,
        // Need to grab handle here since we don't have it at client-side route
        // creation time
        handle: routeModules[match.id].handle
      })), [matches, routeModules]);
    }
    function useLoaderData3() {
      return reactRouterDom.useLoaderData();
    }
    function useActionData3() {
      return reactRouterDom.useActionData();
    }
    function useTransition() {
      let navigation = reactRouterDom.useNavigation();
      return React__namespace.useEffect(() => {
        warnings.logDeprecationOnce(useTransitionWarning);
      }, []), React__namespace.useMemo(() => convertNavigationToTransition(navigation), [navigation]);
    }
    function convertNavigationToTransition(navigation) {
      let {
        location,
        state,
        formMethod,
        formAction,
        formEncType,
        formData
      } = navigation;
      if (!location)
        return transition.IDLE_TRANSITION;
      let isActionSubmission = formMethod != null && ["POST", "PUT", "PATCH", "DELETE"].includes(formMethod.toUpperCase());
      if (state === "submitting" && formMethod && formAction && formEncType && formData) {
        if (isActionSubmission)
          return {
            location,
            state,
            submission: {
              method: formMethod.toUpperCase(),
              action: formAction,
              encType: formEncType,
              formData,
              key: ""
            },
            type: "actionSubmission"
          };
        invariant(!1, "Encountered an unexpected navigation scenario in useTransition()");
      }
      if (state === "loading") {
        let {
          _isRedirect,
          _isFetchActionRedirect
        } = location.state || {};
        if (formMethod && formAction && formEncType && formData) {
          if (_isRedirect)
            return isActionSubmission ? {
              location,
              state,
              submission: {
                method: formMethod.toUpperCase(),
                action: formAction,
                encType: formEncType,
                formData,
                key: ""
              },
              type: "actionRedirect"
            } : {
              location,
              state,
              submission: {
                method: formMethod.toUpperCase(),
                action: formAction,
                encType: formEncType,
                formData,
                key: ""
              },
              type: "loaderSubmissionRedirect"
            };
          if (isActionSubmission)
            return {
              location,
              state,
              submission: {
                method: formMethod.toUpperCase(),
                action: formAction,
                encType: formEncType,
                formData,
                key: ""
              },
              type: "actionReload"
            };
          {
            let url = new URL(formAction, window.location.origin);
            return url.search = new URLSearchParams(formData.entries()).toString(), {
              location,
              state: "submitting",
              submission: {
                method: formMethod.toUpperCase(),
                action: url.pathname + url.search,
                encType: formEncType,
                formData,
                key: ""
              },
              type: "loaderSubmission"
            };
          }
        } else if (_isRedirect)
          return _isFetchActionRedirect ? {
            location,
            state,
            submission: void 0,
            type: "fetchActionRedirect"
          } : {
            location,
            state,
            submission: void 0,
            type: "normalRedirect"
          };
      }
      return {
        location,
        state: "loading",
        submission: void 0,
        type: "normalLoad"
      };
    }
    function useFetchers() {
      return reactRouterDom.useFetchers().map((f3) => {
        let fetcher2 = convertRouterFetcherToRemixFetcher({
          state: f3.state,
          data: f3.data,
          formMethod: f3.formMethod,
          formAction: f3.formAction,
          formData: f3.formData,
          formEncType: f3.formEncType,
          " _hasFetcherDoneAnything ": f3[" _hasFetcherDoneAnything "]
        });
        return addFetcherDeprecationWarnings(fetcher2), fetcher2;
      });
    }
    function useFetcher2() {
      let fetcherRR = reactRouterDom.useFetcher();
      return React__namespace.useMemo(() => {
        let fetcherWithComponents = {
          ...convertRouterFetcherToRemixFetcher({
            state: fetcherRR.state,
            data: fetcherRR.data,
            formMethod: fetcherRR.formMethod,
            formAction: fetcherRR.formAction,
            formData: fetcherRR.formData,
            formEncType: fetcherRR.formEncType,
            " _hasFetcherDoneAnything ": fetcherRR[" _hasFetcherDoneAnything "]
          }),
          load: fetcherRR.load,
          submit: fetcherRR.submit,
          Form: fetcherRR.Form
        };
        return addFetcherDeprecationWarnings(fetcherWithComponents), fetcherWithComponents;
      }, [fetcherRR]);
    }
    function addFetcherDeprecationWarnings(fetcher2) {
      let type = fetcher2.type;
      Object.defineProperty(fetcher2, "type", {
        get() {
          return warnings.logDeprecationOnce(fetcherTypeWarning), type;
        },
        set(value) {
          type = value;
        },
        // These settings should make this behave like a normal object `type` field
        configurable: !0,
        enumerable: !0
      });
      let submission = fetcher2.submission;
      Object.defineProperty(fetcher2, "submission", {
        get() {
          return warnings.logDeprecationOnce(fetcherSubmissionWarning), submission;
        },
        set(value) {
          submission = value;
        },
        // These settings should make this behave like a normal object `type` field
        configurable: !0,
        enumerable: !0
      });
    }
    function convertRouterFetcherToRemixFetcher(fetcherRR) {
      let {
        state,
        formMethod,
        formAction,
        formEncType,
        formData,
        data
      } = fetcherRR, isActionSubmission = formMethod != null && ["POST", "PUT", "PATCH", "DELETE"].includes(formMethod.toUpperCase());
      if (state === "idle")
        return fetcherRR[" _hasFetcherDoneAnything "] === !0 ? {
          state: "idle",
          type: "done",
          formMethod: void 0,
          formAction: void 0,
          formData: void 0,
          formEncType: void 0,
          submission: void 0,
          data
        } : transition.IDLE_FETCHER;
      if (state === "submitting" && formMethod && formAction && formEncType && formData) {
        if (isActionSubmission)
          return {
            state,
            type: "actionSubmission",
            formMethod: formMethod.toUpperCase(),
            formAction,
            formEncType,
            formData,
            submission: {
              method: formMethod.toUpperCase(),
              action: formAction,
              encType: formEncType,
              formData,
              key: ""
            },
            data
          };
        invariant(!1, "Encountered an unexpected fetcher scenario in useFetcher()");
      }
      if (state === "loading" && formMethod && formAction && formEncType && formData) {
        if (isActionSubmission)
          return data ? {
            state,
            type: "actionReload",
            formMethod: formMethod.toUpperCase(),
            formAction,
            formEncType,
            formData,
            submission: {
              method: formMethod.toUpperCase(),
              action: formAction,
              encType: formEncType,
              formData,
              key: ""
            },
            data
          } : {
            state,
            type: "actionRedirect",
            formMethod: formMethod.toUpperCase(),
            formAction,
            formEncType,
            formData,
            submission: {
              method: formMethod.toUpperCase(),
              action: formAction,
              encType: formEncType,
              formData,
              key: ""
            },
            data: void 0
          };
        {
          let url = new URL(formAction, window.location.origin);
          return url.search = new URLSearchParams(formData.entries()).toString(), {
            state: "submitting",
            type: "loaderSubmission",
            formMethod: formMethod.toUpperCase(),
            formAction,
            formEncType,
            formData,
            submission: {
              method: formMethod.toUpperCase(),
              action: url.pathname + url.search,
              encType: formEncType,
              formData,
              key: ""
            },
            data
          };
        }
      }
      return {
        state: "loading",
        type: "normalLoad",
        formMethod: void 0,
        formAction: void 0,
        formData: void 0,
        formEncType: void 0,
        submission: void 0,
        data
      };
    }
    var LiveReload2 = function({
      // TODO: remove REMIX_DEV_SERVER_WS_PORT in v2
      port,
      timeoutMs = 1e3,
      nonce = void 0
    }) {
      let js = String.raw;
      return /* @__PURE__ */ React__namespace.createElement("script", {
        nonce,
        suppressHydrationWarning: !0,
        dangerouslySetInnerHTML: {
          __html: js`
                function remixLiveReloadConnect(config) {
                  let protocol = location.protocol === "https:" ? "wss:" : "ws:";
                  let host = location.hostname;
                  let port = ${port} || (window.__remixContext && window.__remixContext.dev && window.__remixContext.dev.port) || ${Number(8002)};
                  let socketPath = protocol + "//" + host + ":" + port + "/socket";
                  let ws = new WebSocket(socketPath);
                  ws.onmessage = async (message) => {
                    let event = JSON.parse(message.data);
                    if (event.type === "LOG") {
                      console.log(event.message);
                    }
                    if (event.type === "RELOAD") {
                      console.log(" Reloading window ...");
                      window.location.reload();
                    }
                    if (event.type === "HMR") {
                      if (!window.__hmr__ || !window.__hmr__.contexts) {
                        console.log(" [HMR] No HMR context, reloading window ...");
                        window.location.reload();
                        return;
                      }
                      if (!event.updates || !event.updates.length) return;
                      let updateAccepted = false;
                      let needsRevalidation = new Set();
                      for (let update of event.updates) {
                        console.log("[HMR] " + update.reason + " [" + update.id +"]")
                        if (update.revalidate) {
                          needsRevalidation.add(update.routeId);
                          console.log("[HMR] Revalidating [" + update.routeId + "]");
                        }
                        let imported = await import(update.url +  '?t=' + event.assetsManifest.hmr.timestamp);
                        if (window.__hmr__.contexts[update.id]) {
                          let accepted = window.__hmr__.contexts[update.id].emit(
                            imported
                          );
                          if (accepted) {
                            console.log("[HMR] Updated accepted by", update.id);
                            updateAccepted = true;
                          }
                        }
                      }
                      if (event.assetsManifest && window.__hmr__.contexts["remix:manifest"]) {
                        let accepted = window.__hmr__.contexts["remix:manifest"].emit(
                          { needsRevalidation, assetsManifest: event.assetsManifest }
                        );
                        if (accepted) {
                          console.log("[HMR] Updated accepted by", "remix:manifest");
                          updateAccepted = true;
                        }
                      }
                      if (!updateAccepted) {
                        console.log("[HMR] Updated rejected, reloading...");
                        window.location.reload();
                      }
                    }
                  };
                  ws.onopen = () => {
                    if (config && typeof config.onOpen === "function") {
                      config.onOpen();
                    }
                  };
                  ws.onclose = (event) => {
                    if (event.code === 1006) {
                      console.log("Remix dev asset server web socket closed. Reconnecting...");
                      setTimeout(
                        () =>
                          remixLiveReloadConnect({
                            onOpen: () => window.location.reload(),
                          }),
                      ${String(timeoutMs)}
                      );
                    }
                  };
                  ws.onerror = (error) => {
                    console.log("Remix dev asset server web socket error:");
                    console.error(error);
                  };
                }
                remixLiveReloadConnect();
              `
        }
      });
    };
    exports.Await = Await;
    exports.Link = Link2;
    exports.Links = Links2;
    exports.LiveReload = LiveReload2;
    exports.Meta = Meta;
    exports.NavLink = NavLink;
    exports.PrefetchPageLinks = PrefetchPageLinks;
    exports.RemixContext = RemixContext;
    exports.RemixRoute = RemixRoute;
    exports.RemixRouteError = RemixRouteError;
    exports.Scripts = Scripts2;
    exports.composeEventHandlers = composeEventHandlers;
    exports.useActionData = useActionData3;
    exports.useFetcher = useFetcher2;
    exports.useFetchers = useFetchers;
    exports.useLoaderData = useLoaderData3;
    exports.useMatches = useMatches;
    exports.useTransition = useTransition;
  }
});

// node_modules/@remix-run/react/dist/errors.js
var require_errors3 = __commonJS({
  "node_modules/@remix-run/react/dist/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var router = require_router_cjs();
    function deserializeErrors(errors) {
      if (!errors)
        return null;
      let entries = Object.entries(errors), serialized = {};
      for (let [key, val] of entries)
        if (val && val.__type === "RouteErrorResponse")
          serialized[key] = new router.ErrorResponse(val.status, val.statusText, val.data, val.internal === !0);
        else if (val && val.__type === "Error") {
          let error = new Error(val.message);
          error.stack = val.stack, serialized[key] = error;
        } else
          serialized[key] = val;
      return serialized;
    }
    exports.deserializeErrors = deserializeErrors;
  }
});

// node_modules/@remix-run/react/dist/data.js
var require_data2 = __commonJS({
  "node_modules/@remix-run/react/dist/data.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var router = require_router_cjs();
    function isCatchResponse(response) {
      return response.headers.get("X-Remix-Catch") != null;
    }
    function isErrorResponse(response) {
      return response.headers.get("X-Remix-Error") != null;
    }
    function isRedirectResponse(response) {
      return response.headers.get("X-Remix-Redirect") != null;
    }
    function isDeferredResponse(response) {
      var _response$headers$get;
      return !!((_response$headers$get = response.headers.get("Content-Type")) !== null && _response$headers$get !== void 0 && _response$headers$get.match(/text\/remix-deferred/));
    }
    async function fetchData(request, routeId, retry = 0) {
      let url = new URL(request.url);
      url.searchParams.set("_data", routeId);
      let init = {
        signal: request.signal
      };
      if (request.method !== "GET") {
        init.method = request.method;
        let contentType = request.headers.get("Content-Type");
        init.body = // Check between word boundaries instead of startsWith() due to the last
        // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type
        contentType && /\bapplication\/x-www-form-urlencoded\b/.test(contentType) ? new URLSearchParams(await request.text()) : await request.formData();
      }
      retry > 0 && await new Promise((resolve) => setTimeout(resolve, 5 ** retry * 10));
      let revalidation = window.__remixRevalidation, response = await fetch(url.href, init).catch((error) => {
        if (typeof revalidation == "number" && revalidation === window.__remixRevalidation && (error == null ? void 0 : error.name) === "TypeError" && retry < 3)
          return fetchData(request, routeId, retry + 1);
        throw error;
      });
      if (isErrorResponse(response)) {
        let data = await response.json(), error = new Error(data.message);
        return error.stack = data.stack, error;
      }
      return response;
    }
    var DEFERRED_VALUE_PLACEHOLDER_PREFIX = "__deferred_promise:";
    async function parseDeferredReadableStream(stream) {
      if (!stream)
        throw new Error("parseDeferredReadableStream requires stream argument");
      let deferredData, deferredResolvers = {};
      try {
        let sectionReader = readStreamSections(stream), initialSection = (await sectionReader.next()).value;
        if (!initialSection)
          throw new Error("no critical data");
        let criticalData = JSON.parse(initialSection);
        if (typeof criticalData == "object" && criticalData !== null)
          for (let [eventKey, value] of Object.entries(criticalData))
            typeof value != "string" || !value.startsWith(DEFERRED_VALUE_PLACEHOLDER_PREFIX) || (deferredData = deferredData || {}, deferredData[eventKey] = new Promise((resolve, reject) => {
              deferredResolvers[eventKey] = {
                resolve: (value2) => {
                  resolve(value2), delete deferredResolvers[eventKey];
                },
                reject: (error) => {
                  reject(error), delete deferredResolvers[eventKey];
                }
              };
            }));
        return (async () => {
          try {
            for await (let section of sectionReader) {
              let [event, ...sectionDataStrings] = section.split(":"), sectionDataString = sectionDataStrings.join(":"), data = JSON.parse(sectionDataString);
              if (event === "data")
                for (let [key, value] of Object.entries(data))
                  deferredResolvers[key] && deferredResolvers[key].resolve(value);
              else if (event === "error")
                for (let [key, value] of Object.entries(data)) {
                  let err = new Error(value.message);
                  err.stack = value.stack, deferredResolvers[key] && deferredResolvers[key].reject(err);
                }
            }
            for (let [key, resolver] of Object.entries(deferredResolvers))
              resolver.reject(new router.AbortedDeferredError(`Deferred ${key} will never be resolved`));
          } catch (error) {
            for (let resolver of Object.values(deferredResolvers))
              resolver.reject(error);
          }
        })(), new router.UNSAFE_DeferredData({
          ...criticalData,
          ...deferredData
        });
      } catch (error) {
        for (let resolver of Object.values(deferredResolvers))
          resolver.reject(error);
        throw error;
      }
    }
    async function* readStreamSections(stream) {
      let reader = stream.getReader(), buffer = [], sections = [], closed = !1, encoder = new TextEncoder(), decoder = new TextDecoder(), readStreamSection = async () => {
        if (sections.length > 0)
          return sections.shift();
        for (; !closed && sections.length === 0; ) {
          let chunk = await reader.read();
          if (chunk.done) {
            closed = !0;
            break;
          }
          buffer.push(chunk.value);
          try {
            let splitSections = decoder.decode(mergeArrays(...buffer)).split(`

`);
            if (splitSections.length >= 2 && (sections.push(...splitSections.slice(0, -1)), buffer = [encoder.encode(splitSections.slice(-1).join(`

`))]), sections.length > 0)
              break;
          } catch {
            continue;
          }
        }
        return sections.length > 0 || buffer.length > 0 && (sections = decoder.decode(mergeArrays(...buffer)).split(`

`).filter((s2) => s2), buffer = []), sections.shift();
      }, section = await readStreamSection();
      for (; section; )
        yield section, section = await readStreamSection();
    }
    function mergeArrays(...arrays) {
      let out = new Uint8Array(arrays.reduce((total, arr) => total + arr.length, 0)), offset = 0;
      for (let arr of arrays)
        out.set(arr, offset), offset += arr.length;
      return out;
    }
    exports.fetchData = fetchData;
    exports.isCatchResponse = isCatchResponse;
    exports.isDeferredResponse = isDeferredResponse;
    exports.isErrorResponse = isErrorResponse;
    exports.isRedirectResponse = isRedirectResponse;
    exports.parseDeferredReadableStream = parseDeferredReadableStream;
  }
});

// node_modules/@remix-run/react/dist/routes.js
var require_routes2 = __commonJS({
  "node_modules/@remix-run/react/dist/routes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var React5 = require_react(), reactRouterDom = require_main2(), routeModules = require_routeModules(), data = require_data2(), links2 = require_links(), invariant = require_invariant2(), components = require_components();
    function _interopNamespace(e2) {
      if (e2 && e2.__esModule)
        return e2;
      var n = /* @__PURE__ */ Object.create(null);
      return e2 && Object.keys(e2).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e2, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e2[k];
            }
          });
        }
      }), n.default = e2, Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React5);
    function groupRoutesByParentId(manifest) {
      let routes2 = {};
      return Object.values(manifest).forEach((route) => {
        let parentId = route.parentId || "";
        routes2[parentId] || (routes2[parentId] = []), routes2[parentId].push(route);
      }), routes2;
    }
    function createServerRoutes(manifest, routeModules2, future2, parentId = "", routesByParentId = groupRoutesByParentId(manifest)) {
      return (routesByParentId[parentId] || []).map((route) => {
        let hasErrorBoundary = future2.v2_errorBoundary === !0 ? route.id === "root" || route.hasErrorBoundary : route.id === "root" || route.hasCatchBoundary || route.hasErrorBoundary, dataRoute = {
          caseSensitive: route.caseSensitive,
          element: /* @__PURE__ */ React__namespace.createElement(components.RemixRoute, {
            id: route.id
          }),
          errorElement: hasErrorBoundary ? /* @__PURE__ */ React__namespace.createElement(components.RemixRouteError, {
            id: route.id
          }) : void 0,
          id: route.id,
          index: route.index,
          path: route.path,
          handle: routeModules2[route.id].handle
          // Note: we don't need loader/action/shouldRevalidate on these routes
          // since they're for a static render
        }, children = createServerRoutes(manifest, routeModules2, future2, route.id, routesByParentId);
        return children.length > 0 && (dataRoute.children = children), dataRoute;
      });
    }
    function createClientRoutes(manifest, routeModulesCache, future2, parentId = "", routesByParentId = groupRoutesByParentId(manifest), needsRevalidation) {
      return (routesByParentId[parentId] || []).map((route) => {
        let hasErrorBoundary = future2.v2_errorBoundary === !0 ? route.id === "root" || route.hasErrorBoundary : route.id === "root" || route.hasCatchBoundary || route.hasErrorBoundary, dataRoute = {
          caseSensitive: route.caseSensitive,
          element: /* @__PURE__ */ React__namespace.createElement(components.RemixRoute, {
            id: route.id
          }),
          errorElement: hasErrorBoundary ? /* @__PURE__ */ React__namespace.createElement(components.RemixRouteError, {
            id: route.id
          }) : void 0,
          id: route.id,
          index: route.index,
          path: route.path,
          // handle gets added in via useMatches since we aren't guaranteed to
          // have the route module available here
          handle: void 0,
          loader: createDataFunction(route, routeModulesCache, !1),
          action: createDataFunction(route, routeModulesCache, !0),
          shouldRevalidate: createShouldRevalidate(route, routeModulesCache, needsRevalidation)
        }, children = createClientRoutes(manifest, routeModulesCache, future2, route.id, routesByParentId, needsRevalidation);
        return children.length > 0 && (dataRoute.children = children), dataRoute;
      });
    }
    function createShouldRevalidate(route, routeModules2, needsRevalidation) {
      let handledRevalidation = !1;
      return function(arg) {
        let module3 = routeModules2[route.id];
        return invariant(module3, `Expected route module to be loaded for ${route.id}`), needsRevalidation !== void 0 && !handledRevalidation ? (handledRevalidation = !0, needsRevalidation.has(route.id)) : module3.shouldRevalidate ? module3.shouldRevalidate(arg) : arg.defaultShouldRevalidate;
      };
    }
    async function loadRouteModuleWithBlockingLinks(route, routeModules$1) {
      let routeModule = await routeModules.loadRouteModule(route, routeModules$1);
      return await links2.prefetchStyleLinks(routeModule), routeModule;
    }
    function createDataFunction(route, routeModules2, isAction) {
      return async ({
        request
      }) => {
        let routeModulePromise = loadRouteModuleWithBlockingLinks(route, routeModules2);
        try {
          if (isAction && !route.hasAction) {
            let msg = `Route "${route.id}" does not have an action, but you are trying to submit to it. To fix this, please add an \`action\` function to the route`;
            throw console.error(msg), new Error(msg);
          } else if (!isAction && !route.hasLoader)
            return null;
          let result = await data.fetchData(request, route.id);
          if (result instanceof Error)
            throw result;
          if (data.isRedirectResponse(result))
            throw getRedirect(result);
          if (data.isCatchResponse(result))
            throw result;
          return data.isDeferredResponse(result) && result.body ? await data.parseDeferredReadableStream(result.body) : result;
        } finally {
          await routeModulePromise;
        }
      };
    }
    function getRedirect(response) {
      let status = parseInt(response.headers.get("X-Remix-Status"), 10) || 302, url = response.headers.get("X-Remix-Redirect"), headers = {}, revalidate = response.headers.get("X-Remix-Revalidate");
      return revalidate && (headers["X-Remix-Revalidate"] = revalidate), reactRouterDom.redirect(url, {
        status,
        headers
      });
    }
    exports.createClientRoutes = createClientRoutes;
    exports.createServerRoutes = createServerRoutes;
  }
});

// node_modules/@remix-run/react/dist/browser.js
var require_browser = __commonJS({
  "node_modules/@remix-run/react/dist/browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var React5 = require_react(), reactRouterDom = require_main2(), components = require_components(), errorBoundaries = require_errorBoundaries(), errors = require_errors3(), routes2 = require_routes2();
    function _interopNamespace(e2) {
      if (e2 && e2.__esModule)
        return e2;
      var n = /* @__PURE__ */ Object.create(null);
      return e2 && Object.keys(e2).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e2, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e2[k];
            }
          });
        }
      }), n.default = e2, Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React5), router;
    function RemixBrowser(_props) {
      if (!router) {
        let routes$1 = routes2.createClientRoutes(window.__remixManifest.routes, window.__remixRouteModules, window.__remixContext.future), hydrationData = window.__remixContext.state;
        hydrationData && hydrationData.errors && (hydrationData = {
          ...hydrationData,
          errors: errors.deserializeErrors(hydrationData.errors)
        }), router = reactRouterDom.createBrowserRouter(routes$1, {
          hydrationData,
          future: {
            // Pass through the Remix future flag to avoid a v1 breaking change in
            // useNavigation() - users can control the casing via the flag in v1.
            // useFetcher still always uppercases in the back-compat layer in v1.
            // In v2 we can just always pass true here and remove the back-compat
            // layer
            v7_normalizeFormMethod: window.__remixContext.future.v2_normalizeFormMethod
          }
        });
      }
      let [location, setLocation] = React__namespace.useState(router.state.location);
      return React__namespace.useLayoutEffect(() => router.subscribe((newState) => {
        newState.location !== location && setLocation(newState.location);
      }), [location]), /* @__PURE__ */ React__namespace.createElement(components.RemixContext.Provider, {
        value: {
          manifest: window.__remixManifest,
          routeModules: window.__remixRouteModules,
          future: window.__remixContext.future
        }
      }, /* @__PURE__ */ React__namespace.createElement(errorBoundaries.RemixErrorBoundary, {
        location,
        component: errorBoundaries.RemixRootDefaultErrorBoundary
      }, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.RouterProvider, {
        router,
        fallbackElement: null
      })));
    }
    exports.RemixBrowser = RemixBrowser;
  }
});

// node_modules/@remix-run/react/dist/scroll-restoration.js
var require_scroll_restoration = __commonJS({
  "node_modules/@remix-run/react/dist/scroll-restoration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var _rollupPluginBabelHelpers = require_rollupPluginBabelHelpers(), React5 = require_react(), reactRouterDom = require_main2(), components = require_components();
    function _interopNamespace(e2) {
      if (e2 && e2.__esModule)
        return e2;
      var n = /* @__PURE__ */ Object.create(null);
      return e2 && Object.keys(e2).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e2, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e2[k];
            }
          });
        }
      }), n.default = e2, Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React5), STORAGE_KEY = "positions";
    function ScrollRestoration({
      getKey,
      ...props
    }) {
      let location = reactRouterDom.useLocation(), matches = components.useMatches();
      reactRouterDom.UNSAFE_useScrollRestoration({
        getKey,
        storageKey: STORAGE_KEY
      });
      let key = React__namespace.useMemo(
        () => {
          if (!getKey)
            return null;
          let userKey = getKey(location, matches);
          return userKey !== location.key ? userKey : null;
        },
        // Nah, we only need this the first time for the SSR render
        // eslint-disable-next-line react-hooks/exhaustive-deps
        []
      ), restoreScroll = ((STORAGE_KEY2, restoreKey) => {
        if (!window.history.state || !window.history.state.key) {
          let key2 = Math.random().toString(32).slice(2);
          window.history.replaceState({
            key: key2
          }, "");
        }
        try {
          let storedY = JSON.parse(sessionStorage.getItem(STORAGE_KEY2) || "{}")[restoreKey || window.history.state.key];
          typeof storedY == "number" && window.scrollTo(0, storedY);
        } catch (error) {
          console.error(error), sessionStorage.removeItem(STORAGE_KEY2);
        }
      }).toString();
      return /* @__PURE__ */ React__namespace.createElement("script", _rollupPluginBabelHelpers.extends({}, props, {
        suppressHydrationWarning: !0,
        dangerouslySetInnerHTML: {
          __html: `(${restoreScroll})(${JSON.stringify(STORAGE_KEY)}, ${JSON.stringify(key)})`
        }
      }));
    }
    exports.ScrollRestoration = ScrollRestoration;
  }
});

// node_modules/react-router-dom/server.js
var require_server2 = __commonJS({
  "node_modules/react-router-dom/server.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var React5 = require_react(), router = require_router_cjs(), reactRouter = require_main(), reactRouterDom = require_main2();
    function _interopNamespace(e2) {
      if (e2 && e2.__esModule)
        return e2;
      var n = /* @__PURE__ */ Object.create(null);
      return e2 && Object.keys(e2).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e2, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e2[k];
            }
          });
        }
      }), n.default = e2, Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React5);
    function StaticRouter({
      basename,
      children,
      location: locationProp = "/"
    }) {
      typeof locationProp == "string" && (locationProp = reactRouterDom.parsePath(locationProp));
      let action3 = router.Action.Pop, location = {
        pathname: locationProp.pathname || "/",
        search: locationProp.search || "",
        hash: locationProp.hash || "",
        state: locationProp.state || null,
        key: locationProp.key || "default"
      }, staticNavigator = getStatelessNavigator();
      return /* @__PURE__ */ React__namespace.createElement(reactRouterDom.Router, {
        basename,
        children,
        location,
        navigationType: action3,
        navigator: staticNavigator,
        static: !0
      });
    }
    function StaticRouterProvider({
      context,
      router: router$1,
      hydrate = !0,
      nonce
    }) {
      router$1 && context || router.UNSAFE_invariant(!1, "You must provide `router` and `context` to <StaticRouterProvider>");
      let dataRouterContext = {
        router: router$1,
        navigator: getStatelessNavigator(),
        static: !0,
        staticContext: context,
        basename: context.basename || "/"
      }, hydrateScript = "";
      if (hydrate !== !1) {
        let data = {
          loaderData: context.loaderData,
          actionData: context.actionData,
          errors: serializeErrors(context.errors)
        };
        hydrateScript = `window.__staticRouterHydrationData = JSON.parse(${htmlEscape(JSON.stringify(JSON.stringify(data)))});`;
      }
      let {
        state
      } = dataRouterContext.router;
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.UNSAFE_DataRouterContext.Provider, {
        value: dataRouterContext
      }, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.UNSAFE_DataRouterStateContext.Provider, {
        value: state
      }, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.Router, {
        basename: dataRouterContext.basename,
        location: state.location,
        navigationType: state.historyAction,
        navigator: dataRouterContext.navigator,
        static: dataRouterContext.static
      }, /* @__PURE__ */ React__namespace.createElement(DataRoutes, {
        routes: router$1.routes,
        state
      })))), hydrateScript ? /* @__PURE__ */ React__namespace.createElement("script", {
        suppressHydrationWarning: !0,
        nonce,
        dangerouslySetInnerHTML: {
          __html: hydrateScript
        }
      }) : null);
    }
    function DataRoutes({
      routes: routes2,
      state
    }) {
      return reactRouter.UNSAFE_useRoutesImpl(routes2, void 0, state);
    }
    function serializeErrors(errors) {
      if (!errors)
        return null;
      let entries = Object.entries(errors), serialized = {};
      for (let [key, val] of entries)
        router.isRouteErrorResponse(val) ? serialized[key] = {
          ...val,
          __type: "RouteErrorResponse"
        } : val instanceof Error ? serialized[key] = {
          message: val.message,
          __type: "Error"
        } : serialized[key] = val;
      return serialized;
    }
    function getStatelessNavigator() {
      return {
        createHref,
        encodeLocation,
        push(to) {
          throw new Error(`You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)})\` somewhere in your app.`);
        },
        replace(to) {
          throw new Error(`You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)}, { replace: true })\` somewhere in your app.`);
        },
        go(delta) {
          throw new Error(`You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${delta})\` somewhere in your app.`);
        },
        back() {
          throw new Error("You cannot use navigator.back() on the server because it is a stateless environment.");
        },
        forward() {
          throw new Error("You cannot use navigator.forward() on the server because it is a stateless environment.");
        }
      };
    }
    function createStaticHandler(routes2, opts) {
      return router.createStaticHandler(routes2, {
        ...opts,
        mapRouteProperties: reactRouter.UNSAFE_mapRouteProperties
      });
    }
    function createStaticRouter(routes2, context) {
      let manifest = {}, dataRoutes = router.UNSAFE_convertRoutesToDataRoutes(routes2, reactRouter.UNSAFE_mapRouteProperties, void 0, manifest), matches = context.matches.map((match) => {
        let route = manifest[match.route.id] || match.route;
        return {
          ...match,
          route
        };
      }), msg = (method) => `You cannot use router.${method}() on the server because it is a stateless environment`;
      return {
        get basename() {
          return context.basename;
        },
        get state() {
          return {
            historyAction: router.Action.Pop,
            location: context.location,
            matches,
            loaderData: context.loaderData,
            actionData: context.actionData,
            errors: context.errors,
            initialized: !0,
            navigation: router.IDLE_NAVIGATION,
            restoreScrollPosition: null,
            preventScrollReset: !1,
            revalidation: "idle",
            fetchers: /* @__PURE__ */ new Map(),
            blockers: /* @__PURE__ */ new Map()
          };
        },
        get routes() {
          return dataRoutes;
        },
        initialize() {
          throw msg("initialize");
        },
        subscribe() {
          throw msg("subscribe");
        },
        enableScrollRestoration() {
          throw msg("enableScrollRestoration");
        },
        navigate() {
          throw msg("navigate");
        },
        fetch() {
          throw msg("fetch");
        },
        revalidate() {
          throw msg("revalidate");
        },
        createHref,
        encodeLocation,
        getFetcher() {
          return router.IDLE_FETCHER;
        },
        deleteFetcher() {
          throw msg("deleteFetcher");
        },
        dispose() {
          throw msg("dispose");
        },
        getBlocker() {
          return router.IDLE_BLOCKER;
        },
        deleteBlocker() {
          throw msg("deleteBlocker");
        },
        _internalFetchControllers: /* @__PURE__ */ new Map(),
        _internalActiveDeferreds: /* @__PURE__ */ new Map(),
        _internalSetRoutes() {
          throw msg("_internalSetRoutes");
        }
      };
    }
    function createHref(to) {
      return typeof to == "string" ? to : reactRouterDom.createPath(to);
    }
    function encodeLocation(to) {
      let path = typeof to == "string" ? reactRouterDom.parsePath(to) : to;
      return {
        pathname: path.pathname || "",
        search: path.search || "",
        hash: path.hash || ""
      };
    }
    var ESCAPE_LOOKUP = {
      "&": "\\u0026",
      ">": "\\u003e",
      "<": "\\u003c",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    }, ESCAPE_REGEX = /[&><\u2028\u2029]/g;
    function htmlEscape(str) {
      return str.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
    }
    exports.StaticRouter = StaticRouter;
    exports.StaticRouterProvider = StaticRouterProvider;
    exports.createStaticHandler = createStaticHandler;
    exports.createStaticRouter = createStaticRouter;
  }
});

// node_modules/@remix-run/react/dist/server.js
var require_server3 = __commonJS({
  "node_modules/@remix-run/react/dist/server.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var React5 = require_react(), server = require_server2(), components = require_components(), errorBoundaries = require_errorBoundaries(), routes2 = require_routes2();
    function _interopNamespace(e2) {
      if (e2 && e2.__esModule)
        return e2;
      var n = /* @__PURE__ */ Object.create(null);
      return e2 && Object.keys(e2).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e2, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e2[k];
            }
          });
        }
      }), n.default = e2, Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React5);
    function RemixServer2({
      context,
      url,
      abortDelay
    }) {
      typeof url == "string" && (url = new URL(url));
      let {
        manifest,
        routeModules,
        serverHandoffString
      } = context, routes$1 = routes2.createServerRoutes(manifest.routes, routeModules, context.future), router = server.createStaticRouter(routes$1, context.staticHandlerContext);
      return /* @__PURE__ */ React__namespace.createElement(components.RemixContext.Provider, {
        value: {
          manifest,
          routeModules,
          serverHandoffString,
          future: context.future,
          abortDelay
        }
      }, /* @__PURE__ */ React__namespace.createElement(errorBoundaries.RemixErrorBoundary, {
        location: router.state.location,
        component: errorBoundaries.RemixRootDefaultErrorBoundary
      }, /* @__PURE__ */ React__namespace.createElement(server.StaticRouterProvider, {
        router,
        context: context.staticHandlerContext,
        hydrate: !1
      })));
    }
    exports.RemixServer = RemixServer2;
  }
});

// node_modules/@remix-run/react/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@remix-run/react/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var browser = require_browser(), reactRouterDom = require_main2(), components = require_components(), errorBoundaries = require_errorBoundaries(), scrollRestoration = require_scroll_restoration(), server = require_server3();
    exports.RemixBrowser = browser.RemixBrowser;
    Object.defineProperty(exports, "Form", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.Form;
      }
    });
    Object.defineProperty(exports, "Outlet", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.Outlet;
      }
    });
    Object.defineProperty(exports, "isRouteErrorResponse", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.isRouteErrorResponse;
      }
    });
    Object.defineProperty(exports, "unstable_useBlocker", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.unstable_useBlocker;
      }
    });
    Object.defineProperty(exports, "unstable_usePrompt", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.unstable_usePrompt;
      }
    });
    Object.defineProperty(exports, "useAsyncError", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useAsyncError;
      }
    });
    Object.defineProperty(exports, "useAsyncValue", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useAsyncValue;
      }
    });
    Object.defineProperty(exports, "useBeforeUnload", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useBeforeUnload;
      }
    });
    Object.defineProperty(exports, "useFormAction", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useFormAction;
      }
    });
    Object.defineProperty(exports, "useHref", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useHref;
      }
    });
    Object.defineProperty(exports, "useLocation", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useLocation;
      }
    });
    Object.defineProperty(exports, "useMatch", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useMatch;
      }
    });
    Object.defineProperty(exports, "useNavigate", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useNavigate;
      }
    });
    Object.defineProperty(exports, "useNavigation", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useNavigation;
      }
    });
    Object.defineProperty(exports, "useNavigationType", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useNavigationType;
      }
    });
    Object.defineProperty(exports, "useOutlet", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useOutlet;
      }
    });
    Object.defineProperty(exports, "useOutletContext", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useOutletContext;
      }
    });
    Object.defineProperty(exports, "useParams", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useParams;
      }
    });
    Object.defineProperty(exports, "useResolvedPath", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useResolvedPath;
      }
    });
    Object.defineProperty(exports, "useRevalidator", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useRevalidator;
      }
    });
    Object.defineProperty(exports, "useRouteError", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useRouteError;
      }
    });
    Object.defineProperty(exports, "useRouteLoaderData", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useRouteLoaderData;
      }
    });
    Object.defineProperty(exports, "useSearchParams", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useSearchParams;
      }
    });
    Object.defineProperty(exports, "useSubmit", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useSubmit;
      }
    });
    exports.Await = components.Await;
    exports.Link = components.Link;
    exports.Links = components.Links;
    exports.LiveReload = components.LiveReload;
    exports.Meta = components.Meta;
    exports.NavLink = components.NavLink;
    exports.PrefetchPageLinks = components.PrefetchPageLinks;
    exports.Scripts = components.Scripts;
    exports.UNSAFE_RemixContext = components.RemixContext;
    exports.useActionData = components.useActionData;
    exports.useFetcher = components.useFetcher;
    exports.useFetchers = components.useFetchers;
    exports.useLoaderData = components.useLoaderData;
    exports.useMatches = components.useMatches;
    exports.useTransition = components.useTransition;
    exports.useCatch = errorBoundaries.useCatch;
    exports.ScrollRestoration = scrollRestoration.ScrollRestoration;
    exports.RemixServer = server.RemixServer;
  }
});

// node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js
var require_react_dom_server_legacy_node_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js"(exports) {
    "use strict";
    (function() {
      "use strict";
      var React5 = require_react(), stream = require("stream"), ReactVersion = "18.2.0", ReactSharedInternals = React5.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function warn(format) {
        {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
            args[_key - 1] = arguments[_key];
          printWarning("warn", format, args);
        }
      }
      function error(format) {
        {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
            args[_key2 - 1] = arguments[_key2];
          printWarning("error", format, args);
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame, stack = ReactDebugCurrentFrame2.getStackAddendum();
          stack !== "" && (format += "%s", args = args.concat([stack]));
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format), Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      function scheduleWork(callback) {
        callback();
      }
      function beginWriting(destination) {
      }
      function writeChunk(destination, chunk) {
        writeChunkAndReturn(destination, chunk);
      }
      function writeChunkAndReturn(destination, chunk) {
        return destination.push(chunk);
      }
      function completeWriting(destination) {
      }
      function close(destination) {
        destination.push(null);
      }
      function stringToChunk(content) {
        return content;
      }
      function stringToPrecomputedChunk(content) {
        return content;
      }
      function closeWithError(destination, error2) {
        destination.destroy(error2);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol == "function" && Symbol.toStringTag, type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        try {
          return testStringCoercion(value), !1;
        } catch {
          return !0;
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkAttributeStringCoercion(value, attributeName) {
        if (willCoercionThrow(value))
          return error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value)), testStringCoercion(value);
      }
      function checkCSSPropertyStringCoercion(value, propName) {
        if (willCoercionThrow(value))
          return error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value)), testStringCoercion(value);
      }
      function checkHtmlStringCoercion(value) {
        if (willCoercionThrow(value))
          return error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value)), testStringCoercion(value);
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty, RESERVED = 0, STRING = 1, BOOLEANISH_STRING = 2, BOOLEAN = 3, OVERLOADED_BOOLEAN = 4, NUMERIC = 5, POSITIVE_NUMERIC = 6, ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$"), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        return hasOwnProperty.call(validatedAttributeNameCache, attributeName) ? !0 : hasOwnProperty.call(illegalAttributeNameCache, attributeName) ? !1 : VALID_ATTRIBUTE_NAME_REGEX.test(attributeName) ? (validatedAttributeNameCache[attributeName] = !0, !0) : (illegalAttributeNameCache[attributeName] = !0, error("Invalid attribute name: `%s`", attributeName), !1);
      }
      function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null && propertyInfo.type === RESERVED)
          return !1;
        switch (typeof value) {
          case "function":
          case "symbol":
            return !0;
          case "boolean": {
            if (isCustomComponentTag)
              return !1;
            if (propertyInfo !== null)
              return !propertyInfo.acceptsBooleans;
            var prefix2 = name.toLowerCase().slice(0, 5);
            return prefix2 !== "data-" && prefix2 !== "aria-";
          }
          default:
            return !1;
        }
      }
      function getPropertyInfo(name) {
        return properties.hasOwnProperty(name) ? properties[name] : null;
      }
      function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
        this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN, this.attributeName = attributeName, this.attributeNamespace = attributeNamespace, this.mustUseProperty = mustUseProperty, this.propertyName = name, this.type = type, this.sanitizeURL = sanitizeURL2, this.removeEmptyString = removeEmptyString;
      }
      var properties = {}, reservedProps = [
        "children",
        "dangerouslySetInnerHTML",
        // TODO: This prevents the assignment of defaultValue to regular
        // elements (not just inputs). Now that ReactDOMInput assigns to the
        // defaultValue property -- do we need this?
        "defaultValue",
        "defaultChecked",
        "innerHTML",
        "suppressContentEditableWarning",
        "suppressHydrationWarning",
        "style"
      ];
      reservedProps.forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          RESERVED,
          !1,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          !1,
          // sanitizeURL
          !1
        );
      }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
        var name = _ref[0], attributeName = _ref[1];
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          !1,
          // mustUseProperty
          attributeName,
          // attributeName
          null,
          // attributeNamespace
          !1,
          // sanitizeURL
          !1
        );
      }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEANISH_STRING,
          !1,
          // mustUseProperty
          name.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          !1,
          // sanitizeURL
          !1
        );
      }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEANISH_STRING,
          !1,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          !1,
          // sanitizeURL
          !1
        );
      }), [
        "allowFullScreen",
        "async",
        // Note: there is a special case that prevents it from being written to the DOM
        // on the client side because the browsers are inconsistent. Instead we call focus().
        "autoFocus",
        "autoPlay",
        "controls",
        "default",
        "defer",
        "disabled",
        "disablePictureInPicture",
        "disableRemotePlayback",
        "formNoValidate",
        "hidden",
        "loop",
        "noModule",
        "noValidate",
        "open",
        "playsInline",
        "readOnly",
        "required",
        "reversed",
        "scoped",
        "seamless",
        // Microdata
        "itemScope"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEAN,
          !1,
          // mustUseProperty
          name.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          !1,
          // sanitizeURL
          !1
        );
      }), [
        "checked",
        // Note: `option.selected` is not updated if `select.multiple` is
        // disabled with `removeAttribute`. We have special logic for handling this.
        "multiple",
        "muted",
        "selected"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEAN,
          !0,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          !1,
          // sanitizeURL
          !1
        );
      }), [
        "capture",
        "download"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          OVERLOADED_BOOLEAN,
          !1,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          !1,
          // sanitizeURL
          !1
        );
      }), [
        "cols",
        "rows",
        "size",
        "span"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          POSITIVE_NUMERIC,
          !1,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          !1,
          // sanitizeURL
          !1
        );
      }), ["rowSpan", "start"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          NUMERIC,
          !1,
          // mustUseProperty
          name.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          !1,
          // sanitizeURL
          !1
        );
      });
      var CAMELIZE = /[\-\:]([a-z])/g, capitalize2 = function(token) {
        return token[1].toUpperCase();
      };
      [
        "accent-height",
        "alignment-baseline",
        "arabic-form",
        "baseline-shift",
        "cap-height",
        "clip-path",
        "clip-rule",
        "color-interpolation",
        "color-interpolation-filters",
        "color-profile",
        "color-rendering",
        "dominant-baseline",
        "enable-background",
        "fill-opacity",
        "fill-rule",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "glyph-name",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "horiz-adv-x",
        "horiz-origin-x",
        "image-rendering",
        "letter-spacing",
        "lighting-color",
        "marker-end",
        "marker-mid",
        "marker-start",
        "overline-position",
        "overline-thickness",
        "paint-order",
        "panose-1",
        "pointer-events",
        "rendering-intent",
        "shape-rendering",
        "stop-color",
        "stop-opacity",
        "strikethrough-position",
        "strikethrough-thickness",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "text-anchor",
        "text-decoration",
        "text-rendering",
        "underline-position",
        "underline-thickness",
        "unicode-bidi",
        "unicode-range",
        "units-per-em",
        "v-alphabetic",
        "v-hanging",
        "v-ideographic",
        "v-mathematical",
        "vector-effect",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y",
        "word-spacing",
        "writing-mode",
        "xmlns:xlink",
        "x-height"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize2);
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          !1,
          // mustUseProperty
          attributeName,
          null,
          // attributeNamespace
          !1,
          // sanitizeURL
          !1
        );
      }), [
        "xlink:actuate",
        "xlink:arcrole",
        "xlink:role",
        "xlink:show",
        "xlink:title",
        "xlink:type"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize2);
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          !1,
          // mustUseProperty
          attributeName,
          "http://www.w3.org/1999/xlink",
          !1,
          // sanitizeURL
          !1
        );
      }), [
        "xml:base",
        "xml:lang",
        "xml:space"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize2);
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          !1,
          // mustUseProperty
          attributeName,
          "http://www.w3.org/XML/1998/namespace",
          !1,
          // sanitizeURL
          !1
        );
      }), ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(
          attributeName,
          STRING,
          !1,
          // mustUseProperty
          attributeName.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          !1,
          // sanitizeURL
          !1
        );
      });
      var xlinkHref = "xlinkHref";
      properties[xlinkHref] = new PropertyInfoRecord(
        "xlinkHref",
        STRING,
        !1,
        // mustUseProperty
        "xlink:href",
        "http://www.w3.org/1999/xlink",
        !0,
        // sanitizeURL
        !1
      ), ["src", "href", "action", "formAction"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(
          attributeName,
          STRING,
          !1,
          // mustUseProperty
          attributeName.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          !0,
          // sanitizeURL
          !0
        );
      });
      var isUnitlessNumber = {
        animationIterationCount: !0,
        aspectRatio: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridArea: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        // SVG-related properties
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0
      };
      function prefixKey(prefix2, key) {
        return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
      }
      var prefixes = ["Webkit", "ms", "Moz", "O"];
      Object.keys(isUnitlessNumber).forEach(function(prop) {
        prefixes.forEach(function(prefix2) {
          isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
        });
      });
      var hasReadOnlyValue = {
        button: !0,
        checkbox: !0,
        image: !0,
        hidden: !0,
        radio: !0,
        reset: !0,
        submit: !0
      };
      function checkControlledValueProps(tagName, props) {
        hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null || error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), props.onChange || props.readOnly || props.disabled || props.checked == null || error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
      }
      function isCustomComponent(tagName, props) {
        if (tagName.indexOf("-") === -1)
          return typeof props.is == "string";
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return !1;
          default:
            return !0;
        }
      }
      var ariaProperties = {
        "aria-current": 0,
        // state
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        // state
        "aria-hidden": 0,
        // state
        "aria-invalid": 0,
        // state
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        // Widget Attributes
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        // Live Region Attributes
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        // Drag-and-Drop Attributes
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        // Relationship Attributes
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      }, warnedProperties = {}, rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$"), rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
      function validateProperty(tagName, name) {
        {
          if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])
            return !0;
          if (rARIACamel.test(name)) {
            var ariaName = "aria-" + name.slice(4).toLowerCase(), correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
            if (correctName == null)
              return error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name), warnedProperties[name] = !0, !0;
            if (name !== correctName)
              return error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName), warnedProperties[name] = !0, !0;
          }
          if (rARIA.test(name)) {
            var lowerCasedName = name.toLowerCase(), standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
            if (standardName == null)
              return warnedProperties[name] = !0, !1;
            if (name !== standardName)
              return error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName), warnedProperties[name] = !0, !0;
          }
        }
        return !0;
      }
      function warnInvalidARIAProps(type, props) {
        {
          var invalidProps = [];
          for (var key in props) {
            var isValid = validateProperty(type, key);
            isValid || invalidProps.push(key);
          }
          var unknownPropString = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          invalidProps.length === 1 ? error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type) : invalidProps.length > 1 && error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
        }
      }
      function validateProperties(type, props) {
        isCustomComponent(type, props) || warnInvalidARIAProps(type, props);
      }
      var didWarnValueNull = !1;
      function validateProperties$1(type, props) {
        {
          if (type !== "input" && type !== "textarea" && type !== "select")
            return;
          props != null && props.value === null && !didWarnValueNull && (didWarnValueNull = !0, type === "select" && props.multiple ? error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type) : error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type));
        }
      }
      var possibleStandardNames = {
        // HTML
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        // SVG
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      }, validateProperty$1 = function() {
      };
      {
        var warnedProperties$1 = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$"), rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        validateProperty$1 = function(tagName, name, value, eventRegistry) {
          if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name])
            return !0;
          var lowerCasedName = name.toLowerCase();
          if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout")
            return error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), warnedProperties$1[name] = !0, !0;
          if (eventRegistry != null) {
            var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
            if (registrationNameDependencies.hasOwnProperty(name))
              return !0;
            var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
            if (registrationName != null)
              return error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName), warnedProperties$1[name] = !0, !0;
            if (EVENT_NAME_REGEX.test(name))
              return error("Unknown event handler property `%s`. It will be ignored.", name), warnedProperties$1[name] = !0, !0;
          } else if (EVENT_NAME_REGEX.test(name))
            return INVALID_EVENT_NAME_REGEX.test(name) && error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name), warnedProperties$1[name] = !0, !0;
          if (rARIA$1.test(name) || rARIACamel$1.test(name))
            return !0;
          if (lowerCasedName === "innerhtml")
            return error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), warnedProperties$1[name] = !0, !0;
          if (lowerCasedName === "aria")
            return error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), warnedProperties$1[name] = !0, !0;
          if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value != "string")
            return error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value), warnedProperties$1[name] = !0, !0;
          if (typeof value == "number" && isNaN(value))
            return error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name), warnedProperties$1[name] = !0, !0;
          var propertyInfo = getPropertyInfo(name), isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            var standardName = possibleStandardNames[lowerCasedName];
            if (standardName !== name)
              return error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName), warnedProperties$1[name] = !0, !0;
          } else if (!isReserved && name !== lowerCasedName)
            return error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName), warnedProperties$1[name] = !0, !0;
          return typeof value == "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, !1) ? (value ? error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name) : error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name), warnedProperties$1[name] = !0, !0) : isReserved ? !0 : shouldRemoveAttributeWithWarning(name, value, propertyInfo, !1) ? (warnedProperties$1[name] = !0, !1) : ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN && (error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value), warnedProperties$1[name] = !0), !0);
        };
      }
      var warnUnknownProperties = function(type, props, eventRegistry) {
        {
          var unknownProps = [];
          for (var key in props) {
            var isValid = validateProperty$1(type, key, props[key], eventRegistry);
            isValid || unknownProps.push(key);
          }
          var unknownPropString = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          unknownProps.length === 1 ? error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type) : unknownProps.length > 1 && error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
        }
      };
      function validateProperties$2(type, props, eventRegistry) {
        isCustomComponent(type, props) || warnUnknownProperties(type, props, eventRegistry);
      }
      var warnValidStyle = function() {
      };
      {
        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = !1, warnedForInfinityValue = !1, camelize = function(string) {
          return string.replace(hyphenPattern, function(_, character) {
            return character.toUpperCase();
          });
        }, warnHyphenatedStyleName = function(name) {
          warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = !0, error(
            "Unsupported style property %s. Did you mean %s?",
            name,
            // As Andi Smith suggests
            // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
            // is converted to lowercase `ms`.
            camelize(name.replace(msPattern, "ms-"))
          ));
        }, warnBadVendoredStyleName = function(name) {
          warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = !0, error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1)));
        }, warnStyleValueWithSemicolon = function(name, value) {
          warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value] || (warnedStyleValues[value] = !0, error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, "")));
        }, warnStyleValueIsNaN = function(name, value) {
          warnedForNaNValue || (warnedForNaNValue = !0, error("`NaN` is an invalid value for the `%s` css style property.", name));
        }, warnStyleValueIsInfinity = function(name, value) {
          warnedForInfinityValue || (warnedForInfinityValue = !0, error("`Infinity` is an invalid value for the `%s` css style property.", name));
        };
        warnValidStyle = function(name, value) {
          name.indexOf("-") > -1 ? warnHyphenatedStyleName(name) : badVendoredStyleNamePattern.test(name) ? warnBadVendoredStyleName(name) : badStyleValueWithSemicolonPattern.test(value) && warnStyleValueWithSemicolon(name, value), typeof value == "number" && (isNaN(value) ? warnStyleValueIsNaN(name, value) : isFinite(value) || warnStyleValueIsInfinity(name, value));
        };
      }
      var warnValidStyle$1 = warnValidStyle, matchHtmlRegExp = /["'&<>]/;
      function escapeHtml(string) {
        checkHtmlStringCoercion(string);
        var str = "" + string, match = matchHtmlRegExp.exec(str);
        if (!match)
          return str;
        var escape2, html = "", index, lastIndex = 0;
        for (index = match.index; index < str.length; index++) {
          switch (str.charCodeAt(index)) {
            case 34:
              escape2 = "&quot;";
              break;
            case 38:
              escape2 = "&amp;";
              break;
            case 39:
              escape2 = "&#x27;";
              break;
            case 60:
              escape2 = "&lt;";
              break;
            case 62:
              escape2 = "&gt;";
              break;
            default:
              continue;
          }
          lastIndex !== index && (html += str.substring(lastIndex, index)), lastIndex = index + 1, html += escape2;
        }
        return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
      }
      function escapeTextForBrowser(text) {
        return typeof text == "boolean" || typeof text == "number" ? "" + text : escapeHtml(text);
      }
      var uppercasePattern = /([A-Z])/g, msPattern$1 = /^ms-/;
      function hyphenateStyleName(name) {
        return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-");
      }
      var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, didWarn = !1;
      function sanitizeURL(url) {
        !didWarn && isJavaScriptProtocol.test(url) && (didWarn = !0, error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url)));
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      var startInlineScript = "<script>", endInlineScript = "</script>", startScriptSrc = '<script src="', startModuleSrc = '<script type="module" src="', endAsyncScript = '" async=""></script>';
      function escapeBootstrapScriptContent(scriptText) {
        return checkHtmlStringCoercion(scriptText), ("" + scriptText).replace(scriptRegex, scriptReplacer);
      }
      var scriptRegex = /(<\/|<)(s)(cript)/gi, scriptReplacer = function(match, prefix2, s2, suffix) {
        return "" + prefix2 + (s2 === "s" ? "\\u0073" : "\\u0053") + suffix;
      };
      function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
        var idPrefix = identifierPrefix === void 0 ? "" : identifierPrefix, inlineScriptWithNonce = nonce === void 0 ? startInlineScript : '<script nonce="' + escapeTextForBrowser(nonce) + '">', bootstrapChunks = [];
        if (bootstrapScriptContent !== void 0 && bootstrapChunks.push(inlineScriptWithNonce, escapeBootstrapScriptContent(bootstrapScriptContent), endInlineScript), bootstrapScripts !== void 0)
          for (var i2 = 0; i2 < bootstrapScripts.length; i2++)
            bootstrapChunks.push(startScriptSrc, escapeTextForBrowser(bootstrapScripts[i2]), endAsyncScript);
        if (bootstrapModules !== void 0)
          for (var _i = 0; _i < bootstrapModules.length; _i++)
            bootstrapChunks.push(startModuleSrc, escapeTextForBrowser(bootstrapModules[_i]), endAsyncScript);
        return {
          bootstrapChunks,
          startInlineScript: inlineScriptWithNonce,
          placeholderPrefix: idPrefix + "P:",
          segmentPrefix: idPrefix + "S:",
          boundaryPrefix: idPrefix + "B:",
          idPrefix,
          nextSuspenseID: 0,
          sentCompleteSegmentFunction: !1,
          sentCompleteBoundaryFunction: !1,
          sentClientRenderFunction: !1
        };
      }
      var ROOT_HTML_MODE = 0, HTML_MODE = 1, SVG_MODE = 2, MATHML_MODE = 3, HTML_TABLE_MODE = 4, HTML_TABLE_BODY_MODE = 5, HTML_TABLE_ROW_MODE = 6, HTML_COLGROUP_MODE = 7;
      function createFormatContext(insertionMode, selectedValue) {
        return {
          insertionMode,
          selectedValue
        };
      }
      function getChildFormatContext(parentContext, type, props) {
        switch (type) {
          case "select":
            return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);
          case "svg":
            return createFormatContext(SVG_MODE, null);
          case "math":
            return createFormatContext(MATHML_MODE, null);
          case "foreignObject":
            return createFormatContext(HTML_MODE, null);
          case "table":
            return createFormatContext(HTML_TABLE_MODE, null);
          case "thead":
          case "tbody":
          case "tfoot":
            return createFormatContext(HTML_TABLE_BODY_MODE, null);
          case "colgroup":
            return createFormatContext(HTML_COLGROUP_MODE, null);
          case "tr":
            return createFormatContext(HTML_TABLE_ROW_MODE, null);
        }
        return parentContext.insertionMode >= HTML_TABLE_MODE || parentContext.insertionMode === ROOT_HTML_MODE ? createFormatContext(HTML_MODE, null) : parentContext;
      }
      var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
      function assignSuspenseBoundaryID(responseState) {
        var generatedID = responseState.nextSuspenseID++;
        return responseState.boundaryPrefix + generatedID.toString(16);
      }
      function makeId(responseState, treeId, localId) {
        var idPrefix = responseState.idPrefix, id = ":" + idPrefix + "R" + treeId;
        return localId > 0 && (id += "H" + localId.toString(32)), id + ":";
      }
      function encodeHTMLTextNode(text) {
        return escapeTextForBrowser(text);
      }
      var textSeparator = "<!-- -->";
      function pushTextInstance(target, text, responseState, textEmbedded) {
        return text === "" ? textEmbedded : (textEmbedded && target.push(textSeparator), target.push(encodeHTMLTextNode(text)), !0);
      }
      function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {
        lastPushedText && textEmbedded && target.push(textSeparator);
      }
      var styleNameCache = /* @__PURE__ */ new Map();
      function processStyleName(styleName) {
        var chunk = styleNameCache.get(styleName);
        if (chunk !== void 0)
          return chunk;
        var result = escapeTextForBrowser(hyphenateStyleName(styleName));
        return styleNameCache.set(styleName, result), result;
      }
      var styleAttributeStart = ' style="', styleAssign = ":", styleSeparator = ";";
      function pushStyle(target, responseState, style) {
        if (typeof style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
        var isFirst = !0;
        for (var styleName in style)
          if (hasOwnProperty.call(style, styleName)) {
            var styleValue = style[styleName];
            if (!(styleValue == null || typeof styleValue == "boolean" || styleValue === "")) {
              var nameChunk = void 0, valueChunk = void 0, isCustomProperty = styleName.indexOf("--") === 0;
              isCustomProperty ? (nameChunk = escapeTextForBrowser(styleName), checkCSSPropertyStringCoercion(styleValue, styleName), valueChunk = escapeTextForBrowser(("" + styleValue).trim())) : (warnValidStyle$1(styleName, styleValue), nameChunk = processStyleName(styleName), typeof styleValue == "number" ? styleValue !== 0 && !hasOwnProperty.call(isUnitlessNumber, styleName) ? valueChunk = styleValue + "px" : valueChunk = "" + styleValue : (checkCSSPropertyStringCoercion(styleValue, styleName), valueChunk = escapeTextForBrowser(("" + styleValue).trim()))), isFirst ? (isFirst = !1, target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk)) : target.push(styleSeparator, nameChunk, styleAssign, valueChunk);
            }
          }
        isFirst || target.push(attributeEnd);
      }
      var attributeSeparator = " ", attributeAssign = '="', attributeEnd = '"', attributeEmptyString = '=""';
      function pushAttribute(target, responseState, name, value) {
        switch (name) {
          case "style": {
            pushStyle(target, responseState, value);
            return;
          }
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
            return;
        }
        if (
          // shouldIgnoreAttribute
          // We have already filtered out null/undefined and reserved words.
          !(name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N"))
        ) {
          var propertyInfo = getPropertyInfo(name);
          if (propertyInfo !== null) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
              case "boolean":
                if (!propertyInfo.acceptsBooleans)
                  return;
            }
            var attributeName = propertyInfo.attributeName, attributeNameChunk = attributeName;
            switch (propertyInfo.type) {
              case BOOLEAN:
                value && target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                return;
              case OVERLOADED_BOOLEAN:
                value === !0 ? target.push(attributeSeparator, attributeNameChunk, attributeEmptyString) : value === !1 || target.push(attributeSeparator, attributeNameChunk, attributeAssign, escapeTextForBrowser(value), attributeEnd);
                return;
              case NUMERIC:
                isNaN(value) || target.push(attributeSeparator, attributeNameChunk, attributeAssign, escapeTextForBrowser(value), attributeEnd);
                break;
              case POSITIVE_NUMERIC:
                !isNaN(value) && value >= 1 && target.push(attributeSeparator, attributeNameChunk, attributeAssign, escapeTextForBrowser(value), attributeEnd);
                break;
              default:
                propertyInfo.sanitizeURL && (checkAttributeStringCoercion(value, attributeName), value = "" + value, sanitizeURL(value)), target.push(attributeSeparator, attributeNameChunk, attributeAssign, escapeTextForBrowser(value), attributeEnd);
            }
          } else if (isAttributeNameSafe(name)) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
              case "boolean": {
                var prefix2 = name.toLowerCase().slice(0, 5);
                if (prefix2 !== "data-" && prefix2 !== "aria-")
                  return;
              }
            }
            target.push(attributeSeparator, name, attributeAssign, escapeTextForBrowser(value), attributeEnd);
          }
        }
      }
      var endOfStartTag = ">", endOfStartTagSelfClosing = "/>";
      function pushInnerHTML(target, innerHTML, children) {
        if (innerHTML != null) {
          if (children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof innerHTML != "object" || !("__html" in innerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
          var html = innerHTML.__html;
          html != null && (checkHtmlStringCoercion(html), target.push("" + html));
        }
      }
      var didWarnDefaultInputValue = !1, didWarnDefaultChecked = !1, didWarnDefaultSelectValue = !1, didWarnDefaultTextareaValue = !1, didWarnInvalidOptionChildren = !1, didWarnInvalidOptionInnerHTML = !1, didWarnSelectedSetOnOption = !1;
      function checkSelectProp(props, propName) {
        {
          var value = props[propName];
          if (value != null) {
            var array = isArray(value);
            props.multiple && !array ? error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName) : !props.multiple && array && error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
          }
        }
      }
      function pushStartSelect(target, props, responseState) {
        checkControlledValueProps("select", props), checkSelectProp(props, "value"), checkSelectProp(props, "defaultValue"), props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultSelectValue && (error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), didWarnDefaultSelectValue = !0), target.push(startChunkForTag("select"));
        var children = null, innerHTML = null;
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "defaultValue":
              case "value":
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        return target.push(endOfStartTag), pushInnerHTML(target, innerHTML, children), children;
      }
      function flattenOptionChildren(children) {
        var content = "";
        return React5.Children.forEach(children, function(child) {
          child != null && (content += child, !didWarnInvalidOptionChildren && typeof child != "string" && typeof child != "number" && (didWarnInvalidOptionChildren = !0, error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
        }), content;
      }
      var selectedMarkerAttribute = ' selected=""';
      function pushStartOption(target, props, responseState, formatContext) {
        var selectedValue = formatContext.selectedValue;
        target.push(startChunkForTag("option"));
        var children = null, value = null, selected = null, innerHTML = null;
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "selected":
                selected = propValue, didWarnSelectedSetOnOption || (error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), didWarnSelectedSetOnOption = !0);
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "value":
                value = propValue;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        if (selectedValue != null) {
          var stringValue;
          if (value !== null ? (checkAttributeStringCoercion(value, "value"), stringValue = "" + value) : (innerHTML !== null && (didWarnInvalidOptionInnerHTML || (didWarnInvalidOptionInnerHTML = !0, error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), stringValue = flattenOptionChildren(children)), isArray(selectedValue))
            for (var i2 = 0; i2 < selectedValue.length; i2++) {
              checkAttributeStringCoercion(selectedValue[i2], "value");
              var v = "" + selectedValue[i2];
              if (v === stringValue) {
                target.push(selectedMarkerAttribute);
                break;
              }
            }
          else
            checkAttributeStringCoercion(selectedValue, "select.value"), "" + selectedValue === stringValue && target.push(selectedMarkerAttribute);
        } else
          selected && target.push(selectedMarkerAttribute);
        return target.push(endOfStartTag), pushInnerHTML(target, innerHTML, children), children;
      }
      function pushInput(target, props, responseState) {
        checkControlledValueProps("input", props), props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnDefaultChecked && (error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type), didWarnDefaultChecked = !0), props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultInputValue && (error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type), didWarnDefaultInputValue = !0), target.push(startChunkForTag("input"));
        var value = null, defaultValue = null, checked = null, defaultChecked = null;
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              case "defaultChecked":
                defaultChecked = propValue;
                break;
              case "defaultValue":
                defaultValue = propValue;
                break;
              case "checked":
                checked = propValue;
                break;
              case "value":
                value = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        return checked !== null ? pushAttribute(target, responseState, "checked", checked) : defaultChecked !== null && pushAttribute(target, responseState, "checked", defaultChecked), value !== null ? pushAttribute(target, responseState, "value", value) : defaultValue !== null && pushAttribute(target, responseState, "value", defaultValue), target.push(endOfStartTagSelfClosing), null;
      }
      function pushStartTextArea(target, props, responseState) {
        checkControlledValueProps("textarea", props), props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultTextareaValue && (error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), didWarnDefaultTextareaValue = !0), target.push(startChunkForTag("textarea"));
        var value = null, defaultValue = null, children = null;
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "value":
                value = propValue;
                break;
              case "defaultValue":
                defaultValue = propValue;
                break;
              case "dangerouslySetInnerHTML":
                throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        if (value === null && defaultValue !== null && (value = defaultValue), target.push(endOfStartTag), children != null) {
          if (error("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), value != null)
            throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
          if (isArray(children)) {
            if (children.length > 1)
              throw new Error("<textarea> can only have at most one child.");
            checkHtmlStringCoercion(children[0]), value = "" + children[0];
          }
          checkHtmlStringCoercion(children), value = "" + children;
        }
        return typeof value == "string" && value[0] === `
` && target.push(leadingNewline), value !== null && (checkAttributeStringCoercion(value, "value"), target.push(encodeHTMLTextNode("" + value))), null;
      }
      function pushSelfClosing(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        return target.push(endOfStartTagSelfClosing), null;
      }
      function pushStartMenuItem(target, props, responseState) {
        target.push(startChunkForTag("menuitem"));
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        return target.push(endOfStartTag), null;
      }
      function pushStartTitle(target, props, responseState) {
        target.push(startChunkForTag("title"));
        var children = null;
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        target.push(endOfStartTag);
        {
          var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
          Array.isArray(children) && children.length > 1 ? error("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : child != null && child.$$typeof != null ? error("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : child != null && typeof child != "string" && typeof child != "number" && error("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
        }
        return children;
      }
      function pushStartGenericElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null, innerHTML = null;
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        return target.push(endOfStartTag), pushInnerHTML(target, innerHTML, children), typeof children == "string" ? (target.push(encodeHTMLTextNode(children)), null) : children;
      }
      function pushStartCustomElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null, innerHTML = null;
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "style":
                pushStyle(target, responseState, propValue);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                isAttributeNameSafe(propKey) && typeof propValue != "function" && typeof propValue != "symbol" && target.push(attributeSeparator, propKey, attributeAssign, escapeTextForBrowser(propValue), attributeEnd);
                break;
            }
          }
        return target.push(endOfStartTag), pushInnerHTML(target, innerHTML, children), children;
      }
      var leadingNewline = `
`;
      function pushStartPreformattedElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null, innerHTML = null;
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        if (target.push(endOfStartTag), innerHTML != null) {
          if (children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof innerHTML != "object" || !("__html" in innerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
          var html = innerHTML.__html;
          html != null && (typeof html == "string" && html.length > 0 && html[0] === `
` ? target.push(leadingNewline, html) : (checkHtmlStringCoercion(html), target.push("" + html)));
        }
        return typeof children == "string" && children[0] === `
` && target.push(leadingNewline), children;
      }
      var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, validatedTagCache = /* @__PURE__ */ new Map();
      function startChunkForTag(tag) {
        var tagStartChunk = validatedTagCache.get(tag);
        if (tagStartChunk === void 0) {
          if (!VALID_TAG_REGEX.test(tag))
            throw new Error("Invalid tag: " + tag);
          tagStartChunk = "<" + tag, validatedTagCache.set(tag, tagStartChunk);
        }
        return tagStartChunk;
      }
      var DOCTYPE = "<!DOCTYPE html>";
      function pushStartInstance(target, type, props, responseState, formatContext) {
        switch (validateProperties(type, props), validateProperties$1(type, props), validateProperties$2(type, props, null), !props.suppressContentEditableWarning && props.contentEditable && props.children != null && error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE && type.indexOf("-") === -1 && typeof props.is != "string" && type.toLowerCase() !== type && error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type), type) {
          case "select":
            return pushStartSelect(target, props, responseState);
          case "option":
            return pushStartOption(target, props, responseState, formatContext);
          case "textarea":
            return pushStartTextArea(target, props, responseState);
          case "input":
            return pushInput(target, props, responseState);
          case "menuitem":
            return pushStartMenuItem(target, props, responseState);
          case "title":
            return pushStartTitle(target, props, responseState);
          case "listing":
          case "pre":
            return pushStartPreformattedElement(target, props, type, responseState);
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
            return pushSelfClosing(target, props, type, responseState);
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return pushStartGenericElement(target, props, type, responseState);
          case "html":
            return formatContext.insertionMode === ROOT_HTML_MODE && target.push(DOCTYPE), pushStartGenericElement(target, props, type, responseState);
          default:
            return type.indexOf("-") === -1 && typeof props.is != "string" ? pushStartGenericElement(target, props, type, responseState) : pushStartCustomElement(target, props, type, responseState);
        }
      }
      var endTag1 = "</", endTag2 = ">";
      function pushEndInstance(target, type, props) {
        switch (type) {
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "input":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
            break;
          default:
            target.push(endTag1, type, endTag2);
        }
      }
      function writeCompletedRoot(destination, responseState) {
        for (var bootstrapChunks = responseState.bootstrapChunks, i2 = 0; i2 < bootstrapChunks.length - 1; i2++)
          writeChunk(destination, bootstrapChunks[i2]);
        return i2 < bootstrapChunks.length ? writeChunkAndReturn(destination, bootstrapChunks[i2]) : !0;
      }
      var placeholder1 = '<template id="', placeholder2 = '"></template>';
      function writePlaceholder(destination, responseState, id) {
        writeChunk(destination, placeholder1), writeChunk(destination, responseState.placeholderPrefix);
        var formattedID = id.toString(16);
        return writeChunk(destination, formattedID), writeChunkAndReturn(destination, placeholder2);
      }
      var startCompletedSuspenseBoundary = "<!--$-->", startPendingSuspenseBoundary1 = '<!--$?--><template id="', startPendingSuspenseBoundary2 = '"></template>', startClientRenderedSuspenseBoundary = "<!--$!-->", endSuspenseBoundary = "<!--/$-->", clientRenderedSuspenseBoundaryError1 = "<template", clientRenderedSuspenseBoundaryErrorAttrInterstitial = '"', clientRenderedSuspenseBoundaryError1A = ' data-dgst="', clientRenderedSuspenseBoundaryError1B = ' data-msg="', clientRenderedSuspenseBoundaryError1C = ' data-stck="', clientRenderedSuspenseBoundaryError2 = "></template>";
      function writeStartCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
      }
      function writeStartPendingSuspenseBoundary(destination, responseState, id) {
        if (writeChunk(destination, startPendingSuspenseBoundary1), id === null)
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        return writeChunk(destination, id), writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
      }
      function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
        var result;
        return result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary), writeChunk(destination, clientRenderedSuspenseBoundaryError1), errorDigest && (writeChunk(destination, clientRenderedSuspenseBoundaryError1A), writeChunk(destination, escapeTextForBrowser(errorDigest)), writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial)), errorMesssage && (writeChunk(destination, clientRenderedSuspenseBoundaryError1B), writeChunk(destination, escapeTextForBrowser(errorMesssage)), writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial)), errorComponentStack && (writeChunk(destination, clientRenderedSuspenseBoundaryError1C), writeChunk(destination, escapeTextForBrowser(errorComponentStack)), writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial)), result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2), result;
      }
      function writeEndCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      function writeEndPendingSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      var startSegmentHTML = '<div hidden id="', startSegmentHTML2 = '">', endSegmentHTML = "</div>", startSegmentSVG = '<svg aria-hidden="true" style="display:none" id="', startSegmentSVG2 = '">', endSegmentSVG = "</svg>", startSegmentMathML = '<math aria-hidden="true" style="display:none" id="', startSegmentMathML2 = '">', endSegmentMathML = "</math>", startSegmentTable = '<table hidden id="', startSegmentTable2 = '">', endSegmentTable = "</table>", startSegmentTableBody = '<table hidden><tbody id="', startSegmentTableBody2 = '">', endSegmentTableBody = "</tbody></table>", startSegmentTableRow = '<table hidden><tr id="', startSegmentTableRow2 = '">', endSegmentTableRow = "</tr></table>", startSegmentColGroup = '<table hidden><colgroup id="', startSegmentColGroup2 = '">', endSegmentColGroup = "</colgroup></table>";
      function writeStartSegment(destination, responseState, formatContext, id) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE:
            return writeChunk(destination, startSegmentHTML), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentHTML2);
          case SVG_MODE:
            return writeChunk(destination, startSegmentSVG), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentSVG2);
          case MATHML_MODE:
            return writeChunk(destination, startSegmentMathML), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentMathML2);
          case HTML_TABLE_MODE:
            return writeChunk(destination, startSegmentTable), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentTable2);
          case HTML_TABLE_BODY_MODE:
            return writeChunk(destination, startSegmentTableBody), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentTableBody2);
          case HTML_TABLE_ROW_MODE:
            return writeChunk(destination, startSegmentTableRow), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentTableRow2);
          case HTML_COLGROUP_MODE:
            return writeChunk(destination, startSegmentColGroup), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentColGroup2);
          default:
            throw new Error("Unknown insertion mode. This is a bug in React.");
        }
      }
      function writeEndSegment(destination, formatContext) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE:
            return writeChunkAndReturn(destination, endSegmentHTML);
          case SVG_MODE:
            return writeChunkAndReturn(destination, endSegmentSVG);
          case MATHML_MODE:
            return writeChunkAndReturn(destination, endSegmentMathML);
          case HTML_TABLE_MODE:
            return writeChunkAndReturn(destination, endSegmentTable);
          case HTML_TABLE_BODY_MODE:
            return writeChunkAndReturn(destination, endSegmentTableBody);
          case HTML_TABLE_ROW_MODE:
            return writeChunkAndReturn(destination, endSegmentTableRow);
          case HTML_COLGROUP_MODE:
            return writeChunkAndReturn(destination, endSegmentColGroup);
          default:
            throw new Error("Unknown insertion mode. This is a bug in React.");
        }
      }
      var completeSegmentFunction = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', completeSegmentScript1Full = completeSegmentFunction + ';$RS("', completeSegmentScript1Partial = '$RS("', completeSegmentScript2 = '","', completeSegmentScript3 = '")</script>';
      function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
        writeChunk(destination, responseState.startInlineScript), responseState.sentCompleteSegmentFunction ? writeChunk(destination, completeSegmentScript1Partial) : (responseState.sentCompleteSegmentFunction = !0, writeChunk(destination, completeSegmentScript1Full)), writeChunk(destination, responseState.segmentPrefix);
        var formattedID = contentSegmentID.toString(16);
        return writeChunk(destination, formattedID), writeChunk(destination, completeSegmentScript2), writeChunk(destination, responseState.placeholderPrefix), writeChunk(destination, formattedID), writeChunkAndReturn(destination, completeSegmentScript3);
      }
      var completeBoundaryScript1Full = completeBoundaryFunction + ';$RC("', completeBoundaryScript1Partial = '$RC("', completeBoundaryScript2 = '","', completeBoundaryScript3 = '")</script>';
      function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
        if (writeChunk(destination, responseState.startInlineScript), responseState.sentCompleteBoundaryFunction ? writeChunk(destination, completeBoundaryScript1Partial) : (responseState.sentCompleteBoundaryFunction = !0, writeChunk(destination, completeBoundaryScript1Full)), boundaryID === null)
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        var formattedContentID = contentSegmentID.toString(16);
        return writeChunk(destination, boundaryID), writeChunk(destination, completeBoundaryScript2), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, formattedContentID), writeChunkAndReturn(destination, completeBoundaryScript3);
      }
      var clientRenderScript1Full = clientRenderFunction + ';$RX("', clientRenderScript1Partial = '$RX("', clientRenderScript1A = '"', clientRenderScript2 = ")</script>", clientRenderErrorScriptArgInterstitial = ",";
      function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
        if (writeChunk(destination, responseState.startInlineScript), responseState.sentClientRenderFunction ? writeChunk(destination, clientRenderScript1Partial) : (responseState.sentClientRenderFunction = !0, writeChunk(destination, clientRenderScript1Full)), boundaryID === null)
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        return writeChunk(destination, boundaryID), writeChunk(destination, clientRenderScript1A), (errorDigest || errorMessage || errorComponentStack) && (writeChunk(destination, clientRenderErrorScriptArgInterstitial), writeChunk(destination, escapeJSStringsForInstructionScripts(errorDigest || ""))), (errorMessage || errorComponentStack) && (writeChunk(destination, clientRenderErrorScriptArgInterstitial), writeChunk(destination, escapeJSStringsForInstructionScripts(errorMessage || ""))), errorComponentStack && (writeChunk(destination, clientRenderErrorScriptArgInterstitial), writeChunk(destination, escapeJSStringsForInstructionScripts(errorComponentStack))), writeChunkAndReturn(destination, clientRenderScript2);
      }
      var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
      function escapeJSStringsForInstructionScripts(input) {
        var escaped = JSON.stringify(input);
        return escaped.replace(regexForJSStringsInScripts, function(match) {
          switch (match) {
            case "<":
              return "\\u003c";
            case "\u2028":
              return "\\u2028";
            case "\u2029":
              return "\\u2029";
            default:
              throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
          }
        });
      }
      function createResponseState$1(generateStaticMarkup, identifierPrefix) {
        var responseState = createResponseState(identifierPrefix, void 0);
        return {
          // Keep this in sync with ReactDOMServerFormatConfig
          bootstrapChunks: responseState.bootstrapChunks,
          startInlineScript: responseState.startInlineScript,
          placeholderPrefix: responseState.placeholderPrefix,
          segmentPrefix: responseState.segmentPrefix,
          boundaryPrefix: responseState.boundaryPrefix,
          idPrefix: responseState.idPrefix,
          nextSuspenseID: responseState.nextSuspenseID,
          sentCompleteSegmentFunction: responseState.sentCompleteSegmentFunction,
          sentCompleteBoundaryFunction: responseState.sentCompleteBoundaryFunction,
          sentClientRenderFunction: responseState.sentClientRenderFunction,
          // This is an extra field for the legacy renderer
          generateStaticMarkup
        };
      }
      function createRootFormatContext() {
        return {
          insertionMode: HTML_MODE,
          // We skip the root mode because we don't want to emit the DOCTYPE in legacy mode.
          selectedValue: null
        };
      }
      function pushTextInstance$1(target, text, responseState, textEmbedded) {
        return responseState.generateStaticMarkup ? (target.push(escapeTextForBrowser(text)), !1) : pushTextInstance(target, text, responseState, textEmbedded);
      }
      function pushSegmentFinale$1(target, responseState, lastPushedText, textEmbedded) {
        if (!responseState.generateStaticMarkup)
          return pushSegmentFinale(target, responseState, lastPushedText, textEmbedded);
      }
      function writeStartCompletedSuspenseBoundary$1(destination, responseState) {
        return responseState.generateStaticMarkup ? !0 : writeStartCompletedSuspenseBoundary(destination);
      }
      function writeStartClientRenderedSuspenseBoundary$1(destination, responseState, errorDigest, errorMessage, errorComponentStack) {
        return responseState.generateStaticMarkup ? !0 : writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMessage, errorComponentStack);
      }
      function writeEndCompletedSuspenseBoundary$1(destination, responseState) {
        return responseState.generateStaticMarkup ? !0 : writeEndCompletedSuspenseBoundary(destination);
      }
      function writeEndClientRenderedSuspenseBoundary$1(destination, responseState) {
        return responseState.generateStaticMarkup ? !0 : writeEndClientRenderedSuspenseBoundary(destination);
      }
      var assign = Object.assign, REACT_ELEMENT_TYPE = Symbol.for("react.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_SCOPE_TYPE = Symbol.for("react.scope"), REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode"), REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"), REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for("react.default_value"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable != "object")
          return null;
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        return typeof maybeIterator == "function" ? maybeIterator : null;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName)
          return displayName;
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null)
          return null;
        if (typeof type.tag == "number" && error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof type == "function")
          return type.displayName || type.name || null;
        if (typeof type == "string")
          return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type == "object")
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              return outerName !== null ? outerName : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type, payload = lazyComponent._payload, init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = !0;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log, prevInfo = console.info, prevWarn = console.warn, prevError = console.error, prevGroup = console.group, prevGroupCollapsed = console.groupCollapsed, prevGroupEnd = console.groupEnd;
            var props = {
              configurable: !0,
              enumerable: !0,
              value: disabledLog,
              writable: !0
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          if (disabledDepth--, disabledDepth === 0) {
            var props = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          disabledDepth < 0 && error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher, prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === void 0)
            try {
              throw Error();
            } catch (x2) {
              var match = x2.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          return `
` + prefix + name;
        }
      }
      var reentry = !1, componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap == "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry)
          return "";
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0)
            return frame;
        }
        var control;
        reentry = !0;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        previousDispatcher = ReactCurrentDispatcher.current, ReactCurrentDispatcher.current = null, disableLogs();
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            if (Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x2) {
                control = x2;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x2) {
                control = x2;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x2) {
              control = x2;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack == "string") {
            for (var sampleLines = sample.stack.split(`
`), controlLines = control.stack.split(`
`), s2 = sampleLines.length - 1, c = controlLines.length - 1; s2 >= 1 && c >= 0 && sampleLines[s2] !== controlLines[c]; )
              c--;
            for (; s2 >= 1 && c >= 0; s2--, c--)
              if (sampleLines[s2] !== controlLines[c]) {
                if (s2 !== 1 || c !== 1)
                  do
                    if (s2--, c--, c < 0 || sampleLines[s2] !== controlLines[c]) {
                      var _frame = `
` + sampleLines[s2].replace(" at new ", " at ");
                      return fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName)), typeof fn == "function" && componentFrameCache.set(fn, _frame), _frame;
                    }
                  while (s2 >= 1 && c >= 0);
                break;
              }
          }
        } finally {
          reentry = !1, ReactCurrentDispatcher.current = previousDispatcher, reenableLogs(), Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "", syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        return typeof fn == "function" && componentFrameCache.set(fn, syntheticFrame), syntheticFrame;
      }
      function describeClassComponentFrame(ctor, source, ownerFn) {
        return describeNativeComponentFrame(ctor, !0);
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        return describeNativeComponentFrame(fn, !1);
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null)
          return "";
        if (typeof type == "function")
          return describeNativeComponentFrame(type, shouldConstruct(type));
        if (typeof type == "string")
          return describeBuiltInComponentFrame(type);
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type == "object")
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type, payload = lazyComponent._payload, init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch {
              }
            }
          }
        return "";
      }
      var loggedTypeFailures = {}, ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        if (element) {
          var owner = element._owner, stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame.setExtraStackFrame(stack);
        } else
          ReactDebugCurrentFrame.setExtraStackFrame(null);
      }
      function checkPropTypes(typeSpecs, values, location, componentName, element) {
        {
          var has2 = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs)
            if (has2(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] != "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw err.name = "Invariant Violation", err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              error$1 && !(error$1 instanceof Error) && (setCurrentlyValidatingElement(element), error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1), setCurrentlyValidatingElement(null)), error$1 instanceof Error && !(error$1.message in loggedTypeFailures) && (loggedTypeFailures[error$1.message] = !0, setCurrentlyValidatingElement(element), error("Failed %s type: %s", location, error$1.message), setCurrentlyValidatingElement(null));
            }
        }
      }
      var warnedAboutMissingGetChildContext;
      warnedAboutMissingGetChildContext = {};
      var emptyContextObject = {};
      Object.freeze(emptyContextObject);
      function getMaskedContext(type, unmaskedContext) {
        {
          var contextTypes = type.contextTypes;
          if (!contextTypes)
            return emptyContextObject;
          var context = {};
          for (var key in contextTypes)
            context[key] = unmaskedContext[key];
          {
            var name = getComponentNameFromType(type) || "Unknown";
            checkPropTypes(contextTypes, context, "context", name);
          }
          return context;
        }
      }
      function processChildContext(instance, type, parentContext, childContextTypes) {
        {
          if (typeof instance.getChildContext != "function") {
            {
              var componentName = getComponentNameFromType(type) || "Unknown";
              warnedAboutMissingGetChildContext[componentName] || (warnedAboutMissingGetChildContext[componentName] = !0, error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName));
            }
            return parentContext;
          }
          var childContext = instance.getChildContext();
          for (var contextKey in childContext)
            if (!(contextKey in childContextTypes))
              throw new Error((getComponentNameFromType(type) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
          {
            var name = getComponentNameFromType(type) || "Unknown";
            checkPropTypes(childContextTypes, childContext, "child context", name);
          }
          return assign({}, parentContext, childContext);
        }
      }
      var rendererSigil;
      rendererSigil = {};
      var rootContextSnapshot = null, currentActiveSnapshot = null;
      function popNode(prev) {
        prev.context._currentValue2 = prev.parentValue;
      }
      function pushNode(next) {
        next.context._currentValue2 = next.value;
      }
      function popToNearestCommonAncestor(prev, next) {
        if (prev !== next) {
          popNode(prev);
          var parentPrev = prev.parent, parentNext = next.parent;
          if (parentPrev === null) {
            if (parentNext !== null)
              throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          } else {
            if (parentNext === null)
              throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
            popToNearestCommonAncestor(parentPrev, parentNext);
          }
          pushNode(next);
        }
      }
      function popAllPrevious(prev) {
        popNode(prev);
        var parentPrev = prev.parent;
        parentPrev !== null && popAllPrevious(parentPrev);
      }
      function pushAllNext(next) {
        var parentNext = next.parent;
        parentNext !== null && pushAllNext(parentNext), pushNode(next);
      }
      function popPreviousToCommonLevel(prev, next) {
        popNode(prev);
        var parentPrev = prev.parent;
        if (parentPrev === null)
          throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
        parentPrev.depth === next.depth ? popToNearestCommonAncestor(parentPrev, next) : popPreviousToCommonLevel(parentPrev, next);
      }
      function popNextToCommonLevel(prev, next) {
        var parentNext = next.parent;
        if (parentNext === null)
          throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
        prev.depth === parentNext.depth ? popToNearestCommonAncestor(prev, parentNext) : popNextToCommonLevel(prev, parentNext), pushNode(next);
      }
      function switchContext(newSnapshot) {
        var prev = currentActiveSnapshot, next = newSnapshot;
        prev !== next && (prev === null ? pushAllNext(next) : next === null ? popAllPrevious(prev) : prev.depth === next.depth ? popToNearestCommonAncestor(prev, next) : prev.depth > next.depth ? popPreviousToCommonLevel(prev, next) : popNextToCommonLevel(prev, next), currentActiveSnapshot = next);
      }
      function pushProvider(context, nextValue) {
        var prevValue;
        prevValue = context._currentValue2, context._currentValue2 = nextValue, context._currentRenderer2 !== void 0 && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil && error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), context._currentRenderer2 = rendererSigil;
        var prevNode = currentActiveSnapshot, newNode = {
          parent: prevNode,
          depth: prevNode === null ? 0 : prevNode.depth + 1,
          context,
          parentValue: prevValue,
          value: nextValue
        };
        return currentActiveSnapshot = newNode, newNode;
      }
      function popProvider(context) {
        var prevSnapshot = currentActiveSnapshot;
        if (prevSnapshot === null)
          throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
        prevSnapshot.context !== context && error("The parent context is not the expected context. This is probably a bug in React.");
        {
          var _value = prevSnapshot.parentValue;
          _value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED ? prevSnapshot.context._currentValue2 = prevSnapshot.context._defaultValue : prevSnapshot.context._currentValue2 = _value, context._currentRenderer2 !== void 0 && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil && error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), context._currentRenderer2 = rendererSigil;
        }
        return currentActiveSnapshot = prevSnapshot.parent;
      }
      function getActiveContext() {
        return currentActiveSnapshot;
      }
      function readContext(context) {
        var value = context._currentValue2;
        return value;
      }
      function get(key) {
        return key._reactInternals;
      }
      function set(key, value) {
        key._reactInternals = value;
      }
      var didWarnAboutNoopUpdateForComponent = {}, didWarnAboutDeprecatedWillMount = {}, didWarnAboutUninitializedState, didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate, didWarnAboutLegacyLifecyclesAndDerivedState, didWarnAboutUndefinedDerivedState, warnOnUndefinedDerivedState, warnOnInvalidCallback, didWarnAboutDirectlyAssigningPropsToState, didWarnAboutContextTypeAndContextTypes, didWarnAboutInvalidateContextType;
      {
        didWarnAboutUninitializedState = /* @__PURE__ */ new Set(), didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set(), didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set(), didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set(), didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set(), didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set(), didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
        var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
        warnOnInvalidCallback = function(callback, callerName) {
          if (!(callback === null || typeof callback == "function")) {
            var key = callerName + "_" + callback;
            didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback));
          }
        }, warnOnUndefinedDerivedState = function(type, partialState) {
          if (partialState === void 0) {
            var componentName = getComponentNameFromType(type) || "Component";
            didWarnAboutUndefinedDerivedState.has(componentName) || (didWarnAboutUndefinedDerivedState.add(componentName), error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName));
          }
        };
      }
      function warnNoop(publicInstance, callerName) {
        {
          var _constructor = publicInstance.constructor, componentName = _constructor && getComponentNameFromType(_constructor) || "ReactClass", warningKey = componentName + "." + callerName;
          if (didWarnAboutNoopUpdateForComponent[warningKey])
            return;
          error(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, callerName, callerName, componentName), didWarnAboutNoopUpdateForComponent[warningKey] = !0;
        }
      }
      var classComponentUpdater = {
        isMounted: function(inst) {
          return !1;
        },
        enqueueSetState: function(inst, payload, callback) {
          var internals = get(inst);
          internals.queue === null ? warnNoop(inst, "setState") : (internals.queue.push(payload), callback != null && warnOnInvalidCallback(callback, "setState"));
        },
        enqueueReplaceState: function(inst, payload, callback) {
          var internals = get(inst);
          internals.replace = !0, internals.queue = [payload], callback != null && warnOnInvalidCallback(callback, "setState");
        },
        enqueueForceUpdate: function(inst, callback) {
          var internals = get(inst);
          internals.queue === null ? warnNoop(inst, "forceUpdate") : callback != null && warnOnInvalidCallback(callback, "setState");
        }
      };
      function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {
        var partialState = getDerivedStateFromProps(nextProps, prevState);
        warnOnUndefinedDerivedState(ctor, partialState);
        var newState = partialState == null ? prevState : assign({}, prevState, partialState);
        return newState;
      }
      function constructClassInstance(ctor, props, maskedLegacyContext) {
        var context = emptyContextObject, contextType = ctor.contextType;
        if ("contextType" in ctor) {
          var isValid = (
            // Allow null for conditional declaration
            contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0
          );
          if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
            didWarnAboutInvalidateContextType.add(ctor);
            var addendum = "";
            contextType === void 0 ? addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof contextType != "object" ? addendum = " However, it is set to a " + typeof contextType + "." : contextType.$$typeof === REACT_PROVIDER_TYPE ? addendum = " Did you accidentally pass the Context.Provider instead?" : contextType._context !== void 0 ? addendum = " Did you accidentally pass the Context.Consumer instead?" : addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.", error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
          }
        }
        typeof contextType == "object" && contextType !== null ? context = readContext(contextType) : context = maskedLegacyContext;
        var instance = new ctor(props, context);
        {
          if (typeof ctor.getDerivedStateFromProps == "function" && (instance.state === null || instance.state === void 0)) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            didWarnAboutUninitializedState.has(componentName) || (didWarnAboutUninitializedState.add(componentName), error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName));
          }
          if (typeof ctor.getDerivedStateFromProps == "function" || typeof instance.getSnapshotBeforeUpdate == "function") {
            var foundWillMountName = null, foundWillReceivePropsName = null, foundWillUpdateName = null;
            if (typeof instance.componentWillMount == "function" && instance.componentWillMount.__suppressDeprecationWarning !== !0 ? foundWillMountName = "componentWillMount" : typeof instance.UNSAFE_componentWillMount == "function" && (foundWillMountName = "UNSAFE_componentWillMount"), typeof instance.componentWillReceiveProps == "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? foundWillReceivePropsName = "componentWillReceiveProps" : typeof instance.UNSAFE_componentWillReceiveProps == "function" && (foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps"), typeof instance.componentWillUpdate == "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== !0 ? foundWillUpdateName = "componentWillUpdate" : typeof instance.UNSAFE_componentWillUpdate == "function" && (foundWillUpdateName = "UNSAFE_componentWillUpdate"), foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
              var _componentName = getComponentNameFromType(ctor) || "Component", newApiName = typeof ctor.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
              didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName), error(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, _componentName, newApiName, foundWillMountName !== null ? `
  ` + foundWillMountName : "", foundWillReceivePropsName !== null ? `
  ` + foundWillReceivePropsName : "", foundWillUpdateName !== null ? `
  ` + foundWillUpdateName : ""));
            }
          }
        }
        return instance;
      }
      function checkClassInstance(instance, ctor, newProps) {
        {
          var name = getComponentNameFromType(ctor) || "Component", renderPresent = instance.render;
          renderPresent || (ctor.prototype && typeof ctor.prototype.render == "function" ? error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name) : error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name)), instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state && error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name), instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved && error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name), instance.propTypes && error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name), instance.contextType && error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name), instance.contextTypes && error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name), ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor) && (didWarnAboutContextTypeAndContextTypes.add(ctor), error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name)), typeof instance.componentShouldUpdate == "function" && error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name), ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate < "u" && error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component"), typeof instance.componentDidUnmount == "function" && error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name), typeof instance.componentDidReceiveProps == "function" && error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name), typeof instance.componentWillRecieveProps == "function" && error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name), typeof instance.UNSAFE_componentWillRecieveProps == "function" && error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
          var hasMutatedProps = instance.props !== newProps;
          instance.props !== void 0 && hasMutatedProps && error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name), instance.defaultProps && error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name), typeof instance.getSnapshotBeforeUpdate == "function" && typeof instance.componentDidUpdate != "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor) && (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor), error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor))), typeof instance.getDerivedStateFromProps == "function" && error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name), typeof instance.getDerivedStateFromError == "function" && error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name), typeof ctor.getSnapshotBeforeUpdate == "function" && error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
          var _state = instance.state;
          _state && (typeof _state != "object" || isArray(_state)) && error("%s.state: must be set to an object or null", name), typeof instance.getChildContext == "function" && typeof ctor.childContextTypes != "object" && error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
        }
      }
      function callComponentWillMount(type, instance) {
        var oldState = instance.state;
        if (typeof instance.componentWillMount == "function") {
          if (instance.componentWillMount.__suppressDeprecationWarning !== !0) {
            var componentName = getComponentNameFromType(type) || "Unknown";
            didWarnAboutDeprecatedWillMount[componentName] || (warn(
              // keep this warning in sync with ReactStrictModeWarning.js
              `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
              componentName
            ), didWarnAboutDeprecatedWillMount[componentName] = !0);
          }
          instance.componentWillMount();
        }
        typeof instance.UNSAFE_componentWillMount == "function" && instance.UNSAFE_componentWillMount(), oldState !== instance.state && (error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type) || "Component"), classComponentUpdater.enqueueReplaceState(instance, instance.state, null));
      }
      function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {
        if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
          var oldQueue = internalInstance.queue, oldReplace = internalInstance.replace;
          if (internalInstance.queue = null, internalInstance.replace = !1, oldReplace && oldQueue.length === 1)
            inst.state = oldQueue[0];
          else {
            for (var nextState = oldReplace ? oldQueue[0] : inst.state, dontMutate = !0, i2 = oldReplace ? 1 : 0; i2 < oldQueue.length; i2++) {
              var partial = oldQueue[i2], partialState = typeof partial == "function" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;
              partialState != null && (dontMutate ? (dontMutate = !1, nextState = assign({}, nextState, partialState)) : assign(nextState, partialState));
            }
            inst.state = nextState;
          }
        } else
          internalInstance.queue = null;
      }
      function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {
        checkClassInstance(instance, ctor, newProps);
        var initialState = instance.state !== void 0 ? instance.state : null;
        instance.updater = classComponentUpdater, instance.props = newProps, instance.state = initialState;
        var internalInstance = {
          queue: [],
          replace: !1
        };
        set(instance, internalInstance);
        var contextType = ctor.contextType;
        if (typeof contextType == "object" && contextType !== null ? instance.context = readContext(contextType) : instance.context = maskedLegacyContext, instance.state === newProps) {
          var componentName = getComponentNameFromType(ctor) || "Component";
          didWarnAboutDirectlyAssigningPropsToState.has(componentName) || (didWarnAboutDirectlyAssigningPropsToState.add(componentName), error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName));
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        typeof getDerivedStateFromProps == "function" && (instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps)), typeof ctor.getDerivedStateFromProps != "function" && typeof instance.getSnapshotBeforeUpdate != "function" && (typeof instance.UNSAFE_componentWillMount == "function" || typeof instance.componentWillMount == "function") && (callComponentWillMount(ctor, instance), processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext));
      }
      var emptyTreeContext = {
        id: 1,
        overflow: ""
      };
      function getTreeId(context) {
        var overflow = context.overflow, idWithLeadingBit = context.id, id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
        return id.toString(32) + overflow;
      }
      function pushTreeContext(baseContext, totalChildren, index) {
        var baseIdWithLeadingBit = baseContext.id, baseOverflow = baseContext.overflow, baseLength = getBitLength(baseIdWithLeadingBit) - 1, baseId = baseIdWithLeadingBit & ~(1 << baseLength), slot = index + 1, length = getBitLength(totalChildren) + baseLength;
        if (length > 30) {
          var numberOfOverflowBits = baseLength - baseLength % 5, newOverflowBits = (1 << numberOfOverflowBits) - 1, newOverflow = (baseId & newOverflowBits).toString(32), restOfBaseId = baseId >> numberOfOverflowBits, restOfBaseLength = baseLength - numberOfOverflowBits, restOfLength = getBitLength(totalChildren) + restOfBaseLength, restOfNewBits = slot << restOfBaseLength, id = restOfNewBits | restOfBaseId, overflow = newOverflow + baseOverflow;
          return {
            id: 1 << restOfLength | id,
            overflow
          };
        } else {
          var newBits = slot << baseLength, _id = newBits | baseId, _overflow = baseOverflow;
          return {
            id: 1 << length | _id,
            overflow: _overflow
          };
        }
      }
      function getBitLength(number) {
        return 32 - clz32(number);
      }
      function getLeadingBit(id) {
        return 1 << getBitLength(id) - 1;
      }
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2;
      function clz32Fallback(x2) {
        var asUint = x2 >>> 0;
        return asUint === 0 ? 32 : 31 - (log(asUint) / LN2 | 0) | 0;
      }
      function is(x2, y) {
        return x2 === y && (x2 !== 0 || 1 / x2 === 1 / y) || x2 !== x2 && y !== y;
      }
      var objectIs = typeof Object.is == "function" ? Object.is : is, currentlyRenderingComponent = null, currentlyRenderingTask = null, firstWorkInProgressHook = null, workInProgressHook = null, isReRender = !1, didScheduleRenderPhaseUpdate = !1, localIdCounter = 0, renderPhaseUpdates = null, numberOfReRenders = 0, RE_RENDER_LIMIT = 25, isInHookUserCodeInDev = !1, currentHookNameInDev;
      function resolveCurrentlyRenderingComponent() {
        if (currentlyRenderingComponent === null)
          throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
        return isInHookUserCodeInDev && error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), currentlyRenderingComponent;
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (prevDeps === null)
          return error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev), !1;
        nextDeps.length !== prevDeps.length && error(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
        for (var i2 = 0; i2 < prevDeps.length && i2 < nextDeps.length; i2++)
          if (!objectIs(nextDeps[i2], prevDeps[i2]))
            return !1;
        return !0;
      }
      function createHook() {
        if (numberOfReRenders > 0)
          throw new Error("Rendered more hooks than during the previous render");
        return {
          memoizedState: null,
          queue: null,
          next: null
        };
      }
      function createWorkInProgressHook() {
        return workInProgressHook === null ? firstWorkInProgressHook === null ? (isReRender = !1, firstWorkInProgressHook = workInProgressHook = createHook()) : (isReRender = !0, workInProgressHook = firstWorkInProgressHook) : workInProgressHook.next === null ? (isReRender = !1, workInProgressHook = workInProgressHook.next = createHook()) : (isReRender = !0, workInProgressHook = workInProgressHook.next), workInProgressHook;
      }
      function prepareToUseHooks(task, componentIdentity) {
        currentlyRenderingComponent = componentIdentity, currentlyRenderingTask = task, isInHookUserCodeInDev = !1, localIdCounter = 0;
      }
      function finishHooks(Component, props, children, refOrContext) {
        for (; didScheduleRenderPhaseUpdate; )
          didScheduleRenderPhaseUpdate = !1, localIdCounter = 0, numberOfReRenders += 1, workInProgressHook = null, children = Component(props, refOrContext);
        return resetHooksState(), children;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = localIdCounter !== 0;
        return didRenderIdHook;
      }
      function resetHooksState() {
        isInHookUserCodeInDev = !1, currentlyRenderingComponent = null, currentlyRenderingTask = null, didScheduleRenderPhaseUpdate = !1, firstWorkInProgressHook = null, numberOfReRenders = 0, renderPhaseUpdates = null, workInProgressHook = null;
      }
      function readContext$1(context) {
        return isInHookUserCodeInDev && error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), readContext(context);
      }
      function useContext(context) {
        return currentHookNameInDev = "useContext", resolveCurrentlyRenderingComponent(), readContext(context);
      }
      function basicStateReducer(state, action3) {
        return typeof action3 == "function" ? action3(state) : action3;
      }
      function useState(initialState) {
        return currentHookNameInDev = "useState", useReducer(
          basicStateReducer,
          // useReducer has a special case to support lazy useState initializers
          initialState
        );
      }
      function useReducer(reducer, initialArg, init) {
        if (reducer !== basicStateReducer && (currentHookNameInDev = "useReducer"), currentlyRenderingComponent = resolveCurrentlyRenderingComponent(), workInProgressHook = createWorkInProgressHook(), isReRender) {
          var queue = workInProgressHook.queue, dispatch = queue.dispatch;
          if (renderPhaseUpdates !== null) {
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
            if (firstRenderPhaseUpdate !== void 0) {
              renderPhaseUpdates.delete(queue);
              var newState = workInProgressHook.memoizedState, update = firstRenderPhaseUpdate;
              do {
                var action3 = update.action;
                isInHookUserCodeInDev = !0, newState = reducer(newState, action3), isInHookUserCodeInDev = !1, update = update.next;
              } while (update !== null);
              return workInProgressHook.memoizedState = newState, [newState, dispatch];
            }
          }
          return [workInProgressHook.memoizedState, dispatch];
        } else {
          isInHookUserCodeInDev = !0;
          var initialState;
          reducer === basicStateReducer ? initialState = typeof initialArg == "function" ? initialArg() : initialArg : initialState = init !== void 0 ? init(initialArg) : initialArg, isInHookUserCodeInDev = !1, workInProgressHook.memoizedState = initialState;
          var _queue = workInProgressHook.queue = {
            last: null,
            dispatch: null
          }, _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
          return [workInProgressHook.memoizedState, _dispatch];
        }
      }
      function useMemo(nextCreate, deps) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent(), workInProgressHook = createWorkInProgressHook();
        var nextDeps = deps === void 0 ? null : deps;
        if (workInProgressHook !== null) {
          var prevState = workInProgressHook.memoizedState;
          if (prevState !== null && nextDeps !== null) {
            var prevDeps = prevState[1];
            if (areHookInputsEqual(nextDeps, prevDeps))
              return prevState[0];
          }
        }
        isInHookUserCodeInDev = !0;
        var nextValue = nextCreate();
        return isInHookUserCodeInDev = !1, workInProgressHook.memoizedState = [nextValue, nextDeps], nextValue;
      }
      function useRef(initialValue) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent(), workInProgressHook = createWorkInProgressHook();
        var previousRef = workInProgressHook.memoizedState;
        if (previousRef === null) {
          var ref = {
            current: initialValue
          };
          return Object.seal(ref), workInProgressHook.memoizedState = ref, ref;
        } else
          return previousRef;
      }
      function useLayoutEffect(create, inputs) {
        currentHookNameInDev = "useLayoutEffect", error("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
      }
      function dispatchAction(componentIdentity, queue, action3) {
        if (numberOfReRenders >= RE_RENDER_LIMIT)
          throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
        if (componentIdentity === currentlyRenderingComponent) {
          didScheduleRenderPhaseUpdate = !0;
          var update = {
            action: action3,
            next: null
          };
          renderPhaseUpdates === null && (renderPhaseUpdates = /* @__PURE__ */ new Map());
          var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
          if (firstRenderPhaseUpdate === void 0)
            renderPhaseUpdates.set(queue, update);
          else {
            for (var lastRenderPhaseUpdate = firstRenderPhaseUpdate; lastRenderPhaseUpdate.next !== null; )
              lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            lastRenderPhaseUpdate.next = update;
          }
        }
      }
      function useCallback(callback, deps) {
        return useMemo(function() {
          return callback;
        }, deps);
      }
      function useMutableSource(source, getSnapshot, subscribe) {
        return resolveCurrentlyRenderingComponent(), getSnapshot(source._source);
      }
      function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        if (getServerSnapshot === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        return getServerSnapshot();
      }
      function useDeferredValue(value) {
        return resolveCurrentlyRenderingComponent(), value;
      }
      function unsupportedStartTransition() {
        throw new Error("startTransition cannot be called during server rendering.");
      }
      function useTransition() {
        return resolveCurrentlyRenderingComponent(), [!1, unsupportedStartTransition];
      }
      function useId() {
        var task = currentlyRenderingTask, treeId = getTreeId(task.treeContext), responseState = currentResponseState;
        if (responseState === null)
          throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
        var localId = localIdCounter++;
        return makeId(responseState, treeId, localId);
      }
      function noop2() {
      }
      var Dispatcher = {
        readContext: readContext$1,
        useContext,
        useMemo,
        useReducer,
        useRef,
        useState,
        useInsertionEffect: noop2,
        useLayoutEffect,
        useCallback,
        // useImperativeHandle is not run in the server environment
        useImperativeHandle: noop2,
        // Effects are not run in the server environment.
        useEffect: noop2,
        // Debugging effect
        useDebugValue: noop2,
        useDeferredValue,
        useTransition,
        useId,
        // Subscriptions are not setup in a server environment.
        useMutableSource,
        useSyncExternalStore
      }, currentResponseState = null;
      function setCurrentResponseState(responseState) {
        currentResponseState = responseState;
      }
      function getStackByComponentStackNode(componentStack) {
        try {
          var info = "", node = componentStack;
          do {
            switch (node.tag) {
              case 0:
                info += describeBuiltInComponentFrame(node.type, null, null);
                break;
              case 1:
                info += describeFunctionComponentFrame(node.type, null, null);
                break;
              case 2:
                info += describeClassComponentFrame(node.type, null, null);
                break;
            }
            node = node.parent;
          } while (node);
          return info;
        } catch (x2) {
          return `
Error generating stack: ` + x2.message + `
` + x2.stack;
        }
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame, PENDING = 0, COMPLETED = 1, FLUSHED = 2, ABORTED = 3, ERRORED = 4, OPEN = 0, CLOSING = 1, CLOSED = 2, DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
      function defaultErrorHandler(error2) {
        return console.error(error2), null;
      }
      function noop$1() {
      }
      function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError) {
        var pingedTasks = [], abortSet = /* @__PURE__ */ new Set(), request = {
          destination: null,
          responseState,
          progressiveChunkSize: progressiveChunkSize === void 0 ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
          status: OPEN,
          fatalError: null,
          nextSegmentId: 0,
          allPendingTasks: 0,
          pendingRootTasks: 0,
          completedRootSegment: null,
          abortableTasks: abortSet,
          pingedTasks,
          clientRenderedBoundaries: [],
          completedBoundaries: [],
          partialBoundaries: [],
          onError: onError2 === void 0 ? defaultErrorHandler : onError2,
          onAllReady: onAllReady === void 0 ? noop$1 : onAllReady,
          onShellReady: onShellReady === void 0 ? noop$1 : onShellReady,
          onShellError: onShellError === void 0 ? noop$1 : onShellError,
          onFatalError: onFatalError === void 0 ? noop$1 : onFatalError
        }, rootSegment = createPendingSegment(
          request,
          0,
          null,
          rootFormatContext,
          // Root segments are never embedded in Text on either edge
          !1,
          !1
        );
        rootSegment.parentFlushed = !0;
        var rootTask = createTask(request, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
        return pingedTasks.push(rootTask), request;
      }
      function pingTask(request, task) {
        var pingedTasks = request.pingedTasks;
        pingedTasks.push(task), pingedTasks.length === 1 && scheduleWork(function() {
          return performWork(request);
        });
      }
      function createSuspenseBoundary(request, fallbackAbortableTasks) {
        return {
          id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
          rootSegmentID: -1,
          parentFlushed: !1,
          pendingTasks: 0,
          forceClientRender: !1,
          completedSegments: [],
          byteSize: 0,
          fallbackAbortableTasks,
          errorDigest: null
        };
      }
      function createTask(request, node, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {
        request.allPendingTasks++, blockedBoundary === null ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
        var task = {
          node,
          ping: function() {
            return pingTask(request, task);
          },
          blockedBoundary,
          blockedSegment,
          abortSet,
          legacyContext,
          context,
          treeContext
        };
        return task.componentStack = null, abortSet.add(task), task;
      }
      function createPendingSegment(request, index, boundary, formatContext, lastPushedText, textEmbedded) {
        return {
          status: PENDING,
          id: -1,
          // lazily assigned later
          index,
          parentFlushed: !1,
          chunks: [],
          children: [],
          formatContext,
          boundary,
          lastPushedText,
          textEmbedded
        };
      }
      var currentTaskInDEV = null;
      function getCurrentStackInDEV() {
        return currentTaskInDEV === null || currentTaskInDEV.componentStack === null ? "" : getStackByComponentStackNode(currentTaskInDEV.componentStack);
      }
      function pushBuiltInComponentStackInDEV(task, type) {
        task.componentStack = {
          tag: 0,
          parent: task.componentStack,
          type
        };
      }
      function pushFunctionComponentStackInDEV(task, type) {
        task.componentStack = {
          tag: 1,
          parent: task.componentStack,
          type
        };
      }
      function pushClassComponentStackInDEV(task, type) {
        task.componentStack = {
          tag: 2,
          parent: task.componentStack,
          type
        };
      }
      function popComponentStackInDEV(task) {
        task.componentStack === null ? error("Unexpectedly popped too many stack frames. This is a bug in React.") : task.componentStack = task.componentStack.parent;
      }
      var lastBoundaryErrorComponentStackDev = null;
      function captureBoundaryErrorDetailsDev(boundary, error2) {
        {
          var errorMessage;
          typeof error2 == "string" ? errorMessage = error2 : error2 && typeof error2.message == "string" ? errorMessage = error2.message : errorMessage = String(error2);
          var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
          lastBoundaryErrorComponentStackDev = null, boundary.errorMessage = errorMessage, boundary.errorComponentStack = errorComponentStack;
        }
      }
      function logRecoverableError(request, error2) {
        var errorDigest = request.onError(error2);
        if (errorDigest != null && typeof errorDigest != "string")
          throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof errorDigest + '" instead');
        return errorDigest;
      }
      function fatalError(request, error2) {
        var onShellError = request.onShellError;
        onShellError(error2);
        var onFatalError = request.onFatalError;
        onFatalError(error2), request.destination !== null ? (request.status = CLOSED, closeWithError(request.destination, error2)) : (request.status = CLOSING, request.fatalError = error2);
      }
      function renderSuspenseBoundary(request, task, props) {
        pushBuiltInComponentStackInDEV(task, "Suspense");
        var parentBoundary = task.blockedBoundary, parentSegment = task.blockedSegment, fallback = props.fallback, content = props.children, fallbackAbortSet = /* @__PURE__ */ new Set(), newBoundary = createSuspenseBoundary(request, fallbackAbortSet), insertionIndex = parentSegment.chunks.length, boundarySegment = createPendingSegment(
          request,
          insertionIndex,
          newBoundary,
          parentSegment.formatContext,
          // boundaries never require text embedding at their edges because comment nodes bound them
          !1,
          !1
        );
        parentSegment.children.push(boundarySegment), parentSegment.lastPushedText = !1;
        var contentRootSegment = createPendingSegment(
          request,
          0,
          null,
          parentSegment.formatContext,
          // boundaries never require text embedding at their edges because comment nodes bound them
          !1,
          !1
        );
        contentRootSegment.parentFlushed = !0, task.blockedBoundary = newBoundary, task.blockedSegment = contentRootSegment;
        try {
          if (renderNode(request, task, content), pushSegmentFinale$1(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded), contentRootSegment.status = COMPLETED, queueCompletedSegment(newBoundary, contentRootSegment), newBoundary.pendingTasks === 0) {
            popComponentStackInDEV(task);
            return;
          }
        } catch (error2) {
          contentRootSegment.status = ERRORED, newBoundary.forceClientRender = !0, newBoundary.errorDigest = logRecoverableError(request, error2), captureBoundaryErrorDetailsDev(newBoundary, error2);
        } finally {
          task.blockedBoundary = parentBoundary, task.blockedSegment = parentSegment;
        }
        var suspendedFallbackTask = createTask(request, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
        suspendedFallbackTask.componentStack = task.componentStack, request.pingedTasks.push(suspendedFallbackTask), popComponentStackInDEV(task);
      }
      function renderHostElement(request, task, type, props) {
        pushBuiltInComponentStackInDEV(task, type);
        var segment = task.blockedSegment, children = pushStartInstance(segment.chunks, type, props, request.responseState, segment.formatContext);
        segment.lastPushedText = !1;
        var prevContext = segment.formatContext;
        segment.formatContext = getChildFormatContext(prevContext, type, props), renderNode(request, task, children), segment.formatContext = prevContext, pushEndInstance(segment.chunks, type), segment.lastPushedText = !1, popComponentStackInDEV(task);
      }
      function shouldConstruct$1(Component) {
        return Component.prototype && Component.prototype.isReactComponent;
      }
      function renderWithHooks(request, task, Component, props, secondArg) {
        var componentIdentity = {};
        prepareToUseHooks(task, componentIdentity);
        var result = Component(props, secondArg);
        return finishHooks(Component, props, result, secondArg);
      }
      function finishClassComponent(request, task, instance, Component, props) {
        var nextChildren = instance.render();
        instance.props !== props && (didWarnAboutReassigningProps || error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component) || "a component"), didWarnAboutReassigningProps = !0);
        {
          var childContextTypes = Component.childContextTypes;
          if (childContextTypes != null) {
            var previousContext = task.legacyContext, mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);
            task.legacyContext = mergedContext, renderNodeDestructive(request, task, nextChildren), task.legacyContext = previousContext;
            return;
          }
        }
        renderNodeDestructive(request, task, nextChildren);
      }
      function renderClassComponent(request, task, Component, props) {
        pushClassComponentStackInDEV(task, Component);
        var maskedContext = getMaskedContext(Component, task.legacyContext), instance = constructClassInstance(Component, props, maskedContext);
        mountClassInstance(instance, Component, props, maskedContext), finishClassComponent(request, task, instance, Component, props), popComponentStackInDEV(task);
      }
      var didWarnAboutBadClass = {}, didWarnAboutModulePatternComponent = {}, didWarnAboutContextTypeOnFunctionComponent = {}, didWarnAboutGetDerivedStateOnFunctionComponent = {}, didWarnAboutReassigningProps = !1, didWarnAboutGenerators = !1, didWarnAboutMaps = !1, hasWarnedAboutUsingContextAsConsumer = !1;
      function renderIndeterminateComponent(request, task, Component, props) {
        var legacyContext;
        if (legacyContext = getMaskedContext(Component, task.legacyContext), pushFunctionComponentStackInDEV(task, Component), Component.prototype && typeof Component.prototype.render == "function") {
          var componentName = getComponentNameFromType(Component) || "Unknown";
          didWarnAboutBadClass[componentName] || (error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName), didWarnAboutBadClass[componentName] = !0);
        }
        var value = renderWithHooks(request, task, Component, props, legacyContext), hasId = checkDidRenderIdHook();
        if (typeof value == "object" && value !== null && typeof value.render == "function" && value.$$typeof === void 0) {
          var _componentName = getComponentNameFromType(Component) || "Unknown";
          didWarnAboutModulePatternComponent[_componentName] || (error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName), didWarnAboutModulePatternComponent[_componentName] = !0);
        }
        if (
          // Run these checks in production only if the flag is off.
          // Eventually we'll delete this branch altogether.
          typeof value == "object" && value !== null && typeof value.render == "function" && value.$$typeof === void 0
        ) {
          {
            var _componentName2 = getComponentNameFromType(Component) || "Unknown";
            didWarnAboutModulePatternComponent[_componentName2] || (error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2), didWarnAboutModulePatternComponent[_componentName2] = !0);
          }
          mountClassInstance(value, Component, props, legacyContext), finishClassComponent(request, task, value, Component, props);
        } else if (validateFunctionComponentInDev(Component), hasId) {
          var prevTreeContext = task.treeContext, totalChildren = 1, index = 0;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
          try {
            renderNodeDestructive(request, task, value);
          } finally {
            task.treeContext = prevTreeContext;
          }
        } else
          renderNodeDestructive(request, task, value);
        popComponentStackInDEV(task);
      }
      function validateFunctionComponentInDev(Component) {
        {
          if (Component && Component.childContextTypes && error("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component"), typeof Component.getDerivedStateFromProps == "function") {
            var _componentName3 = getComponentNameFromType(Component) || "Unknown";
            didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] || (error("%s: Function components do not support getDerivedStateFromProps.", _componentName3), didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = !0);
          }
          if (typeof Component.contextType == "object" && Component.contextType !== null) {
            var _componentName4 = getComponentNameFromType(Component) || "Unknown";
            didWarnAboutContextTypeOnFunctionComponent[_componentName4] || (error("%s: Function components do not support contextType.", _componentName4), didWarnAboutContextTypeOnFunctionComponent[_componentName4] = !0);
          }
        }
      }
      function resolveDefaultProps(Component, baseProps) {
        if (Component && Component.defaultProps) {
          var props = assign({}, baseProps), defaultProps = Component.defaultProps;
          for (var propName in defaultProps)
            props[propName] === void 0 && (props[propName] = defaultProps[propName]);
          return props;
        }
        return baseProps;
      }
      function renderForwardRef(request, task, type, props, ref) {
        pushFunctionComponentStackInDEV(task, type.render);
        var children = renderWithHooks(request, task, type.render, props, ref), hasId = checkDidRenderIdHook();
        if (hasId) {
          var prevTreeContext = task.treeContext, totalChildren = 1, index = 0;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
          try {
            renderNodeDestructive(request, task, children);
          } finally {
            task.treeContext = prevTreeContext;
          }
        } else
          renderNodeDestructive(request, task, children);
        popComponentStackInDEV(task);
      }
      function renderMemo(request, task, type, props, ref) {
        var innerType = type.type, resolvedProps = resolveDefaultProps(innerType, props);
        renderElement(request, task, innerType, resolvedProps, ref);
      }
      function renderContextConsumer(request, task, context, props) {
        context._context === void 0 ? context !== context.Consumer && (hasWarnedAboutUsingContextAsConsumer || (hasWarnedAboutUsingContextAsConsumer = !0, error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : context = context._context;
        var render = props.children;
        typeof render != "function" && error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
        var newValue = readContext(context), newChildren = render(newValue);
        renderNodeDestructive(request, task, newChildren);
      }
      function renderContextProvider(request, task, type, props) {
        var context = type._context, value = props.value, children = props.children, prevSnapshot;
        prevSnapshot = task.context, task.context = pushProvider(context, value), renderNodeDestructive(request, task, children), task.context = popProvider(context), prevSnapshot !== task.context && error("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
      }
      function renderLazyComponent(request, task, lazyComponent, props, ref) {
        pushBuiltInComponentStackInDEV(task, "Lazy");
        var payload = lazyComponent._payload, init = lazyComponent._init, Component = init(payload), resolvedProps = resolveDefaultProps(Component, props);
        renderElement(request, task, Component, resolvedProps, ref), popComponentStackInDEV(task);
      }
      function renderElement(request, task, type, props, ref) {
        if (typeof type == "function")
          if (shouldConstruct$1(type)) {
            renderClassComponent(request, task, type, props);
            return;
          } else {
            renderIndeterminateComponent(request, task, type, props);
            return;
          }
        if (typeof type == "string") {
          renderHostElement(request, task, type, props);
          return;
        }
        switch (type) {
          case REACT_LEGACY_HIDDEN_TYPE:
          case REACT_DEBUG_TRACING_MODE_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_FRAGMENT_TYPE: {
            renderNodeDestructive(request, task, props.children);
            return;
          }
          case REACT_SUSPENSE_LIST_TYPE: {
            pushBuiltInComponentStackInDEV(task, "SuspenseList"), renderNodeDestructive(request, task, props.children), popComponentStackInDEV(task);
            return;
          }
          case REACT_SCOPE_TYPE:
            throw new Error("ReactDOMServer does not yet support scope components.");
          case REACT_SUSPENSE_TYPE: {
            renderSuspenseBoundary(request, task, props);
            return;
          }
        }
        if (typeof type == "object" && type !== null)
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE: {
              renderForwardRef(request, task, type, props, ref);
              return;
            }
            case REACT_MEMO_TYPE: {
              renderMemo(request, task, type, props, ref);
              return;
            }
            case REACT_PROVIDER_TYPE: {
              renderContextProvider(request, task, type, props);
              return;
            }
            case REACT_CONTEXT_TYPE: {
              renderContextConsumer(request, task, type, props);
              return;
            }
            case REACT_LAZY_TYPE: {
              renderLazyComponent(request, task, type, props);
              return;
            }
          }
        var info = "";
        throw (type === void 0 || typeof type == "object" && type !== null && Object.keys(type).length === 0) && (info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
      }
      function validateIterable(iterable, iteratorFn) {
        typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
        iterable[Symbol.toStringTag] === "Generator" && (didWarnAboutGenerators || error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), didWarnAboutGenerators = !0), iterable.entries === iteratorFn && (didWarnAboutMaps || error("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = !0);
      }
      function renderNodeDestructive(request, task, node) {
        try {
          return renderNodeDestructiveImpl(request, task, node);
        } catch (x2) {
          throw typeof x2 == "object" && x2 !== null && typeof x2.then == "function" || (lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV()), x2;
        }
      }
      function renderNodeDestructiveImpl(request, task, node) {
        if (task.node = node, typeof node == "object" && node !== null) {
          switch (node.$$typeof) {
            case REACT_ELEMENT_TYPE: {
              var element = node, type = element.type, props = element.props, ref = element.ref;
              renderElement(request, task, type, props, ref);
              return;
            }
            case REACT_PORTAL_TYPE:
              throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
            case REACT_LAZY_TYPE: {
              var lazyNode = node, payload = lazyNode._payload, init = lazyNode._init, resolvedNode;
              try {
                resolvedNode = init(payload);
              } catch (x2) {
                throw typeof x2 == "object" && x2 !== null && typeof x2.then == "function" && pushBuiltInComponentStackInDEV(task, "Lazy"), x2;
              }
              renderNodeDestructive(request, task, resolvedNode);
              return;
            }
          }
          if (isArray(node)) {
            renderChildrenArray(request, task, node);
            return;
          }
          var iteratorFn = getIteratorFn(node);
          if (iteratorFn) {
            validateIterable(node, iteratorFn);
            var iterator = iteratorFn.call(node);
            if (iterator) {
              var step = iterator.next();
              if (!step.done) {
                var children = [];
                do
                  children.push(step.value), step = iterator.next();
                while (!step.done);
                renderChildrenArray(request, task, children);
                return;
              }
              return;
            }
          }
          var childString = Object.prototype.toString.call(node);
          throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(node).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
        }
        if (typeof node == "string") {
          var segment = task.blockedSegment;
          segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, node, request.responseState, segment.lastPushedText);
          return;
        }
        if (typeof node == "number") {
          var _segment = task.blockedSegment;
          _segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, "" + node, request.responseState, _segment.lastPushedText);
          return;
        }
        typeof node == "function" && error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
      function renderChildrenArray(request, task, children) {
        for (var totalChildren = children.length, i2 = 0; i2 < totalChildren; i2++) {
          var prevTreeContext = task.treeContext;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i2);
          try {
            renderNode(request, task, children[i2]);
          } finally {
            task.treeContext = prevTreeContext;
          }
        }
      }
      function spawnNewSuspendedTask(request, task, x2) {
        var segment = task.blockedSegment, insertionIndex = segment.chunks.length, newSegment = createPendingSegment(
          request,
          insertionIndex,
          null,
          segment.formatContext,
          // Adopt the parent segment's leading text embed
          segment.lastPushedText,
          // Assume we are text embedded at the trailing edge
          !0
        );
        segment.children.push(newSegment), segment.lastPushedText = !1;
        var newTask = createTask(request, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
        task.componentStack !== null && (newTask.componentStack = task.componentStack.parent);
        var ping = newTask.ping;
        x2.then(ping, ping);
      }
      function renderNode(request, task, node) {
        var previousFormatContext = task.blockedSegment.formatContext, previousLegacyContext = task.legacyContext, previousContext = task.context, previousComponentStack = null;
        previousComponentStack = task.componentStack;
        try {
          return renderNodeDestructive(request, task, node);
        } catch (x2) {
          if (resetHooksState(), typeof x2 == "object" && x2 !== null && typeof x2.then == "function") {
            spawnNewSuspendedTask(request, task, x2), task.blockedSegment.formatContext = previousFormatContext, task.legacyContext = previousLegacyContext, task.context = previousContext, switchContext(previousContext), task.componentStack = previousComponentStack;
            return;
          } else
            throw task.blockedSegment.formatContext = previousFormatContext, task.legacyContext = previousLegacyContext, task.context = previousContext, switchContext(previousContext), task.componentStack = previousComponentStack, x2;
        }
      }
      function erroredTask(request, boundary, segment, error2) {
        var errorDigest = logRecoverableError(request, error2);
        if (boundary === null ? fatalError(request, error2) : (boundary.pendingTasks--, boundary.forceClientRender || (boundary.forceClientRender = !0, boundary.errorDigest = errorDigest, captureBoundaryErrorDetailsDev(boundary, error2), boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary))), request.allPendingTasks--, request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady;
          onAllReady();
        }
      }
      function abortTaskSoft(task) {
        var request = this, boundary = task.blockedBoundary, segment = task.blockedSegment;
        segment.status = ABORTED, finishedTask(request, boundary, segment);
      }
      function abortTask(task, request, reason) {
        var boundary = task.blockedBoundary, segment = task.blockedSegment;
        if (segment.status = ABORTED, boundary === null)
          request.allPendingTasks--, request.status !== CLOSED && (request.status = CLOSED, request.destination !== null && close(request.destination));
        else {
          if (boundary.pendingTasks--, !boundary.forceClientRender) {
            boundary.forceClientRender = !0;
            var _error = reason === void 0 ? new Error("The render was aborted by the server without a reason.") : reason;
            boundary.errorDigest = request.onError(_error);
            {
              var errorPrefix = "The server did not finish this Suspense boundary: ";
              _error && typeof _error.message == "string" ? _error = errorPrefix + _error.message : _error = errorPrefix + String(_error);
              var previousTaskInDev = currentTaskInDEV;
              currentTaskInDEV = task;
              try {
                captureBoundaryErrorDetailsDev(boundary, _error);
              } finally {
                currentTaskInDEV = previousTaskInDev;
              }
            }
            boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary);
          }
          if (boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
            return abortTask(fallbackTask, request, reason);
          }), boundary.fallbackAbortableTasks.clear(), request.allPendingTasks--, request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
      }
      function queueCompletedSegment(boundary, segment) {
        if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
          var childSegment = segment.children[0];
          childSegment.id = segment.id, childSegment.parentFlushed = !0, childSegment.status === COMPLETED && queueCompletedSegment(boundary, childSegment);
        } else {
          var completedSegments = boundary.completedSegments;
          completedSegments.push(segment);
        }
      }
      function finishedTask(request, boundary, segment) {
        if (boundary === null) {
          if (segment.parentFlushed) {
            if (request.completedRootSegment !== null)
              throw new Error("There can only be one root segment. This is a bug in React.");
            request.completedRootSegment = segment;
          }
          if (request.pendingRootTasks--, request.pendingRootTasks === 0) {
            request.onShellError = noop$1;
            var onShellReady = request.onShellReady;
            onShellReady();
          }
        } else if (boundary.pendingTasks--, !boundary.forceClientRender) {
          if (boundary.pendingTasks === 0)
            segment.parentFlushed && segment.status === COMPLETED && queueCompletedSegment(boundary, segment), boundary.parentFlushed && request.completedBoundaries.push(boundary), boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request), boundary.fallbackAbortableTasks.clear();
          else if (segment.parentFlushed && segment.status === COMPLETED) {
            queueCompletedSegment(boundary, segment);
            var completedSegments = boundary.completedSegments;
            completedSegments.length === 1 && boundary.parentFlushed && request.partialBoundaries.push(boundary);
          }
        }
        if (request.allPendingTasks--, request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady;
          onAllReady();
        }
      }
      function retryTask(request, task) {
        var segment = task.blockedSegment;
        if (segment.status === PENDING) {
          switchContext(task.context);
          var prevTaskInDEV = null;
          prevTaskInDEV = currentTaskInDEV, currentTaskInDEV = task;
          try {
            renderNodeDestructive(request, task, task.node), pushSegmentFinale$1(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded), task.abortSet.delete(task), segment.status = COMPLETED, finishedTask(request, task.blockedBoundary, segment);
          } catch (x2) {
            if (resetHooksState(), typeof x2 == "object" && x2 !== null && typeof x2.then == "function") {
              var ping = task.ping;
              x2.then(ping, ping);
            } else
              task.abortSet.delete(task), segment.status = ERRORED, erroredTask(request, task.blockedBoundary, segment, x2);
          } finally {
            currentTaskInDEV = prevTaskInDEV;
          }
        }
      }
      function performWork(request) {
        if (request.status !== CLOSED) {
          var prevContext = getActiveContext(), prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = Dispatcher;
          var prevGetCurrentStackImpl;
          prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack, ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
          var prevResponseState = currentResponseState;
          setCurrentResponseState(request.responseState);
          try {
            var pingedTasks = request.pingedTasks, i2;
            for (i2 = 0; i2 < pingedTasks.length; i2++) {
              var task = pingedTasks[i2];
              retryTask(request, task);
            }
            pingedTasks.splice(0, i2), request.destination !== null && flushCompletedQueues(request, request.destination);
          } catch (error2) {
            logRecoverableError(request, error2), fatalError(request, error2);
          } finally {
            setCurrentResponseState(prevResponseState), ReactCurrentDispatcher$1.current = prevDispatcher, ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl, prevDispatcher === Dispatcher && switchContext(prevContext);
          }
        }
      }
      function flushSubtree(request, destination, segment) {
        switch (segment.parentFlushed = !0, segment.status) {
          case PENDING: {
            var segmentID = segment.id = request.nextSegmentId++;
            return segment.lastPushedText = !1, segment.textEmbedded = !1, writePlaceholder(destination, request.responseState, segmentID);
          }
          case COMPLETED: {
            segment.status = FLUSHED;
            for (var r2 = !0, chunks = segment.chunks, chunkIdx = 0, children = segment.children, childIdx = 0; childIdx < children.length; childIdx++) {
              for (var nextChild = children[childIdx]; chunkIdx < nextChild.index; chunkIdx++)
                writeChunk(destination, chunks[chunkIdx]);
              r2 = flushSegment(request, destination, nextChild);
            }
            for (; chunkIdx < chunks.length - 1; chunkIdx++)
              writeChunk(destination, chunks[chunkIdx]);
            return chunkIdx < chunks.length && (r2 = writeChunkAndReturn(destination, chunks[chunkIdx])), r2;
          }
          default:
            throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
        }
      }
      function flushSegment(request, destination, segment) {
        var boundary = segment.boundary;
        if (boundary === null)
          return flushSubtree(request, destination, segment);
        if (boundary.parentFlushed = !0, boundary.forceClientRender)
          return writeStartClientRenderedSuspenseBoundary$1(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack), flushSubtree(request, destination, segment), writeEndClientRenderedSuspenseBoundary$1(destination, request.responseState);
        if (boundary.pendingTasks > 0) {
          boundary.rootSegmentID = request.nextSegmentId++, boundary.completedSegments.length > 0 && request.partialBoundaries.push(boundary);
          var id = boundary.id = assignSuspenseBoundaryID(request.responseState);
          return writeStartPendingSuspenseBoundary(destination, request.responseState, id), flushSubtree(request, destination, segment), writeEndPendingSuspenseBoundary(destination, request.responseState);
        } else {
          if (boundary.byteSize > request.progressiveChunkSize)
            return boundary.rootSegmentID = request.nextSegmentId++, request.completedBoundaries.push(boundary), writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id), flushSubtree(request, destination, segment), writeEndPendingSuspenseBoundary(destination, request.responseState);
          writeStartCompletedSuspenseBoundary$1(destination, request.responseState);
          var completedSegments = boundary.completedSegments;
          if (completedSegments.length !== 1)
            throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
          var contentSegment = completedSegments[0];
          return flushSegment(request, destination, contentSegment), writeEndCompletedSuspenseBoundary$1(destination, request.responseState);
        }
      }
      function flushClientRenderedBoundary(request, destination, boundary) {
        return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
      }
      function flushSegmentContainer(request, destination, segment) {
        return writeStartSegment(destination, request.responseState, segment.formatContext, segment.id), flushSegment(request, destination, segment), writeEndSegment(destination, segment.formatContext);
      }
      function flushCompletedBoundary(request, destination, boundary) {
        for (var completedSegments = boundary.completedSegments, i2 = 0; i2 < completedSegments.length; i2++) {
          var segment = completedSegments[i2];
          flushPartiallyCompletedSegment(request, destination, boundary, segment);
        }
        return completedSegments.length = 0, writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID);
      }
      function flushPartialBoundary(request, destination, boundary) {
        for (var completedSegments = boundary.completedSegments, i2 = 0; i2 < completedSegments.length; i2++) {
          var segment = completedSegments[i2];
          if (!flushPartiallyCompletedSegment(request, destination, boundary, segment))
            return i2++, completedSegments.splice(0, i2), !1;
        }
        return completedSegments.splice(0, i2), !0;
      }
      function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
        if (segment.status === FLUSHED)
          return !0;
        var segmentID = segment.id;
        if (segmentID === -1) {
          var rootSegmentID = segment.id = boundary.rootSegmentID;
          if (rootSegmentID === -1)
            throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
          return flushSegmentContainer(request, destination, segment);
        } else
          return flushSegmentContainer(request, destination, segment), writeCompletedSegmentInstruction(destination, request.responseState, segmentID);
      }
      function flushCompletedQueues(request, destination) {
        try {
          var completedRootSegment = request.completedRootSegment;
          completedRootSegment !== null && request.pendingRootTasks === 0 && (flushSegment(request, destination, completedRootSegment), request.completedRootSegment = null, writeCompletedRoot(destination, request.responseState));
          var clientRenderedBoundaries = request.clientRenderedBoundaries, i2;
          for (i2 = 0; i2 < clientRenderedBoundaries.length; i2++) {
            var boundary = clientRenderedBoundaries[i2];
            if (!flushClientRenderedBoundary(request, destination, boundary)) {
              request.destination = null, i2++, clientRenderedBoundaries.splice(0, i2);
              return;
            }
          }
          clientRenderedBoundaries.splice(0, i2);
          var completedBoundaries = request.completedBoundaries;
          for (i2 = 0; i2 < completedBoundaries.length; i2++) {
            var _boundary = completedBoundaries[i2];
            if (!flushCompletedBoundary(request, destination, _boundary)) {
              request.destination = null, i2++, completedBoundaries.splice(0, i2);
              return;
            }
          }
          completedBoundaries.splice(0, i2);
          var partialBoundaries = request.partialBoundaries;
          for (i2 = 0; i2 < partialBoundaries.length; i2++) {
            var _boundary2 = partialBoundaries[i2];
            if (!flushPartialBoundary(request, destination, _boundary2)) {
              request.destination = null, i2++, partialBoundaries.splice(0, i2);
              return;
            }
          }
          partialBoundaries.splice(0, i2);
          var largeBoundaries = request.completedBoundaries;
          for (i2 = 0; i2 < largeBoundaries.length; i2++) {
            var _boundary3 = largeBoundaries[i2];
            if (!flushCompletedBoundary(request, destination, _boundary3)) {
              request.destination = null, i2++, largeBoundaries.splice(0, i2);
              return;
            }
          }
          largeBoundaries.splice(0, i2);
        } finally {
          request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0 && (request.abortableTasks.size !== 0 && error("There was still abortable task at the root when we closed. This is a bug in React."), close(destination));
        }
      }
      function startWork(request) {
        scheduleWork(function() {
          return performWork(request);
        });
      }
      function startFlowing(request, destination) {
        if (request.status === CLOSING) {
          request.status = CLOSED, closeWithError(destination, request.fatalError);
          return;
        }
        if (request.status !== CLOSED && request.destination === null) {
          request.destination = destination;
          try {
            flushCompletedQueues(request, destination);
          } catch (error2) {
            logRecoverableError(request, error2), fatalError(request, error2);
          }
        }
      }
      function abort(request, reason) {
        try {
          var abortableTasks = request.abortableTasks;
          abortableTasks.forEach(function(task) {
            return abortTask(task, request, reason);
          }), abortableTasks.clear(), request.destination !== null && flushCompletedQueues(request, request.destination);
        } catch (error2) {
          logRecoverableError(request, error2), fatalError(request, error2);
        }
      }
      function onError() {
      }
      function renderToStringImpl(children, options, generateStaticMarkup, abortReason) {
        var didFatal = !1, fatalError2 = null, result = "", destination = {
          push: function(chunk) {
            return chunk !== null && (result += chunk), !0;
          },
          destroy: function(error2) {
            didFatal = !0, fatalError2 = error2;
          }
        }, readyToStream = !1;
        function onShellReady() {
          readyToStream = !0;
        }
        var request = createRequest(children, createResponseState$1(generateStaticMarkup, options ? options.identifierPrefix : void 0), createRootFormatContext(), 1 / 0, onError, void 0, onShellReady, void 0, void 0);
        if (startWork(request), abort(request, abortReason), startFlowing(request, destination), didFatal)
          throw fatalError2;
        if (!readyToStream)
          throw new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
        return result;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype), subClass.prototype.constructor = subClass, subClass.__proto__ = superClass;
      }
      var ReactMarkupReadableStream = /* @__PURE__ */ function(_Readable) {
        _inheritsLoose(ReactMarkupReadableStream2, _Readable);
        function ReactMarkupReadableStream2() {
          var _this;
          return _this = _Readable.call(this, {}) || this, _this.request = null, _this.startedFlowing = !1, _this;
        }
        var _proto = ReactMarkupReadableStream2.prototype;
        return _proto._destroy = function(err, callback) {
          abort(this.request), callback(err);
        }, _proto._read = function(size) {
          this.startedFlowing && startFlowing(this.request, this);
        }, ReactMarkupReadableStream2;
      }(stream.Readable);
      function onError$1() {
      }
      function renderToNodeStreamImpl(children, options, generateStaticMarkup) {
        function onAllReady() {
          destination.startedFlowing = !0, startFlowing(request, destination);
        }
        var destination = new ReactMarkupReadableStream(), request = createRequest(children, createResponseState$1(!1, options ? options.identifierPrefix : void 0), createRootFormatContext(), 1 / 0, onError$1, onAllReady, void 0, void 0);
        return destination.request = request, startWork(request), destination;
      }
      function renderToNodeStream(children, options) {
        return error("renderToNodeStream is deprecated. Use renderToPipeableStream instead."), renderToNodeStreamImpl(children, options);
      }
      function renderToStaticNodeStream(children, options) {
        return renderToNodeStreamImpl(children, options);
      }
      function renderToString(children, options) {
        return renderToStringImpl(children, options, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server');
      }
      function renderToStaticMarkup(children, options) {
        return renderToStringImpl(children, options, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server');
      }
      exports.renderToNodeStream = renderToNodeStream, exports.renderToStaticMarkup = renderToStaticMarkup, exports.renderToStaticNodeStream = renderToStaticNodeStream, exports.renderToString = renderToString, exports.version = ReactVersion;
    })();
  }
});

// node_modules/react-dom/cjs/react-dom-server.node.development.js
var require_react_dom_server_node_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server.node.development.js"(exports) {
    "use strict";
    (function() {
      "use strict";
      var React5 = require_react(), util = require("util"), ReactVersion = "18.2.0", ReactSharedInternals = React5.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function warn(format) {
        {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
            args[_key - 1] = arguments[_key];
          printWarning("warn", format, args);
        }
      }
      function error(format) {
        {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
            args[_key2 - 1] = arguments[_key2];
          printWarning("error", format, args);
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame, stack = ReactDebugCurrentFrame2.getStackAddendum();
          stack !== "" && (format += "%s", args = args.concat([stack]));
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format), Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      function scheduleWork(callback) {
        setImmediate(callback);
      }
      function flushBuffered(destination) {
        typeof destination.flush == "function" && destination.flush();
      }
      var VIEW_SIZE = 2048, currentView = null, writtenBytes = 0, destinationHasCapacity = !0;
      function beginWriting(destination) {
        currentView = new Uint8Array(VIEW_SIZE), writtenBytes = 0, destinationHasCapacity = !0;
      }
      function writeStringChunk(destination, stringChunk) {
        if (stringChunk.length !== 0) {
          if (stringChunk.length * 3 > VIEW_SIZE) {
            writtenBytes > 0 && (writeToDestination(destination, currentView.subarray(0, writtenBytes)), currentView = new Uint8Array(VIEW_SIZE), writtenBytes = 0), writeToDestination(destination, textEncoder.encode(stringChunk));
            return;
          }
          var target = currentView;
          writtenBytes > 0 && (target = currentView.subarray(writtenBytes));
          var _textEncoder$encodeIn = textEncoder.encodeInto(stringChunk, target), read = _textEncoder$encodeIn.read, written = _textEncoder$encodeIn.written;
          writtenBytes += written, read < stringChunk.length && (writeToDestination(destination, currentView), currentView = new Uint8Array(VIEW_SIZE), writtenBytes = textEncoder.encodeInto(stringChunk.slice(read), currentView).written), writtenBytes === VIEW_SIZE && (writeToDestination(destination, currentView), currentView = new Uint8Array(VIEW_SIZE), writtenBytes = 0);
        }
      }
      function writeViewChunk(destination, chunk) {
        if (chunk.byteLength !== 0) {
          if (chunk.byteLength > VIEW_SIZE) {
            writtenBytes > 0 && (writeToDestination(destination, currentView.subarray(0, writtenBytes)), currentView = new Uint8Array(VIEW_SIZE), writtenBytes = 0), writeToDestination(destination, chunk);
            return;
          }
          var bytesToWrite = chunk, allowableBytes = currentView.length - writtenBytes;
          allowableBytes < bytesToWrite.byteLength && (allowableBytes === 0 ? writeToDestination(destination, currentView) : (currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes), writtenBytes += allowableBytes, writeToDestination(destination, currentView), bytesToWrite = bytesToWrite.subarray(allowableBytes)), currentView = new Uint8Array(VIEW_SIZE), writtenBytes = 0), currentView.set(bytesToWrite, writtenBytes), writtenBytes += bytesToWrite.byteLength, writtenBytes === VIEW_SIZE && (writeToDestination(destination, currentView), currentView = new Uint8Array(VIEW_SIZE), writtenBytes = 0);
        }
      }
      function writeChunk(destination, chunk) {
        typeof chunk == "string" ? writeStringChunk(destination, chunk) : writeViewChunk(destination, chunk);
      }
      function writeToDestination(destination, view) {
        var currentHasCapacity = destination.write(view);
        destinationHasCapacity = destinationHasCapacity && currentHasCapacity;
      }
      function writeChunkAndReturn(destination, chunk) {
        return writeChunk(destination, chunk), destinationHasCapacity;
      }
      function completeWriting(destination) {
        currentView && writtenBytes > 0 && destination.write(currentView.subarray(0, writtenBytes)), currentView = null, writtenBytes = 0, destinationHasCapacity = !0;
      }
      function close(destination) {
        destination.end();
      }
      var textEncoder = new util.TextEncoder();
      function stringToChunk(content) {
        return content;
      }
      function stringToPrecomputedChunk(content) {
        return textEncoder.encode(content);
      }
      function closeWithError(destination, error2) {
        destination.destroy(error2);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol == "function" && Symbol.toStringTag, type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        try {
          return testStringCoercion(value), !1;
        } catch {
          return !0;
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkAttributeStringCoercion(value, attributeName) {
        if (willCoercionThrow(value))
          return error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value)), testStringCoercion(value);
      }
      function checkCSSPropertyStringCoercion(value, propName) {
        if (willCoercionThrow(value))
          return error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value)), testStringCoercion(value);
      }
      function checkHtmlStringCoercion(value) {
        if (willCoercionThrow(value))
          return error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value)), testStringCoercion(value);
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty, RESERVED = 0, STRING = 1, BOOLEANISH_STRING = 2, BOOLEAN = 3, OVERLOADED_BOOLEAN = 4, NUMERIC = 5, POSITIVE_NUMERIC = 6, ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$"), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        return hasOwnProperty.call(validatedAttributeNameCache, attributeName) ? !0 : hasOwnProperty.call(illegalAttributeNameCache, attributeName) ? !1 : VALID_ATTRIBUTE_NAME_REGEX.test(attributeName) ? (validatedAttributeNameCache[attributeName] = !0, !0) : (illegalAttributeNameCache[attributeName] = !0, error("Invalid attribute name: `%s`", attributeName), !1);
      }
      function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null && propertyInfo.type === RESERVED)
          return !1;
        switch (typeof value) {
          case "function":
          case "symbol":
            return !0;
          case "boolean": {
            if (isCustomComponentTag)
              return !1;
            if (propertyInfo !== null)
              return !propertyInfo.acceptsBooleans;
            var prefix2 = name.toLowerCase().slice(0, 5);
            return prefix2 !== "data-" && prefix2 !== "aria-";
          }
          default:
            return !1;
        }
      }
      function getPropertyInfo(name) {
        return properties.hasOwnProperty(name) ? properties[name] : null;
      }
      function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
        this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN, this.attributeName = attributeName, this.attributeNamespace = attributeNamespace, this.mustUseProperty = mustUseProperty, this.propertyName = name, this.type = type, this.sanitizeURL = sanitizeURL2, this.removeEmptyString = removeEmptyString;
      }
      var properties = {}, reservedProps = [
        "children",
        "dangerouslySetInnerHTML",
        // TODO: This prevents the assignment of defaultValue to regular
        // elements (not just inputs). Now that ReactDOMInput assigns to the
        // defaultValue property -- do we need this?
        "defaultValue",
        "defaultChecked",
        "innerHTML",
        "suppressContentEditableWarning",
        "suppressHydrationWarning",
        "style"
      ];
      reservedProps.forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          RESERVED,
          !1,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          !1,
          // sanitizeURL
          !1
        );
      }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
        var name = _ref[0], attributeName = _ref[1];
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          !1,
          // mustUseProperty
          attributeName,
          // attributeName
          null,
          // attributeNamespace
          !1,
          // sanitizeURL
          !1
        );
      }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEANISH_STRING,
          !1,
          // mustUseProperty
          name.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          !1,
          // sanitizeURL
          !1
        );
      }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEANISH_STRING,
          !1,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          !1,
          // sanitizeURL
          !1
        );
      }), [
        "allowFullScreen",
        "async",
        // Note: there is a special case that prevents it from being written to the DOM
        // on the client side because the browsers are inconsistent. Instead we call focus().
        "autoFocus",
        "autoPlay",
        "controls",
        "default",
        "defer",
        "disabled",
        "disablePictureInPicture",
        "disableRemotePlayback",
        "formNoValidate",
        "hidden",
        "loop",
        "noModule",
        "noValidate",
        "open",
        "playsInline",
        "readOnly",
        "required",
        "reversed",
        "scoped",
        "seamless",
        // Microdata
        "itemScope"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEAN,
          !1,
          // mustUseProperty
          name.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          !1,
          // sanitizeURL
          !1
        );
      }), [
        "checked",
        // Note: `option.selected` is not updated if `select.multiple` is
        // disabled with `removeAttribute`. We have special logic for handling this.
        "multiple",
        "muted",
        "selected"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEAN,
          !0,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          !1,
          // sanitizeURL
          !1
        );
      }), [
        "capture",
        "download"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          OVERLOADED_BOOLEAN,
          !1,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          !1,
          // sanitizeURL
          !1
        );
      }), [
        "cols",
        "rows",
        "size",
        "span"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          POSITIVE_NUMERIC,
          !1,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          !1,
          // sanitizeURL
          !1
        );
      }), ["rowSpan", "start"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          NUMERIC,
          !1,
          // mustUseProperty
          name.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          !1,
          // sanitizeURL
          !1
        );
      });
      var CAMELIZE = /[\-\:]([a-z])/g, capitalize2 = function(token) {
        return token[1].toUpperCase();
      };
      [
        "accent-height",
        "alignment-baseline",
        "arabic-form",
        "baseline-shift",
        "cap-height",
        "clip-path",
        "clip-rule",
        "color-interpolation",
        "color-interpolation-filters",
        "color-profile",
        "color-rendering",
        "dominant-baseline",
        "enable-background",
        "fill-opacity",
        "fill-rule",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "glyph-name",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "horiz-adv-x",
        "horiz-origin-x",
        "image-rendering",
        "letter-spacing",
        "lighting-color",
        "marker-end",
        "marker-mid",
        "marker-start",
        "overline-position",
        "overline-thickness",
        "paint-order",
        "panose-1",
        "pointer-events",
        "rendering-intent",
        "shape-rendering",
        "stop-color",
        "stop-opacity",
        "strikethrough-position",
        "strikethrough-thickness",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "text-anchor",
        "text-decoration",
        "text-rendering",
        "underline-position",
        "underline-thickness",
        "unicode-bidi",
        "unicode-range",
        "units-per-em",
        "v-alphabetic",
        "v-hanging",
        "v-ideographic",
        "v-mathematical",
        "vector-effect",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y",
        "word-spacing",
        "writing-mode",
        "xmlns:xlink",
        "x-height"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize2);
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          !1,
          // mustUseProperty
          attributeName,
          null,
          // attributeNamespace
          !1,
          // sanitizeURL
          !1
        );
      }), [
        "xlink:actuate",
        "xlink:arcrole",
        "xlink:role",
        "xlink:show",
        "xlink:title",
        "xlink:type"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize2);
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          !1,
          // mustUseProperty
          attributeName,
          "http://www.w3.org/1999/xlink",
          !1,
          // sanitizeURL
          !1
        );
      }), [
        "xml:base",
        "xml:lang",
        "xml:space"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize2);
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          !1,
          // mustUseProperty
          attributeName,
          "http://www.w3.org/XML/1998/namespace",
          !1,
          // sanitizeURL
          !1
        );
      }), ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(
          attributeName,
          STRING,
          !1,
          // mustUseProperty
          attributeName.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          !1,
          // sanitizeURL
          !1
        );
      });
      var xlinkHref = "xlinkHref";
      properties[xlinkHref] = new PropertyInfoRecord(
        "xlinkHref",
        STRING,
        !1,
        // mustUseProperty
        "xlink:href",
        "http://www.w3.org/1999/xlink",
        !0,
        // sanitizeURL
        !1
      ), ["src", "href", "action", "formAction"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(
          attributeName,
          STRING,
          !1,
          // mustUseProperty
          attributeName.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          !0,
          // sanitizeURL
          !0
        );
      });
      var isUnitlessNumber = {
        animationIterationCount: !0,
        aspectRatio: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridArea: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        // SVG-related properties
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0
      };
      function prefixKey(prefix2, key) {
        return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
      }
      var prefixes = ["Webkit", "ms", "Moz", "O"];
      Object.keys(isUnitlessNumber).forEach(function(prop) {
        prefixes.forEach(function(prefix2) {
          isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
        });
      });
      var hasReadOnlyValue = {
        button: !0,
        checkbox: !0,
        image: !0,
        hidden: !0,
        radio: !0,
        reset: !0,
        submit: !0
      };
      function checkControlledValueProps(tagName, props) {
        hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null || error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), props.onChange || props.readOnly || props.disabled || props.checked == null || error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
      }
      function isCustomComponent(tagName, props) {
        if (tagName.indexOf("-") === -1)
          return typeof props.is == "string";
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return !1;
          default:
            return !0;
        }
      }
      var ariaProperties = {
        "aria-current": 0,
        // state
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        // state
        "aria-hidden": 0,
        // state
        "aria-invalid": 0,
        // state
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        // Widget Attributes
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        // Live Region Attributes
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        // Drag-and-Drop Attributes
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        // Relationship Attributes
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      }, warnedProperties = {}, rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$"), rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
      function validateProperty(tagName, name) {
        {
          if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])
            return !0;
          if (rARIACamel.test(name)) {
            var ariaName = "aria-" + name.slice(4).toLowerCase(), correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
            if (correctName == null)
              return error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name), warnedProperties[name] = !0, !0;
            if (name !== correctName)
              return error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName), warnedProperties[name] = !0, !0;
          }
          if (rARIA.test(name)) {
            var lowerCasedName = name.toLowerCase(), standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
            if (standardName == null)
              return warnedProperties[name] = !0, !1;
            if (name !== standardName)
              return error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName), warnedProperties[name] = !0, !0;
          }
        }
        return !0;
      }
      function warnInvalidARIAProps(type, props) {
        {
          var invalidProps = [];
          for (var key in props) {
            var isValid = validateProperty(type, key);
            isValid || invalidProps.push(key);
          }
          var unknownPropString = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          invalidProps.length === 1 ? error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type) : invalidProps.length > 1 && error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
        }
      }
      function validateProperties(type, props) {
        isCustomComponent(type, props) || warnInvalidARIAProps(type, props);
      }
      var didWarnValueNull = !1;
      function validateProperties$1(type, props) {
        {
          if (type !== "input" && type !== "textarea" && type !== "select")
            return;
          props != null && props.value === null && !didWarnValueNull && (didWarnValueNull = !0, type === "select" && props.multiple ? error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type) : error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type));
        }
      }
      var possibleStandardNames = {
        // HTML
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        // SVG
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      }, validateProperty$1 = function() {
      };
      {
        var warnedProperties$1 = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$"), rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        validateProperty$1 = function(tagName, name, value, eventRegistry) {
          if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name])
            return !0;
          var lowerCasedName = name.toLowerCase();
          if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout")
            return error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), warnedProperties$1[name] = !0, !0;
          if (eventRegistry != null) {
            var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
            if (registrationNameDependencies.hasOwnProperty(name))
              return !0;
            var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
            if (registrationName != null)
              return error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName), warnedProperties$1[name] = !0, !0;
            if (EVENT_NAME_REGEX.test(name))
              return error("Unknown event handler property `%s`. It will be ignored.", name), warnedProperties$1[name] = !0, !0;
          } else if (EVENT_NAME_REGEX.test(name))
            return INVALID_EVENT_NAME_REGEX.test(name) && error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name), warnedProperties$1[name] = !0, !0;
          if (rARIA$1.test(name) || rARIACamel$1.test(name))
            return !0;
          if (lowerCasedName === "innerhtml")
            return error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), warnedProperties$1[name] = !0, !0;
          if (lowerCasedName === "aria")
            return error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), warnedProperties$1[name] = !0, !0;
          if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value != "string")
            return error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value), warnedProperties$1[name] = !0, !0;
          if (typeof value == "number" && isNaN(value))
            return error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name), warnedProperties$1[name] = !0, !0;
          var propertyInfo = getPropertyInfo(name), isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            var standardName = possibleStandardNames[lowerCasedName];
            if (standardName !== name)
              return error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName), warnedProperties$1[name] = !0, !0;
          } else if (!isReserved && name !== lowerCasedName)
            return error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName), warnedProperties$1[name] = !0, !0;
          return typeof value == "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, !1) ? (value ? error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name) : error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name), warnedProperties$1[name] = !0, !0) : isReserved ? !0 : shouldRemoveAttributeWithWarning(name, value, propertyInfo, !1) ? (warnedProperties$1[name] = !0, !1) : ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN && (error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value), warnedProperties$1[name] = !0), !0);
        };
      }
      var warnUnknownProperties = function(type, props, eventRegistry) {
        {
          var unknownProps = [];
          for (var key in props) {
            var isValid = validateProperty$1(type, key, props[key], eventRegistry);
            isValid || unknownProps.push(key);
          }
          var unknownPropString = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          unknownProps.length === 1 ? error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type) : unknownProps.length > 1 && error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
        }
      };
      function validateProperties$2(type, props, eventRegistry) {
        isCustomComponent(type, props) || warnUnknownProperties(type, props, eventRegistry);
      }
      var warnValidStyle = function() {
      };
      {
        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = !1, warnedForInfinityValue = !1, camelize = function(string) {
          return string.replace(hyphenPattern, function(_, character) {
            return character.toUpperCase();
          });
        }, warnHyphenatedStyleName = function(name) {
          warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = !0, error(
            "Unsupported style property %s. Did you mean %s?",
            name,
            // As Andi Smith suggests
            // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
            // is converted to lowercase `ms`.
            camelize(name.replace(msPattern, "ms-"))
          ));
        }, warnBadVendoredStyleName = function(name) {
          warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = !0, error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1)));
        }, warnStyleValueWithSemicolon = function(name, value) {
          warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value] || (warnedStyleValues[value] = !0, error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, "")));
        }, warnStyleValueIsNaN = function(name, value) {
          warnedForNaNValue || (warnedForNaNValue = !0, error("`NaN` is an invalid value for the `%s` css style property.", name));
        }, warnStyleValueIsInfinity = function(name, value) {
          warnedForInfinityValue || (warnedForInfinityValue = !0, error("`Infinity` is an invalid value for the `%s` css style property.", name));
        };
        warnValidStyle = function(name, value) {
          name.indexOf("-") > -1 ? warnHyphenatedStyleName(name) : badVendoredStyleNamePattern.test(name) ? warnBadVendoredStyleName(name) : badStyleValueWithSemicolonPattern.test(value) && warnStyleValueWithSemicolon(name, value), typeof value == "number" && (isNaN(value) ? warnStyleValueIsNaN(name, value) : isFinite(value) || warnStyleValueIsInfinity(name, value));
        };
      }
      var warnValidStyle$1 = warnValidStyle, matchHtmlRegExp = /["'&<>]/;
      function escapeHtml(string) {
        checkHtmlStringCoercion(string);
        var str = "" + string, match = matchHtmlRegExp.exec(str);
        if (!match)
          return str;
        var escape2, html = "", index, lastIndex = 0;
        for (index = match.index; index < str.length; index++) {
          switch (str.charCodeAt(index)) {
            case 34:
              escape2 = "&quot;";
              break;
            case 38:
              escape2 = "&amp;";
              break;
            case 39:
              escape2 = "&#x27;";
              break;
            case 60:
              escape2 = "&lt;";
              break;
            case 62:
              escape2 = "&gt;";
              break;
            default:
              continue;
          }
          lastIndex !== index && (html += str.substring(lastIndex, index)), lastIndex = index + 1, html += escape2;
        }
        return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
      }
      function escapeTextForBrowser(text) {
        return typeof text == "boolean" || typeof text == "number" ? "" + text : escapeHtml(text);
      }
      var uppercasePattern = /([A-Z])/g, msPattern$1 = /^ms-/;
      function hyphenateStyleName(name) {
        return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-");
      }
      var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, didWarn = !1;
      function sanitizeURL(url) {
        !didWarn && isJavaScriptProtocol.test(url) && (didWarn = !0, error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url)));
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      var startInlineScript = stringToPrecomputedChunk("<script>"), endInlineScript = stringToPrecomputedChunk("</script>"), startScriptSrc = stringToPrecomputedChunk('<script src="'), startModuleSrc = stringToPrecomputedChunk('<script type="module" src="'), endAsyncScript = stringToPrecomputedChunk('" async=""></script>');
      function escapeBootstrapScriptContent(scriptText) {
        return checkHtmlStringCoercion(scriptText), ("" + scriptText).replace(scriptRegex, scriptReplacer);
      }
      var scriptRegex = /(<\/|<)(s)(cript)/gi, scriptReplacer = function(match, prefix2, s2, suffix) {
        return "" + prefix2 + (s2 === "s" ? "\\u0073" : "\\u0053") + suffix;
      };
      function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
        var idPrefix = identifierPrefix === void 0 ? "" : identifierPrefix, inlineScriptWithNonce = nonce === void 0 ? startInlineScript : stringToPrecomputedChunk('<script nonce="' + escapeTextForBrowser(nonce) + '">'), bootstrapChunks = [];
        if (bootstrapScriptContent !== void 0 && bootstrapChunks.push(inlineScriptWithNonce, escapeBootstrapScriptContent(bootstrapScriptContent), endInlineScript), bootstrapScripts !== void 0)
          for (var i2 = 0; i2 < bootstrapScripts.length; i2++)
            bootstrapChunks.push(startScriptSrc, escapeTextForBrowser(bootstrapScripts[i2]), endAsyncScript);
        if (bootstrapModules !== void 0)
          for (var _i = 0; _i < bootstrapModules.length; _i++)
            bootstrapChunks.push(startModuleSrc, escapeTextForBrowser(bootstrapModules[_i]), endAsyncScript);
        return {
          bootstrapChunks,
          startInlineScript: inlineScriptWithNonce,
          placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
          segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
          boundaryPrefix: idPrefix + "B:",
          idPrefix,
          nextSuspenseID: 0,
          sentCompleteSegmentFunction: !1,
          sentCompleteBoundaryFunction: !1,
          sentClientRenderFunction: !1
        };
      }
      var ROOT_HTML_MODE = 0, HTML_MODE = 1, SVG_MODE = 2, MATHML_MODE = 3, HTML_TABLE_MODE = 4, HTML_TABLE_BODY_MODE = 5, HTML_TABLE_ROW_MODE = 6, HTML_COLGROUP_MODE = 7;
      function createFormatContext(insertionMode, selectedValue) {
        return {
          insertionMode,
          selectedValue
        };
      }
      function createRootFormatContext(namespaceURI) {
        var insertionMode = namespaceURI === "http://www.w3.org/2000/svg" ? SVG_MODE : namespaceURI === "http://www.w3.org/1998/Math/MathML" ? MATHML_MODE : ROOT_HTML_MODE;
        return createFormatContext(insertionMode, null);
      }
      function getChildFormatContext(parentContext, type, props) {
        switch (type) {
          case "select":
            return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);
          case "svg":
            return createFormatContext(SVG_MODE, null);
          case "math":
            return createFormatContext(MATHML_MODE, null);
          case "foreignObject":
            return createFormatContext(HTML_MODE, null);
          case "table":
            return createFormatContext(HTML_TABLE_MODE, null);
          case "thead":
          case "tbody":
          case "tfoot":
            return createFormatContext(HTML_TABLE_BODY_MODE, null);
          case "colgroup":
            return createFormatContext(HTML_COLGROUP_MODE, null);
          case "tr":
            return createFormatContext(HTML_TABLE_ROW_MODE, null);
        }
        return parentContext.insertionMode >= HTML_TABLE_MODE || parentContext.insertionMode === ROOT_HTML_MODE ? createFormatContext(HTML_MODE, null) : parentContext;
      }
      var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
      function assignSuspenseBoundaryID(responseState) {
        var generatedID = responseState.nextSuspenseID++;
        return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));
      }
      function makeId(responseState, treeId, localId) {
        var idPrefix = responseState.idPrefix, id = ":" + idPrefix + "R" + treeId;
        return localId > 0 && (id += "H" + localId.toString(32)), id + ":";
      }
      function encodeHTMLTextNode(text) {
        return escapeTextForBrowser(text);
      }
      var textSeparator = stringToPrecomputedChunk("<!-- -->");
      function pushTextInstance(target, text, responseState, textEmbedded) {
        return text === "" ? textEmbedded : (textEmbedded && target.push(textSeparator), target.push(encodeHTMLTextNode(text)), !0);
      }
      function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {
        lastPushedText && textEmbedded && target.push(textSeparator);
      }
      var styleNameCache = /* @__PURE__ */ new Map();
      function processStyleName(styleName) {
        var chunk = styleNameCache.get(styleName);
        if (chunk !== void 0)
          return chunk;
        var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));
        return styleNameCache.set(styleName, result), result;
      }
      var styleAttributeStart = stringToPrecomputedChunk(' style="'), styleAssign = stringToPrecomputedChunk(":"), styleSeparator = stringToPrecomputedChunk(";");
      function pushStyle(target, responseState, style) {
        if (typeof style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
        var isFirst = !0;
        for (var styleName in style)
          if (hasOwnProperty.call(style, styleName)) {
            var styleValue = style[styleName];
            if (!(styleValue == null || typeof styleValue == "boolean" || styleValue === "")) {
              var nameChunk = void 0, valueChunk = void 0, isCustomProperty = styleName.indexOf("--") === 0;
              isCustomProperty ? (nameChunk = escapeTextForBrowser(styleName), checkCSSPropertyStringCoercion(styleValue, styleName), valueChunk = escapeTextForBrowser(("" + styleValue).trim())) : (warnValidStyle$1(styleName, styleValue), nameChunk = processStyleName(styleName), typeof styleValue == "number" ? styleValue !== 0 && !hasOwnProperty.call(isUnitlessNumber, styleName) ? valueChunk = styleValue + "px" : valueChunk = "" + styleValue : (checkCSSPropertyStringCoercion(styleValue, styleName), valueChunk = escapeTextForBrowser(("" + styleValue).trim()))), isFirst ? (isFirst = !1, target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk)) : target.push(styleSeparator, nameChunk, styleAssign, valueChunk);
            }
          }
        isFirst || target.push(attributeEnd);
      }
      var attributeSeparator = stringToPrecomputedChunk(" "), attributeAssign = stringToPrecomputedChunk('="'), attributeEnd = stringToPrecomputedChunk('"'), attributeEmptyString = stringToPrecomputedChunk('=""');
      function pushAttribute(target, responseState, name, value) {
        switch (name) {
          case "style": {
            pushStyle(target, responseState, value);
            return;
          }
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
            return;
        }
        if (
          // shouldIgnoreAttribute
          // We have already filtered out null/undefined and reserved words.
          !(name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N"))
        ) {
          var propertyInfo = getPropertyInfo(name);
          if (propertyInfo !== null) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
              case "boolean":
                if (!propertyInfo.acceptsBooleans)
                  return;
            }
            var attributeName = propertyInfo.attributeName, attributeNameChunk = attributeName;
            switch (propertyInfo.type) {
              case BOOLEAN:
                value && target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                return;
              case OVERLOADED_BOOLEAN:
                value === !0 ? target.push(attributeSeparator, attributeNameChunk, attributeEmptyString) : value === !1 || target.push(attributeSeparator, attributeNameChunk, attributeAssign, escapeTextForBrowser(value), attributeEnd);
                return;
              case NUMERIC:
                isNaN(value) || target.push(attributeSeparator, attributeNameChunk, attributeAssign, escapeTextForBrowser(value), attributeEnd);
                break;
              case POSITIVE_NUMERIC:
                !isNaN(value) && value >= 1 && target.push(attributeSeparator, attributeNameChunk, attributeAssign, escapeTextForBrowser(value), attributeEnd);
                break;
              default:
                propertyInfo.sanitizeURL && (checkAttributeStringCoercion(value, attributeName), value = "" + value, sanitizeURL(value)), target.push(attributeSeparator, attributeNameChunk, attributeAssign, escapeTextForBrowser(value), attributeEnd);
            }
          } else if (isAttributeNameSafe(name)) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
              case "boolean": {
                var prefix2 = name.toLowerCase().slice(0, 5);
                if (prefix2 !== "data-" && prefix2 !== "aria-")
                  return;
              }
            }
            target.push(attributeSeparator, name, attributeAssign, escapeTextForBrowser(value), attributeEnd);
          }
        }
      }
      var endOfStartTag = stringToPrecomputedChunk(">"), endOfStartTagSelfClosing = stringToPrecomputedChunk("/>");
      function pushInnerHTML(target, innerHTML, children) {
        if (innerHTML != null) {
          if (children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof innerHTML != "object" || !("__html" in innerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
          var html = innerHTML.__html;
          html != null && (checkHtmlStringCoercion(html), target.push("" + html));
        }
      }
      var didWarnDefaultInputValue = !1, didWarnDefaultChecked = !1, didWarnDefaultSelectValue = !1, didWarnDefaultTextareaValue = !1, didWarnInvalidOptionChildren = !1, didWarnInvalidOptionInnerHTML = !1, didWarnSelectedSetOnOption = !1;
      function checkSelectProp(props, propName) {
        {
          var value = props[propName];
          if (value != null) {
            var array = isArray(value);
            props.multiple && !array ? error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName) : !props.multiple && array && error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
          }
        }
      }
      function pushStartSelect(target, props, responseState) {
        checkControlledValueProps("select", props), checkSelectProp(props, "value"), checkSelectProp(props, "defaultValue"), props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultSelectValue && (error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), didWarnDefaultSelectValue = !0), target.push(startChunkForTag("select"));
        var children = null, innerHTML = null;
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "defaultValue":
              case "value":
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        return target.push(endOfStartTag), pushInnerHTML(target, innerHTML, children), children;
      }
      function flattenOptionChildren(children) {
        var content = "";
        return React5.Children.forEach(children, function(child) {
          child != null && (content += child, !didWarnInvalidOptionChildren && typeof child != "string" && typeof child != "number" && (didWarnInvalidOptionChildren = !0, error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
        }), content;
      }
      var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
      function pushStartOption(target, props, responseState, formatContext) {
        var selectedValue = formatContext.selectedValue;
        target.push(startChunkForTag("option"));
        var children = null, value = null, selected = null, innerHTML = null;
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "selected":
                selected = propValue, didWarnSelectedSetOnOption || (error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), didWarnSelectedSetOnOption = !0);
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "value":
                value = propValue;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        if (selectedValue != null) {
          var stringValue;
          if (value !== null ? (checkAttributeStringCoercion(value, "value"), stringValue = "" + value) : (innerHTML !== null && (didWarnInvalidOptionInnerHTML || (didWarnInvalidOptionInnerHTML = !0, error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), stringValue = flattenOptionChildren(children)), isArray(selectedValue))
            for (var i2 = 0; i2 < selectedValue.length; i2++) {
              checkAttributeStringCoercion(selectedValue[i2], "value");
              var v = "" + selectedValue[i2];
              if (v === stringValue) {
                target.push(selectedMarkerAttribute);
                break;
              }
            }
          else
            checkAttributeStringCoercion(selectedValue, "select.value"), "" + selectedValue === stringValue && target.push(selectedMarkerAttribute);
        } else
          selected && target.push(selectedMarkerAttribute);
        return target.push(endOfStartTag), pushInnerHTML(target, innerHTML, children), children;
      }
      function pushInput(target, props, responseState) {
        checkControlledValueProps("input", props), props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnDefaultChecked && (error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type), didWarnDefaultChecked = !0), props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultInputValue && (error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type), didWarnDefaultInputValue = !0), target.push(startChunkForTag("input"));
        var value = null, defaultValue = null, checked = null, defaultChecked = null;
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              case "defaultChecked":
                defaultChecked = propValue;
                break;
              case "defaultValue":
                defaultValue = propValue;
                break;
              case "checked":
                checked = propValue;
                break;
              case "value":
                value = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        return checked !== null ? pushAttribute(target, responseState, "checked", checked) : defaultChecked !== null && pushAttribute(target, responseState, "checked", defaultChecked), value !== null ? pushAttribute(target, responseState, "value", value) : defaultValue !== null && pushAttribute(target, responseState, "value", defaultValue), target.push(endOfStartTagSelfClosing), null;
      }
      function pushStartTextArea(target, props, responseState) {
        checkControlledValueProps("textarea", props), props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultTextareaValue && (error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), didWarnDefaultTextareaValue = !0), target.push(startChunkForTag("textarea"));
        var value = null, defaultValue = null, children = null;
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "value":
                value = propValue;
                break;
              case "defaultValue":
                defaultValue = propValue;
                break;
              case "dangerouslySetInnerHTML":
                throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        if (value === null && defaultValue !== null && (value = defaultValue), target.push(endOfStartTag), children != null) {
          if (error("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), value != null)
            throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
          if (isArray(children)) {
            if (children.length > 1)
              throw new Error("<textarea> can only have at most one child.");
            checkHtmlStringCoercion(children[0]), value = "" + children[0];
          }
          checkHtmlStringCoercion(children), value = "" + children;
        }
        return typeof value == "string" && value[0] === `
` && target.push(leadingNewline), value !== null && (checkAttributeStringCoercion(value, "value"), target.push(encodeHTMLTextNode("" + value))), null;
      }
      function pushSelfClosing(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        return target.push(endOfStartTagSelfClosing), null;
      }
      function pushStartMenuItem(target, props, responseState) {
        target.push(startChunkForTag("menuitem"));
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        return target.push(endOfStartTag), null;
      }
      function pushStartTitle(target, props, responseState) {
        target.push(startChunkForTag("title"));
        var children = null;
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        target.push(endOfStartTag);
        {
          var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
          Array.isArray(children) && children.length > 1 ? error("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : child != null && child.$$typeof != null ? error("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : child != null && typeof child != "string" && typeof child != "number" && error("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
        }
        return children;
      }
      function pushStartGenericElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null, innerHTML = null;
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        return target.push(endOfStartTag), pushInnerHTML(target, innerHTML, children), typeof children == "string" ? (target.push(encodeHTMLTextNode(children)), null) : children;
      }
      function pushStartCustomElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null, innerHTML = null;
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "style":
                pushStyle(target, responseState, propValue);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                isAttributeNameSafe(propKey) && typeof propValue != "function" && typeof propValue != "symbol" && target.push(attributeSeparator, propKey, attributeAssign, escapeTextForBrowser(propValue), attributeEnd);
                break;
            }
          }
        return target.push(endOfStartTag), pushInnerHTML(target, innerHTML, children), children;
      }
      var leadingNewline = stringToPrecomputedChunk(`
`);
      function pushStartPreformattedElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null, innerHTML = null;
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        if (target.push(endOfStartTag), innerHTML != null) {
          if (children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof innerHTML != "object" || !("__html" in innerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
          var html = innerHTML.__html;
          html != null && (typeof html == "string" && html.length > 0 && html[0] === `
` ? target.push(leadingNewline, html) : (checkHtmlStringCoercion(html), target.push("" + html)));
        }
        return typeof children == "string" && children[0] === `
` && target.push(leadingNewline), children;
      }
      var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, validatedTagCache = /* @__PURE__ */ new Map();
      function startChunkForTag(tag) {
        var tagStartChunk = validatedTagCache.get(tag);
        if (tagStartChunk === void 0) {
          if (!VALID_TAG_REGEX.test(tag))
            throw new Error("Invalid tag: " + tag);
          tagStartChunk = stringToPrecomputedChunk("<" + tag), validatedTagCache.set(tag, tagStartChunk);
        }
        return tagStartChunk;
      }
      var DOCTYPE = stringToPrecomputedChunk("<!DOCTYPE html>");
      function pushStartInstance(target, type, props, responseState, formatContext) {
        switch (validateProperties(type, props), validateProperties$1(type, props), validateProperties$2(type, props, null), !props.suppressContentEditableWarning && props.contentEditable && props.children != null && error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE && type.indexOf("-") === -1 && typeof props.is != "string" && type.toLowerCase() !== type && error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type), type) {
          case "select":
            return pushStartSelect(target, props, responseState);
          case "option":
            return pushStartOption(target, props, responseState, formatContext);
          case "textarea":
            return pushStartTextArea(target, props, responseState);
          case "input":
            return pushInput(target, props, responseState);
          case "menuitem":
            return pushStartMenuItem(target, props, responseState);
          case "title":
            return pushStartTitle(target, props, responseState);
          case "listing":
          case "pre":
            return pushStartPreformattedElement(target, props, type, responseState);
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
            return pushSelfClosing(target, props, type, responseState);
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return pushStartGenericElement(target, props, type, responseState);
          case "html":
            return formatContext.insertionMode === ROOT_HTML_MODE && target.push(DOCTYPE), pushStartGenericElement(target, props, type, responseState);
          default:
            return type.indexOf("-") === -1 && typeof props.is != "string" ? pushStartGenericElement(target, props, type, responseState) : pushStartCustomElement(target, props, type, responseState);
        }
      }
      var endTag1 = stringToPrecomputedChunk("</"), endTag2 = stringToPrecomputedChunk(">");
      function pushEndInstance(target, type, props) {
        switch (type) {
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "input":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
            break;
          default:
            target.push(endTag1, type, endTag2);
        }
      }
      function writeCompletedRoot(destination, responseState) {
        for (var bootstrapChunks = responseState.bootstrapChunks, i2 = 0; i2 < bootstrapChunks.length - 1; i2++)
          writeChunk(destination, bootstrapChunks[i2]);
        return i2 < bootstrapChunks.length ? writeChunkAndReturn(destination, bootstrapChunks[i2]) : !0;
      }
      var placeholder1 = stringToPrecomputedChunk('<template id="'), placeholder2 = stringToPrecomputedChunk('"></template>');
      function writePlaceholder(destination, responseState, id) {
        writeChunk(destination, placeholder1), writeChunk(destination, responseState.placeholderPrefix);
        var formattedID = id.toString(16);
        return writeChunk(destination, formattedID), writeChunkAndReturn(destination, placeholder2);
      }
      var startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->"), startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="'), startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>'), startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->"), endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->"), clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template"), clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"'), clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="'), clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="'), clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="'), clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>");
      function writeStartCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
      }
      function writeStartPendingSuspenseBoundary(destination, responseState, id) {
        if (writeChunk(destination, startPendingSuspenseBoundary1), id === null)
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        return writeChunk(destination, id), writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
      }
      function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
        var result;
        return result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary), writeChunk(destination, clientRenderedSuspenseBoundaryError1), errorDigest && (writeChunk(destination, clientRenderedSuspenseBoundaryError1A), writeChunk(destination, escapeTextForBrowser(errorDigest)), writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial)), errorMesssage && (writeChunk(destination, clientRenderedSuspenseBoundaryError1B), writeChunk(destination, escapeTextForBrowser(errorMesssage)), writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial)), errorComponentStack && (writeChunk(destination, clientRenderedSuspenseBoundaryError1C), writeChunk(destination, escapeTextForBrowser(errorComponentStack)), writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial)), result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2), result;
      }
      function writeEndCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      function writeEndPendingSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="'), startSegmentHTML2 = stringToPrecomputedChunk('">'), endSegmentHTML = stringToPrecomputedChunk("</div>"), startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="'), startSegmentSVG2 = stringToPrecomputedChunk('">'), endSegmentSVG = stringToPrecomputedChunk("</svg>"), startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="'), startSegmentMathML2 = stringToPrecomputedChunk('">'), endSegmentMathML = stringToPrecomputedChunk("</math>"), startSegmentTable = stringToPrecomputedChunk('<table hidden id="'), startSegmentTable2 = stringToPrecomputedChunk('">'), endSegmentTable = stringToPrecomputedChunk("</table>"), startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="'), startSegmentTableBody2 = stringToPrecomputedChunk('">'), endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>"), startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="'), startSegmentTableRow2 = stringToPrecomputedChunk('">'), endSegmentTableRow = stringToPrecomputedChunk("</tr></table>"), startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="'), startSegmentColGroup2 = stringToPrecomputedChunk('">'), endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>");
      function writeStartSegment(destination, responseState, formatContext, id) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE:
            return writeChunk(destination, startSegmentHTML), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentHTML2);
          case SVG_MODE:
            return writeChunk(destination, startSegmentSVG), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentSVG2);
          case MATHML_MODE:
            return writeChunk(destination, startSegmentMathML), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentMathML2);
          case HTML_TABLE_MODE:
            return writeChunk(destination, startSegmentTable), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentTable2);
          case HTML_TABLE_BODY_MODE:
            return writeChunk(destination, startSegmentTableBody), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentTableBody2);
          case HTML_TABLE_ROW_MODE:
            return writeChunk(destination, startSegmentTableRow), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentTableRow2);
          case HTML_COLGROUP_MODE:
            return writeChunk(destination, startSegmentColGroup), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentColGroup2);
          default:
            throw new Error("Unknown insertion mode. This is a bug in React.");
        }
      }
      function writeEndSegment(destination, formatContext) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE:
            return writeChunkAndReturn(destination, endSegmentHTML);
          case SVG_MODE:
            return writeChunkAndReturn(destination, endSegmentSVG);
          case MATHML_MODE:
            return writeChunkAndReturn(destination, endSegmentMathML);
          case HTML_TABLE_MODE:
            return writeChunkAndReturn(destination, endSegmentTable);
          case HTML_TABLE_BODY_MODE:
            return writeChunkAndReturn(destination, endSegmentTableBody);
          case HTML_TABLE_ROW_MODE:
            return writeChunkAndReturn(destination, endSegmentTableRow);
          case HTML_COLGROUP_MODE:
            return writeChunkAndReturn(destination, endSegmentColGroup);
          default:
            throw new Error("Unknown insertion mode. This is a bug in React.");
        }
      }
      var completeSegmentFunction = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("'), completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("'), completeSegmentScript2 = stringToPrecomputedChunk('","'), completeSegmentScript3 = stringToPrecomputedChunk('")</script>');
      function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
        writeChunk(destination, responseState.startInlineScript), responseState.sentCompleteSegmentFunction ? writeChunk(destination, completeSegmentScript1Partial) : (responseState.sentCompleteSegmentFunction = !0, writeChunk(destination, completeSegmentScript1Full)), writeChunk(destination, responseState.segmentPrefix);
        var formattedID = contentSegmentID.toString(16);
        return writeChunk(destination, formattedID), writeChunk(destination, completeSegmentScript2), writeChunk(destination, responseState.placeholderPrefix), writeChunk(destination, formattedID), writeChunkAndReturn(destination, completeSegmentScript3);
      }
      var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("'), completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("'), completeBoundaryScript2 = stringToPrecomputedChunk('","'), completeBoundaryScript3 = stringToPrecomputedChunk('")</script>');
      function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
        if (writeChunk(destination, responseState.startInlineScript), responseState.sentCompleteBoundaryFunction ? writeChunk(destination, completeBoundaryScript1Partial) : (responseState.sentCompleteBoundaryFunction = !0, writeChunk(destination, completeBoundaryScript1Full)), boundaryID === null)
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        var formattedContentID = contentSegmentID.toString(16);
        return writeChunk(destination, boundaryID), writeChunk(destination, completeBoundaryScript2), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, formattedContentID), writeChunkAndReturn(destination, completeBoundaryScript3);
      }
      var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("'), clientRenderScript1Partial = stringToPrecomputedChunk('$RX("'), clientRenderScript1A = stringToPrecomputedChunk('"'), clientRenderScript2 = stringToPrecomputedChunk(")</script>"), clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(",");
      function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
        if (writeChunk(destination, responseState.startInlineScript), responseState.sentClientRenderFunction ? writeChunk(destination, clientRenderScript1Partial) : (responseState.sentClientRenderFunction = !0, writeChunk(destination, clientRenderScript1Full)), boundaryID === null)
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        return writeChunk(destination, boundaryID), writeChunk(destination, clientRenderScript1A), (errorDigest || errorMessage || errorComponentStack) && (writeChunk(destination, clientRenderErrorScriptArgInterstitial), writeChunk(destination, escapeJSStringsForInstructionScripts(errorDigest || ""))), (errorMessage || errorComponentStack) && (writeChunk(destination, clientRenderErrorScriptArgInterstitial), writeChunk(destination, escapeJSStringsForInstructionScripts(errorMessage || ""))), errorComponentStack && (writeChunk(destination, clientRenderErrorScriptArgInterstitial), writeChunk(destination, escapeJSStringsForInstructionScripts(errorComponentStack))), writeChunkAndReturn(destination, clientRenderScript2);
      }
      var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
      function escapeJSStringsForInstructionScripts(input) {
        var escaped = JSON.stringify(input);
        return escaped.replace(regexForJSStringsInScripts, function(match) {
          switch (match) {
            case "<":
              return "\\u003c";
            case "\u2028":
              return "\\u2028";
            case "\u2029":
              return "\\u2029";
            default:
              throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
          }
        });
      }
      var assign = Object.assign, REACT_ELEMENT_TYPE = Symbol.for("react.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_SCOPE_TYPE = Symbol.for("react.scope"), REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode"), REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"), REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for("react.default_value"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable != "object")
          return null;
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        return typeof maybeIterator == "function" ? maybeIterator : null;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName)
          return displayName;
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null)
          return null;
        if (typeof type.tag == "number" && error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof type == "function")
          return type.displayName || type.name || null;
        if (typeof type == "string")
          return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type == "object")
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              return outerName !== null ? outerName : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type, payload = lazyComponent._payload, init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = !0;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log, prevInfo = console.info, prevWarn = console.warn, prevError = console.error, prevGroup = console.group, prevGroupCollapsed = console.groupCollapsed, prevGroupEnd = console.groupEnd;
            var props = {
              configurable: !0,
              enumerable: !0,
              value: disabledLog,
              writable: !0
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          if (disabledDepth--, disabledDepth === 0) {
            var props = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          disabledDepth < 0 && error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher, prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === void 0)
            try {
              throw Error();
            } catch (x2) {
              var match = x2.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          return `
` + prefix + name;
        }
      }
      var reentry = !1, componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap == "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry)
          return "";
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0)
            return frame;
        }
        var control;
        reentry = !0;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        previousDispatcher = ReactCurrentDispatcher.current, ReactCurrentDispatcher.current = null, disableLogs();
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            if (Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x2) {
                control = x2;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x2) {
                control = x2;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x2) {
              control = x2;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack == "string") {
            for (var sampleLines = sample.stack.split(`
`), controlLines = control.stack.split(`
`), s2 = sampleLines.length - 1, c = controlLines.length - 1; s2 >= 1 && c >= 0 && sampleLines[s2] !== controlLines[c]; )
              c--;
            for (; s2 >= 1 && c >= 0; s2--, c--)
              if (sampleLines[s2] !== controlLines[c]) {
                if (s2 !== 1 || c !== 1)
                  do
                    if (s2--, c--, c < 0 || sampleLines[s2] !== controlLines[c]) {
                      var _frame = `
` + sampleLines[s2].replace(" at new ", " at ");
                      return fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName)), typeof fn == "function" && componentFrameCache.set(fn, _frame), _frame;
                    }
                  while (s2 >= 1 && c >= 0);
                break;
              }
          }
        } finally {
          reentry = !1, ReactCurrentDispatcher.current = previousDispatcher, reenableLogs(), Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "", syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        return typeof fn == "function" && componentFrameCache.set(fn, syntheticFrame), syntheticFrame;
      }
      function describeClassComponentFrame(ctor, source, ownerFn) {
        return describeNativeComponentFrame(ctor, !0);
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        return describeNativeComponentFrame(fn, !1);
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null)
          return "";
        if (typeof type == "function")
          return describeNativeComponentFrame(type, shouldConstruct(type));
        if (typeof type == "string")
          return describeBuiltInComponentFrame(type);
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type == "object")
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type, payload = lazyComponent._payload, init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch {
              }
            }
          }
        return "";
      }
      var loggedTypeFailures = {}, ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        if (element) {
          var owner = element._owner, stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame.setExtraStackFrame(stack);
        } else
          ReactDebugCurrentFrame.setExtraStackFrame(null);
      }
      function checkPropTypes(typeSpecs, values, location, componentName, element) {
        {
          var has2 = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs)
            if (has2(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] != "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw err.name = "Invariant Violation", err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              error$1 && !(error$1 instanceof Error) && (setCurrentlyValidatingElement(element), error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1), setCurrentlyValidatingElement(null)), error$1 instanceof Error && !(error$1.message in loggedTypeFailures) && (loggedTypeFailures[error$1.message] = !0, setCurrentlyValidatingElement(element), error("Failed %s type: %s", location, error$1.message), setCurrentlyValidatingElement(null));
            }
        }
      }
      var warnedAboutMissingGetChildContext;
      warnedAboutMissingGetChildContext = {};
      var emptyContextObject = {};
      Object.freeze(emptyContextObject);
      function getMaskedContext(type, unmaskedContext) {
        {
          var contextTypes = type.contextTypes;
          if (!contextTypes)
            return emptyContextObject;
          var context = {};
          for (var key in contextTypes)
            context[key] = unmaskedContext[key];
          {
            var name = getComponentNameFromType(type) || "Unknown";
            checkPropTypes(contextTypes, context, "context", name);
          }
          return context;
        }
      }
      function processChildContext(instance, type, parentContext, childContextTypes) {
        {
          if (typeof instance.getChildContext != "function") {
            {
              var componentName = getComponentNameFromType(type) || "Unknown";
              warnedAboutMissingGetChildContext[componentName] || (warnedAboutMissingGetChildContext[componentName] = !0, error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName));
            }
            return parentContext;
          }
          var childContext = instance.getChildContext();
          for (var contextKey in childContext)
            if (!(contextKey in childContextTypes))
              throw new Error((getComponentNameFromType(type) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
          {
            var name = getComponentNameFromType(type) || "Unknown";
            checkPropTypes(childContextTypes, childContext, "child context", name);
          }
          return assign({}, parentContext, childContext);
        }
      }
      var rendererSigil;
      rendererSigil = {};
      var rootContextSnapshot = null, currentActiveSnapshot = null;
      function popNode(prev) {
        prev.context._currentValue = prev.parentValue;
      }
      function pushNode(next) {
        next.context._currentValue = next.value;
      }
      function popToNearestCommonAncestor(prev, next) {
        if (prev !== next) {
          popNode(prev);
          var parentPrev = prev.parent, parentNext = next.parent;
          if (parentPrev === null) {
            if (parentNext !== null)
              throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          } else {
            if (parentNext === null)
              throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
            popToNearestCommonAncestor(parentPrev, parentNext);
          }
          pushNode(next);
        }
      }
      function popAllPrevious(prev) {
        popNode(prev);
        var parentPrev = prev.parent;
        parentPrev !== null && popAllPrevious(parentPrev);
      }
      function pushAllNext(next) {
        var parentNext = next.parent;
        parentNext !== null && pushAllNext(parentNext), pushNode(next);
      }
      function popPreviousToCommonLevel(prev, next) {
        popNode(prev);
        var parentPrev = prev.parent;
        if (parentPrev === null)
          throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
        parentPrev.depth === next.depth ? popToNearestCommonAncestor(parentPrev, next) : popPreviousToCommonLevel(parentPrev, next);
      }
      function popNextToCommonLevel(prev, next) {
        var parentNext = next.parent;
        if (parentNext === null)
          throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
        prev.depth === parentNext.depth ? popToNearestCommonAncestor(prev, parentNext) : popNextToCommonLevel(prev, parentNext), pushNode(next);
      }
      function switchContext(newSnapshot) {
        var prev = currentActiveSnapshot, next = newSnapshot;
        prev !== next && (prev === null ? pushAllNext(next) : next === null ? popAllPrevious(prev) : prev.depth === next.depth ? popToNearestCommonAncestor(prev, next) : prev.depth > next.depth ? popPreviousToCommonLevel(prev, next) : popNextToCommonLevel(prev, next), currentActiveSnapshot = next);
      }
      function pushProvider(context, nextValue) {
        var prevValue;
        prevValue = context._currentValue, context._currentValue = nextValue, context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil && error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), context._currentRenderer = rendererSigil;
        var prevNode = currentActiveSnapshot, newNode = {
          parent: prevNode,
          depth: prevNode === null ? 0 : prevNode.depth + 1,
          context,
          parentValue: prevValue,
          value: nextValue
        };
        return currentActiveSnapshot = newNode, newNode;
      }
      function popProvider(context) {
        var prevSnapshot = currentActiveSnapshot;
        if (prevSnapshot === null)
          throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
        prevSnapshot.context !== context && error("The parent context is not the expected context. This is probably a bug in React.");
        {
          var value = prevSnapshot.parentValue;
          value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED ? prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue : prevSnapshot.context._currentValue = value, context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil && error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), context._currentRenderer = rendererSigil;
        }
        return currentActiveSnapshot = prevSnapshot.parent;
      }
      function getActiveContext() {
        return currentActiveSnapshot;
      }
      function readContext(context) {
        var value = context._currentValue;
        return value;
      }
      function get(key) {
        return key._reactInternals;
      }
      function set(key, value) {
        key._reactInternals = value;
      }
      var didWarnAboutNoopUpdateForComponent = {}, didWarnAboutDeprecatedWillMount = {}, didWarnAboutUninitializedState, didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate, didWarnAboutLegacyLifecyclesAndDerivedState, didWarnAboutUndefinedDerivedState, warnOnUndefinedDerivedState, warnOnInvalidCallback, didWarnAboutDirectlyAssigningPropsToState, didWarnAboutContextTypeAndContextTypes, didWarnAboutInvalidateContextType;
      {
        didWarnAboutUninitializedState = /* @__PURE__ */ new Set(), didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set(), didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set(), didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set(), didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set(), didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set(), didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
        var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
        warnOnInvalidCallback = function(callback, callerName) {
          if (!(callback === null || typeof callback == "function")) {
            var key = callerName + "_" + callback;
            didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback));
          }
        }, warnOnUndefinedDerivedState = function(type, partialState) {
          if (partialState === void 0) {
            var componentName = getComponentNameFromType(type) || "Component";
            didWarnAboutUndefinedDerivedState.has(componentName) || (didWarnAboutUndefinedDerivedState.add(componentName), error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName));
          }
        };
      }
      function warnNoop(publicInstance, callerName) {
        {
          var _constructor = publicInstance.constructor, componentName = _constructor && getComponentNameFromType(_constructor) || "ReactClass", warningKey = componentName + "." + callerName;
          if (didWarnAboutNoopUpdateForComponent[warningKey])
            return;
          error(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, callerName, callerName, componentName), didWarnAboutNoopUpdateForComponent[warningKey] = !0;
        }
      }
      var classComponentUpdater = {
        isMounted: function(inst) {
          return !1;
        },
        enqueueSetState: function(inst, payload, callback) {
          var internals = get(inst);
          internals.queue === null ? warnNoop(inst, "setState") : (internals.queue.push(payload), callback != null && warnOnInvalidCallback(callback, "setState"));
        },
        enqueueReplaceState: function(inst, payload, callback) {
          var internals = get(inst);
          internals.replace = !0, internals.queue = [payload], callback != null && warnOnInvalidCallback(callback, "setState");
        },
        enqueueForceUpdate: function(inst, callback) {
          var internals = get(inst);
          internals.queue === null ? warnNoop(inst, "forceUpdate") : callback != null && warnOnInvalidCallback(callback, "setState");
        }
      };
      function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {
        var partialState = getDerivedStateFromProps(nextProps, prevState);
        warnOnUndefinedDerivedState(ctor, partialState);
        var newState = partialState == null ? prevState : assign({}, prevState, partialState);
        return newState;
      }
      function constructClassInstance(ctor, props, maskedLegacyContext) {
        var context = emptyContextObject, contextType = ctor.contextType;
        if ("contextType" in ctor) {
          var isValid = (
            // Allow null for conditional declaration
            contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0
          );
          if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
            didWarnAboutInvalidateContextType.add(ctor);
            var addendum = "";
            contextType === void 0 ? addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof contextType != "object" ? addendum = " However, it is set to a " + typeof contextType + "." : contextType.$$typeof === REACT_PROVIDER_TYPE ? addendum = " Did you accidentally pass the Context.Provider instead?" : contextType._context !== void 0 ? addendum = " Did you accidentally pass the Context.Consumer instead?" : addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.", error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
          }
        }
        typeof contextType == "object" && contextType !== null ? context = readContext(contextType) : context = maskedLegacyContext;
        var instance = new ctor(props, context);
        {
          if (typeof ctor.getDerivedStateFromProps == "function" && (instance.state === null || instance.state === void 0)) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            didWarnAboutUninitializedState.has(componentName) || (didWarnAboutUninitializedState.add(componentName), error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName));
          }
          if (typeof ctor.getDerivedStateFromProps == "function" || typeof instance.getSnapshotBeforeUpdate == "function") {
            var foundWillMountName = null, foundWillReceivePropsName = null, foundWillUpdateName = null;
            if (typeof instance.componentWillMount == "function" && instance.componentWillMount.__suppressDeprecationWarning !== !0 ? foundWillMountName = "componentWillMount" : typeof instance.UNSAFE_componentWillMount == "function" && (foundWillMountName = "UNSAFE_componentWillMount"), typeof instance.componentWillReceiveProps == "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? foundWillReceivePropsName = "componentWillReceiveProps" : typeof instance.UNSAFE_componentWillReceiveProps == "function" && (foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps"), typeof instance.componentWillUpdate == "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== !0 ? foundWillUpdateName = "componentWillUpdate" : typeof instance.UNSAFE_componentWillUpdate == "function" && (foundWillUpdateName = "UNSAFE_componentWillUpdate"), foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
              var _componentName = getComponentNameFromType(ctor) || "Component", newApiName = typeof ctor.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
              didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName), error(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, _componentName, newApiName, foundWillMountName !== null ? `
  ` + foundWillMountName : "", foundWillReceivePropsName !== null ? `
  ` + foundWillReceivePropsName : "", foundWillUpdateName !== null ? `
  ` + foundWillUpdateName : ""));
            }
          }
        }
        return instance;
      }
      function checkClassInstance(instance, ctor, newProps) {
        {
          var name = getComponentNameFromType(ctor) || "Component", renderPresent = instance.render;
          renderPresent || (ctor.prototype && typeof ctor.prototype.render == "function" ? error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name) : error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name)), instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state && error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name), instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved && error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name), instance.propTypes && error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name), instance.contextType && error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name), instance.contextTypes && error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name), ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor) && (didWarnAboutContextTypeAndContextTypes.add(ctor), error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name)), typeof instance.componentShouldUpdate == "function" && error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name), ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate < "u" && error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component"), typeof instance.componentDidUnmount == "function" && error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name), typeof instance.componentDidReceiveProps == "function" && error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name), typeof instance.componentWillRecieveProps == "function" && error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name), typeof instance.UNSAFE_componentWillRecieveProps == "function" && error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
          var hasMutatedProps = instance.props !== newProps;
          instance.props !== void 0 && hasMutatedProps && error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name), instance.defaultProps && error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name), typeof instance.getSnapshotBeforeUpdate == "function" && typeof instance.componentDidUpdate != "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor) && (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor), error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor))), typeof instance.getDerivedStateFromProps == "function" && error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name), typeof instance.getDerivedStateFromError == "function" && error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name), typeof ctor.getSnapshotBeforeUpdate == "function" && error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
          var _state = instance.state;
          _state && (typeof _state != "object" || isArray(_state)) && error("%s.state: must be set to an object or null", name), typeof instance.getChildContext == "function" && typeof ctor.childContextTypes != "object" && error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
        }
      }
      function callComponentWillMount(type, instance) {
        var oldState = instance.state;
        if (typeof instance.componentWillMount == "function") {
          if (instance.componentWillMount.__suppressDeprecationWarning !== !0) {
            var componentName = getComponentNameFromType(type) || "Unknown";
            didWarnAboutDeprecatedWillMount[componentName] || (warn(
              // keep this warning in sync with ReactStrictModeWarning.js
              `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
              componentName
            ), didWarnAboutDeprecatedWillMount[componentName] = !0);
          }
          instance.componentWillMount();
        }
        typeof instance.UNSAFE_componentWillMount == "function" && instance.UNSAFE_componentWillMount(), oldState !== instance.state && (error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type) || "Component"), classComponentUpdater.enqueueReplaceState(instance, instance.state, null));
      }
      function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {
        if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
          var oldQueue = internalInstance.queue, oldReplace = internalInstance.replace;
          if (internalInstance.queue = null, internalInstance.replace = !1, oldReplace && oldQueue.length === 1)
            inst.state = oldQueue[0];
          else {
            for (var nextState = oldReplace ? oldQueue[0] : inst.state, dontMutate = !0, i2 = oldReplace ? 1 : 0; i2 < oldQueue.length; i2++) {
              var partial = oldQueue[i2], partialState = typeof partial == "function" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;
              partialState != null && (dontMutate ? (dontMutate = !1, nextState = assign({}, nextState, partialState)) : assign(nextState, partialState));
            }
            inst.state = nextState;
          }
        } else
          internalInstance.queue = null;
      }
      function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {
        checkClassInstance(instance, ctor, newProps);
        var initialState = instance.state !== void 0 ? instance.state : null;
        instance.updater = classComponentUpdater, instance.props = newProps, instance.state = initialState;
        var internalInstance = {
          queue: [],
          replace: !1
        };
        set(instance, internalInstance);
        var contextType = ctor.contextType;
        if (typeof contextType == "object" && contextType !== null ? instance.context = readContext(contextType) : instance.context = maskedLegacyContext, instance.state === newProps) {
          var componentName = getComponentNameFromType(ctor) || "Component";
          didWarnAboutDirectlyAssigningPropsToState.has(componentName) || (didWarnAboutDirectlyAssigningPropsToState.add(componentName), error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName));
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        typeof getDerivedStateFromProps == "function" && (instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps)), typeof ctor.getDerivedStateFromProps != "function" && typeof instance.getSnapshotBeforeUpdate != "function" && (typeof instance.UNSAFE_componentWillMount == "function" || typeof instance.componentWillMount == "function") && (callComponentWillMount(ctor, instance), processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext));
      }
      var emptyTreeContext = {
        id: 1,
        overflow: ""
      };
      function getTreeId(context) {
        var overflow = context.overflow, idWithLeadingBit = context.id, id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
        return id.toString(32) + overflow;
      }
      function pushTreeContext(baseContext, totalChildren, index) {
        var baseIdWithLeadingBit = baseContext.id, baseOverflow = baseContext.overflow, baseLength = getBitLength(baseIdWithLeadingBit) - 1, baseId = baseIdWithLeadingBit & ~(1 << baseLength), slot = index + 1, length = getBitLength(totalChildren) + baseLength;
        if (length > 30) {
          var numberOfOverflowBits = baseLength - baseLength % 5, newOverflowBits = (1 << numberOfOverflowBits) - 1, newOverflow = (baseId & newOverflowBits).toString(32), restOfBaseId = baseId >> numberOfOverflowBits, restOfBaseLength = baseLength - numberOfOverflowBits, restOfLength = getBitLength(totalChildren) + restOfBaseLength, restOfNewBits = slot << restOfBaseLength, id = restOfNewBits | restOfBaseId, overflow = newOverflow + baseOverflow;
          return {
            id: 1 << restOfLength | id,
            overflow
          };
        } else {
          var newBits = slot << baseLength, _id = newBits | baseId, _overflow = baseOverflow;
          return {
            id: 1 << length | _id,
            overflow: _overflow
          };
        }
      }
      function getBitLength(number) {
        return 32 - clz32(number);
      }
      function getLeadingBit(id) {
        return 1 << getBitLength(id) - 1;
      }
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2;
      function clz32Fallback(x2) {
        var asUint = x2 >>> 0;
        return asUint === 0 ? 32 : 31 - (log(asUint) / LN2 | 0) | 0;
      }
      function is(x2, y) {
        return x2 === y && (x2 !== 0 || 1 / x2 === 1 / y) || x2 !== x2 && y !== y;
      }
      var objectIs = typeof Object.is == "function" ? Object.is : is, currentlyRenderingComponent = null, currentlyRenderingTask = null, firstWorkInProgressHook = null, workInProgressHook = null, isReRender = !1, didScheduleRenderPhaseUpdate = !1, localIdCounter = 0, renderPhaseUpdates = null, numberOfReRenders = 0, RE_RENDER_LIMIT = 25, isInHookUserCodeInDev = !1, currentHookNameInDev;
      function resolveCurrentlyRenderingComponent() {
        if (currentlyRenderingComponent === null)
          throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
        return isInHookUserCodeInDev && error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), currentlyRenderingComponent;
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (prevDeps === null)
          return error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev), !1;
        nextDeps.length !== prevDeps.length && error(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
        for (var i2 = 0; i2 < prevDeps.length && i2 < nextDeps.length; i2++)
          if (!objectIs(nextDeps[i2], prevDeps[i2]))
            return !1;
        return !0;
      }
      function createHook() {
        if (numberOfReRenders > 0)
          throw new Error("Rendered more hooks than during the previous render");
        return {
          memoizedState: null,
          queue: null,
          next: null
        };
      }
      function createWorkInProgressHook() {
        return workInProgressHook === null ? firstWorkInProgressHook === null ? (isReRender = !1, firstWorkInProgressHook = workInProgressHook = createHook()) : (isReRender = !0, workInProgressHook = firstWorkInProgressHook) : workInProgressHook.next === null ? (isReRender = !1, workInProgressHook = workInProgressHook.next = createHook()) : (isReRender = !0, workInProgressHook = workInProgressHook.next), workInProgressHook;
      }
      function prepareToUseHooks(task, componentIdentity) {
        currentlyRenderingComponent = componentIdentity, currentlyRenderingTask = task, isInHookUserCodeInDev = !1, localIdCounter = 0;
      }
      function finishHooks(Component, props, children, refOrContext) {
        for (; didScheduleRenderPhaseUpdate; )
          didScheduleRenderPhaseUpdate = !1, localIdCounter = 0, numberOfReRenders += 1, workInProgressHook = null, children = Component(props, refOrContext);
        return resetHooksState(), children;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = localIdCounter !== 0;
        return didRenderIdHook;
      }
      function resetHooksState() {
        isInHookUserCodeInDev = !1, currentlyRenderingComponent = null, currentlyRenderingTask = null, didScheduleRenderPhaseUpdate = !1, firstWorkInProgressHook = null, numberOfReRenders = 0, renderPhaseUpdates = null, workInProgressHook = null;
      }
      function readContext$1(context) {
        return isInHookUserCodeInDev && error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), readContext(context);
      }
      function useContext(context) {
        return currentHookNameInDev = "useContext", resolveCurrentlyRenderingComponent(), readContext(context);
      }
      function basicStateReducer(state, action3) {
        return typeof action3 == "function" ? action3(state) : action3;
      }
      function useState(initialState) {
        return currentHookNameInDev = "useState", useReducer(
          basicStateReducer,
          // useReducer has a special case to support lazy useState initializers
          initialState
        );
      }
      function useReducer(reducer, initialArg, init) {
        if (reducer !== basicStateReducer && (currentHookNameInDev = "useReducer"), currentlyRenderingComponent = resolveCurrentlyRenderingComponent(), workInProgressHook = createWorkInProgressHook(), isReRender) {
          var queue = workInProgressHook.queue, dispatch = queue.dispatch;
          if (renderPhaseUpdates !== null) {
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
            if (firstRenderPhaseUpdate !== void 0) {
              renderPhaseUpdates.delete(queue);
              var newState = workInProgressHook.memoizedState, update = firstRenderPhaseUpdate;
              do {
                var action3 = update.action;
                isInHookUserCodeInDev = !0, newState = reducer(newState, action3), isInHookUserCodeInDev = !1, update = update.next;
              } while (update !== null);
              return workInProgressHook.memoizedState = newState, [newState, dispatch];
            }
          }
          return [workInProgressHook.memoizedState, dispatch];
        } else {
          isInHookUserCodeInDev = !0;
          var initialState;
          reducer === basicStateReducer ? initialState = typeof initialArg == "function" ? initialArg() : initialArg : initialState = init !== void 0 ? init(initialArg) : initialArg, isInHookUserCodeInDev = !1, workInProgressHook.memoizedState = initialState;
          var _queue = workInProgressHook.queue = {
            last: null,
            dispatch: null
          }, _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
          return [workInProgressHook.memoizedState, _dispatch];
        }
      }
      function useMemo(nextCreate, deps) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent(), workInProgressHook = createWorkInProgressHook();
        var nextDeps = deps === void 0 ? null : deps;
        if (workInProgressHook !== null) {
          var prevState = workInProgressHook.memoizedState;
          if (prevState !== null && nextDeps !== null) {
            var prevDeps = prevState[1];
            if (areHookInputsEqual(nextDeps, prevDeps))
              return prevState[0];
          }
        }
        isInHookUserCodeInDev = !0;
        var nextValue = nextCreate();
        return isInHookUserCodeInDev = !1, workInProgressHook.memoizedState = [nextValue, nextDeps], nextValue;
      }
      function useRef(initialValue) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent(), workInProgressHook = createWorkInProgressHook();
        var previousRef = workInProgressHook.memoizedState;
        if (previousRef === null) {
          var ref = {
            current: initialValue
          };
          return Object.seal(ref), workInProgressHook.memoizedState = ref, ref;
        } else
          return previousRef;
      }
      function useLayoutEffect(create, inputs) {
        currentHookNameInDev = "useLayoutEffect", error("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
      }
      function dispatchAction(componentIdentity, queue, action3) {
        if (numberOfReRenders >= RE_RENDER_LIMIT)
          throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
        if (componentIdentity === currentlyRenderingComponent) {
          didScheduleRenderPhaseUpdate = !0;
          var update = {
            action: action3,
            next: null
          };
          renderPhaseUpdates === null && (renderPhaseUpdates = /* @__PURE__ */ new Map());
          var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
          if (firstRenderPhaseUpdate === void 0)
            renderPhaseUpdates.set(queue, update);
          else {
            for (var lastRenderPhaseUpdate = firstRenderPhaseUpdate; lastRenderPhaseUpdate.next !== null; )
              lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            lastRenderPhaseUpdate.next = update;
          }
        }
      }
      function useCallback(callback, deps) {
        return useMemo(function() {
          return callback;
        }, deps);
      }
      function useMutableSource(source, getSnapshot, subscribe) {
        return resolveCurrentlyRenderingComponent(), getSnapshot(source._source);
      }
      function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        if (getServerSnapshot === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        return getServerSnapshot();
      }
      function useDeferredValue(value) {
        return resolveCurrentlyRenderingComponent(), value;
      }
      function unsupportedStartTransition() {
        throw new Error("startTransition cannot be called during server rendering.");
      }
      function useTransition() {
        return resolveCurrentlyRenderingComponent(), [!1, unsupportedStartTransition];
      }
      function useId() {
        var task = currentlyRenderingTask, treeId = getTreeId(task.treeContext), responseState = currentResponseState;
        if (responseState === null)
          throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
        var localId = localIdCounter++;
        return makeId(responseState, treeId, localId);
      }
      function noop2() {
      }
      var Dispatcher = {
        readContext: readContext$1,
        useContext,
        useMemo,
        useReducer,
        useRef,
        useState,
        useInsertionEffect: noop2,
        useLayoutEffect,
        useCallback,
        // useImperativeHandle is not run in the server environment
        useImperativeHandle: noop2,
        // Effects are not run in the server environment.
        useEffect: noop2,
        // Debugging effect
        useDebugValue: noop2,
        useDeferredValue,
        useTransition,
        useId,
        // Subscriptions are not setup in a server environment.
        useMutableSource,
        useSyncExternalStore
      }, currentResponseState = null;
      function setCurrentResponseState(responseState) {
        currentResponseState = responseState;
      }
      function getStackByComponentStackNode(componentStack) {
        try {
          var info = "", node = componentStack;
          do {
            switch (node.tag) {
              case 0:
                info += describeBuiltInComponentFrame(node.type, null, null);
                break;
              case 1:
                info += describeFunctionComponentFrame(node.type, null, null);
                break;
              case 2:
                info += describeClassComponentFrame(node.type, null, null);
                break;
            }
            node = node.parent;
          } while (node);
          return info;
        } catch (x2) {
          return `
Error generating stack: ` + x2.message + `
` + x2.stack;
        }
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame, PENDING = 0, COMPLETED = 1, FLUSHED = 2, ABORTED = 3, ERRORED = 4, OPEN = 0, CLOSING = 1, CLOSED = 2, DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
      function defaultErrorHandler(error2) {
        return console.error(error2), null;
      }
      function noop$1() {
      }
      function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError) {
        var pingedTasks = [], abortSet = /* @__PURE__ */ new Set(), request = {
          destination: null,
          responseState,
          progressiveChunkSize: progressiveChunkSize === void 0 ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
          status: OPEN,
          fatalError: null,
          nextSegmentId: 0,
          allPendingTasks: 0,
          pendingRootTasks: 0,
          completedRootSegment: null,
          abortableTasks: abortSet,
          pingedTasks,
          clientRenderedBoundaries: [],
          completedBoundaries: [],
          partialBoundaries: [],
          onError: onError === void 0 ? defaultErrorHandler : onError,
          onAllReady: onAllReady === void 0 ? noop$1 : onAllReady,
          onShellReady: onShellReady === void 0 ? noop$1 : onShellReady,
          onShellError: onShellError === void 0 ? noop$1 : onShellError,
          onFatalError: onFatalError === void 0 ? noop$1 : onFatalError
        }, rootSegment = createPendingSegment(
          request,
          0,
          null,
          rootFormatContext,
          // Root segments are never embedded in Text on either edge
          !1,
          !1
        );
        rootSegment.parentFlushed = !0;
        var rootTask = createTask(request, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
        return pingedTasks.push(rootTask), request;
      }
      function pingTask(request, task) {
        var pingedTasks = request.pingedTasks;
        pingedTasks.push(task), pingedTasks.length === 1 && scheduleWork(function() {
          return performWork(request);
        });
      }
      function createSuspenseBoundary(request, fallbackAbortableTasks) {
        return {
          id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
          rootSegmentID: -1,
          parentFlushed: !1,
          pendingTasks: 0,
          forceClientRender: !1,
          completedSegments: [],
          byteSize: 0,
          fallbackAbortableTasks,
          errorDigest: null
        };
      }
      function createTask(request, node, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {
        request.allPendingTasks++, blockedBoundary === null ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
        var task = {
          node,
          ping: function() {
            return pingTask(request, task);
          },
          blockedBoundary,
          blockedSegment,
          abortSet,
          legacyContext,
          context,
          treeContext
        };
        return task.componentStack = null, abortSet.add(task), task;
      }
      function createPendingSegment(request, index, boundary, formatContext, lastPushedText, textEmbedded) {
        return {
          status: PENDING,
          id: -1,
          // lazily assigned later
          index,
          parentFlushed: !1,
          chunks: [],
          children: [],
          formatContext,
          boundary,
          lastPushedText,
          textEmbedded
        };
      }
      var currentTaskInDEV = null;
      function getCurrentStackInDEV() {
        return currentTaskInDEV === null || currentTaskInDEV.componentStack === null ? "" : getStackByComponentStackNode(currentTaskInDEV.componentStack);
      }
      function pushBuiltInComponentStackInDEV(task, type) {
        task.componentStack = {
          tag: 0,
          parent: task.componentStack,
          type
        };
      }
      function pushFunctionComponentStackInDEV(task, type) {
        task.componentStack = {
          tag: 1,
          parent: task.componentStack,
          type
        };
      }
      function pushClassComponentStackInDEV(task, type) {
        task.componentStack = {
          tag: 2,
          parent: task.componentStack,
          type
        };
      }
      function popComponentStackInDEV(task) {
        task.componentStack === null ? error("Unexpectedly popped too many stack frames. This is a bug in React.") : task.componentStack = task.componentStack.parent;
      }
      var lastBoundaryErrorComponentStackDev = null;
      function captureBoundaryErrorDetailsDev(boundary, error2) {
        {
          var errorMessage;
          typeof error2 == "string" ? errorMessage = error2 : error2 && typeof error2.message == "string" ? errorMessage = error2.message : errorMessage = String(error2);
          var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
          lastBoundaryErrorComponentStackDev = null, boundary.errorMessage = errorMessage, boundary.errorComponentStack = errorComponentStack;
        }
      }
      function logRecoverableError(request, error2) {
        var errorDigest = request.onError(error2);
        if (errorDigest != null && typeof errorDigest != "string")
          throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof errorDigest + '" instead');
        return errorDigest;
      }
      function fatalError(request, error2) {
        var onShellError = request.onShellError;
        onShellError(error2);
        var onFatalError = request.onFatalError;
        onFatalError(error2), request.destination !== null ? (request.status = CLOSED, closeWithError(request.destination, error2)) : (request.status = CLOSING, request.fatalError = error2);
      }
      function renderSuspenseBoundary(request, task, props) {
        pushBuiltInComponentStackInDEV(task, "Suspense");
        var parentBoundary = task.blockedBoundary, parentSegment = task.blockedSegment, fallback = props.fallback, content = props.children, fallbackAbortSet = /* @__PURE__ */ new Set(), newBoundary = createSuspenseBoundary(request, fallbackAbortSet), insertionIndex = parentSegment.chunks.length, boundarySegment = createPendingSegment(
          request,
          insertionIndex,
          newBoundary,
          parentSegment.formatContext,
          // boundaries never require text embedding at their edges because comment nodes bound them
          !1,
          !1
        );
        parentSegment.children.push(boundarySegment), parentSegment.lastPushedText = !1;
        var contentRootSegment = createPendingSegment(
          request,
          0,
          null,
          parentSegment.formatContext,
          // boundaries never require text embedding at their edges because comment nodes bound them
          !1,
          !1
        );
        contentRootSegment.parentFlushed = !0, task.blockedBoundary = newBoundary, task.blockedSegment = contentRootSegment;
        try {
          if (renderNode(request, task, content), pushSegmentFinale(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded), contentRootSegment.status = COMPLETED, queueCompletedSegment(newBoundary, contentRootSegment), newBoundary.pendingTasks === 0) {
            popComponentStackInDEV(task);
            return;
          }
        } catch (error2) {
          contentRootSegment.status = ERRORED, newBoundary.forceClientRender = !0, newBoundary.errorDigest = logRecoverableError(request, error2), captureBoundaryErrorDetailsDev(newBoundary, error2);
        } finally {
          task.blockedBoundary = parentBoundary, task.blockedSegment = parentSegment;
        }
        var suspendedFallbackTask = createTask(request, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
        suspendedFallbackTask.componentStack = task.componentStack, request.pingedTasks.push(suspendedFallbackTask), popComponentStackInDEV(task);
      }
      function renderHostElement(request, task, type, props) {
        pushBuiltInComponentStackInDEV(task, type);
        var segment = task.blockedSegment, children = pushStartInstance(segment.chunks, type, props, request.responseState, segment.formatContext);
        segment.lastPushedText = !1;
        var prevContext = segment.formatContext;
        segment.formatContext = getChildFormatContext(prevContext, type, props), renderNode(request, task, children), segment.formatContext = prevContext, pushEndInstance(segment.chunks, type), segment.lastPushedText = !1, popComponentStackInDEV(task);
      }
      function shouldConstruct$1(Component) {
        return Component.prototype && Component.prototype.isReactComponent;
      }
      function renderWithHooks(request, task, Component, props, secondArg) {
        var componentIdentity = {};
        prepareToUseHooks(task, componentIdentity);
        var result = Component(props, secondArg);
        return finishHooks(Component, props, result, secondArg);
      }
      function finishClassComponent(request, task, instance, Component, props) {
        var nextChildren = instance.render();
        instance.props !== props && (didWarnAboutReassigningProps || error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component) || "a component"), didWarnAboutReassigningProps = !0);
        {
          var childContextTypes = Component.childContextTypes;
          if (childContextTypes != null) {
            var previousContext = task.legacyContext, mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);
            task.legacyContext = mergedContext, renderNodeDestructive(request, task, nextChildren), task.legacyContext = previousContext;
            return;
          }
        }
        renderNodeDestructive(request, task, nextChildren);
      }
      function renderClassComponent(request, task, Component, props) {
        pushClassComponentStackInDEV(task, Component);
        var maskedContext = getMaskedContext(Component, task.legacyContext), instance = constructClassInstance(Component, props, maskedContext);
        mountClassInstance(instance, Component, props, maskedContext), finishClassComponent(request, task, instance, Component, props), popComponentStackInDEV(task);
      }
      var didWarnAboutBadClass = {}, didWarnAboutModulePatternComponent = {}, didWarnAboutContextTypeOnFunctionComponent = {}, didWarnAboutGetDerivedStateOnFunctionComponent = {}, didWarnAboutReassigningProps = !1, didWarnAboutGenerators = !1, didWarnAboutMaps = !1, hasWarnedAboutUsingContextAsConsumer = !1;
      function renderIndeterminateComponent(request, task, Component, props) {
        var legacyContext;
        if (legacyContext = getMaskedContext(Component, task.legacyContext), pushFunctionComponentStackInDEV(task, Component), Component.prototype && typeof Component.prototype.render == "function") {
          var componentName = getComponentNameFromType(Component) || "Unknown";
          didWarnAboutBadClass[componentName] || (error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName), didWarnAboutBadClass[componentName] = !0);
        }
        var value = renderWithHooks(request, task, Component, props, legacyContext), hasId = checkDidRenderIdHook();
        if (typeof value == "object" && value !== null && typeof value.render == "function" && value.$$typeof === void 0) {
          var _componentName = getComponentNameFromType(Component) || "Unknown";
          didWarnAboutModulePatternComponent[_componentName] || (error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName), didWarnAboutModulePatternComponent[_componentName] = !0);
        }
        if (
          // Run these checks in production only if the flag is off.
          // Eventually we'll delete this branch altogether.
          typeof value == "object" && value !== null && typeof value.render == "function" && value.$$typeof === void 0
        ) {
          {
            var _componentName2 = getComponentNameFromType(Component) || "Unknown";
            didWarnAboutModulePatternComponent[_componentName2] || (error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2), didWarnAboutModulePatternComponent[_componentName2] = !0);
          }
          mountClassInstance(value, Component, props, legacyContext), finishClassComponent(request, task, value, Component, props);
        } else if (validateFunctionComponentInDev(Component), hasId) {
          var prevTreeContext = task.treeContext, totalChildren = 1, index = 0;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
          try {
            renderNodeDestructive(request, task, value);
          } finally {
            task.treeContext = prevTreeContext;
          }
        } else
          renderNodeDestructive(request, task, value);
        popComponentStackInDEV(task);
      }
      function validateFunctionComponentInDev(Component) {
        {
          if (Component && Component.childContextTypes && error("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component"), typeof Component.getDerivedStateFromProps == "function") {
            var _componentName3 = getComponentNameFromType(Component) || "Unknown";
            didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] || (error("%s: Function components do not support getDerivedStateFromProps.", _componentName3), didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = !0);
          }
          if (typeof Component.contextType == "object" && Component.contextType !== null) {
            var _componentName4 = getComponentNameFromType(Component) || "Unknown";
            didWarnAboutContextTypeOnFunctionComponent[_componentName4] || (error("%s: Function components do not support contextType.", _componentName4), didWarnAboutContextTypeOnFunctionComponent[_componentName4] = !0);
          }
        }
      }
      function resolveDefaultProps(Component, baseProps) {
        if (Component && Component.defaultProps) {
          var props = assign({}, baseProps), defaultProps = Component.defaultProps;
          for (var propName in defaultProps)
            props[propName] === void 0 && (props[propName] = defaultProps[propName]);
          return props;
        }
        return baseProps;
      }
      function renderForwardRef(request, task, type, props, ref) {
        pushFunctionComponentStackInDEV(task, type.render);
        var children = renderWithHooks(request, task, type.render, props, ref), hasId = checkDidRenderIdHook();
        if (hasId) {
          var prevTreeContext = task.treeContext, totalChildren = 1, index = 0;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
          try {
            renderNodeDestructive(request, task, children);
          } finally {
            task.treeContext = prevTreeContext;
          }
        } else
          renderNodeDestructive(request, task, children);
        popComponentStackInDEV(task);
      }
      function renderMemo(request, task, type, props, ref) {
        var innerType = type.type, resolvedProps = resolveDefaultProps(innerType, props);
        renderElement(request, task, innerType, resolvedProps, ref);
      }
      function renderContextConsumer(request, task, context, props) {
        context._context === void 0 ? context !== context.Consumer && (hasWarnedAboutUsingContextAsConsumer || (hasWarnedAboutUsingContextAsConsumer = !0, error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : context = context._context;
        var render = props.children;
        typeof render != "function" && error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
        var newValue = readContext(context), newChildren = render(newValue);
        renderNodeDestructive(request, task, newChildren);
      }
      function renderContextProvider(request, task, type, props) {
        var context = type._context, value = props.value, children = props.children, prevSnapshot;
        prevSnapshot = task.context, task.context = pushProvider(context, value), renderNodeDestructive(request, task, children), task.context = popProvider(context), prevSnapshot !== task.context && error("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
      }
      function renderLazyComponent(request, task, lazyComponent, props, ref) {
        pushBuiltInComponentStackInDEV(task, "Lazy");
        var payload = lazyComponent._payload, init = lazyComponent._init, Component = init(payload), resolvedProps = resolveDefaultProps(Component, props);
        renderElement(request, task, Component, resolvedProps, ref), popComponentStackInDEV(task);
      }
      function renderElement(request, task, type, props, ref) {
        if (typeof type == "function")
          if (shouldConstruct$1(type)) {
            renderClassComponent(request, task, type, props);
            return;
          } else {
            renderIndeterminateComponent(request, task, type, props);
            return;
          }
        if (typeof type == "string") {
          renderHostElement(request, task, type, props);
          return;
        }
        switch (type) {
          case REACT_LEGACY_HIDDEN_TYPE:
          case REACT_DEBUG_TRACING_MODE_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_FRAGMENT_TYPE: {
            renderNodeDestructive(request, task, props.children);
            return;
          }
          case REACT_SUSPENSE_LIST_TYPE: {
            pushBuiltInComponentStackInDEV(task, "SuspenseList"), renderNodeDestructive(request, task, props.children), popComponentStackInDEV(task);
            return;
          }
          case REACT_SCOPE_TYPE:
            throw new Error("ReactDOMServer does not yet support scope components.");
          case REACT_SUSPENSE_TYPE: {
            renderSuspenseBoundary(request, task, props);
            return;
          }
        }
        if (typeof type == "object" && type !== null)
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE: {
              renderForwardRef(request, task, type, props, ref);
              return;
            }
            case REACT_MEMO_TYPE: {
              renderMemo(request, task, type, props, ref);
              return;
            }
            case REACT_PROVIDER_TYPE: {
              renderContextProvider(request, task, type, props);
              return;
            }
            case REACT_CONTEXT_TYPE: {
              renderContextConsumer(request, task, type, props);
              return;
            }
            case REACT_LAZY_TYPE: {
              renderLazyComponent(request, task, type, props);
              return;
            }
          }
        var info = "";
        throw (type === void 0 || typeof type == "object" && type !== null && Object.keys(type).length === 0) && (info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
      }
      function validateIterable(iterable, iteratorFn) {
        typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
        iterable[Symbol.toStringTag] === "Generator" && (didWarnAboutGenerators || error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), didWarnAboutGenerators = !0), iterable.entries === iteratorFn && (didWarnAboutMaps || error("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = !0);
      }
      function renderNodeDestructive(request, task, node) {
        try {
          return renderNodeDestructiveImpl(request, task, node);
        } catch (x2) {
          throw typeof x2 == "object" && x2 !== null && typeof x2.then == "function" || (lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV()), x2;
        }
      }
      function renderNodeDestructiveImpl(request, task, node) {
        if (task.node = node, typeof node == "object" && node !== null) {
          switch (node.$$typeof) {
            case REACT_ELEMENT_TYPE: {
              var element = node, type = element.type, props = element.props, ref = element.ref;
              renderElement(request, task, type, props, ref);
              return;
            }
            case REACT_PORTAL_TYPE:
              throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
            case REACT_LAZY_TYPE: {
              var lazyNode = node, payload = lazyNode._payload, init = lazyNode._init, resolvedNode;
              try {
                resolvedNode = init(payload);
              } catch (x2) {
                throw typeof x2 == "object" && x2 !== null && typeof x2.then == "function" && pushBuiltInComponentStackInDEV(task, "Lazy"), x2;
              }
              renderNodeDestructive(request, task, resolvedNode);
              return;
            }
          }
          if (isArray(node)) {
            renderChildrenArray(request, task, node);
            return;
          }
          var iteratorFn = getIteratorFn(node);
          if (iteratorFn) {
            validateIterable(node, iteratorFn);
            var iterator = iteratorFn.call(node);
            if (iterator) {
              var step = iterator.next();
              if (!step.done) {
                var children = [];
                do
                  children.push(step.value), step = iterator.next();
                while (!step.done);
                renderChildrenArray(request, task, children);
                return;
              }
              return;
            }
          }
          var childString = Object.prototype.toString.call(node);
          throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(node).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
        }
        if (typeof node == "string") {
          var segment = task.blockedSegment;
          segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, node, request.responseState, segment.lastPushedText);
          return;
        }
        if (typeof node == "number") {
          var _segment = task.blockedSegment;
          _segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, "" + node, request.responseState, _segment.lastPushedText);
          return;
        }
        typeof node == "function" && error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
      function renderChildrenArray(request, task, children) {
        for (var totalChildren = children.length, i2 = 0; i2 < totalChildren; i2++) {
          var prevTreeContext = task.treeContext;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i2);
          try {
            renderNode(request, task, children[i2]);
          } finally {
            task.treeContext = prevTreeContext;
          }
        }
      }
      function spawnNewSuspendedTask(request, task, x2) {
        var segment = task.blockedSegment, insertionIndex = segment.chunks.length, newSegment = createPendingSegment(
          request,
          insertionIndex,
          null,
          segment.formatContext,
          // Adopt the parent segment's leading text embed
          segment.lastPushedText,
          // Assume we are text embedded at the trailing edge
          !0
        );
        segment.children.push(newSegment), segment.lastPushedText = !1;
        var newTask = createTask(request, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
        task.componentStack !== null && (newTask.componentStack = task.componentStack.parent);
        var ping = newTask.ping;
        x2.then(ping, ping);
      }
      function renderNode(request, task, node) {
        var previousFormatContext = task.blockedSegment.formatContext, previousLegacyContext = task.legacyContext, previousContext = task.context, previousComponentStack = null;
        previousComponentStack = task.componentStack;
        try {
          return renderNodeDestructive(request, task, node);
        } catch (x2) {
          if (resetHooksState(), typeof x2 == "object" && x2 !== null && typeof x2.then == "function") {
            spawnNewSuspendedTask(request, task, x2), task.blockedSegment.formatContext = previousFormatContext, task.legacyContext = previousLegacyContext, task.context = previousContext, switchContext(previousContext), task.componentStack = previousComponentStack;
            return;
          } else
            throw task.blockedSegment.formatContext = previousFormatContext, task.legacyContext = previousLegacyContext, task.context = previousContext, switchContext(previousContext), task.componentStack = previousComponentStack, x2;
        }
      }
      function erroredTask(request, boundary, segment, error2) {
        var errorDigest = logRecoverableError(request, error2);
        if (boundary === null ? fatalError(request, error2) : (boundary.pendingTasks--, boundary.forceClientRender || (boundary.forceClientRender = !0, boundary.errorDigest = errorDigest, captureBoundaryErrorDetailsDev(boundary, error2), boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary))), request.allPendingTasks--, request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady;
          onAllReady();
        }
      }
      function abortTaskSoft(task) {
        var request = this, boundary = task.blockedBoundary, segment = task.blockedSegment;
        segment.status = ABORTED, finishedTask(request, boundary, segment);
      }
      function abortTask(task, request, reason) {
        var boundary = task.blockedBoundary, segment = task.blockedSegment;
        if (segment.status = ABORTED, boundary === null)
          request.allPendingTasks--, request.status !== CLOSED && (request.status = CLOSED, request.destination !== null && close(request.destination));
        else {
          if (boundary.pendingTasks--, !boundary.forceClientRender) {
            boundary.forceClientRender = !0;
            var _error = reason === void 0 ? new Error("The render was aborted by the server without a reason.") : reason;
            boundary.errorDigest = request.onError(_error);
            {
              var errorPrefix = "The server did not finish this Suspense boundary: ";
              _error && typeof _error.message == "string" ? _error = errorPrefix + _error.message : _error = errorPrefix + String(_error);
              var previousTaskInDev = currentTaskInDEV;
              currentTaskInDEV = task;
              try {
                captureBoundaryErrorDetailsDev(boundary, _error);
              } finally {
                currentTaskInDEV = previousTaskInDev;
              }
            }
            boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary);
          }
          if (boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
            return abortTask(fallbackTask, request, reason);
          }), boundary.fallbackAbortableTasks.clear(), request.allPendingTasks--, request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
      }
      function queueCompletedSegment(boundary, segment) {
        if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
          var childSegment = segment.children[0];
          childSegment.id = segment.id, childSegment.parentFlushed = !0, childSegment.status === COMPLETED && queueCompletedSegment(boundary, childSegment);
        } else {
          var completedSegments = boundary.completedSegments;
          completedSegments.push(segment);
        }
      }
      function finishedTask(request, boundary, segment) {
        if (boundary === null) {
          if (segment.parentFlushed) {
            if (request.completedRootSegment !== null)
              throw new Error("There can only be one root segment. This is a bug in React.");
            request.completedRootSegment = segment;
          }
          if (request.pendingRootTasks--, request.pendingRootTasks === 0) {
            request.onShellError = noop$1;
            var onShellReady = request.onShellReady;
            onShellReady();
          }
        } else if (boundary.pendingTasks--, !boundary.forceClientRender) {
          if (boundary.pendingTasks === 0)
            segment.parentFlushed && segment.status === COMPLETED && queueCompletedSegment(boundary, segment), boundary.parentFlushed && request.completedBoundaries.push(boundary), boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request), boundary.fallbackAbortableTasks.clear();
          else if (segment.parentFlushed && segment.status === COMPLETED) {
            queueCompletedSegment(boundary, segment);
            var completedSegments = boundary.completedSegments;
            completedSegments.length === 1 && boundary.parentFlushed && request.partialBoundaries.push(boundary);
          }
        }
        if (request.allPendingTasks--, request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady;
          onAllReady();
        }
      }
      function retryTask(request, task) {
        var segment = task.blockedSegment;
        if (segment.status === PENDING) {
          switchContext(task.context);
          var prevTaskInDEV = null;
          prevTaskInDEV = currentTaskInDEV, currentTaskInDEV = task;
          try {
            renderNodeDestructive(request, task, task.node), pushSegmentFinale(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded), task.abortSet.delete(task), segment.status = COMPLETED, finishedTask(request, task.blockedBoundary, segment);
          } catch (x2) {
            if (resetHooksState(), typeof x2 == "object" && x2 !== null && typeof x2.then == "function") {
              var ping = task.ping;
              x2.then(ping, ping);
            } else
              task.abortSet.delete(task), segment.status = ERRORED, erroredTask(request, task.blockedBoundary, segment, x2);
          } finally {
            currentTaskInDEV = prevTaskInDEV;
          }
        }
      }
      function performWork(request) {
        if (request.status !== CLOSED) {
          var prevContext = getActiveContext(), prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = Dispatcher;
          var prevGetCurrentStackImpl;
          prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack, ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
          var prevResponseState = currentResponseState;
          setCurrentResponseState(request.responseState);
          try {
            var pingedTasks = request.pingedTasks, i2;
            for (i2 = 0; i2 < pingedTasks.length; i2++) {
              var task = pingedTasks[i2];
              retryTask(request, task);
            }
            pingedTasks.splice(0, i2), request.destination !== null && flushCompletedQueues(request, request.destination);
          } catch (error2) {
            logRecoverableError(request, error2), fatalError(request, error2);
          } finally {
            setCurrentResponseState(prevResponseState), ReactCurrentDispatcher$1.current = prevDispatcher, ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl, prevDispatcher === Dispatcher && switchContext(prevContext);
          }
        }
      }
      function flushSubtree(request, destination, segment) {
        switch (segment.parentFlushed = !0, segment.status) {
          case PENDING: {
            var segmentID = segment.id = request.nextSegmentId++;
            return segment.lastPushedText = !1, segment.textEmbedded = !1, writePlaceholder(destination, request.responseState, segmentID);
          }
          case COMPLETED: {
            segment.status = FLUSHED;
            for (var r2 = !0, chunks = segment.chunks, chunkIdx = 0, children = segment.children, childIdx = 0; childIdx < children.length; childIdx++) {
              for (var nextChild = children[childIdx]; chunkIdx < nextChild.index; chunkIdx++)
                writeChunk(destination, chunks[chunkIdx]);
              r2 = flushSegment(request, destination, nextChild);
            }
            for (; chunkIdx < chunks.length - 1; chunkIdx++)
              writeChunk(destination, chunks[chunkIdx]);
            return chunkIdx < chunks.length && (r2 = writeChunkAndReturn(destination, chunks[chunkIdx])), r2;
          }
          default:
            throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
        }
      }
      function flushSegment(request, destination, segment) {
        var boundary = segment.boundary;
        if (boundary === null)
          return flushSubtree(request, destination, segment);
        if (boundary.parentFlushed = !0, boundary.forceClientRender)
          return writeStartClientRenderedSuspenseBoundary(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack), flushSubtree(request, destination, segment), writeEndClientRenderedSuspenseBoundary(destination, request.responseState);
        if (boundary.pendingTasks > 0) {
          boundary.rootSegmentID = request.nextSegmentId++, boundary.completedSegments.length > 0 && request.partialBoundaries.push(boundary);
          var id = boundary.id = assignSuspenseBoundaryID(request.responseState);
          return writeStartPendingSuspenseBoundary(destination, request.responseState, id), flushSubtree(request, destination, segment), writeEndPendingSuspenseBoundary(destination, request.responseState);
        } else {
          if (boundary.byteSize > request.progressiveChunkSize)
            return boundary.rootSegmentID = request.nextSegmentId++, request.completedBoundaries.push(boundary), writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id), flushSubtree(request, destination, segment), writeEndPendingSuspenseBoundary(destination, request.responseState);
          writeStartCompletedSuspenseBoundary(destination, request.responseState);
          var completedSegments = boundary.completedSegments;
          if (completedSegments.length !== 1)
            throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
          var contentSegment = completedSegments[0];
          return flushSegment(request, destination, contentSegment), writeEndCompletedSuspenseBoundary(destination, request.responseState);
        }
      }
      function flushClientRenderedBoundary(request, destination, boundary) {
        return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
      }
      function flushSegmentContainer(request, destination, segment) {
        return writeStartSegment(destination, request.responseState, segment.formatContext, segment.id), flushSegment(request, destination, segment), writeEndSegment(destination, segment.formatContext);
      }
      function flushCompletedBoundary(request, destination, boundary) {
        for (var completedSegments = boundary.completedSegments, i2 = 0; i2 < completedSegments.length; i2++) {
          var segment = completedSegments[i2];
          flushPartiallyCompletedSegment(request, destination, boundary, segment);
        }
        return completedSegments.length = 0, writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID);
      }
      function flushPartialBoundary(request, destination, boundary) {
        for (var completedSegments = boundary.completedSegments, i2 = 0; i2 < completedSegments.length; i2++) {
          var segment = completedSegments[i2];
          if (!flushPartiallyCompletedSegment(request, destination, boundary, segment))
            return i2++, completedSegments.splice(0, i2), !1;
        }
        return completedSegments.splice(0, i2), !0;
      }
      function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
        if (segment.status === FLUSHED)
          return !0;
        var segmentID = segment.id;
        if (segmentID === -1) {
          var rootSegmentID = segment.id = boundary.rootSegmentID;
          if (rootSegmentID === -1)
            throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
          return flushSegmentContainer(request, destination, segment);
        } else
          return flushSegmentContainer(request, destination, segment), writeCompletedSegmentInstruction(destination, request.responseState, segmentID);
      }
      function flushCompletedQueues(request, destination) {
        beginWriting();
        try {
          var completedRootSegment = request.completedRootSegment;
          completedRootSegment !== null && request.pendingRootTasks === 0 && (flushSegment(request, destination, completedRootSegment), request.completedRootSegment = null, writeCompletedRoot(destination, request.responseState));
          var clientRenderedBoundaries = request.clientRenderedBoundaries, i2;
          for (i2 = 0; i2 < clientRenderedBoundaries.length; i2++) {
            var boundary = clientRenderedBoundaries[i2];
            if (!flushClientRenderedBoundary(request, destination, boundary)) {
              request.destination = null, i2++, clientRenderedBoundaries.splice(0, i2);
              return;
            }
          }
          clientRenderedBoundaries.splice(0, i2);
          var completedBoundaries = request.completedBoundaries;
          for (i2 = 0; i2 < completedBoundaries.length; i2++) {
            var _boundary = completedBoundaries[i2];
            if (!flushCompletedBoundary(request, destination, _boundary)) {
              request.destination = null, i2++, completedBoundaries.splice(0, i2);
              return;
            }
          }
          completedBoundaries.splice(0, i2), completeWriting(destination), beginWriting(destination);
          var partialBoundaries = request.partialBoundaries;
          for (i2 = 0; i2 < partialBoundaries.length; i2++) {
            var _boundary2 = partialBoundaries[i2];
            if (!flushPartialBoundary(request, destination, _boundary2)) {
              request.destination = null, i2++, partialBoundaries.splice(0, i2);
              return;
            }
          }
          partialBoundaries.splice(0, i2);
          var largeBoundaries = request.completedBoundaries;
          for (i2 = 0; i2 < largeBoundaries.length; i2++) {
            var _boundary3 = largeBoundaries[i2];
            if (!flushCompletedBoundary(request, destination, _boundary3)) {
              request.destination = null, i2++, largeBoundaries.splice(0, i2);
              return;
            }
          }
          largeBoundaries.splice(0, i2);
        } finally {
          completeWriting(destination), flushBuffered(destination), request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0 && (request.abortableTasks.size !== 0 && error("There was still abortable task at the root when we closed. This is a bug in React."), close(destination));
        }
      }
      function startWork(request) {
        scheduleWork(function() {
          return performWork(request);
        });
      }
      function startFlowing(request, destination) {
        if (request.status === CLOSING) {
          request.status = CLOSED, closeWithError(destination, request.fatalError);
          return;
        }
        if (request.status !== CLOSED && request.destination === null) {
          request.destination = destination;
          try {
            flushCompletedQueues(request, destination);
          } catch (error2) {
            logRecoverableError(request, error2), fatalError(request, error2);
          }
        }
      }
      function abort(request, reason) {
        try {
          var abortableTasks = request.abortableTasks;
          abortableTasks.forEach(function(task) {
            return abortTask(task, request, reason);
          }), abortableTasks.clear(), request.destination !== null && flushCompletedQueues(request, request.destination);
        } catch (error2) {
          logRecoverableError(request, error2), fatalError(request, error2);
        }
      }
      function createDrainHandler(destination, request) {
        return function() {
          return startFlowing(request, destination);
        };
      }
      function createAbortHandler(request, reason) {
        return function() {
          return abort(request, reason);
        };
      }
      function createRequestImpl(children, options) {
        return createRequest(children, createResponseState(options ? options.identifierPrefix : void 0, options ? options.nonce : void 0, options ? options.bootstrapScriptContent : void 0, options ? options.bootstrapScripts : void 0, options ? options.bootstrapModules : void 0), createRootFormatContext(options ? options.namespaceURI : void 0), options ? options.progressiveChunkSize : void 0, options ? options.onError : void 0, options ? options.onAllReady : void 0, options ? options.onShellReady : void 0, options ? options.onShellError : void 0, void 0);
      }
      function renderToPipeableStream2(children, options) {
        var request = createRequestImpl(children, options), hasStartedFlowing = !1;
        return startWork(request), {
          pipe: function(destination) {
            if (hasStartedFlowing)
              throw new Error("React currently only supports piping to one writable stream.");
            return hasStartedFlowing = !0, startFlowing(request, destination), destination.on("drain", createDrainHandler(destination, request)), destination.on("error", createAbortHandler(
              request,
              // eslint-disable-next-line react-internal/prod-error-codes
              new Error("The destination stream errored while writing data.")
            )), destination.on("close", createAbortHandler(
              request,
              // eslint-disable-next-line react-internal/prod-error-codes
              new Error("The destination stream closed early.")
            )), destination;
          },
          abort: function(reason) {
            abort(request, reason);
          }
        };
      }
      exports.renderToPipeableStream = renderToPipeableStream2, exports.version = ReactVersion;
    })();
  }
});

// node_modules/react-dom/server.node.js
var require_server_node = __commonJS({
  "node_modules/react-dom/server.node.js"(exports) {
    "use strict";
    var l, s2;
    l = require_react_dom_server_legacy_node_development(), s2 = require_react_dom_server_node_development();
    exports.version = l.version;
    exports.renderToString = l.renderToString;
    exports.renderToStaticMarkup = l.renderToStaticMarkup;
    exports.renderToNodeStream = l.renderToNodeStream;
    exports.renderToStaticNodeStream = l.renderToStaticNodeStream;
    exports.renderToPipeableStream = s2.renderToPipeableStream;
  }
});

// node_modules/react/cjs/react-jsx-dev-runtime.development.js
var require_react_jsx_dev_runtime_development = __commonJS({
  "node_modules/react/cjs/react-jsx-dev-runtime.development.js"(exports) {
    "use strict";
    (function() {
      "use strict";
      var React5 = require_react(), REACT_ELEMENT_TYPE = Symbol.for("react.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable != "object")
          return null;
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        return typeof maybeIterator == "function" ? maybeIterator : null;
      }
      var ReactSharedInternals = React5.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error(format) {
        {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
            args[_key2 - 1] = arguments[_key2];
          printWarning("error", format, args);
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame, stack = ReactDebugCurrentFrame2.getStackAddendum();
          stack !== "" && (format += "%s", args = args.concat([stack]));
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format), Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var enableScopeAPI = !1, enableCacheElement = !1, enableTransitionTracing = !1, enableLegacyHidden = !1, enableDebugTracing = !1, REACT_MODULE_REFERENCE;
      REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      function isValidElementType(type) {
        return !!(typeof type == "string" || typeof type == "function" || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing || typeof type == "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0));
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName)
          return displayName;
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null)
          return null;
        if (typeof type.tag == "number" && error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof type == "function")
          return type.displayName || type.name || null;
        if (typeof type == "string")
          return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type == "object")
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              return outerName !== null ? outerName : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type, payload = lazyComponent._payload, init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var assign = Object.assign, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = !0;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log, prevInfo = console.info, prevWarn = console.warn, prevError = console.error, prevGroup = console.group, prevGroupCollapsed = console.groupCollapsed, prevGroupEnd = console.groupEnd;
            var props = {
              configurable: !0,
              enumerable: !0,
              value: disabledLog,
              writable: !0
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          if (disabledDepth--, disabledDepth === 0) {
            var props = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          disabledDepth < 0 && error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher, prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === void 0)
            try {
              throw Error();
            } catch (x2) {
              var match = x2.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          return `
` + prefix + name;
        }
      }
      var reentry = !1, componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap == "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry)
          return "";
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0)
            return frame;
        }
        var control;
        reentry = !0;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        previousDispatcher = ReactCurrentDispatcher.current, ReactCurrentDispatcher.current = null, disableLogs();
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            if (Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x2) {
                control = x2;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x2) {
                control = x2;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x2) {
              control = x2;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack == "string") {
            for (var sampleLines = sample.stack.split(`
`), controlLines = control.stack.split(`
`), s2 = sampleLines.length - 1, c = controlLines.length - 1; s2 >= 1 && c >= 0 && sampleLines[s2] !== controlLines[c]; )
              c--;
            for (; s2 >= 1 && c >= 0; s2--, c--)
              if (sampleLines[s2] !== controlLines[c]) {
                if (s2 !== 1 || c !== 1)
                  do
                    if (s2--, c--, c < 0 || sampleLines[s2] !== controlLines[c]) {
                      var _frame = `
` + sampleLines[s2].replace(" at new ", " at ");
                      return fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName)), typeof fn == "function" && componentFrameCache.set(fn, _frame), _frame;
                    }
                  while (s2 >= 1 && c >= 0);
                break;
              }
          }
        } finally {
          reentry = !1, ReactCurrentDispatcher.current = previousDispatcher, reenableLogs(), Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "", syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        return typeof fn == "function" && componentFrameCache.set(fn, syntheticFrame), syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        return describeNativeComponentFrame(fn, !1);
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null)
          return "";
        if (typeof type == "function")
          return describeNativeComponentFrame(type, shouldConstruct(type));
        if (typeof type == "string")
          return describeBuiltInComponentFrame(type);
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type == "object")
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type, payload = lazyComponent._payload, init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch {
              }
            }
          }
        return "";
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty, loggedTypeFailures = {}, ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        if (element) {
          var owner = element._owner, stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame.setExtraStackFrame(stack);
        } else
          ReactDebugCurrentFrame.setExtraStackFrame(null);
      }
      function checkPropTypes(typeSpecs, values, location, componentName, element) {
        {
          var has2 = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs)
            if (has2(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] != "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw err.name = "Invariant Violation", err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              error$1 && !(error$1 instanceof Error) && (setCurrentlyValidatingElement(element), error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1), setCurrentlyValidatingElement(null)), error$1 instanceof Error && !(error$1.message in loggedTypeFailures) && (loggedTypeFailures[error$1.message] = !0, setCurrentlyValidatingElement(element), error("Failed %s type: %s", location, error$1.message), setCurrentlyValidatingElement(null));
            }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol == "function" && Symbol.toStringTag, type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        try {
          return testStringCoercion(value), !1;
        } catch {
          return !0;
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        if (willCoercionThrow(value))
          return error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value)), testStringCoercion(value);
      }
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner, RESERVED_PROPS = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
      didWarnAboutStringRefs = {};
      function hasValidRef(config) {
        if (hasOwnProperty.call(config, "ref")) {
          var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
          if (getter && getter.isReactWarning)
            return !1;
        }
        return config.ref !== void 0;
      }
      function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config, "key").get;
          if (getter && getter.isReactWarning)
            return !1;
        }
        return config.key !== void 0;
      }
      function warnIfStringRefCannotBeAutoConverted(config, self2) {
        if (typeof config.ref == "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
          var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
          didWarnAboutStringRefs[componentName] || (error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref), didWarnAboutStringRefs[componentName] = !0);
        }
      }
      function defineKeyPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingKey = function() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName));
          };
          warnAboutAccessingKey.isReactWarning = !0, Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
          });
        }
      }
      function defineRefPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingRef = function() {
            specialPropRefWarningShown || (specialPropRefWarningShown = !0, error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName));
          };
          warnAboutAccessingRef.isReactWarning = !0, Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: !0
          });
        }
      }
      var ReactElement = function(type, key, ref, self2, source, owner, props) {
        var element = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: REACT_ELEMENT_TYPE,
          // Built-in properties that belong on the element
          type,
          key,
          ref,
          props,
          // Record the component responsible for creating this element.
          _owner: owner
        };
        return element._store = {}, Object.defineProperty(element._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(element, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: self2
        }), Object.defineProperty(element, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: source
        }), Object.freeze && (Object.freeze(element.props), Object.freeze(element)), element;
      };
      function jsxDEV15(type, config, maybeKey, source, self2) {
        {
          var propName, props = {}, key = null, ref = null;
          maybeKey !== void 0 && (checkKeyStringCoercion(maybeKey), key = "" + maybeKey), hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key), hasValidRef(config) && (ref = config.ref, warnIfStringRefCannotBeAutoConverted(config, self2));
          for (propName in config)
            hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName) && (props[propName] = config[propName]);
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps)
              props[propName] === void 0 && (props[propName] = defaultProps[propName]);
          }
          if (key || ref) {
            var displayName = typeof type == "function" ? type.displayName || type.name || "Unknown" : type;
            key && defineKeyPropWarningGetter(props, displayName), ref && defineRefPropWarningGetter(props, displayName);
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner, ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement$1(element) {
        if (element) {
          var owner = element._owner, stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
        } else
          ReactDebugCurrentFrame$1.setExtraStackFrame(null);
      }
      var propTypesMisspellWarningShown;
      propTypesMisspellWarningShown = !1;
      function isValidElement(object) {
        return typeof object == "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function getDeclarationErrorAddendum() {
        {
          if (ReactCurrentOwner$1.current) {
            var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
            if (name)
              return `

Check the render method of \`` + name + "`.";
          }
          return "";
        }
      }
      function getSourceInfoErrorAddendum(source) {
        {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, ""), lineNumber = source.lineNumber;
            return `

Check your code at ` + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType == "string" ? parentType : parentType.displayName || parentType.name;
            parentName && (info = `

Check the top-level render call using <` + parentName + ">.");
          }
          return info;
        }
      }
      function validateExplicitKey(element, parentType) {
        {
          if (!element._store || element._store.validated || element.key != null)
            return;
          element._store.validated = !0;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo])
            return;
          ownerHasKeyUseWarning[currentComponentErrorInfo] = !0;
          var childOwner = "";
          element && element._owner && element._owner !== ReactCurrentOwner$1.current && (childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + "."), setCurrentlyValidatingElement$1(element), error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner), setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node, parentType) {
        {
          if (typeof node != "object")
            return;
          if (isArray(node))
            for (var i2 = 0; i2 < node.length; i2++) {
              var child = node[i2];
              isValidElement(child) && validateExplicitKey(child, parentType);
            }
          else if (isValidElement(node))
            node._store && (node._store.validated = !0);
          else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn == "function" && iteratorFn !== node.entries)
              for (var iterator = iteratorFn.call(node), step; !(step = iterator.next()).done; )
                isValidElement(step.value) && validateExplicitKey(step.value, parentType);
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type = element.type;
          if (type == null || typeof type == "string")
            return;
          var propTypes;
          if (typeof type == "function")
            propTypes = type.propTypes;
          else if (typeof type == "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          type.$$typeof === REACT_MEMO_TYPE))
            propTypes = type.propTypes;
          else
            return;
          if (propTypes) {
            var name = getComponentNameFromType(type);
            checkPropTypes(propTypes, element.props, "prop", name, element);
          } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = !0;
            var _name2 = getComponentNameFromType(type);
            error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name2 || "Unknown");
          }
          typeof type.getDefaultProps == "function" && !type.getDefaultProps.isReactClassApproved && error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function validateFragmentProps(fragment) {
        {
          for (var keys = Object.keys(fragment.props), i2 = 0; i2 < keys.length; i2++) {
            var key = keys[i2];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment), error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key), setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          fragment.ref !== null && (setCurrentlyValidatingElement$1(fragment), error("Invalid attribute `ref` supplied to `React.Fragment`."), setCurrentlyValidatingElement$1(null));
        }
      }
      function jsxWithValidation(type, props, key, isStaticChildren, source, self2) {
        {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            (type === void 0 || typeof type == "object" && type !== null && Object.keys(type).length === 0) && (info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
            var sourceInfo = getSourceInfoErrorAddendum(source);
            sourceInfo ? info += sourceInfo : info += getDeclarationErrorAddendum();
            var typeString;
            type === null ? typeString = "null" : isArray(type) ? typeString = "array" : type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE ? (typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", info = " Did you accidentally export a JSX literal instead of a component?") : typeString = typeof type, error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
          }
          var element = jsxDEV15(type, props, key, source, self2);
          if (element == null)
            return element;
          if (validType) {
            var children = props.children;
            if (children !== void 0)
              if (isStaticChildren)
                if (isArray(children)) {
                  for (var i2 = 0; i2 < children.length; i2++)
                    validateChildKeys(children[i2], type);
                  Object.freeze && Object.freeze(children);
                } else
                  error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
              else
                validateChildKeys(children, type);
          }
          return type === REACT_FRAGMENT_TYPE ? validateFragmentProps(element) : validatePropTypes(element), element;
        }
      }
      var jsxDEV$1 = jsxWithValidation;
      exports.Fragment = REACT_FRAGMENT_TYPE, exports.jsxDEV = jsxDEV$1;
    })();
  }
});

// node_modules/react/jsx-dev-runtime.js
var require_jsx_dev_runtime = __commonJS({
  "node_modules/react/jsx-dev-runtime.js"(exports, module2) {
    "use strict";
    module2.exports = require_react_jsx_dev_runtime_development();
  }
});

// node_modules/map-obj/index.js
var require_map_obj = __commonJS({
  "node_modules/map-obj/index.js"(exports, module2) {
    "use strict";
    var isObject2 = (value) => typeof value == "object" && value !== null, mapObjectSkip = Symbol("skip"), isObjectCustom = (value) => isObject2(value) && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date), mapObject2 = (object, mapper, options, isSeen = /* @__PURE__ */ new WeakMap()) => {
      if (options = {
        deep: !1,
        target: {},
        ...options
      }, isSeen.has(object))
        return isSeen.get(object);
      isSeen.set(object, options.target);
      let { target } = options;
      delete options.target;
      let mapArray = (array) => array.map((element) => isObjectCustom(element) ? mapObject2(element, mapper, options, isSeen) : element);
      if (Array.isArray(object))
        return mapArray(object);
      for (let [key, value] of Object.entries(object)) {
        let mapResult = mapper(key, value, object);
        if (mapResult === mapObjectSkip)
          continue;
        let [newKey, newValue, { shouldRecurse = !0 } = {}] = mapResult;
        newKey !== "__proto__" && (options.deep && shouldRecurse && isObjectCustom(newValue) && (newValue = Array.isArray(newValue) ? mapArray(newValue) : mapObject2(newValue, mapper, options, isSeen)), target[newKey] = newValue);
      }
      return target;
    };
    module2.exports = (object, mapper, options) => {
      if (!isObject2(object))
        throw new TypeError(`Expected an object, got \`${object}\` (${typeof object})`);
      return mapObject2(object, mapper, options);
    };
    module2.exports.mapObjectSkip = mapObjectSkip;
  }
});

// node_modules/lodash.merge/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.merge/index.js"(exports, module2) {
    var LARGE_ARRAY_SIZE = 200, HASH_UNDEFINED = "__lodash_hash_undefined__", HOT_COUNT = 800, HOT_SPAN = 16, MAX_SAFE_INTEGER = 9007199254740991, argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, reIsUint = /^(?:0|[1-9]\d*)$/, typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = !1;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global, freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), freeExports = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2, moduleExports = freeModule && freeModule.exports === freeExports, freeProcess = moduleExports && freeGlobal.process, nodeUtil = function() {
      try {
        var types3 = freeModule && freeModule.require && freeModule.require("util").types;
        return types3 || freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch {
      }
    }(), nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n, iteratee) {
      for (var index = -1, result = Array(n); ++index < n; )
        result[index] = iteratee(index);
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype, coreJsData = root["__core-js_shared__"], funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }(), nativeObjectToString = objectProto.toString, objectCtorString = funcToString.call(Object), reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    ), Buffer4 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, allocUnsafe = Buffer4 ? Buffer4.allocUnsafe : void 0, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0, defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        return func({}, "", {}), func;
      } catch {
      }
    }(), nativeIsBuffer = Buffer4 ? Buffer4.isBuffer : void 0, nativeMax = Math.max, nativeNow = Date.now, Map2 = getNative(root, "Map"), nativeCreate = getNative(Object, "create"), baseCreate = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject2(proto))
          return {};
        if (objectCreate)
          return objectCreate(proto);
        object.prototype = proto;
        var result = new object();
        return object.prototype = void 0, result;
      };
    }();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      for (this.clear(); ++index < length; ) {
        var entry2 = entries[index];
        this.set(entry2[0], entry2[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      return this.size -= result ? 1 : 0, result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      return this.size += this.has(key) ? 0 : 1, data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value, this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype.delete = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      for (this.clear(); ++index < length; ) {
        var entry2 = entries[index];
        this.set(entry2[0], entry2[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [], this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0)
        return !1;
      var lastIndex = data.length - 1;
      return index == lastIndex ? data.pop() : splice.call(data, index, 1), --this.size, !0;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? (++this.size, data.push([key, value])) : data[index][1] = value, this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype.delete = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      for (this.clear(); ++index < length; ) {
        var entry2 = entries[index];
        this.set(entry2[0], entry2[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0, this.__data__ = {
        hash: new Hash(),
        map: new (Map2 || ListCache)(),
        string: new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key).delete(key);
      return this.size -= result ? 1 : 0, result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      return data.set(key, value), this.size += data.size == size ? 0 : 1, this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype.delete = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache(), this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data.delete(key);
      return this.size = data.size, result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1)
          return pairs.push([key, value]), this.size = ++data.size, this;
        data = this.__data__ = new MapCache(pairs);
      }
      return data.set(key, value), this.size = data.size, this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype.delete = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value)
        (inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length))) && result.push(key);
      return result;
    }
    function assignMergeValue(object, key, value) {
      (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) && baseAssignValue(object, key, value);
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) && baseAssignValue(object, key, value);
    }
    function assocIndexOf(array, key) {
      for (var length = array.length; length--; )
        if (eq(array[length][0], key))
          return length;
      return -1;
    }
    function baseAssignValue(object, key, value) {
      key == "__proto__" && defineProperty ? defineProperty(object, key, {
        configurable: !0,
        enumerable: !0,
        value,
        writable: !0
      }) : object[key] = value;
    }
    var baseFor = createBaseFor();
    function baseGetTag(value) {
      return value == null ? value === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value))
        return !1;
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeysIn(object) {
      if (!isObject2(object))
        return nativeKeysIn(object);
      var isProto = isPrototype(object), result = [];
      for (var key in object)
        key == "constructor" && (isProto || !hasOwnProperty.call(object, key)) || result.push(key);
      return result;
    }
    function baseMerge(object, source, srcIndex, customizer, stack) {
      object !== source && baseFor(source, function(srcValue, key) {
        if (stack || (stack = new Stack()), isObject2(srcValue))
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          newValue === void 0 && (newValue = srcValue), assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0, isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue, isArr || isBuff || isTyped ? isArray(objValue) ? newValue = objValue : isArrayLikeObject(objValue) ? newValue = copyArray(objValue) : isBuff ? (isCommon = !1, newValue = cloneBuffer(srcValue, !0)) : isTyped ? (isCommon = !1, newValue = cloneTypedArray(srcValue, !0)) : newValue = [] : isPlainObject(srcValue) || isArguments(srcValue) ? (newValue = objValue, isArguments(objValue) ? newValue = toPlainObject(objValue) : (!isObject2(objValue) || isFunction(objValue)) && (newValue = initCloneObject(srcValue))) : isCommon = !1;
      }
      isCommon && (stack.set(srcValue, newValue), mergeFunc(newValue, srcValue, srcIndex, customizer, stack), stack.delete(srcValue)), assignMergeValue(object, key, newValue);
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    var baseSetToString = defineProperty ? function(func, string) {
      return defineProperty(func, "toString", {
        configurable: !0,
        enumerable: !1,
        value: constant(string),
        writable: !0
      });
    } : identity;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep)
        return buffer.slice();
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      return buffer.copy(result), result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      return new Uint8Array2(result).set(new Uint8Array2(arrayBuffer)), result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      for (array || (array = Array(length)); ++index < length; )
        array[index] = source[index];
      return array;
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      for (var index = -1, length = props.length; ++index < length; ) {
        var key = props[index], newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        newValue === void 0 && (newValue = source[key]), isNew ? baseAssignValue(object, key, newValue) : assignValue(object, key, newValue);
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        for (customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0, guard && isIterateeCall(sources[0], sources[1], guard) && (customizer = length < 3 ? void 0 : customizer, length = 1), object = Object(object); ++index < length; ) {
          var source = sources[index];
          source && assigner(object, source, index, customizer);
        }
        return object;
      });
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        for (var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length; length--; ) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === !1)
            break;
        }
        return object;
      };
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = !0;
      } catch {
      }
      var result = nativeObjectToString.call(value);
      return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]), result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function isIndex(value, length) {
      var type = typeof value;
      return length = length ?? MAX_SAFE_INTEGER, !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
    }
    function isIterateeCall(value, index, object) {
      if (!isObject2(object))
        return !1;
      var type = typeof index;
      return (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) ? eq(object[index], value) : !1;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null)
        for (var key in Object(object))
          result.push(key);
      return result;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function overRest(func, start, transform) {
      return start = nativeMax(start === void 0 ? func.length - 1 : start, 0), function() {
        for (var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length); ++index < length; )
          array[index] = args[start + index];
        index = -1;
        for (var otherArgs = Array(start + 1); ++index < start; )
          otherArgs[index] = args[index];
        return otherArgs[start] = transform(array), apply(func, this, otherArgs);
      };
    }
    function safeGet(object, key) {
      if (!(key === "constructor" && typeof object[key] == "function") && key != "__proto__")
        return object[key];
    }
    var setToString = shortOut(baseSetToString);
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        if (lastCalled = stamp, remaining > 0) {
          if (++count >= HOT_COUNT)
            return arguments[0];
        } else
          count = 0;
        return func.apply(void 0, arguments);
      };
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch {
        }
        try {
          return func + "";
        } catch {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    }, isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      if (!isObject2(value))
        return !1;
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag)
        return !1;
      var proto = getPrototype(value);
      if (proto === null)
        return !0;
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, !0) : baseKeysIn(object);
    }
    var merge2 = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    function constant(value) {
      return function() {
        return value;
      };
    }
    function identity(value) {
      return value;
    }
    function stubFalse() {
      return !1;
    }
    module2.exports = merge2;
  }
});

// node_modules/web-streams-polyfill/dist/ponyfill.es2018.js
var require_ponyfill_es2018 = __commonJS({
  "node_modules/web-streams-polyfill/dist/ponyfill.es2018.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports == "object" && typeof module2 < "u" ? factory(exports) : typeof define == "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis < "u" ? globalThis : global2 || self, factory(global2.WebStreamsPolyfill = {}));
    })(exports, function(exports2) {
      "use strict";
      let SymbolPolyfill = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol : (description) => `Symbol(${description})`;
      function noop2() {
      }
      function getGlobals() {
        if (typeof self < "u")
          return self;
        if (typeof window < "u")
          return window;
        if (typeof global < "u")
          return global;
      }
      let globals = getGlobals();
      function typeIsObject(x2) {
        return typeof x2 == "object" && x2 !== null || typeof x2 == "function";
      }
      let rethrowAssertionErrorRejection = noop2, originalPromise = Promise, originalPromiseThen = Promise.prototype.then, originalPromiseResolve = Promise.resolve.bind(originalPromise), originalPromiseReject = Promise.reject.bind(originalPromise);
      function newPromise(executor) {
        return new originalPromise(executor);
      }
      function promiseResolvedWith(value) {
        return originalPromiseResolve(value);
      }
      function promiseRejectedWith(reason) {
        return originalPromiseReject(reason);
      }
      function PerformPromiseThen(promise, onFulfilled, onRejected) {
        return originalPromiseThen.call(promise, onFulfilled, onRejected);
      }
      function uponPromise(promise, onFulfilled, onRejected) {
        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
      }
      function uponFulfillment(promise, onFulfilled) {
        uponPromise(promise, onFulfilled);
      }
      function uponRejection(promise, onRejected) {
        uponPromise(promise, void 0, onRejected);
      }
      function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
      }
      function setPromiseIsHandledToTrue(promise) {
        PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
      }
      let queueMicrotask = (() => {
        let globalQueueMicrotask = globals && globals.queueMicrotask;
        if (typeof globalQueueMicrotask == "function")
          return globalQueueMicrotask;
        let resolvedPromise = promiseResolvedWith(void 0);
        return (fn) => PerformPromiseThen(resolvedPromise, fn);
      })();
      function reflectCall(F2, V, args) {
        if (typeof F2 != "function")
          throw new TypeError("Argument is not a function");
        return Function.prototype.apply.call(F2, V, args);
      }
      function promiseCall(F2, V, args) {
        try {
          return promiseResolvedWith(reflectCall(F2, V, args));
        } catch (value) {
          return promiseRejectedWith(value);
        }
      }
      let QUEUE_MAX_ARRAY_SIZE = 16384;
      class SimpleQueue {
        constructor() {
          this._cursor = 0, this._size = 0, this._front = {
            _elements: [],
            _next: void 0
          }, this._back = this._front, this._cursor = 0, this._size = 0;
        }
        get length() {
          return this._size;
        }
        // For exception safety, this method is structured in order:
        // 1. Read state
        // 2. Calculate required state mutations
        // 3. Perform state mutations
        push(element) {
          let oldBack = this._back, newBack = oldBack;
          oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1 && (newBack = {
            _elements: [],
            _next: void 0
          }), oldBack._elements.push(element), newBack !== oldBack && (this._back = newBack, oldBack._next = newBack), ++this._size;
        }
        // Like push(), shift() follows the read -> calculate -> mutate pattern for
        // exception safety.
        shift() {
          let oldFront = this._front, newFront = oldFront, oldCursor = this._cursor, newCursor = oldCursor + 1, elements = oldFront._elements, element = elements[oldCursor];
          return newCursor === QUEUE_MAX_ARRAY_SIZE && (newFront = oldFront._next, newCursor = 0), --this._size, this._cursor = newCursor, oldFront !== newFront && (this._front = newFront), elements[oldCursor] = void 0, element;
        }
        // The tricky thing about forEach() is that it can be called
        // re-entrantly. The queue may be mutated inside the callback. It is easy to
        // see that push() within the callback has no negative effects since the end
        // of the queue is checked for on every iteration. If shift() is called
        // repeatedly within the callback then the next iteration may return an
        // element that has been removed. In this case the callback will be called
        // with undefined values until we either "catch up" with elements that still
        // exist or reach the back of the queue.
        forEach(callback) {
          let i2 = this._cursor, node = this._front, elements = node._elements;
          for (; (i2 !== elements.length || node._next !== void 0) && !(i2 === elements.length && (node = node._next, elements = node._elements, i2 = 0, elements.length === 0)); )
            callback(elements[i2]), ++i2;
        }
        // Return the element that would be returned if shift() was called now,
        // without modifying the queue.
        peek() {
          let front = this._front, cursor = this._cursor;
          return front._elements[cursor];
        }
      }
      function ReadableStreamReaderGenericInitialize(reader, stream) {
        reader._ownerReadableStream = stream, stream._reader = reader, stream._state === "readable" ? defaultReaderClosedPromiseInitialize(reader) : stream._state === "closed" ? defaultReaderClosedPromiseInitializeAsResolved(reader) : defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
      }
      function ReadableStreamReaderGenericCancel(reader, reason) {
        let stream = reader._ownerReadableStream;
        return ReadableStreamCancel(stream, reason);
      }
      function ReadableStreamReaderGenericRelease(reader) {
        reader._ownerReadableStream._state === "readable" ? defaultReaderClosedPromiseReject(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : defaultReaderClosedPromiseResetToRejected(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), reader._ownerReadableStream._reader = void 0, reader._ownerReadableStream = void 0;
      }
      function readerLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released reader");
      }
      function defaultReaderClosedPromiseInitialize(reader) {
        reader._closedPromise = newPromise((resolve, reject) => {
          reader._closedPromise_resolve = resolve, reader._closedPromise_reject = reject;
        });
      }
      function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
        defaultReaderClosedPromiseInitialize(reader), defaultReaderClosedPromiseReject(reader, reason);
      }
      function defaultReaderClosedPromiseInitializeAsResolved(reader) {
        defaultReaderClosedPromiseInitialize(reader), defaultReaderClosedPromiseResolve(reader);
      }
      function defaultReaderClosedPromiseReject(reader, reason) {
        reader._closedPromise_reject !== void 0 && (setPromiseIsHandledToTrue(reader._closedPromise), reader._closedPromise_reject(reason), reader._closedPromise_resolve = void 0, reader._closedPromise_reject = void 0);
      }
      function defaultReaderClosedPromiseResetToRejected(reader, reason) {
        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
      }
      function defaultReaderClosedPromiseResolve(reader) {
        reader._closedPromise_resolve !== void 0 && (reader._closedPromise_resolve(void 0), reader._closedPromise_resolve = void 0, reader._closedPromise_reject = void 0);
      }
      let AbortSteps = SymbolPolyfill("[[AbortSteps]]"), ErrorSteps = SymbolPolyfill("[[ErrorSteps]]"), CancelSteps = SymbolPolyfill("[[CancelSteps]]"), PullSteps = SymbolPolyfill("[[PullSteps]]"), NumberIsFinite = Number.isFinite || function(x2) {
        return typeof x2 == "number" && isFinite(x2);
      }, MathTrunc = Math.trunc || function(v) {
        return v < 0 ? Math.ceil(v) : Math.floor(v);
      };
      function isDictionary(x2) {
        return typeof x2 == "object" || typeof x2 == "function";
      }
      function assertDictionary(obj, context) {
        if (obj !== void 0 && !isDictionary(obj))
          throw new TypeError(`${context} is not an object.`);
      }
      function assertFunction(x2, context) {
        if (typeof x2 != "function")
          throw new TypeError(`${context} is not a function.`);
      }
      function isObject2(x2) {
        return typeof x2 == "object" && x2 !== null || typeof x2 == "function";
      }
      function assertObject(x2, context) {
        if (!isObject2(x2))
          throw new TypeError(`${context} is not an object.`);
      }
      function assertRequiredArgument(x2, position, context) {
        if (x2 === void 0)
          throw new TypeError(`Parameter ${position} is required in '${context}'.`);
      }
      function assertRequiredField(x2, field, context) {
        if (x2 === void 0)
          throw new TypeError(`${field} is required in '${context}'.`);
      }
      function convertUnrestrictedDouble(value) {
        return Number(value);
      }
      function censorNegativeZero(x2) {
        return x2 === 0 ? 0 : x2;
      }
      function integerPart(x2) {
        return censorNegativeZero(MathTrunc(x2));
      }
      function convertUnsignedLongLongWithEnforceRange(value, context) {
        let upperBound = Number.MAX_SAFE_INTEGER, x2 = Number(value);
        if (x2 = censorNegativeZero(x2), !NumberIsFinite(x2))
          throw new TypeError(`${context} is not a finite number`);
        if (x2 = integerPart(x2), x2 < 0 || x2 > upperBound)
          throw new TypeError(`${context} is outside the accepted range of 0 to ${upperBound}, inclusive`);
        return !NumberIsFinite(x2) || x2 === 0 ? 0 : x2;
      }
      function assertReadableStream(x2, context) {
        if (!IsReadableStream(x2))
          throw new TypeError(`${context} is not a ReadableStream.`);
      }
      function AcquireReadableStreamDefaultReader(stream) {
        return new ReadableStreamDefaultReader(stream);
      }
      function ReadableStreamAddReadRequest(stream, readRequest) {
        stream._reader._readRequests.push(readRequest);
      }
      function ReadableStreamFulfillReadRequest(stream, chunk, done) {
        let readRequest = stream._reader._readRequests.shift();
        done ? readRequest._closeSteps() : readRequest._chunkSteps(chunk);
      }
      function ReadableStreamGetNumReadRequests(stream) {
        return stream._reader._readRequests.length;
      }
      function ReadableStreamHasDefaultReader(stream) {
        let reader = stream._reader;
        return !(reader === void 0 || !IsReadableStreamDefaultReader(reader));
      }
      class ReadableStreamDefaultReader {
        constructor(stream) {
          if (assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader"), assertReadableStream(stream, "First parameter"), IsReadableStreamLocked(stream))
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          ReadableStreamReaderGenericInitialize(this, stream), this._readRequests = new SimpleQueue();
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed,
         * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
         */
        get closed() {
          return IsReadableStreamDefaultReader(this) ? this._closedPromise : promiseRejectedWith(defaultReaderBrandCheckException("closed"));
        }
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */
        cancel(reason = void 0) {
          return IsReadableStreamDefaultReader(this) ? this._ownerReadableStream === void 0 ? promiseRejectedWith(readerLockException("cancel")) : ReadableStreamReaderGenericCancel(this, reason) : promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
        }
        /**
         * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.
         *
         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
         */
        read() {
          if (!IsReadableStreamDefaultReader(this))
            return promiseRejectedWith(defaultReaderBrandCheckException("read"));
          if (this._ownerReadableStream === void 0)
            return promiseRejectedWith(readerLockException("read from"));
          let resolvePromise, rejectPromise, promise = newPromise((resolve, reject) => {
            resolvePromise = resolve, rejectPromise = reject;
          });
          return ReadableStreamDefaultReaderRead(this, {
            _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: !1 }),
            _closeSteps: () => resolvePromise({ value: void 0, done: !0 }),
            _errorSteps: (e2) => rejectPromise(e2)
          }), promise;
        }
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */
        releaseLock() {
          if (!IsReadableStreamDefaultReader(this))
            throw defaultReaderBrandCheckException("releaseLock");
          if (this._ownerReadableStream !== void 0) {
            if (this._readRequests.length > 0)
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            ReadableStreamReaderGenericRelease(this);
          }
        }
      }
      Object.defineProperties(ReadableStreamDefaultReader.prototype, {
        cancel: { enumerable: !0 },
        read: { enumerable: !0 },
        releaseLock: { enumerable: !0 },
        closed: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamDefaultReader",
        configurable: !0
      });
      function IsReadableStreamDefaultReader(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_readRequests") ? !1 : x2 instanceof ReadableStreamDefaultReader;
      }
      function ReadableStreamDefaultReaderRead(reader, readRequest) {
        let stream = reader._ownerReadableStream;
        stream._disturbed = !0, stream._state === "closed" ? readRequest._closeSteps() : stream._state === "errored" ? readRequest._errorSteps(stream._storedError) : stream._readableStreamController[PullSteps](readRequest);
      }
      function defaultReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
      }
      let AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
      }).prototype);
      class ReadableStreamAsyncIteratorImpl {
        constructor(reader, preventCancel) {
          this._ongoingPromise = void 0, this._isFinished = !1, this._reader = reader, this._preventCancel = preventCancel;
        }
        next() {
          let nextSteps = () => this._nextSteps();
          return this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps(), this._ongoingPromise;
        }
        return(value) {
          let returnSteps = () => this._returnSteps(value);
          return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
        }
        _nextSteps() {
          if (this._isFinished)
            return Promise.resolve({ value: void 0, done: !0 });
          let reader = this._reader;
          if (reader._ownerReadableStream === void 0)
            return promiseRejectedWith(readerLockException("iterate"));
          let resolvePromise, rejectPromise, promise = newPromise((resolve, reject) => {
            resolvePromise = resolve, rejectPromise = reject;
          });
          return ReadableStreamDefaultReaderRead(reader, {
            _chunkSteps: (chunk) => {
              this._ongoingPromise = void 0, queueMicrotask(() => resolvePromise({ value: chunk, done: !1 }));
            },
            _closeSteps: () => {
              this._ongoingPromise = void 0, this._isFinished = !0, ReadableStreamReaderGenericRelease(reader), resolvePromise({ value: void 0, done: !0 });
            },
            _errorSteps: (reason) => {
              this._ongoingPromise = void 0, this._isFinished = !0, ReadableStreamReaderGenericRelease(reader), rejectPromise(reason);
            }
          }), promise;
        }
        _returnSteps(value) {
          if (this._isFinished)
            return Promise.resolve({ value, done: !0 });
          this._isFinished = !0;
          let reader = this._reader;
          if (reader._ownerReadableStream === void 0)
            return promiseRejectedWith(readerLockException("finish iterating"));
          if (!this._preventCancel) {
            let result = ReadableStreamReaderGenericCancel(reader, value);
            return ReadableStreamReaderGenericRelease(reader), transformPromiseWith(result, () => ({ value, done: !0 }));
          }
          return ReadableStreamReaderGenericRelease(reader), promiseResolvedWith({ value, done: !0 });
        }
      }
      let ReadableStreamAsyncIteratorPrototype = {
        next() {
          return IsReadableStreamAsyncIterator(this) ? this._asyncIteratorImpl.next() : promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
        },
        return(value) {
          return IsReadableStreamAsyncIterator(this) ? this._asyncIteratorImpl.return(value) : promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
        }
      };
      AsyncIteratorPrototype !== void 0 && Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
      function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
        let reader = AcquireReadableStreamDefaultReader(stream), impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel), iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
        return iterator._asyncIteratorImpl = impl, iterator;
      }
      function IsReadableStreamAsyncIterator(x2) {
        if (!typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_asyncIteratorImpl"))
          return !1;
        try {
          return x2._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
        } catch {
          return !1;
        }
      }
      function streamAsyncIteratorBrandCheckException(name) {
        return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
      }
      let NumberIsNaN = Number.isNaN || function(x2) {
        return x2 !== x2;
      };
      function CreateArrayFromList(elements) {
        return elements.slice();
      }
      function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
      }
      function TransferArrayBuffer(O) {
        return O;
      }
      function IsDetachedBuffer(O) {
        return !1;
      }
      function ArrayBufferSlice(buffer, begin, end) {
        if (buffer.slice)
          return buffer.slice(begin, end);
        let length = end - begin, slice = new ArrayBuffer(length);
        return CopyDataBlockBytes(slice, 0, buffer, begin, length), slice;
      }
      function IsNonNegativeNumber(v) {
        return !(typeof v != "number" || NumberIsNaN(v) || v < 0);
      }
      function CloneAsUint8Array(O) {
        let buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
        return new Uint8Array(buffer);
      }
      function DequeueValue(container) {
        let pair = container._queue.shift();
        return container._queueTotalSize -= pair.size, container._queueTotalSize < 0 && (container._queueTotalSize = 0), pair.value;
      }
      function EnqueueValueWithSize(container, value, size) {
        if (!IsNonNegativeNumber(size) || size === 1 / 0)
          throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
        container._queue.push({ value, size }), container._queueTotalSize += size;
      }
      function PeekQueueValue(container) {
        return container._queue.peek().value;
      }
      function ResetQueue(container) {
        container._queue = new SimpleQueue(), container._queueTotalSize = 0;
      }
      class ReadableStreamBYOBRequest {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
         */
        get view() {
          if (!IsReadableStreamBYOBRequest(this))
            throw byobRequestBrandCheckException("view");
          return this._view;
        }
        respond(bytesWritten) {
          if (!IsReadableStreamBYOBRequest(this))
            throw byobRequestBrandCheckException("respond");
          if (assertRequiredArgument(bytesWritten, 1, "respond"), bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter"), this._associatedReadableByteStreamController === void 0)
            throw new TypeError("This BYOB request has been invalidated");
          IsDetachedBuffer(this._view.buffer), ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
        }
        respondWithNewView(view) {
          if (!IsReadableStreamBYOBRequest(this))
            throw byobRequestBrandCheckException("respondWithNewView");
          if (assertRequiredArgument(view, 1, "respondWithNewView"), !ArrayBuffer.isView(view))
            throw new TypeError("You can only respond with array buffer views");
          if (this._associatedReadableByteStreamController === void 0)
            throw new TypeError("This BYOB request has been invalidated");
          IsDetachedBuffer(view.buffer), ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
        }
      }
      Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
        respond: { enumerable: !0 },
        respondWithNewView: { enumerable: !0 },
        view: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamBYOBRequest",
        configurable: !0
      });
      class ReadableByteStreamController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the current BYOB pull request, or `null` if there isn't one.
         */
        get byobRequest() {
          if (!IsReadableByteStreamController(this))
            throw byteStreamControllerBrandCheckException("byobRequest");
          return ReadableByteStreamControllerGetBYOBRequest(this);
        }
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
         */
        get desiredSize() {
          if (!IsReadableByteStreamController(this))
            throw byteStreamControllerBrandCheckException("desiredSize");
          return ReadableByteStreamControllerGetDesiredSize(this);
        }
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */
        close() {
          if (!IsReadableByteStreamController(this))
            throw byteStreamControllerBrandCheckException("close");
          if (this._closeRequested)
            throw new TypeError("The stream has already been closed; do not close it again!");
          let state = this._controlledReadableByteStream._state;
          if (state !== "readable")
            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
          ReadableByteStreamControllerClose(this);
        }
        enqueue(chunk) {
          if (!IsReadableByteStreamController(this))
            throw byteStreamControllerBrandCheckException("enqueue");
          if (assertRequiredArgument(chunk, 1, "enqueue"), !ArrayBuffer.isView(chunk))
            throw new TypeError("chunk must be an array buffer view");
          if (chunk.byteLength === 0)
            throw new TypeError("chunk must have non-zero byteLength");
          if (chunk.buffer.byteLength === 0)
            throw new TypeError("chunk's buffer must have non-zero byteLength");
          if (this._closeRequested)
            throw new TypeError("stream is closed or draining");
          let state = this._controlledReadableByteStream._state;
          if (state !== "readable")
            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
          ReadableByteStreamControllerEnqueue(this, chunk);
        }
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */
        error(e2 = void 0) {
          if (!IsReadableByteStreamController(this))
            throw byteStreamControllerBrandCheckException("error");
          ReadableByteStreamControllerError(this, e2);
        }
        /** @internal */
        [CancelSteps](reason) {
          ReadableByteStreamControllerClearPendingPullIntos(this), ResetQueue(this);
          let result = this._cancelAlgorithm(reason);
          return ReadableByteStreamControllerClearAlgorithms(this), result;
        }
        /** @internal */
        [PullSteps](readRequest) {
          let stream = this._controlledReadableByteStream;
          if (this._queueTotalSize > 0) {
            let entry2 = this._queue.shift();
            this._queueTotalSize -= entry2.byteLength, ReadableByteStreamControllerHandleQueueDrain(this);
            let view = new Uint8Array(entry2.buffer, entry2.byteOffset, entry2.byteLength);
            readRequest._chunkSteps(view);
            return;
          }
          let autoAllocateChunkSize = this._autoAllocateChunkSize;
          if (autoAllocateChunkSize !== void 0) {
            let buffer;
            try {
              buffer = new ArrayBuffer(autoAllocateChunkSize);
            } catch (bufferE) {
              readRequest._errorSteps(bufferE);
              return;
            }
            let pullIntoDescriptor = {
              buffer,
              bufferByteLength: autoAllocateChunkSize,
              byteOffset: 0,
              byteLength: autoAllocateChunkSize,
              bytesFilled: 0,
              elementSize: 1,
              viewConstructor: Uint8Array,
              readerType: "default"
            };
            this._pendingPullIntos.push(pullIntoDescriptor);
          }
          ReadableStreamAddReadRequest(stream, readRequest), ReadableByteStreamControllerCallPullIfNeeded(this);
        }
      }
      Object.defineProperties(ReadableByteStreamController.prototype, {
        close: { enumerable: !0 },
        enqueue: { enumerable: !0 },
        error: { enumerable: !0 },
        byobRequest: { enumerable: !0 },
        desiredSize: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableByteStreamController",
        configurable: !0
      });
      function IsReadableByteStreamController(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_controlledReadableByteStream") ? !1 : x2 instanceof ReadableByteStreamController;
      }
      function IsReadableStreamBYOBRequest(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_associatedReadableByteStreamController") ? !1 : x2 instanceof ReadableStreamBYOBRequest;
      }
      function ReadableByteStreamControllerCallPullIfNeeded(controller) {
        if (!ReadableByteStreamControllerShouldCallPull(controller))
          return;
        if (controller._pulling) {
          controller._pullAgain = !0;
          return;
        }
        controller._pulling = !0;
        let pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
          controller._pulling = !1, controller._pullAgain && (controller._pullAgain = !1, ReadableByteStreamControllerCallPullIfNeeded(controller));
        }, (e2) => {
          ReadableByteStreamControllerError(controller, e2);
        });
      }
      function ReadableByteStreamControllerClearPendingPullIntos(controller) {
        ReadableByteStreamControllerInvalidateBYOBRequest(controller), controller._pendingPullIntos = new SimpleQueue();
      }
      function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
        let done = !1;
        stream._state === "closed" && (done = !0);
        let filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        pullIntoDescriptor.readerType === "default" ? ReadableStreamFulfillReadRequest(stream, filledView, done) : ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
      }
      function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
        let bytesFilled = pullIntoDescriptor.bytesFilled, elementSize = pullIntoDescriptor.elementSize;
        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
      }
      function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
        controller._queue.push({ buffer, byteOffset, byteLength }), controller._queueTotalSize += byteLength;
      }
      function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
        let elementSize = pullIntoDescriptor.elementSize, currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize, maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled), maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy, maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize, totalBytesToCopyRemaining = maxBytesToCopy, ready = !1;
        maxAlignedBytes > currentAlignedBytes && (totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled, ready = !0);
        let queue = controller._queue;
        for (; totalBytesToCopyRemaining > 0; ) {
          let headOfQueue = queue.peek(), bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength), destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy), headOfQueue.byteLength === bytesToCopy ? queue.shift() : (headOfQueue.byteOffset += bytesToCopy, headOfQueue.byteLength -= bytesToCopy), controller._queueTotalSize -= bytesToCopy, ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor), totalBytesToCopyRemaining -= bytesToCopy;
        }
        return ready;
      }
      function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
        pullIntoDescriptor.bytesFilled += size;
      }
      function ReadableByteStreamControllerHandleQueueDrain(controller) {
        controller._queueTotalSize === 0 && controller._closeRequested ? (ReadableByteStreamControllerClearAlgorithms(controller), ReadableStreamClose(controller._controlledReadableByteStream)) : ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
        controller._byobRequest !== null && (controller._byobRequest._associatedReadableByteStreamController = void 0, controller._byobRequest._view = null, controller._byobRequest = null);
      }
      function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
        for (; controller._pendingPullIntos.length > 0; ) {
          if (controller._queueTotalSize === 0)
            return;
          let pullIntoDescriptor = controller._pendingPullIntos.peek();
          ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) && (ReadableByteStreamControllerShiftPendingPullInto(controller), ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor));
        }
      }
      function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
        let stream = controller._controlledReadableByteStream, elementSize = 1;
        view.constructor !== DataView && (elementSize = view.constructor.BYTES_PER_ELEMENT);
        let ctor = view.constructor, buffer = view.buffer, pullIntoDescriptor = {
          buffer,
          bufferByteLength: buffer.byteLength,
          byteOffset: view.byteOffset,
          byteLength: view.byteLength,
          bytesFilled: 0,
          elementSize,
          viewConstructor: ctor,
          readerType: "byob"
        };
        if (controller._pendingPullIntos.length > 0) {
          controller._pendingPullIntos.push(pullIntoDescriptor), ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          return;
        }
        if (stream._state === "closed") {
          let emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
          readIntoRequest._closeSteps(emptyView);
          return;
        }
        if (controller._queueTotalSize > 0) {
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            let filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
            ReadableByteStreamControllerHandleQueueDrain(controller), readIntoRequest._chunkSteps(filledView);
            return;
          }
          if (controller._closeRequested) {
            let e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e2), readIntoRequest._errorSteps(e2);
            return;
          }
        }
        controller._pendingPullIntos.push(pullIntoDescriptor), ReadableStreamAddReadIntoRequest(stream, readIntoRequest), ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
        let stream = controller._controlledReadableByteStream;
        if (ReadableStreamHasBYOBReader(stream))
          for (; ReadableStreamGetNumReadIntoRequests(stream) > 0; ) {
            let pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
          }
      }
      function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
        if (ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor), pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize)
          return;
        ReadableByteStreamControllerShiftPendingPullInto(controller);
        let remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
        if (remainderSize > 0) {
          let end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled, remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
        }
        pullIntoDescriptor.bytesFilled -= remainderSize, ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor), ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
      }
      function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
        let firstDescriptor = controller._pendingPullIntos.peek();
        ReadableByteStreamControllerInvalidateBYOBRequest(controller), controller._controlledReadableByteStream._state === "closed" ? ReadableByteStreamControllerRespondInClosedState(controller) : ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor), ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerShiftPendingPullInto(controller) {
        return controller._pendingPullIntos.shift();
      }
      function ReadableByteStreamControllerShouldCallPull(controller) {
        let stream = controller._controlledReadableByteStream;
        return stream._state !== "readable" || controller._closeRequested || !controller._started ? !1 : !!(ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0 || ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0 || ReadableByteStreamControllerGetDesiredSize(controller) > 0);
      }
      function ReadableByteStreamControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0, controller._cancelAlgorithm = void 0;
      }
      function ReadableByteStreamControllerClose(controller) {
        let stream = controller._controlledReadableByteStream;
        if (!(controller._closeRequested || stream._state !== "readable")) {
          if (controller._queueTotalSize > 0) {
            controller._closeRequested = !0;
            return;
          }
          if (controller._pendingPullIntos.length > 0 && controller._pendingPullIntos.peek().bytesFilled > 0) {
            let e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
            throw ReadableByteStreamControllerError(controller, e2), e2;
          }
          ReadableByteStreamControllerClearAlgorithms(controller), ReadableStreamClose(stream);
        }
      }
      function ReadableByteStreamControllerEnqueue(controller, chunk) {
        let stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable")
          return;
        let buffer = chunk.buffer, byteOffset = chunk.byteOffset, byteLength = chunk.byteLength, transferredBuffer = buffer;
        if (controller._pendingPullIntos.length > 0) {
          let firstPendingPullInto = controller._pendingPullIntos.peek();
          IsDetachedBuffer(firstPendingPullInto.buffer), firstPendingPullInto.buffer = firstPendingPullInto.buffer;
        }
        if (ReadableByteStreamControllerInvalidateBYOBRequest(controller), ReadableStreamHasDefaultReader(stream))
          if (ReadableStreamGetNumReadRequests(stream) === 0)
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          else {
            controller._pendingPullIntos.length > 0 && ReadableByteStreamControllerShiftPendingPullInto(controller);
            let transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
            ReadableStreamFulfillReadRequest(stream, transferredView, !1);
          }
        else
          ReadableStreamHasBYOBReader(stream) ? (ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength), ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller)) : ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerError(controller, e2) {
        let stream = controller._controlledReadableByteStream;
        stream._state === "readable" && (ReadableByteStreamControllerClearPendingPullIntos(controller), ResetQueue(controller), ReadableByteStreamControllerClearAlgorithms(controller), ReadableStreamError(stream, e2));
      }
      function ReadableByteStreamControllerGetBYOBRequest(controller) {
        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
          let firstDescriptor = controller._pendingPullIntos.peek(), view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled), byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
          SetUpReadableStreamBYOBRequest(byobRequest, controller, view), controller._byobRequest = byobRequest;
        }
        return controller._byobRequest;
      }
      function ReadableByteStreamControllerGetDesiredSize(controller) {
        let state = controller._controlledReadableByteStream._state;
        return state === "errored" ? null : state === "closed" ? 0 : controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableByteStreamControllerRespond(controller, bytesWritten) {
        let firstDescriptor = controller._pendingPullIntos.peek();
        if (controller._controlledReadableByteStream._state === "closed") {
          if (bytesWritten !== 0)
            throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
        } else {
          if (bytesWritten === 0)
            throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
          if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength)
            throw new RangeError("bytesWritten out of range");
        }
        firstDescriptor.buffer = firstDescriptor.buffer, ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
      }
      function ReadableByteStreamControllerRespondWithNewView(controller, view) {
        let firstDescriptor = controller._pendingPullIntos.peek();
        if (controller._controlledReadableByteStream._state === "closed") {
          if (view.byteLength !== 0)
            throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
        } else if (view.byteLength === 0)
          throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset)
          throw new RangeError("The region specified by view does not match byobRequest");
        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength)
          throw new RangeError("The buffer of view has different capacity than byobRequest");
        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength)
          throw new RangeError("The region specified by view is larger than byobRequest");
        let viewByteLength = view.byteLength;
        firstDescriptor.buffer = view.buffer, ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
      }
      function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
        controller._controlledReadableByteStream = stream, controller._pullAgain = !1, controller._pulling = !1, controller._byobRequest = null, controller._queue = controller._queueTotalSize = void 0, ResetQueue(controller), controller._closeRequested = !1, controller._started = !1, controller._strategyHWM = highWaterMark, controller._pullAlgorithm = pullAlgorithm, controller._cancelAlgorithm = cancelAlgorithm, controller._autoAllocateChunkSize = autoAllocateChunkSize, controller._pendingPullIntos = new SimpleQueue(), stream._readableStreamController = controller;
        let startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
          controller._started = !0, ReadableByteStreamControllerCallPullIfNeeded(controller);
        }, (r2) => {
          ReadableByteStreamControllerError(controller, r2);
        });
      }
      function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
        let controller = Object.create(ReadableByteStreamController.prototype), startAlgorithm = () => {
        }, pullAlgorithm = () => promiseResolvedWith(void 0), cancelAlgorithm = () => promiseResolvedWith(void 0);
        underlyingByteSource.start !== void 0 && (startAlgorithm = () => underlyingByteSource.start(controller)), underlyingByteSource.pull !== void 0 && (pullAlgorithm = () => underlyingByteSource.pull(controller)), underlyingByteSource.cancel !== void 0 && (cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason));
        let autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
        if (autoAllocateChunkSize === 0)
          throw new TypeError("autoAllocateChunkSize must be greater than 0");
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
      }
      function SetUpReadableStreamBYOBRequest(request, controller, view) {
        request._associatedReadableByteStreamController = controller, request._view = view;
      }
      function byobRequestBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
      }
      function byteStreamControllerBrandCheckException(name) {
        return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
      }
      function AcquireReadableStreamBYOBReader(stream) {
        return new ReadableStreamBYOBReader(stream);
      }
      function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
        stream._reader._readIntoRequests.push(readIntoRequest);
      }
      function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
        let readIntoRequest = stream._reader._readIntoRequests.shift();
        done ? readIntoRequest._closeSteps(chunk) : readIntoRequest._chunkSteps(chunk);
      }
      function ReadableStreamGetNumReadIntoRequests(stream) {
        return stream._reader._readIntoRequests.length;
      }
      function ReadableStreamHasBYOBReader(stream) {
        let reader = stream._reader;
        return !(reader === void 0 || !IsReadableStreamBYOBReader(reader));
      }
      class ReadableStreamBYOBReader {
        constructor(stream) {
          if (assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader"), assertReadableStream(stream, "First parameter"), IsReadableStreamLocked(stream))
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          if (!IsReadableByteStreamController(stream._readableStreamController))
            throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
          ReadableStreamReaderGenericInitialize(this, stream), this._readIntoRequests = new SimpleQueue();
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the reader's lock is released before the stream finishes closing.
         */
        get closed() {
          return IsReadableStreamBYOBReader(this) ? this._closedPromise : promiseRejectedWith(byobReaderBrandCheckException("closed"));
        }
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */
        cancel(reason = void 0) {
          return IsReadableStreamBYOBReader(this) ? this._ownerReadableStream === void 0 ? promiseRejectedWith(readerLockException("cancel")) : ReadableStreamReaderGenericCancel(this, reason) : promiseRejectedWith(byobReaderBrandCheckException("cancel"));
        }
        /**
         * Attempts to reads bytes into view, and returns a promise resolved with the result.
         *
         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
         */
        read(view) {
          if (!IsReadableStreamBYOBReader(this))
            return promiseRejectedWith(byobReaderBrandCheckException("read"));
          if (!ArrayBuffer.isView(view))
            return promiseRejectedWith(new TypeError("view must be an array buffer view"));
          if (view.byteLength === 0)
            return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
          if (view.buffer.byteLength === 0)
            return promiseRejectedWith(new TypeError("view's buffer must have non-zero byteLength"));
          if (IsDetachedBuffer(view.buffer), this._ownerReadableStream === void 0)
            return promiseRejectedWith(readerLockException("read from"));
          let resolvePromise, rejectPromise, promise = newPromise((resolve, reject) => {
            resolvePromise = resolve, rejectPromise = reject;
          });
          return ReadableStreamBYOBReaderRead(this, view, {
            _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: !1 }),
            _closeSteps: (chunk) => resolvePromise({ value: chunk, done: !0 }),
            _errorSteps: (e2) => rejectPromise(e2)
          }), promise;
        }
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */
        releaseLock() {
          if (!IsReadableStreamBYOBReader(this))
            throw byobReaderBrandCheckException("releaseLock");
          if (this._ownerReadableStream !== void 0) {
            if (this._readIntoRequests.length > 0)
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            ReadableStreamReaderGenericRelease(this);
          }
        }
      }
      Object.defineProperties(ReadableStreamBYOBReader.prototype, {
        cancel: { enumerable: !0 },
        read: { enumerable: !0 },
        releaseLock: { enumerable: !0 },
        closed: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamBYOBReader",
        configurable: !0
      });
      function IsReadableStreamBYOBReader(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_readIntoRequests") ? !1 : x2 instanceof ReadableStreamBYOBReader;
      }
      function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
        let stream = reader._ownerReadableStream;
        stream._disturbed = !0, stream._state === "errored" ? readIntoRequest._errorSteps(stream._storedError) : ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
      }
      function byobReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
      }
      function ExtractHighWaterMark(strategy, defaultHWM) {
        let { highWaterMark } = strategy;
        if (highWaterMark === void 0)
          return defaultHWM;
        if (NumberIsNaN(highWaterMark) || highWaterMark < 0)
          throw new RangeError("Invalid highWaterMark");
        return highWaterMark;
      }
      function ExtractSizeAlgorithm(strategy) {
        let { size } = strategy;
        return size || (() => 1);
      }
      function convertQueuingStrategy(init, context) {
        assertDictionary(init, context);
        let highWaterMark = init == null ? void 0 : init.highWaterMark, size = init == null ? void 0 : init.size;
        return {
          highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
          size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
        };
      }
      function convertQueuingStrategySize(fn, context) {
        return assertFunction(fn, context), (chunk) => convertUnrestrictedDouble(fn(chunk));
      }
      function convertUnderlyingSink(original, context) {
        assertDictionary(original, context);
        let abort = original == null ? void 0 : original.abort, close = original == null ? void 0 : original.close, start = original == null ? void 0 : original.start, type = original == null ? void 0 : original.type, write = original == null ? void 0 : original.write;
        return {
          abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
          close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
          start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
          write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
          type
        };
      }
      function convertUnderlyingSinkAbortCallback(fn, original, context) {
        return assertFunction(fn, context), (reason) => promiseCall(fn, original, [reason]);
      }
      function convertUnderlyingSinkCloseCallback(fn, original, context) {
        return assertFunction(fn, context), () => promiseCall(fn, original, []);
      }
      function convertUnderlyingSinkStartCallback(fn, original, context) {
        return assertFunction(fn, context), (controller) => reflectCall(fn, original, [controller]);
      }
      function convertUnderlyingSinkWriteCallback(fn, original, context) {
        return assertFunction(fn, context), (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
      }
      function assertWritableStream(x2, context) {
        if (!IsWritableStream(x2))
          throw new TypeError(`${context} is not a WritableStream.`);
      }
      function isAbortSignal2(value) {
        if (typeof value != "object" || value === null)
          return !1;
        try {
          return typeof value.aborted == "boolean";
        } catch {
          return !1;
        }
      }
      let supportsAbortController = typeof AbortController == "function";
      function createAbortController() {
        if (supportsAbortController)
          return new AbortController();
      }
      class WritableStream {
        constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
          rawUnderlyingSink === void 0 ? rawUnderlyingSink = null : assertObject(rawUnderlyingSink, "First parameter");
          let strategy = convertQueuingStrategy(rawStrategy, "Second parameter"), underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
          if (InitializeWritableStream(this), underlyingSink.type !== void 0)
            throw new RangeError("Invalid type is specified");
          let sizeAlgorithm = ExtractSizeAlgorithm(strategy), highWaterMark = ExtractHighWaterMark(strategy, 1);
          SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
        }
        /**
         * Returns whether or not the writable stream is locked to a writer.
         */
        get locked() {
          if (!IsWritableStream(this))
            throw streamBrandCheckException$2("locked");
          return IsWritableStreamLocked(this);
        }
        /**
         * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be
         * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort
         * mechanism of the underlying sink.
         *
         * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled
         * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel
         * the stream) if the stream is currently locked.
         */
        abort(reason = void 0) {
          return IsWritableStream(this) ? IsWritableStreamLocked(this) ? promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer")) : WritableStreamAbort(this, reason) : promiseRejectedWith(streamBrandCheckException$2("abort"));
        }
        /**
         * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its
         * close behavior. During this time any further attempts to write will fail (without erroring the stream).
         *
         * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream
         * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with
         * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.
         */
        close() {
          return IsWritableStream(this) ? IsWritableStreamLocked(this) ? promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer")) : WritableStreamCloseQueuedOrInFlight(this) ? promiseRejectedWith(new TypeError("Cannot close an already-closing stream")) : WritableStreamClose(this) : promiseRejectedWith(streamBrandCheckException$2("close"));
        }
        /**
         * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream
         * is locked, no other writer can be acquired until this one is released.
         *
         * This functionality is especially useful for creating abstractions that desire the ability to write to a stream
         * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at
         * the same time, which would cause the resulting written data to be unpredictable and probably useless.
         */
        getWriter() {
          if (!IsWritableStream(this))
            throw streamBrandCheckException$2("getWriter");
          return AcquireWritableStreamDefaultWriter(this);
        }
      }
      Object.defineProperties(WritableStream.prototype, {
        abort: { enumerable: !0 },
        close: { enumerable: !0 },
        getWriter: { enumerable: !0 },
        locked: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
        value: "WritableStream",
        configurable: !0
      });
      function AcquireWritableStreamDefaultWriter(stream) {
        return new WritableStreamDefaultWriter(stream);
      }
      function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        let stream = Object.create(WritableStream.prototype);
        InitializeWritableStream(stream);
        let controller = Object.create(WritableStreamDefaultController.prototype);
        return SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm), stream;
      }
      function InitializeWritableStream(stream) {
        stream._state = "writable", stream._storedError = void 0, stream._writer = void 0, stream._writableStreamController = void 0, stream._writeRequests = new SimpleQueue(), stream._inFlightWriteRequest = void 0, stream._closeRequest = void 0, stream._inFlightCloseRequest = void 0, stream._pendingAbortRequest = void 0, stream._backpressure = !1;
      }
      function IsWritableStream(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_writableStreamController") ? !1 : x2 instanceof WritableStream;
      }
      function IsWritableStreamLocked(stream) {
        return stream._writer !== void 0;
      }
      function WritableStreamAbort(stream, reason) {
        var _a4;
        if (stream._state === "closed" || stream._state === "errored")
          return promiseResolvedWith(void 0);
        stream._writableStreamController._abortReason = reason, (_a4 = stream._writableStreamController._abortController) === null || _a4 === void 0 || _a4.abort();
        let state = stream._state;
        if (state === "closed" || state === "errored")
          return promiseResolvedWith(void 0);
        if (stream._pendingAbortRequest !== void 0)
          return stream._pendingAbortRequest._promise;
        let wasAlreadyErroring = !1;
        state === "erroring" && (wasAlreadyErroring = !0, reason = void 0);
        let promise = newPromise((resolve, reject) => {
          stream._pendingAbortRequest = {
            _promise: void 0,
            _resolve: resolve,
            _reject: reject,
            _reason: reason,
            _wasAlreadyErroring: wasAlreadyErroring
          };
        });
        return stream._pendingAbortRequest._promise = promise, wasAlreadyErroring || WritableStreamStartErroring(stream, reason), promise;
      }
      function WritableStreamClose(stream) {
        let state = stream._state;
        if (state === "closed" || state === "errored")
          return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
        let promise = newPromise((resolve, reject) => {
          let closeRequest = {
            _resolve: resolve,
            _reject: reject
          };
          stream._closeRequest = closeRequest;
        }), writer = stream._writer;
        return writer !== void 0 && stream._backpressure && state === "writable" && defaultWriterReadyPromiseResolve(writer), WritableStreamDefaultControllerClose(stream._writableStreamController), promise;
      }
      function WritableStreamAddWriteRequest(stream) {
        return newPromise((resolve, reject) => {
          let writeRequest = {
            _resolve: resolve,
            _reject: reject
          };
          stream._writeRequests.push(writeRequest);
        });
      }
      function WritableStreamDealWithRejection(stream, error) {
        if (stream._state === "writable") {
          WritableStreamStartErroring(stream, error);
          return;
        }
        WritableStreamFinishErroring(stream);
      }
      function WritableStreamStartErroring(stream, reason) {
        let controller = stream._writableStreamController;
        stream._state = "erroring", stream._storedError = reason;
        let writer = stream._writer;
        writer !== void 0 && WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason), !WritableStreamHasOperationMarkedInFlight(stream) && controller._started && WritableStreamFinishErroring(stream);
      }
      function WritableStreamFinishErroring(stream) {
        stream._state = "errored", stream._writableStreamController[ErrorSteps]();
        let storedError = stream._storedError;
        if (stream._writeRequests.forEach((writeRequest) => {
          writeRequest._reject(storedError);
        }), stream._writeRequests = new SimpleQueue(), stream._pendingAbortRequest === void 0) {
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        let abortRequest = stream._pendingAbortRequest;
        if (stream._pendingAbortRequest = void 0, abortRequest._wasAlreadyErroring) {
          abortRequest._reject(storedError), WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        let promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
        uponPromise(promise, () => {
          abortRequest._resolve(), WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        }, (reason) => {
          abortRequest._reject(reason), WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        });
      }
      function WritableStreamFinishInFlightWrite(stream) {
        stream._inFlightWriteRequest._resolve(void 0), stream._inFlightWriteRequest = void 0;
      }
      function WritableStreamFinishInFlightWriteWithError(stream, error) {
        stream._inFlightWriteRequest._reject(error), stream._inFlightWriteRequest = void 0, WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamFinishInFlightClose(stream) {
        stream._inFlightCloseRequest._resolve(void 0), stream._inFlightCloseRequest = void 0, stream._state === "erroring" && (stream._storedError = void 0, stream._pendingAbortRequest !== void 0 && (stream._pendingAbortRequest._resolve(), stream._pendingAbortRequest = void 0)), stream._state = "closed";
        let writer = stream._writer;
        writer !== void 0 && defaultWriterClosedPromiseResolve(writer);
      }
      function WritableStreamFinishInFlightCloseWithError(stream, error) {
        stream._inFlightCloseRequest._reject(error), stream._inFlightCloseRequest = void 0, stream._pendingAbortRequest !== void 0 && (stream._pendingAbortRequest._reject(error), stream._pendingAbortRequest = void 0), WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamCloseQueuedOrInFlight(stream) {
        return !(stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0);
      }
      function WritableStreamHasOperationMarkedInFlight(stream) {
        return !(stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0);
      }
      function WritableStreamMarkCloseRequestInFlight(stream) {
        stream._inFlightCloseRequest = stream._closeRequest, stream._closeRequest = void 0;
      }
      function WritableStreamMarkFirstWriteRequestInFlight(stream) {
        stream._inFlightWriteRequest = stream._writeRequests.shift();
      }
      function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
        stream._closeRequest !== void 0 && (stream._closeRequest._reject(stream._storedError), stream._closeRequest = void 0);
        let writer = stream._writer;
        writer !== void 0 && defaultWriterClosedPromiseReject(writer, stream._storedError);
      }
      function WritableStreamUpdateBackpressure(stream, backpressure) {
        let writer = stream._writer;
        writer !== void 0 && backpressure !== stream._backpressure && (backpressure ? defaultWriterReadyPromiseReset(writer) : defaultWriterReadyPromiseResolve(writer)), stream._backpressure = backpressure;
      }
      class WritableStreamDefaultWriter {
        constructor(stream) {
          if (assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter"), assertWritableStream(stream, "First parameter"), IsWritableStreamLocked(stream))
            throw new TypeError("This stream has already been locked for exclusive writing by another writer");
          this._ownerWritableStream = stream, stream._writer = this;
          let state = stream._state;
          if (state === "writable")
            !WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure ? defaultWriterReadyPromiseInitialize(this) : defaultWriterReadyPromiseInitializeAsResolved(this), defaultWriterClosedPromiseInitialize(this);
          else if (state === "erroring")
            defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError), defaultWriterClosedPromiseInitialize(this);
          else if (state === "closed")
            defaultWriterReadyPromiseInitializeAsResolved(this), defaultWriterClosedPromiseInitializeAsResolved(this);
          else {
            let storedError = stream._storedError;
            defaultWriterReadyPromiseInitializeAsRejected(this, storedError), defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
          }
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the writers lock is released before the stream finishes closing.
         */
        get closed() {
          return IsWritableStreamDefaultWriter(this) ? this._closedPromise : promiseRejectedWith(defaultWriterBrandCheckException("closed"));
        }
        /**
         * Returns the desired size to fill the streams internal queue. It can be negative, if the queue is over-full.
         * A producer can use this information to determine the right amount of data to write.
         *
         * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
         * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
         * the writers lock is released.
         */
        get desiredSize() {
          if (!IsWritableStreamDefaultWriter(this))
            throw defaultWriterBrandCheckException("desiredSize");
          if (this._ownerWritableStream === void 0)
            throw defaultWriterLockException("desiredSize");
          return WritableStreamDefaultWriterGetDesiredSize(this);
        }
        /**
         * Returns a promise that will be fulfilled when the desired size to fill the streams internal queue transitions
         * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
         * back to zero or below, the getter will return a new promise that stays pending until the next transition.
         *
         * If the stream becomes errored or aborted, or the writers lock is released, the returned promise will become
         * rejected.
         */
        get ready() {
          return IsWritableStreamDefaultWriter(this) ? this._readyPromise : promiseRejectedWith(defaultWriterBrandCheckException("ready"));
        }
        /**
         * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.
         */
        abort(reason = void 0) {
          return IsWritableStreamDefaultWriter(this) ? this._ownerWritableStream === void 0 ? promiseRejectedWith(defaultWriterLockException("abort")) : WritableStreamDefaultWriterAbort(this, reason) : promiseRejectedWith(defaultWriterBrandCheckException("abort"));
        }
        /**
         * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.
         */
        close() {
          if (!IsWritableStreamDefaultWriter(this))
            return promiseRejectedWith(defaultWriterBrandCheckException("close"));
          let stream = this._ownerWritableStream;
          return stream === void 0 ? promiseRejectedWith(defaultWriterLockException("close")) : WritableStreamCloseQueuedOrInFlight(stream) ? promiseRejectedWith(new TypeError("Cannot close an already-closing stream")) : WritableStreamDefaultWriterClose(this);
        }
        /**
         * Releases the writers lock on the corresponding stream. After the lock is released, the writer is no longer active.
         * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from
         * now on; otherwise, the writer will appear closed.
         *
         * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the
         * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).
         * Its not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents
         * other producers from writing in an interleaved manner.
         */
        releaseLock() {
          if (!IsWritableStreamDefaultWriter(this))
            throw defaultWriterBrandCheckException("releaseLock");
          this._ownerWritableStream !== void 0 && WritableStreamDefaultWriterRelease(this);
        }
        write(chunk = void 0) {
          return IsWritableStreamDefaultWriter(this) ? this._ownerWritableStream === void 0 ? promiseRejectedWith(defaultWriterLockException("write to")) : WritableStreamDefaultWriterWrite(this, chunk) : promiseRejectedWith(defaultWriterBrandCheckException("write"));
        }
      }
      Object.defineProperties(WritableStreamDefaultWriter.prototype, {
        abort: { enumerable: !0 },
        close: { enumerable: !0 },
        releaseLock: { enumerable: !0 },
        write: { enumerable: !0 },
        closed: { enumerable: !0 },
        desiredSize: { enumerable: !0 },
        ready: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
        value: "WritableStreamDefaultWriter",
        configurable: !0
      });
      function IsWritableStreamDefaultWriter(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_ownerWritableStream") ? !1 : x2 instanceof WritableStreamDefaultWriter;
      }
      function WritableStreamDefaultWriterAbort(writer, reason) {
        let stream = writer._ownerWritableStream;
        return WritableStreamAbort(stream, reason);
      }
      function WritableStreamDefaultWriterClose(writer) {
        let stream = writer._ownerWritableStream;
        return WritableStreamClose(stream);
      }
      function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
        let stream = writer._ownerWritableStream, state = stream._state;
        return WritableStreamCloseQueuedOrInFlight(stream) || state === "closed" ? promiseResolvedWith(void 0) : state === "errored" ? promiseRejectedWith(stream._storedError) : WritableStreamDefaultWriterClose(writer);
      }
      function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
        writer._closedPromiseState === "pending" ? defaultWriterClosedPromiseReject(writer, error) : defaultWriterClosedPromiseResetToRejected(writer, error);
      }
      function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
        writer._readyPromiseState === "pending" ? defaultWriterReadyPromiseReject(writer, error) : defaultWriterReadyPromiseResetToRejected(writer, error);
      }
      function WritableStreamDefaultWriterGetDesiredSize(writer) {
        let stream = writer._ownerWritableStream, state = stream._state;
        return state === "errored" || state === "erroring" ? null : state === "closed" ? 0 : WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
      }
      function WritableStreamDefaultWriterRelease(writer) {
        let stream = writer._ownerWritableStream, releasedError = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError), WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError), stream._writer = void 0, writer._ownerWritableStream = void 0;
      }
      function WritableStreamDefaultWriterWrite(writer, chunk) {
        let stream = writer._ownerWritableStream, controller = stream._writableStreamController, chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
        if (stream !== writer._ownerWritableStream)
          return promiseRejectedWith(defaultWriterLockException("write to"));
        let state = stream._state;
        if (state === "errored")
          return promiseRejectedWith(stream._storedError);
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed")
          return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
        if (state === "erroring")
          return promiseRejectedWith(stream._storedError);
        let promise = WritableStreamAddWriteRequest(stream);
        return WritableStreamDefaultControllerWrite(controller, chunk, chunkSize), promise;
      }
      let closeSentinel = {};
      class WritableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
         *
         * @deprecated
         *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
         *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
         */
        get abortReason() {
          if (!IsWritableStreamDefaultController(this))
            throw defaultControllerBrandCheckException$2("abortReason");
          return this._abortReason;
        }
        /**
         * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
         */
        get signal() {
          if (!IsWritableStreamDefaultController(this))
            throw defaultControllerBrandCheckException$2("signal");
          if (this._abortController === void 0)
            throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
          return this._abortController.signal;
        }
        /**
         * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.
         *
         * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying
         * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the
         * normal lifecycle of interactions with the underlying sink.
         */
        error(e2 = void 0) {
          if (!IsWritableStreamDefaultController(this))
            throw defaultControllerBrandCheckException$2("error");
          this._controlledWritableStream._state === "writable" && WritableStreamDefaultControllerError(this, e2);
        }
        /** @internal */
        [AbortSteps](reason) {
          let result = this._abortAlgorithm(reason);
          return WritableStreamDefaultControllerClearAlgorithms(this), result;
        }
        /** @internal */
        [ErrorSteps]() {
          ResetQueue(this);
        }
      }
      Object.defineProperties(WritableStreamDefaultController.prototype, {
        abortReason: { enumerable: !0 },
        signal: { enumerable: !0 },
        error: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
        value: "WritableStreamDefaultController",
        configurable: !0
      });
      function IsWritableStreamDefaultController(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_controlledWritableStream") ? !1 : x2 instanceof WritableStreamDefaultController;
      }
      function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledWritableStream = stream, stream._writableStreamController = controller, controller._queue = void 0, controller._queueTotalSize = void 0, ResetQueue(controller), controller._abortReason = void 0, controller._abortController = createAbortController(), controller._started = !1, controller._strategySizeAlgorithm = sizeAlgorithm, controller._strategyHWM = highWaterMark, controller._writeAlgorithm = writeAlgorithm, controller._closeAlgorithm = closeAlgorithm, controller._abortAlgorithm = abortAlgorithm;
        let backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
        let startResult = startAlgorithm(), startPromise = promiseResolvedWith(startResult);
        uponPromise(startPromise, () => {
          controller._started = !0, WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, (r2) => {
          controller._started = !0, WritableStreamDealWithRejection(stream, r2);
        });
      }
      function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
        let controller = Object.create(WritableStreamDefaultController.prototype), startAlgorithm = () => {
        }, writeAlgorithm = () => promiseResolvedWith(void 0), closeAlgorithm = () => promiseResolvedWith(void 0), abortAlgorithm = () => promiseResolvedWith(void 0);
        underlyingSink.start !== void 0 && (startAlgorithm = () => underlyingSink.start(controller)), underlyingSink.write !== void 0 && (writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller)), underlyingSink.close !== void 0 && (closeAlgorithm = () => underlyingSink.close()), underlyingSink.abort !== void 0 && (abortAlgorithm = (reason) => underlyingSink.abort(reason)), SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function WritableStreamDefaultControllerClearAlgorithms(controller) {
        controller._writeAlgorithm = void 0, controller._closeAlgorithm = void 0, controller._abortAlgorithm = void 0, controller._strategySizeAlgorithm = void 0;
      }
      function WritableStreamDefaultControllerClose(controller) {
        EnqueueValueWithSize(controller, closeSentinel, 0), WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
        try {
          return controller._strategySizeAlgorithm(chunk);
        } catch (chunkSizeE) {
          return WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE), 1;
        }
      }
      function WritableStreamDefaultControllerGetDesiredSize(controller) {
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
        try {
          EnqueueValueWithSize(controller, chunk, chunkSize);
        } catch (enqueueE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
          return;
        }
        let stream = controller._controlledWritableStream;
        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
          let backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
        let stream = controller._controlledWritableStream;
        if (!controller._started || stream._inFlightWriteRequest !== void 0)
          return;
        if (stream._state === "erroring") {
          WritableStreamFinishErroring(stream);
          return;
        }
        if (controller._queue.length === 0)
          return;
        let value = PeekQueueValue(controller);
        value === closeSentinel ? WritableStreamDefaultControllerProcessClose(controller) : WritableStreamDefaultControllerProcessWrite(controller, value);
      }
      function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
        controller._controlledWritableStream._state === "writable" && WritableStreamDefaultControllerError(controller, error);
      }
      function WritableStreamDefaultControllerProcessClose(controller) {
        let stream = controller._controlledWritableStream;
        WritableStreamMarkCloseRequestInFlight(stream), DequeueValue(controller);
        let sinkClosePromise = controller._closeAlgorithm();
        WritableStreamDefaultControllerClearAlgorithms(controller), uponPromise(sinkClosePromise, () => {
          WritableStreamFinishInFlightClose(stream);
        }, (reason) => {
          WritableStreamFinishInFlightCloseWithError(stream, reason);
        });
      }
      function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
        let stream = controller._controlledWritableStream;
        WritableStreamMarkFirstWriteRequestInFlight(stream);
        let sinkWritePromise = controller._writeAlgorithm(chunk);
        uponPromise(sinkWritePromise, () => {
          WritableStreamFinishInFlightWrite(stream);
          let state = stream._state;
          if (DequeueValue(controller), !WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
            let backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, (reason) => {
          stream._state === "writable" && WritableStreamDefaultControllerClearAlgorithms(controller), WritableStreamFinishInFlightWriteWithError(stream, reason);
        });
      }
      function WritableStreamDefaultControllerGetBackpressure(controller) {
        return WritableStreamDefaultControllerGetDesiredSize(controller) <= 0;
      }
      function WritableStreamDefaultControllerError(controller, error) {
        let stream = controller._controlledWritableStream;
        WritableStreamDefaultControllerClearAlgorithms(controller), WritableStreamStartErroring(stream, error);
      }
      function streamBrandCheckException$2(name) {
        return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
      }
      function defaultControllerBrandCheckException$2(name) {
        return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
      }
      function defaultWriterBrandCheckException(name) {
        return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
      }
      function defaultWriterLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released writer");
      }
      function defaultWriterClosedPromiseInitialize(writer) {
        writer._closedPromise = newPromise((resolve, reject) => {
          writer._closedPromise_resolve = resolve, writer._closedPromise_reject = reject, writer._closedPromiseState = "pending";
        });
      }
      function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
        defaultWriterClosedPromiseInitialize(writer), defaultWriterClosedPromiseReject(writer, reason);
      }
      function defaultWriterClosedPromiseInitializeAsResolved(writer) {
        defaultWriterClosedPromiseInitialize(writer), defaultWriterClosedPromiseResolve(writer);
      }
      function defaultWriterClosedPromiseReject(writer, reason) {
        writer._closedPromise_reject !== void 0 && (setPromiseIsHandledToTrue(writer._closedPromise), writer._closedPromise_reject(reason), writer._closedPromise_resolve = void 0, writer._closedPromise_reject = void 0, writer._closedPromiseState = "rejected");
      }
      function defaultWriterClosedPromiseResetToRejected(writer, reason) {
        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterClosedPromiseResolve(writer) {
        writer._closedPromise_resolve !== void 0 && (writer._closedPromise_resolve(void 0), writer._closedPromise_resolve = void 0, writer._closedPromise_reject = void 0, writer._closedPromiseState = "resolved");
      }
      function defaultWriterReadyPromiseInitialize(writer) {
        writer._readyPromise = newPromise((resolve, reject) => {
          writer._readyPromise_resolve = resolve, writer._readyPromise_reject = reject;
        }), writer._readyPromiseState = "pending";
      }
      function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
        defaultWriterReadyPromiseInitialize(writer), defaultWriterReadyPromiseReject(writer, reason);
      }
      function defaultWriterReadyPromiseInitializeAsResolved(writer) {
        defaultWriterReadyPromiseInitialize(writer), defaultWriterReadyPromiseResolve(writer);
      }
      function defaultWriterReadyPromiseReject(writer, reason) {
        writer._readyPromise_reject !== void 0 && (setPromiseIsHandledToTrue(writer._readyPromise), writer._readyPromise_reject(reason), writer._readyPromise_resolve = void 0, writer._readyPromise_reject = void 0, writer._readyPromiseState = "rejected");
      }
      function defaultWriterReadyPromiseReset(writer) {
        defaultWriterReadyPromiseInitialize(writer);
      }
      function defaultWriterReadyPromiseResetToRejected(writer, reason) {
        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterReadyPromiseResolve(writer) {
        writer._readyPromise_resolve !== void 0 && (writer._readyPromise_resolve(void 0), writer._readyPromise_resolve = void 0, writer._readyPromise_reject = void 0, writer._readyPromiseState = "fulfilled");
      }
      let NativeDOMException = typeof DOMException < "u" ? DOMException : void 0;
      function isDOMExceptionConstructor(ctor) {
        if (!(typeof ctor == "function" || typeof ctor == "object"))
          return !1;
        try {
          return new ctor(), !0;
        } catch {
          return !1;
        }
      }
      function createDOMExceptionPolyfill() {
        let ctor = function(message, name) {
          this.message = message || "", this.name = name || "Error", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
        };
        return ctor.prototype = Object.create(Error.prototype), Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: !0, configurable: !0 }), ctor;
      }
      let DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
      function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
        let reader = AcquireReadableStreamDefaultReader(source), writer = AcquireWritableStreamDefaultWriter(dest);
        source._disturbed = !0;
        let shuttingDown = !1, currentWrite = promiseResolvedWith(void 0);
        return newPromise((resolve, reject) => {
          let abortAlgorithm;
          if (signal !== void 0) {
            if (abortAlgorithm = () => {
              let error = new DOMException$1("Aborted", "AbortError"), actions = [];
              preventAbort || actions.push(() => dest._state === "writable" ? WritableStreamAbort(dest, error) : promiseResolvedWith(void 0)), preventCancel || actions.push(() => source._state === "readable" ? ReadableStreamCancel(source, error) : promiseResolvedWith(void 0)), shutdownWithAction(() => Promise.all(actions.map((action3) => action3())), !0, error);
            }, signal.aborted) {
              abortAlgorithm();
              return;
            }
            signal.addEventListener("abort", abortAlgorithm);
          }
          function pipeLoop() {
            return newPromise((resolveLoop, rejectLoop) => {
              function next(done) {
                done ? resolveLoop() : PerformPromiseThen(pipeStep(), next, rejectLoop);
              }
              next(!1);
            });
          }
          function pipeStep() {
            return shuttingDown ? promiseResolvedWith(!0) : PerformPromiseThen(writer._readyPromise, () => newPromise((resolveRead, rejectRead) => {
              ReadableStreamDefaultReaderRead(reader, {
                _chunkSteps: (chunk) => {
                  currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop2), resolveRead(!1);
                },
                _closeSteps: () => resolveRead(!0),
                _errorSteps: rejectRead
              });
            }));
          }
          if (isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
            preventAbort ? shutdown(!0, storedError) : shutdownWithAction(() => WritableStreamAbort(dest, storedError), !0, storedError);
          }), isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
            preventCancel ? shutdown(!0, storedError) : shutdownWithAction(() => ReadableStreamCancel(source, storedError), !0, storedError);
          }), isOrBecomesClosed(source, reader._closedPromise, () => {
            preventClose ? shutdown() : shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
          }), WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
            let destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
            preventCancel ? shutdown(!0, destClosed) : shutdownWithAction(() => ReadableStreamCancel(source, destClosed), !0, destClosed);
          }
          setPromiseIsHandledToTrue(pipeLoop());
          function waitForWritesToFinish() {
            let oldCurrentWrite = currentWrite;
            return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
          }
          function isOrBecomesErrored(stream, promise, action3) {
            stream._state === "errored" ? action3(stream._storedError) : uponRejection(promise, action3);
          }
          function isOrBecomesClosed(stream, promise, action3) {
            stream._state === "closed" ? action3() : uponFulfillment(promise, action3);
          }
          function shutdownWithAction(action3, originalIsError, originalError) {
            if (shuttingDown)
              return;
            shuttingDown = !0, dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest) ? uponFulfillment(waitForWritesToFinish(), doTheRest) : doTheRest();
            function doTheRest() {
              uponPromise(action3(), () => finalize(originalIsError, originalError), (newError) => finalize(!0, newError));
            }
          }
          function shutdown(isError, error) {
            shuttingDown || (shuttingDown = !0, dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest) ? uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error)) : finalize(isError, error));
          }
          function finalize(isError, error) {
            WritableStreamDefaultWriterRelease(writer), ReadableStreamReaderGenericRelease(reader), signal !== void 0 && signal.removeEventListener("abort", abortAlgorithm), isError ? reject(error) : resolve(void 0);
          }
        });
      }
      class ReadableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
         */
        get desiredSize() {
          if (!IsReadableStreamDefaultController(this))
            throw defaultControllerBrandCheckException$1("desiredSize");
          return ReadableStreamDefaultControllerGetDesiredSize(this);
        }
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */
        close() {
          if (!IsReadableStreamDefaultController(this))
            throw defaultControllerBrandCheckException$1("close");
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this))
            throw new TypeError("The stream is not in a state that permits close");
          ReadableStreamDefaultControllerClose(this);
        }
        enqueue(chunk = void 0) {
          if (!IsReadableStreamDefaultController(this))
            throw defaultControllerBrandCheckException$1("enqueue");
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this))
            throw new TypeError("The stream is not in a state that permits enqueue");
          return ReadableStreamDefaultControllerEnqueue(this, chunk);
        }
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */
        error(e2 = void 0) {
          if (!IsReadableStreamDefaultController(this))
            throw defaultControllerBrandCheckException$1("error");
          ReadableStreamDefaultControllerError(this, e2);
        }
        /** @internal */
        [CancelSteps](reason) {
          ResetQueue(this);
          let result = this._cancelAlgorithm(reason);
          return ReadableStreamDefaultControllerClearAlgorithms(this), result;
        }
        /** @internal */
        [PullSteps](readRequest) {
          let stream = this._controlledReadableStream;
          if (this._queue.length > 0) {
            let chunk = DequeueValue(this);
            this._closeRequested && this._queue.length === 0 ? (ReadableStreamDefaultControllerClearAlgorithms(this), ReadableStreamClose(stream)) : ReadableStreamDefaultControllerCallPullIfNeeded(this), readRequest._chunkSteps(chunk);
          } else
            ReadableStreamAddReadRequest(stream, readRequest), ReadableStreamDefaultControllerCallPullIfNeeded(this);
        }
      }
      Object.defineProperties(ReadableStreamDefaultController.prototype, {
        close: { enumerable: !0 },
        enqueue: { enumerable: !0 },
        error: { enumerable: !0 },
        desiredSize: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamDefaultController",
        configurable: !0
      });
      function IsReadableStreamDefaultController(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_controlledReadableStream") ? !1 : x2 instanceof ReadableStreamDefaultController;
      }
      function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
        if (!ReadableStreamDefaultControllerShouldCallPull(controller))
          return;
        if (controller._pulling) {
          controller._pullAgain = !0;
          return;
        }
        controller._pulling = !0;
        let pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
          controller._pulling = !1, controller._pullAgain && (controller._pullAgain = !1, ReadableStreamDefaultControllerCallPullIfNeeded(controller));
        }, (e2) => {
          ReadableStreamDefaultControllerError(controller, e2);
        });
      }
      function ReadableStreamDefaultControllerShouldCallPull(controller) {
        let stream = controller._controlledReadableStream;
        return !ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) || !controller._started ? !1 : !!(IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0 || ReadableStreamDefaultControllerGetDesiredSize(controller) > 0);
      }
      function ReadableStreamDefaultControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0, controller._cancelAlgorithm = void 0, controller._strategySizeAlgorithm = void 0;
      }
      function ReadableStreamDefaultControllerClose(controller) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller))
          return;
        let stream = controller._controlledReadableStream;
        controller._closeRequested = !0, controller._queue.length === 0 && (ReadableStreamDefaultControllerClearAlgorithms(controller), ReadableStreamClose(stream));
      }
      function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller))
          return;
        let stream = controller._controlledReadableStream;
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0)
          ReadableStreamFulfillReadRequest(stream, chunk, !1);
        else {
          let chunkSize;
          try {
            chunkSize = controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            throw ReadableStreamDefaultControllerError(controller, chunkSizeE), chunkSizeE;
          }
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            throw ReadableStreamDefaultControllerError(controller, enqueueE), enqueueE;
          }
        }
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
      }
      function ReadableStreamDefaultControllerError(controller, e2) {
        let stream = controller._controlledReadableStream;
        stream._state === "readable" && (ResetQueue(controller), ReadableStreamDefaultControllerClearAlgorithms(controller), ReadableStreamError(stream, e2));
      }
      function ReadableStreamDefaultControllerGetDesiredSize(controller) {
        let state = controller._controlledReadableStream._state;
        return state === "errored" ? null : state === "closed" ? 0 : controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableStreamDefaultControllerHasBackpressure(controller) {
        return !ReadableStreamDefaultControllerShouldCallPull(controller);
      }
      function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
        let state = controller._controlledReadableStream._state;
        return !controller._closeRequested && state === "readable";
      }
      function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledReadableStream = stream, controller._queue = void 0, controller._queueTotalSize = void 0, ResetQueue(controller), controller._started = !1, controller._closeRequested = !1, controller._pullAgain = !1, controller._pulling = !1, controller._strategySizeAlgorithm = sizeAlgorithm, controller._strategyHWM = highWaterMark, controller._pullAlgorithm = pullAlgorithm, controller._cancelAlgorithm = cancelAlgorithm, stream._readableStreamController = controller;
        let startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
          controller._started = !0, ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }, (r2) => {
          ReadableStreamDefaultControllerError(controller, r2);
        });
      }
      function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
        let controller = Object.create(ReadableStreamDefaultController.prototype), startAlgorithm = () => {
        }, pullAlgorithm = () => promiseResolvedWith(void 0), cancelAlgorithm = () => promiseResolvedWith(void 0);
        underlyingSource.start !== void 0 && (startAlgorithm = () => underlyingSource.start(controller)), underlyingSource.pull !== void 0 && (pullAlgorithm = () => underlyingSource.pull(controller)), underlyingSource.cancel !== void 0 && (cancelAlgorithm = (reason) => underlyingSource.cancel(reason)), SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function defaultControllerBrandCheckException$1(name) {
        return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
      }
      function ReadableStreamTee(stream, cloneForBranch2) {
        return IsReadableByteStreamController(stream._readableStreamController) ? ReadableByteStreamTee(stream) : ReadableStreamDefaultTee(stream);
      }
      function ReadableStreamDefaultTee(stream, cloneForBranch2) {
        let reader = AcquireReadableStreamDefaultReader(stream), reading = !1, readAgain = !1, canceled1 = !1, canceled2 = !1, reason1, reason2, branch1, branch2, resolveCancelPromise, cancelPromise = newPromise((resolve) => {
          resolveCancelPromise = resolve;
        });
        function pullAlgorithm() {
          return reading ? (readAgain = !0, promiseResolvedWith(void 0)) : (reading = !0, ReadableStreamDefaultReaderRead(reader, {
            _chunkSteps: (chunk) => {
              queueMicrotask(() => {
                readAgain = !1;
                let chunk1 = chunk, chunk2 = chunk;
                canceled1 || ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1), canceled2 || ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2), reading = !1, readAgain && pullAlgorithm();
              });
            },
            _closeSteps: () => {
              reading = !1, canceled1 || ReadableStreamDefaultControllerClose(branch1._readableStreamController), canceled2 || ReadableStreamDefaultControllerClose(branch2._readableStreamController), (!canceled1 || !canceled2) && resolveCancelPromise(void 0);
            },
            _errorSteps: () => {
              reading = !1;
            }
          }), promiseResolvedWith(void 0));
        }
        function cancel1Algorithm(reason) {
          if (canceled1 = !0, reason1 = reason, canceled2) {
            let compositeReason = CreateArrayFromList([reason1, reason2]), cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          if (canceled2 = !0, reason2 = reason, canceled1) {
            let compositeReason = CreateArrayFromList([reason1, reason2]), cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
        }
        return branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm), branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm), uponRejection(reader._closedPromise, (r2) => {
          ReadableStreamDefaultControllerError(branch1._readableStreamController, r2), ReadableStreamDefaultControllerError(branch2._readableStreamController, r2), (!canceled1 || !canceled2) && resolveCancelPromise(void 0);
        }), [branch1, branch2];
      }
      function ReadableByteStreamTee(stream) {
        let reader = AcquireReadableStreamDefaultReader(stream), reading = !1, readAgainForBranch1 = !1, readAgainForBranch2 = !1, canceled1 = !1, canceled2 = !1, reason1, reason2, branch1, branch2, resolveCancelPromise, cancelPromise = newPromise((resolve) => {
          resolveCancelPromise = resolve;
        });
        function forwardReaderError(thisReader) {
          uponRejection(thisReader._closedPromise, (r2) => {
            thisReader === reader && (ReadableByteStreamControllerError(branch1._readableStreamController, r2), ReadableByteStreamControllerError(branch2._readableStreamController, r2), (!canceled1 || !canceled2) && resolveCancelPromise(void 0));
          });
        }
        function pullWithDefaultReader() {
          IsReadableStreamBYOBReader(reader) && (ReadableStreamReaderGenericRelease(reader), reader = AcquireReadableStreamDefaultReader(stream), forwardReaderError(reader)), ReadableStreamDefaultReaderRead(reader, {
            _chunkSteps: (chunk) => {
              queueMicrotask(() => {
                readAgainForBranch1 = !1, readAgainForBranch2 = !1;
                let chunk1 = chunk, chunk2 = chunk;
                if (!canceled1 && !canceled2)
                  try {
                    chunk2 = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(branch1._readableStreamController, cloneE), ReadableByteStreamControllerError(branch2._readableStreamController, cloneE), resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                canceled1 || ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1), canceled2 || ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2), reading = !1, readAgainForBranch1 ? pull1Algorithm() : readAgainForBranch2 && pull2Algorithm();
              });
            },
            _closeSteps: () => {
              reading = !1, canceled1 || ReadableByteStreamControllerClose(branch1._readableStreamController), canceled2 || ReadableByteStreamControllerClose(branch2._readableStreamController), branch1._readableStreamController._pendingPullIntos.length > 0 && ReadableByteStreamControllerRespond(branch1._readableStreamController, 0), branch2._readableStreamController._pendingPullIntos.length > 0 && ReadableByteStreamControllerRespond(branch2._readableStreamController, 0), (!canceled1 || !canceled2) && resolveCancelPromise(void 0);
            },
            _errorSteps: () => {
              reading = !1;
            }
          });
        }
        function pullWithBYOBReader(view, forBranch2) {
          IsReadableStreamDefaultReader(reader) && (ReadableStreamReaderGenericRelease(reader), reader = AcquireReadableStreamBYOBReader(stream), forwardReaderError(reader));
          let byobBranch = forBranch2 ? branch2 : branch1, otherBranch = forBranch2 ? branch1 : branch2;
          ReadableStreamBYOBReaderRead(reader, view, {
            _chunkSteps: (chunk) => {
              queueMicrotask(() => {
                readAgainForBranch1 = !1, readAgainForBranch2 = !1;
                let byobCanceled = forBranch2 ? canceled2 : canceled1;
                if (forBranch2 ? canceled1 : canceled2)
                  byobCanceled || ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                else {
                  let clonedChunk;
                  try {
                    clonedChunk = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE), ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE), resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                  byobCanceled || ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk), ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                }
                reading = !1, readAgainForBranch1 ? pull1Algorithm() : readAgainForBranch2 && pull2Algorithm();
              });
            },
            _closeSteps: (chunk) => {
              reading = !1;
              let byobCanceled = forBranch2 ? canceled2 : canceled1, otherCanceled = forBranch2 ? canceled1 : canceled2;
              byobCanceled || ReadableByteStreamControllerClose(byobBranch._readableStreamController), otherCanceled || ReadableByteStreamControllerClose(otherBranch._readableStreamController), chunk !== void 0 && (byobCanceled || ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk), !otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0 && ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0)), (!byobCanceled || !otherCanceled) && resolveCancelPromise(void 0);
            },
            _errorSteps: () => {
              reading = !1;
            }
          });
        }
        function pull1Algorithm() {
          if (reading)
            return readAgainForBranch1 = !0, promiseResolvedWith(void 0);
          reading = !0;
          let byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
          return byobRequest === null ? pullWithDefaultReader() : pullWithBYOBReader(byobRequest._view, !1), promiseResolvedWith(void 0);
        }
        function pull2Algorithm() {
          if (reading)
            return readAgainForBranch2 = !0, promiseResolvedWith(void 0);
          reading = !0;
          let byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
          return byobRequest === null ? pullWithDefaultReader() : pullWithBYOBReader(byobRequest._view, !0), promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          if (canceled1 = !0, reason1 = reason, canceled2) {
            let compositeReason = CreateArrayFromList([reason1, reason2]), cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          if (canceled2 = !0, reason2 = reason, canceled1) {
            let compositeReason = CreateArrayFromList([reason1, reason2]), cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
        }
        return branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm), branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm), forwardReaderError(reader), [branch1, branch2];
      }
      function convertUnderlyingDefaultOrByteSource(source, context) {
        assertDictionary(source, context);
        let original = source, autoAllocateChunkSize = original == null ? void 0 : original.autoAllocateChunkSize, cancel = original == null ? void 0 : original.cancel, pull = original == null ? void 0 : original.pull, start = original == null ? void 0 : original.start, type = original == null ? void 0 : original.type;
        return {
          autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
          cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
          pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
          start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
          type: type === void 0 ? void 0 : convertReadableStreamType(type, `${context} has member 'type' that`)
        };
      }
      function convertUnderlyingSourceCancelCallback(fn, original, context) {
        return assertFunction(fn, context), (reason) => promiseCall(fn, original, [reason]);
      }
      function convertUnderlyingSourcePullCallback(fn, original, context) {
        return assertFunction(fn, context), (controller) => promiseCall(fn, original, [controller]);
      }
      function convertUnderlyingSourceStartCallback(fn, original, context) {
        return assertFunction(fn, context), (controller) => reflectCall(fn, original, [controller]);
      }
      function convertReadableStreamType(type, context) {
        if (type = `${type}`, type !== "bytes")
          throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
        return type;
      }
      function convertReaderOptions(options, context) {
        assertDictionary(options, context);
        let mode = options == null ? void 0 : options.mode;
        return {
          mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
        };
      }
      function convertReadableStreamReaderMode(mode, context) {
        if (mode = `${mode}`, mode !== "byob")
          throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
        return mode;
      }
      function convertIteratorOptions(options, context) {
        assertDictionary(options, context);
        let preventCancel = options == null ? void 0 : options.preventCancel;
        return { preventCancel: Boolean(preventCancel) };
      }
      function convertPipeOptions(options, context) {
        assertDictionary(options, context);
        let preventAbort = options == null ? void 0 : options.preventAbort, preventCancel = options == null ? void 0 : options.preventCancel, preventClose = options == null ? void 0 : options.preventClose, signal = options == null ? void 0 : options.signal;
        return signal !== void 0 && assertAbortSignal(signal, `${context} has member 'signal' that`), {
          preventAbort: Boolean(preventAbort),
          preventCancel: Boolean(preventCancel),
          preventClose: Boolean(preventClose),
          signal
        };
      }
      function assertAbortSignal(signal, context) {
        if (!isAbortSignal2(signal))
          throw new TypeError(`${context} is not an AbortSignal.`);
      }
      function convertReadableWritablePair(pair, context) {
        assertDictionary(pair, context);
        let readable = pair == null ? void 0 : pair.readable;
        assertRequiredField(readable, "readable", "ReadableWritablePair"), assertReadableStream(readable, `${context} has member 'readable' that`);
        let writable = pair == null ? void 0 : pair.writable;
        return assertRequiredField(writable, "writable", "ReadableWritablePair"), assertWritableStream(writable, `${context} has member 'writable' that`), { readable, writable };
      }
      class ReadableStream2 {
        constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
          rawUnderlyingSource === void 0 ? rawUnderlyingSource = null : assertObject(rawUnderlyingSource, "First parameter");
          let strategy = convertQueuingStrategy(rawStrategy, "Second parameter"), underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
          if (InitializeReadableStream(this), underlyingSource.type === "bytes") {
            if (strategy.size !== void 0)
              throw new RangeError("The strategy for a byte stream cannot have a size function");
            let highWaterMark = ExtractHighWaterMark(strategy, 0);
            SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
          } else {
            let sizeAlgorithm = ExtractSizeAlgorithm(strategy), highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
          }
        }
        /**
         * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
         */
        get locked() {
          if (!IsReadableStream(this))
            throw streamBrandCheckException$1("locked");
          return IsReadableStreamLocked(this);
        }
        /**
         * Cancels the stream, signaling a loss of interest in the stream by a consumer.
         *
         * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}
         * method, which might or might not use it.
         */
        cancel(reason = void 0) {
          return IsReadableStream(this) ? IsReadableStreamLocked(this) ? promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader")) : ReadableStreamCancel(this, reason) : promiseRejectedWith(streamBrandCheckException$1("cancel"));
        }
        getReader(rawOptions = void 0) {
          if (!IsReadableStream(this))
            throw streamBrandCheckException$1("getReader");
          return convertReaderOptions(rawOptions, "First parameter").mode === void 0 ? AcquireReadableStreamDefaultReader(this) : AcquireReadableStreamBYOBReader(this);
        }
        pipeThrough(rawTransform, rawOptions = {}) {
          if (!IsReadableStream(this))
            throw streamBrandCheckException$1("pipeThrough");
          assertRequiredArgument(rawTransform, 1, "pipeThrough");
          let transform = convertReadableWritablePair(rawTransform, "First parameter"), options = convertPipeOptions(rawOptions, "Second parameter");
          if (IsReadableStreamLocked(this))
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
          if (IsWritableStreamLocked(transform.writable))
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
          let promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
          return setPromiseIsHandledToTrue(promise), transform.readable;
        }
        pipeTo(destination, rawOptions = {}) {
          if (!IsReadableStream(this))
            return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
          if (destination === void 0)
            return promiseRejectedWith("Parameter 1 is required in 'pipeTo'.");
          if (!IsWritableStream(destination))
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
          let options;
          try {
            options = convertPipeOptions(rawOptions, "Second parameter");
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          return IsReadableStreamLocked(this) ? promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")) : IsWritableStreamLocked(destination) ? promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")) : ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
        }
        /**
         * Tees this readable stream, returning a two-element array containing the two resulting branches as
         * new {@link ReadableStream} instances.
         *
         * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.
         * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be
         * propagated to the stream's underlying source.
         *
         * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,
         * this could allow interference between the two branches.
         */
        tee() {
          if (!IsReadableStream(this))
            throw streamBrandCheckException$1("tee");
          let branches = ReadableStreamTee(this);
          return CreateArrayFromList(branches);
        }
        values(rawOptions = void 0) {
          if (!IsReadableStream(this))
            throw streamBrandCheckException$1("values");
          let options = convertIteratorOptions(rawOptions, "First parameter");
          return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
        }
      }
      Object.defineProperties(ReadableStream2.prototype, {
        cancel: { enumerable: !0 },
        getReader: { enumerable: !0 },
        pipeThrough: { enumerable: !0 },
        pipeTo: { enumerable: !0 },
        tee: { enumerable: !0 },
        values: { enumerable: !0 },
        locked: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStream",
        configurable: !0
      }), typeof SymbolPolyfill.asyncIterator == "symbol" && Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
        value: ReadableStream2.prototype.values,
        writable: !0,
        configurable: !0
      });
      function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        let stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        let controller = Object.create(ReadableStreamDefaultController.prototype);
        return SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm), stream;
      }
      function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
        let stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        let controller = Object.create(ReadableByteStreamController.prototype);
        return SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0), stream;
      }
      function InitializeReadableStream(stream) {
        stream._state = "readable", stream._reader = void 0, stream._storedError = void 0, stream._disturbed = !1;
      }
      function IsReadableStream(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_readableStreamController") ? !1 : x2 instanceof ReadableStream2;
      }
      function IsReadableStreamLocked(stream) {
        return stream._reader !== void 0;
      }
      function ReadableStreamCancel(stream, reason) {
        if (stream._disturbed = !0, stream._state === "closed")
          return promiseResolvedWith(void 0);
        if (stream._state === "errored")
          return promiseRejectedWith(stream._storedError);
        ReadableStreamClose(stream);
        let reader = stream._reader;
        reader !== void 0 && IsReadableStreamBYOBReader(reader) && (reader._readIntoRequests.forEach((readIntoRequest) => {
          readIntoRequest._closeSteps(void 0);
        }), reader._readIntoRequests = new SimpleQueue());
        let sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
        return transformPromiseWith(sourceCancelPromise, noop2);
      }
      function ReadableStreamClose(stream) {
        stream._state = "closed";
        let reader = stream._reader;
        reader !== void 0 && (defaultReaderClosedPromiseResolve(reader), IsReadableStreamDefaultReader(reader) && (reader._readRequests.forEach((readRequest) => {
          readRequest._closeSteps();
        }), reader._readRequests = new SimpleQueue()));
      }
      function ReadableStreamError(stream, e2) {
        stream._state = "errored", stream._storedError = e2;
        let reader = stream._reader;
        reader !== void 0 && (defaultReaderClosedPromiseReject(reader, e2), IsReadableStreamDefaultReader(reader) ? (reader._readRequests.forEach((readRequest) => {
          readRequest._errorSteps(e2);
        }), reader._readRequests = new SimpleQueue()) : (reader._readIntoRequests.forEach((readIntoRequest) => {
          readIntoRequest._errorSteps(e2);
        }), reader._readIntoRequests = new SimpleQueue()));
      }
      function streamBrandCheckException$1(name) {
        return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
      }
      function convertQueuingStrategyInit(init, context) {
        assertDictionary(init, context);
        let highWaterMark = init == null ? void 0 : init.highWaterMark;
        return assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit"), {
          highWaterMark: convertUnrestrictedDouble(highWaterMark)
        };
      }
      let byteLengthSizeFunction = (chunk) => chunk.byteLength;
      try {
        Object.defineProperty(byteLengthSizeFunction, "name", {
          value: "size",
          configurable: !0
        });
      } catch {
      }
      class ByteLengthQueuingStrategy {
        constructor(options) {
          assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy"), options = convertQueuingStrategyInit(options, "First parameter"), this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        /**
         * Returns the high water mark provided to the constructor.
         */
        get highWaterMark() {
          if (!IsByteLengthQueuingStrategy(this))
            throw byteLengthBrandCheckException("highWaterMark");
          return this._byteLengthQueuingStrategyHighWaterMark;
        }
        /**
         * Measures the size of `chunk` by returning the value of its `byteLength` property.
         */
        get size() {
          if (!IsByteLengthQueuingStrategy(this))
            throw byteLengthBrandCheckException("size");
          return byteLengthSizeFunction;
        }
      }
      Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
        highWaterMark: { enumerable: !0 },
        size: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
        value: "ByteLengthQueuingStrategy",
        configurable: !0
      });
      function byteLengthBrandCheckException(name) {
        return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
      }
      function IsByteLengthQueuingStrategy(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_byteLengthQueuingStrategyHighWaterMark") ? !1 : x2 instanceof ByteLengthQueuingStrategy;
      }
      let countSizeFunction = () => 1;
      try {
        Object.defineProperty(countSizeFunction, "name", {
          value: "size",
          configurable: !0
        });
      } catch {
      }
      class CountQueuingStrategy {
        constructor(options) {
          assertRequiredArgument(options, 1, "CountQueuingStrategy"), options = convertQueuingStrategyInit(options, "First parameter"), this._countQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        /**
         * Returns the high water mark provided to the constructor.
         */
        get highWaterMark() {
          if (!IsCountQueuingStrategy(this))
            throw countBrandCheckException("highWaterMark");
          return this._countQueuingStrategyHighWaterMark;
        }
        /**
         * Measures the size of `chunk` by always returning 1.
         * This ensures that the total queue size is a count of the number of chunks in the queue.
         */
        get size() {
          if (!IsCountQueuingStrategy(this))
            throw countBrandCheckException("size");
          return countSizeFunction;
        }
      }
      Object.defineProperties(CountQueuingStrategy.prototype, {
        highWaterMark: { enumerable: !0 },
        size: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
        value: "CountQueuingStrategy",
        configurable: !0
      });
      function countBrandCheckException(name) {
        return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
      }
      function IsCountQueuingStrategy(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_countQueuingStrategyHighWaterMark") ? !1 : x2 instanceof CountQueuingStrategy;
      }
      function convertTransformer(original, context) {
        assertDictionary(original, context);
        let flush = original == null ? void 0 : original.flush, readableType = original == null ? void 0 : original.readableType, start = original == null ? void 0 : original.start, transform = original == null ? void 0 : original.transform, writableType = original == null ? void 0 : original.writableType;
        return {
          flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
          readableType,
          start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
          transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
          writableType
        };
      }
      function convertTransformerFlushCallback(fn, original, context) {
        return assertFunction(fn, context), (controller) => promiseCall(fn, original, [controller]);
      }
      function convertTransformerStartCallback(fn, original, context) {
        return assertFunction(fn, context), (controller) => reflectCall(fn, original, [controller]);
      }
      function convertTransformerTransformCallback(fn, original, context) {
        return assertFunction(fn, context), (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
      }
      class TransformStream {
        constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
          rawTransformer === void 0 && (rawTransformer = null);
          let writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter"), readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter"), transformer = convertTransformer(rawTransformer, "First parameter");
          if (transformer.readableType !== void 0)
            throw new RangeError("Invalid readableType specified");
          if (transformer.writableType !== void 0)
            throw new RangeError("Invalid writableType specified");
          let readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0), readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy), writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1), writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy), startPromise_resolve, startPromise = newPromise((resolve) => {
            startPromise_resolve = resolve;
          });
          InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm), SetUpTransformStreamDefaultControllerFromTransformer(this, transformer), transformer.start !== void 0 ? startPromise_resolve(transformer.start(this._transformStreamController)) : startPromise_resolve(void 0);
        }
        /**
         * The readable side of the transform stream.
         */
        get readable() {
          if (!IsTransformStream(this))
            throw streamBrandCheckException("readable");
          return this._readable;
        }
        /**
         * The writable side of the transform stream.
         */
        get writable() {
          if (!IsTransformStream(this))
            throw streamBrandCheckException("writable");
          return this._writable;
        }
      }
      Object.defineProperties(TransformStream.prototype, {
        readable: { enumerable: !0 },
        writable: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
        value: "TransformStream",
        configurable: !0
      });
      function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
        function startAlgorithm() {
          return startPromise;
        }
        function writeAlgorithm(chunk) {
          return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
        }
        function abortAlgorithm(reason) {
          return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
        }
        function closeAlgorithm() {
          return TransformStreamDefaultSinkCloseAlgorithm(stream);
        }
        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
        function pullAlgorithm() {
          return TransformStreamDefaultSourcePullAlgorithm(stream);
        }
        function cancelAlgorithm(reason) {
          return TransformStreamErrorWritableAndUnblockWrite(stream, reason), promiseResolvedWith(void 0);
        }
        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm), stream._backpressure = void 0, stream._backpressureChangePromise = void 0, stream._backpressureChangePromise_resolve = void 0, TransformStreamSetBackpressure(stream, !0), stream._transformStreamController = void 0;
      }
      function IsTransformStream(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_transformStreamController") ? !1 : x2 instanceof TransformStream;
      }
      function TransformStreamError(stream, e2) {
        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e2), TransformStreamErrorWritableAndUnblockWrite(stream, e2);
      }
      function TransformStreamErrorWritableAndUnblockWrite(stream, e2) {
        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController), WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e2), stream._backpressure && TransformStreamSetBackpressure(stream, !1);
      }
      function TransformStreamSetBackpressure(stream, backpressure) {
        stream._backpressureChangePromise !== void 0 && stream._backpressureChangePromise_resolve(), stream._backpressureChangePromise = newPromise((resolve) => {
          stream._backpressureChangePromise_resolve = resolve;
        }), stream._backpressure = backpressure;
      }
      class TransformStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the desired size to fill the readable sides internal queue. It can be negative, if the queue is over-full.
         */
        get desiredSize() {
          if (!IsTransformStreamDefaultController(this))
            throw defaultControllerBrandCheckException("desiredSize");
          let readableController = this._controlledTransformStream._readable._readableStreamController;
          return ReadableStreamDefaultControllerGetDesiredSize(readableController);
        }
        enqueue(chunk = void 0) {
          if (!IsTransformStreamDefaultController(this))
            throw defaultControllerBrandCheckException("enqueue");
          TransformStreamDefaultControllerEnqueue(this, chunk);
        }
        /**
         * Errors both the readable side and the writable side of the controlled transform stream, making all future
         * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.
         */
        error(reason = void 0) {
          if (!IsTransformStreamDefaultController(this))
            throw defaultControllerBrandCheckException("error");
          TransformStreamDefaultControllerError(this, reason);
        }
        /**
         * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the
         * transformer only needs to consume a portion of the chunks written to the writable side.
         */
        terminate() {
          if (!IsTransformStreamDefaultController(this))
            throw defaultControllerBrandCheckException("terminate");
          TransformStreamDefaultControllerTerminate(this);
        }
      }
      Object.defineProperties(TransformStreamDefaultController.prototype, {
        enqueue: { enumerable: !0 },
        error: { enumerable: !0 },
        terminate: { enumerable: !0 },
        desiredSize: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
        value: "TransformStreamDefaultController",
        configurable: !0
      });
      function IsTransformStreamDefaultController(x2) {
        return !typeIsObject(x2) || !Object.prototype.hasOwnProperty.call(x2, "_controlledTransformStream") ? !1 : x2 instanceof TransformStreamDefaultController;
      }
      function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
        controller._controlledTransformStream = stream, stream._transformStreamController = controller, controller._transformAlgorithm = transformAlgorithm, controller._flushAlgorithm = flushAlgorithm;
      }
      function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
        let controller = Object.create(TransformStreamDefaultController.prototype), transformAlgorithm = (chunk) => {
          try {
            return TransformStreamDefaultControllerEnqueue(controller, chunk), promiseResolvedWith(void 0);
          } catch (transformResultE) {
            return promiseRejectedWith(transformResultE);
          }
        }, flushAlgorithm = () => promiseResolvedWith(void 0);
        transformer.transform !== void 0 && (transformAlgorithm = (chunk) => transformer.transform(chunk, controller)), transformer.flush !== void 0 && (flushAlgorithm = () => transformer.flush(controller)), SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
      }
      function TransformStreamDefaultControllerClearAlgorithms(controller) {
        controller._transformAlgorithm = void 0, controller._flushAlgorithm = void 0;
      }
      function TransformStreamDefaultControllerEnqueue(controller, chunk) {
        let stream = controller._controlledTransformStream, readableController = stream._readable._readableStreamController;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController))
          throw new TypeError("Readable side is not in a state that permits enqueue");
        try {
          ReadableStreamDefaultControllerEnqueue(readableController, chunk);
        } catch (e2) {
          throw TransformStreamErrorWritableAndUnblockWrite(stream, e2), stream._readable._storedError;
        }
        ReadableStreamDefaultControllerHasBackpressure(readableController) !== stream._backpressure && TransformStreamSetBackpressure(stream, !0);
      }
      function TransformStreamDefaultControllerError(controller, e2) {
        TransformStreamError(controller._controlledTransformStream, e2);
      }
      function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
        let transformPromise = controller._transformAlgorithm(chunk);
        return transformPromiseWith(transformPromise, void 0, (r2) => {
          throw TransformStreamError(controller._controlledTransformStream, r2), r2;
        });
      }
      function TransformStreamDefaultControllerTerminate(controller) {
        let stream = controller._controlledTransformStream, readableController = stream._readable._readableStreamController;
        ReadableStreamDefaultControllerClose(readableController);
        let error = new TypeError("TransformStream terminated");
        TransformStreamErrorWritableAndUnblockWrite(stream, error);
      }
      function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
        let controller = stream._transformStreamController;
        if (stream._backpressure) {
          let backpressureChangePromise = stream._backpressureChangePromise;
          return transformPromiseWith(backpressureChangePromise, () => {
            let writable = stream._writable;
            if (writable._state === "erroring")
              throw writable._storedError;
            return TransformStreamDefaultControllerPerformTransform(controller, chunk);
          });
        }
        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
      }
      function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
        return TransformStreamError(stream, reason), promiseResolvedWith(void 0);
      }
      function TransformStreamDefaultSinkCloseAlgorithm(stream) {
        let readable = stream._readable, controller = stream._transformStreamController, flushPromise = controller._flushAlgorithm();
        return TransformStreamDefaultControllerClearAlgorithms(controller), transformPromiseWith(flushPromise, () => {
          if (readable._state === "errored")
            throw readable._storedError;
          ReadableStreamDefaultControllerClose(readable._readableStreamController);
        }, (r2) => {
          throw TransformStreamError(stream, r2), readable._storedError;
        });
      }
      function TransformStreamDefaultSourcePullAlgorithm(stream) {
        return TransformStreamSetBackpressure(stream, !1), stream._backpressureChangePromise;
      }
      function defaultControllerBrandCheckException(name) {
        return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
      }
      function streamBrandCheckException(name) {
        return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
      }
      exports2.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy, exports2.CountQueuingStrategy = CountQueuingStrategy, exports2.ReadableByteStreamController = ReadableByteStreamController, exports2.ReadableStream = ReadableStream2, exports2.ReadableStreamBYOBReader = ReadableStreamBYOBReader, exports2.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest, exports2.ReadableStreamDefaultController = ReadableStreamDefaultController, exports2.ReadableStreamDefaultReader = ReadableStreamDefaultReader, exports2.TransformStream = TransformStream, exports2.TransformStreamDefaultController = TransformStreamDefaultController, exports2.WritableStream = WritableStream, exports2.WritableStreamDefaultController = WritableStreamDefaultController, exports2.WritableStreamDefaultWriter = WritableStreamDefaultWriter, Object.defineProperty(exports2, "__esModule", { value: !0 });
    });
  }
});

// node_modules/fetch-blob/streams.cjs
var require_streams = __commonJS({
  "node_modules/fetch-blob/streams.cjs"() {
    if (!globalThis.ReadableStream)
      try {
        let process2 = require("node:process"), { emitWarning } = process2;
        try {
          process2.emitWarning = () => {
          }, Object.assign(globalThis, require("node:stream/web")), process2.emitWarning = emitWarning;
        } catch (error) {
          throw process2.emitWarning = emitWarning, error;
        }
      } catch {
        Object.assign(globalThis, require_ponyfill_es2018());
      }
    try {
      let { Blob: Blob3 } = require("buffer");
      Blob3 && !Blob3.prototype.stream && (Blob3.prototype.stream = function(params) {
        let position = 0, blob = this;
        return new ReadableStream({
          type: "bytes",
          async pull(ctrl) {
            let buffer = await blob.slice(position, Math.min(blob.size, position + 65536)).arrayBuffer();
            position += buffer.byteLength, ctrl.enqueue(new Uint8Array(buffer)), position === blob.size && ctrl.close();
          }
        });
      });
    } catch {
    }
  }
});

// node_modules/fetch-blob/index.js
async function* toIterator(parts, clone2 = !0) {
  for (let part of parts)
    if ("stream" in part)
      yield* (
        /** @type {AsyncIterableIterator<Uint8Array>} */
        part.stream()
      );
    else if (ArrayBuffer.isView(part))
      if (clone2) {
        let position = part.byteOffset, end = part.byteOffset + part.byteLength;
        for (; position !== end; ) {
          let size = Math.min(end - position, POOL_SIZE), chunk = part.buffer.slice(position, position + size);
          position += chunk.byteLength, yield new Uint8Array(chunk);
        }
      } else
        yield part;
    else {
      let position = 0, b = (
        /** @type {Blob} */
        part
      );
      for (; position !== b.size; ) {
        let buffer = await b.slice(position, Math.min(b.size, position + POOL_SIZE)).arrayBuffer();
        position += buffer.byteLength, yield new Uint8Array(buffer);
      }
    }
}
var import_streams, POOL_SIZE, _parts, _type, _size, _endings, _a, _Blob, Blob2, fetch_blob_default, init_fetch_blob = __esm({
  "node_modules/fetch-blob/index.js"() {
    import_streams = __toESM(require_streams(), 1);
    POOL_SIZE = 65536;
    _Blob = (_a = class {
      /**
       * The Blob() constructor returns a new Blob object. The content
       * of the blob consists of the concatenation of the values given
       * in the parameter array.
       *
       * @param {*} blobParts
       * @param {{ type?: string, endings?: string }} [options]
       */
      constructor(blobParts = [], options = {}) {
        /** @type {Array.<(Blob|Uint8Array)>} */
        __privateAdd(this, _parts, []);
        __privateAdd(this, _type, "");
        __privateAdd(this, _size, 0);
        __privateAdd(this, _endings, "transparent");
        if (typeof blobParts != "object" || blobParts === null)
          throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
        if (typeof blobParts[Symbol.iterator] != "function")
          throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
        if (typeof options != "object" && typeof options != "function")
          throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        options === null && (options = {});
        let encoder = new TextEncoder();
        for (let element of blobParts) {
          let part;
          ArrayBuffer.isView(element) ? part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength)) : element instanceof ArrayBuffer ? part = new Uint8Array(element.slice(0)) : element instanceof _a ? part = element : part = encoder.encode(`${element}`), __privateSet(this, _size, __privateGet(this, _size) + (ArrayBuffer.isView(part) ? part.byteLength : part.size)), __privateGet(this, _parts).push(part);
        }
        __privateSet(this, _endings, `${options.endings === void 0 ? "transparent" : options.endings}`);
        let type = options.type === void 0 ? "" : String(options.type);
        __privateSet(this, _type, /^[\x20-\x7E]*$/.test(type) ? type : "");
      }
      /**
       * The Blob interface's size property returns the
       * size of the Blob in bytes.
       */
      get size() {
        return __privateGet(this, _size);
      }
      /**
       * The type property of a Blob object returns the MIME type of the file.
       */
      get type() {
        return __privateGet(this, _type);
      }
      /**
       * The text() method in the Blob interface returns a Promise
       * that resolves with a string containing the contents of
       * the blob, interpreted as UTF-8.
       *
       * @return {Promise<string>}
       */
      async text() {
        let decoder = new TextDecoder(), str = "";
        for await (let part of toIterator(__privateGet(this, _parts), !1))
          str += decoder.decode(part, { stream: !0 });
        return str += decoder.decode(), str;
      }
      /**
       * The arrayBuffer() method in the Blob interface returns a
       * Promise that resolves with the contents of the blob as
       * binary data contained in an ArrayBuffer.
       *
       * @return {Promise<ArrayBuffer>}
       */
      async arrayBuffer() {
        let data = new Uint8Array(this.size), offset = 0;
        for await (let chunk of toIterator(__privateGet(this, _parts), !1))
          data.set(chunk, offset), offset += chunk.length;
        return data.buffer;
      }
      stream() {
        let it = toIterator(__privateGet(this, _parts), !0);
        return new globalThis.ReadableStream({
          // @ts-ignore
          type: "bytes",
          async pull(ctrl) {
            let chunk = await it.next();
            chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
          },
          async cancel() {
            await it.return();
          }
        });
      }
      /**
       * The Blob interface's slice() method creates and returns a
       * new Blob object which contains data from a subset of the
       * blob on which it's called.
       *
       * @param {number} [start]
       * @param {number} [end]
       * @param {string} [type]
       */
      slice(start = 0, end = this.size, type = "") {
        let { size } = this, relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size), relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size), span = Math.max(relativeEnd - relativeStart, 0), parts = __privateGet(this, _parts), blobParts = [], added = 0;
        for (let part of parts) {
          if (added >= span)
            break;
          let size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart)
            relativeStart -= size2, relativeEnd -= size2;
          else {
            let chunk;
            ArrayBuffer.isView(part) ? (chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd)), added += chunk.byteLength) : (chunk = part.slice(relativeStart, Math.min(size2, relativeEnd)), added += chunk.size), relativeEnd -= size2, blobParts.push(chunk), relativeStart = 0;
          }
        }
        let blob = new _a([], { type: String(type).toLowerCase() });
        return __privateSet(blob, _size, span), __privateSet(blob, _parts, blobParts), blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object == "object" && typeof object.constructor == "function" && (typeof object.stream == "function" || typeof object.arrayBuffer == "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    }, _parts = new WeakMap(), _type = new WeakMap(), _size = new WeakMap(), _endings = new WeakMap(), _a);
    Object.defineProperties(_Blob.prototype, {
      size: { enumerable: !0 },
      type: { enumerable: !0 },
      slice: { enumerable: !0 }
    });
    Blob2 = _Blob, fetch_blob_default = Blob2;
  }
});

// node_modules/fetch-blob/file.js
var _lastModified, _name, _a2, _File, File3, file_default, init_file = __esm({
  "node_modules/fetch-blob/file.js"() {
    init_fetch_blob();
    _File = (_a2 = class extends fetch_blob_default {
      /**
       * @param {*[]} fileBits
       * @param {string} fileName
       * @param {{lastModified?: number, type?: string}} options
       */
      // @ts-ignore
      constructor(fileBits, fileName, options = {}) {
        if (arguments.length < 2)
          throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
        super(fileBits, options);
        __privateAdd(this, _lastModified, 0);
        __privateAdd(this, _name, "");
        options === null && (options = {});
        let lastModified = options.lastModified === void 0 ? Date.now() : Number(options.lastModified);
        Number.isNaN(lastModified) || __privateSet(this, _lastModified, lastModified), __privateSet(this, _name, String(fileName));
      }
      get name() {
        return __privateGet(this, _name);
      }
      get lastModified() {
        return __privateGet(this, _lastModified);
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
      static [Symbol.hasInstance](object) {
        return !!object && object instanceof fetch_blob_default && /^(File)$/.test(object[Symbol.toStringTag]);
      }
    }, _lastModified = new WeakMap(), _name = new WeakMap(), _a2), File3 = _File, file_default = File3;
  }
});

// node_modules/formdata-polyfill/esm.min.js
function formDataToBlob(F2, B = fetch_blob_default) {
  var b = `${r()}${r()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), c = [], p = `--${b}\r
Content-Disposition: form-data; name="`;
  return F2.forEach((v, n) => typeof v == "string" ? c.push(p + e(n) + `"\r
\r
${v.replace(/\r(?!\n)|(?<!\r)\n/g, `\r
`)}\r
`) : c.push(p + e(n) + `"; filename="${e(v.name, 1)}"\r
Content-Type: ${v.type || "application/octet-stream"}\r
\r
`, v, `\r
`)), c.push(`--${b}--`), new B(c, { type: "multipart/form-data; boundary=" + b });
}
var t, i, h, r, m, f, e, x, _d, _a3, FormData2, init_esm_min = __esm({
  "node_modules/formdata-polyfill/esm.min.js"() {
    init_fetch_blob();
    init_file();
    ({ toStringTag: t, iterator: i, hasInstance: h } = Symbol), r = Math.random, m = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(","), f = (a, b, c) => (a += "", /^(Blob|File)$/.test(b && b[t]) ? [(c = c !== void 0 ? c + "" : b[t] == "File" ? b.name : "blob", a), b.name !== c || b[t] == "blob" ? new file_default([b], c, b) : b] : [a, b + ""]), e = (c, f3) => (f3 ? c : c.replace(/\r?\n|\r/g, `\r
`)).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), x = (n, a, e2) => {
      if (a.length < e2)
        throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e2} arguments required, but only ${a.length} present.`);
    }, FormData2 = (_a3 = class {
      constructor(...a) {
        __privateAdd(this, _d, []);
        if (a.length)
          throw new TypeError("Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.");
      }
      get [t]() {
        return "FormData";
      }
      [i]() {
        return this.entries();
      }
      static [h](o) {
        return o && typeof o == "object" && o[t] === "FormData" && !m.some((m2) => typeof o[m2] != "function");
      }
      append(...a) {
        x("append", arguments, 2), __privateGet(this, _d).push(f(...a));
      }
      delete(a) {
        x("delete", arguments, 1), a += "", __privateSet(this, _d, __privateGet(this, _d).filter(([b]) => b !== a));
      }
      get(a) {
        x("get", arguments, 1), a += "";
        for (var b = __privateGet(this, _d), l = b.length, c = 0; c < l; c++)
          if (b[c][0] === a)
            return b[c][1];
        return null;
      }
      getAll(a, b) {
        return x("getAll", arguments, 1), b = [], a += "", __privateGet(this, _d).forEach((c) => c[0] === a && b.push(c[1])), b;
      }
      has(a) {
        return x("has", arguments, 1), a += "", __privateGet(this, _d).some((b) => b[0] === a);
      }
      forEach(a, b) {
        x("forEach", arguments, 1);
        for (var [c, d] of this)
          a.call(b, d, c, this);
      }
      set(...a) {
        x("set", arguments, 2);
        var b = [], c = !0;
        a = f(...a), __privateGet(this, _d).forEach((d) => {
          d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);
        }), c && b.push(a), __privateSet(this, _d, b);
      }
      *entries() {
        yield* __privateGet(this, _d);
      }
      *keys() {
        for (var [a] of this)
          yield a;
      }
      *values() {
        for (var [, a] of this)
          yield a;
      }
    }, _d = new WeakMap(), _a3);
  }
});

// node_modules/node-domexception/index.js
var require_node_domexception = __commonJS({
  "node_modules/node-domexception/index.js"(exports, module2) {
    if (!globalThis.DOMException)
      try {
        let { MessageChannel: MessageChannel2 } = require("worker_threads"), port = new MessageChannel2().port1, ab = new ArrayBuffer();
        port.postMessage(ab, [ab, ab]);
      } catch (err) {
        err.constructor.name === "DOMException" && (globalThis.DOMException = err.constructor);
      }
    module2.exports = globalThis.DOMException;
  }
});

// node_modules/fetch-blob/from.js
var import_node_fs, import_node_domexception, stat, _path, _start, _BlobDataItem, BlobDataItem, init_from = __esm({
  "node_modules/fetch-blob/from.js"() {
    import_node_fs = require("node:fs"), import_node_domexception = __toESM(require_node_domexception(), 1);
    init_file();
    init_fetch_blob();
    ({ stat } = import_node_fs.promises), _BlobDataItem = class {
      constructor(options) {
        __privateAdd(this, _path, void 0);
        __privateAdd(this, _start, void 0);
        __privateSet(this, _path, options.path), __privateSet(this, _start, options.start), this.size = options.size, this.lastModified = options.lastModified;
      }
      /**
       * Slicing arguments is first validated and formatted
       * to not be out of range by Blob.prototype.slice
       */
      slice(start, end) {
        return new _BlobDataItem({
          path: __privateGet(this, _path),
          lastModified: this.lastModified,
          size: end - start,
          start: __privateGet(this, _start) + start
        });
      }
      async *stream() {
        let { mtimeMs } = await stat(__privateGet(this, _path));
        if (mtimeMs > this.lastModified)
          throw new import_node_domexception.default("The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.", "NotReadableError");
        yield* (0, import_node_fs.createReadStream)(__privateGet(this, _path), {
          start: __privateGet(this, _start),
          end: __privateGet(this, _start) + this.size - 1
        });
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
    }, BlobDataItem = _BlobDataItem;
    _path = new WeakMap(), _start = new WeakMap();
  }
});

// node_modules/node-fetch/src/utils/multipart-parser.js
var multipart_parser_exports = {};
__export(multipart_parser_exports, {
  toFormData: () => toFormData
});
function _fileName(headerValue) {
  let m2 = headerValue.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
  if (!m2)
    return;
  let match = m2[2] || m2[3] || "", filename = match.slice(match.lastIndexOf("\\") + 1);
  return filename = filename.replace(/%22/g, '"'), filename = filename.replace(/&#(\d{4});/g, (m3, code) => String.fromCharCode(code)), filename;
}
async function toFormData(Body2, ct) {
  if (!/multipart/i.test(ct))
    throw new TypeError("Failed to fetch");
  let m2 = ct.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
  if (!m2)
    throw new TypeError("no or bad content-type header, no multipart boundary");
  let parser = new MultipartParser(m2[1] || m2[2]), headerField, headerValue, entryValue, entryName, contentType, filename, entryChunks = [], formData = new FormData2(), onPartData = (ui8a) => {
    entryValue += decoder.decode(ui8a, { stream: !0 });
  }, appendToFile = (ui8a) => {
    entryChunks.push(ui8a);
  }, appendFileToFormData = () => {
    let file = new file_default(entryChunks, filename, { type: contentType });
    formData.append(entryName, file);
  }, appendEntryToFormData = () => {
    formData.append(entryName, entryValue);
  }, decoder = new TextDecoder("utf-8");
  decoder.decode(), parser.onPartBegin = function() {
    parser.onPartData = onPartData, parser.onPartEnd = appendEntryToFormData, headerField = "", headerValue = "", entryValue = "", entryName = "", contentType = "", filename = null, entryChunks.length = 0;
  }, parser.onHeaderField = function(ui8a) {
    headerField += decoder.decode(ui8a, { stream: !0 });
  }, parser.onHeaderValue = function(ui8a) {
    headerValue += decoder.decode(ui8a, { stream: !0 });
  }, parser.onHeaderEnd = function() {
    if (headerValue += decoder.decode(), headerField = headerField.toLowerCase(), headerField === "content-disposition") {
      let m3 = headerValue.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);
      m3 && (entryName = m3[2] || m3[3] || ""), filename = _fileName(headerValue), filename && (parser.onPartData = appendToFile, parser.onPartEnd = appendFileToFormData);
    } else
      headerField === "content-type" && (contentType = headerValue);
    headerValue = "", headerField = "";
  };
  for await (let chunk of Body2)
    parser.write(chunk);
  return parser.end(), formData;
}
var s, S, f2, F, LF, CR, SPACE, HYPHEN, COLON, A, Z, lower, noop, MultipartParser, init_multipart_parser = __esm({
  "node_modules/node-fetch/src/utils/multipart-parser.js"() {
    init_from();
    init_esm_min();
    s = 0, S = {
      START_BOUNDARY: s++,
      HEADER_FIELD_START: s++,
      HEADER_FIELD: s++,
      HEADER_VALUE_START: s++,
      HEADER_VALUE: s++,
      HEADER_VALUE_ALMOST_DONE: s++,
      HEADERS_ALMOST_DONE: s++,
      PART_DATA_START: s++,
      PART_DATA: s++,
      END: s++
    }, f2 = 1, F = {
      PART_BOUNDARY: f2,
      LAST_BOUNDARY: f2 *= 2
    }, LF = 10, CR = 13, SPACE = 32, HYPHEN = 45, COLON = 58, A = 97, Z = 122, lower = (c) => c | 32, noop = () => {
    }, MultipartParser = class {
      /**
       * @param {string} boundary
       */
      constructor(boundary) {
        this.index = 0, this.flags = 0, this.onHeaderEnd = noop, this.onHeaderField = noop, this.onHeadersEnd = noop, this.onHeaderValue = noop, this.onPartBegin = noop, this.onPartData = noop, this.onPartEnd = noop, this.boundaryChars = {}, boundary = `\r
--` + boundary;
        let ui8a = new Uint8Array(boundary.length);
        for (let i2 = 0; i2 < boundary.length; i2++)
          ui8a[i2] = boundary.charCodeAt(i2), this.boundaryChars[ui8a[i2]] = !0;
        this.boundary = ui8a, this.lookbehind = new Uint8Array(this.boundary.length + 8), this.state = S.START_BOUNDARY;
      }
      /**
       * @param {Uint8Array} data
       */
      write(data) {
        let i2 = 0, length_ = data.length, previousIndex = this.index, { lookbehind, boundary, boundaryChars, index, state, flags: flags2 } = this, boundaryLength = this.boundary.length, boundaryEnd = boundaryLength - 1, bufferLength = data.length, c, cl, mark = (name) => {
          this[name + "Mark"] = i2;
        }, clear = (name) => {
          delete this[name + "Mark"];
        }, callback = (callbackSymbol, start, end, ui8a) => {
          (start === void 0 || start !== end) && this[callbackSymbol](ui8a && ui8a.subarray(start, end));
        }, dataCallback = (name, clear2) => {
          let markSymbol = name + "Mark";
          markSymbol in this && (clear2 ? (callback(name, this[markSymbol], i2, data), delete this[markSymbol]) : (callback(name, this[markSymbol], data.length, data), this[markSymbol] = 0));
        };
        for (i2 = 0; i2 < length_; i2++)
          switch (c = data[i2], state) {
            case S.START_BOUNDARY:
              if (index === boundary.length - 2) {
                if (c === HYPHEN)
                  flags2 |= F.LAST_BOUNDARY;
                else if (c !== CR)
                  return;
                index++;
                break;
              } else if (index - 1 === boundary.length - 2) {
                if (flags2 & F.LAST_BOUNDARY && c === HYPHEN)
                  state = S.END, flags2 = 0;
                else if (!(flags2 & F.LAST_BOUNDARY) && c === LF)
                  index = 0, callback("onPartBegin"), state = S.HEADER_FIELD_START;
                else
                  return;
                break;
              }
              c !== boundary[index + 2] && (index = -2), c === boundary[index + 2] && index++;
              break;
            case S.HEADER_FIELD_START:
              state = S.HEADER_FIELD, mark("onHeaderField"), index = 0;
            case S.HEADER_FIELD:
              if (c === CR) {
                clear("onHeaderField"), state = S.HEADERS_ALMOST_DONE;
                break;
              }
              if (index++, c === HYPHEN)
                break;
              if (c === COLON) {
                if (index === 1)
                  return;
                dataCallback("onHeaderField", !0), state = S.HEADER_VALUE_START;
                break;
              }
              if (cl = lower(c), cl < A || cl > Z)
                return;
              break;
            case S.HEADER_VALUE_START:
              if (c === SPACE)
                break;
              mark("onHeaderValue"), state = S.HEADER_VALUE;
            case S.HEADER_VALUE:
              c === CR && (dataCallback("onHeaderValue", !0), callback("onHeaderEnd"), state = S.HEADER_VALUE_ALMOST_DONE);
              break;
            case S.HEADER_VALUE_ALMOST_DONE:
              if (c !== LF)
                return;
              state = S.HEADER_FIELD_START;
              break;
            case S.HEADERS_ALMOST_DONE:
              if (c !== LF)
                return;
              callback("onHeadersEnd"), state = S.PART_DATA_START;
              break;
            case S.PART_DATA_START:
              state = S.PART_DATA, mark("onPartData");
            case S.PART_DATA:
              if (previousIndex = index, index === 0) {
                for (i2 += boundaryEnd; i2 < bufferLength && !(data[i2] in boundaryChars); )
                  i2 += boundaryLength;
                i2 -= boundaryEnd, c = data[i2];
              }
              if (index < boundary.length)
                boundary[index] === c ? (index === 0 && dataCallback("onPartData", !0), index++) : index = 0;
              else if (index === boundary.length)
                index++, c === CR ? flags2 |= F.PART_BOUNDARY : c === HYPHEN ? flags2 |= F.LAST_BOUNDARY : index = 0;
              else if (index - 1 === boundary.length)
                if (flags2 & F.PART_BOUNDARY) {
                  if (index = 0, c === LF) {
                    flags2 &= ~F.PART_BOUNDARY, callback("onPartEnd"), callback("onPartBegin"), state = S.HEADER_FIELD_START;
                    break;
                  }
                } else
                  flags2 & F.LAST_BOUNDARY && c === HYPHEN ? (callback("onPartEnd"), state = S.END, flags2 = 0) : index = 0;
              if (index > 0)
                lookbehind[index - 1] = c;
              else if (previousIndex > 0) {
                let _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);
                callback("onPartData", 0, previousIndex, _lookbehind), previousIndex = 0, mark("onPartData"), i2--;
              }
              break;
            case S.END:
              break;
            default:
              throw new Error(`Unexpected state entered: ${state}`);
          }
        dataCallback("onHeaderField"), dataCallback("onHeaderValue"), dataCallback("onPartData"), this.index = index, this.state = state, this.flags = flags2;
      }
      end() {
        if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length)
          this.onPartEnd();
        else if (this.state !== S.END)
          throw new Error("MultipartParser.end(): stream ended unexpectedly");
      }
    };
  }
});

// node_modules/lodash.capitalize/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.capitalize/index.js"(exports, module2) {
    var INFINITY = 1 / 0, symbolTag = "[object Symbol]", rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23", rsComboSymbolsRange = "\\u20d0-\\u20f0", rsVarRange = "\\ufe0e\\ufe0f", rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")", reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g"), reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]"), freeGlobal = typeof global == "object" && global && global.Object === Object && global, freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")();
    function asciiToArray(string) {
      return string.split("");
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    var objectProto = Object.prototype, objectToString = objectProto.toString, Symbol2 = root.Symbol, symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseSlice(array, start, end) {
      var index = -1, length = array.length;
      start < 0 && (start = -start > length ? 0 : length + start), end = end > length ? length : end, end < 0 && (end += length), length = start > end ? 0 : end - start >>> 0, start >>>= 0;
      for (var result = Array(length); ++index < length; )
        result[index] = array[index + start];
      return result;
    }
    function baseToString(value) {
      if (typeof value == "string")
        return value;
      if (isSymbol(value))
        return symbolToString ? symbolToString.call(value) : "";
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castSlice(array, start, end) {
      var length = array.length;
      return end = end === void 0 ? length : end, !start && end >= length ? array : baseSlice(array, start, end);
    }
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);
        var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0, chr = strSymbols ? strSymbols[0] : string.charAt(0), trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function capitalize2(string) {
      return upperFirst(toString(string).toLowerCase());
    }
    var upperFirst = createCaseFirst("toUpperCase");
    module2.exports = capitalize2;
  }
});

// node_modules/lodash.kebabcase/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.kebabcase/index.js"(exports, module2) {
    var INFINITY = 1 / 0, symbolTag = "[object Symbol]", reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23", rsComboSymbolsRange = "\\u20d0-\\u20f0", rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange, rsApos = "['\u2019]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d", rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")", rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, reApos = RegExp(rsApos, "g"), reComboMark = RegExp(rsCombo, "g"), reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
      rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
      rsUpper + "+" + rsOptUpperContr,
      rsDigits,
      rsEmoji
    ].join("|"), "g"), reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, deburredLetters = {
      // Latin-1 Supplement block.
      \u00C0: "A",
      \u00C1: "A",
      \u00C2: "A",
      \u00C3: "A",
      \u00C4: "A",
      \u00C5: "A",
      \u00E0: "a",
      \u00E1: "a",
      \u00E2: "a",
      \u00E3: "a",
      \u00E4: "a",
      \u00E5: "a",
      \u00C7: "C",
      \u00E7: "c",
      \u00D0: "D",
      \u00F0: "d",
      \u00C8: "E",
      \u00C9: "E",
      \u00CA: "E",
      \u00CB: "E",
      \u00E8: "e",
      \u00E9: "e",
      \u00EA: "e",
      \u00EB: "e",
      \u00CC: "I",
      \u00CD: "I",
      \u00CE: "I",
      \u00CF: "I",
      \u00EC: "i",
      \u00ED: "i",
      \u00EE: "i",
      \u00EF: "i",
      \u00D1: "N",
      \u00F1: "n",
      \u00D2: "O",
      \u00D3: "O",
      \u00D4: "O",
      \u00D5: "O",
      \u00D6: "O",
      \u00D8: "O",
      \u00F2: "o",
      \u00F3: "o",
      \u00F4: "o",
      \u00F5: "o",
      \u00F6: "o",
      \u00F8: "o",
      \u00D9: "U",
      \u00DA: "U",
      \u00DB: "U",
      \u00DC: "U",
      \u00F9: "u",
      \u00FA: "u",
      \u00FB: "u",
      \u00FC: "u",
      \u00DD: "Y",
      \u00FD: "y",
      \u00FF: "y",
      \u00C6: "Ae",
      \u00E6: "ae",
      \u00DE: "Th",
      \u00FE: "th",
      \u00DF: "ss",
      // Latin Extended-A block.
      \u0100: "A",
      \u0102: "A",
      \u0104: "A",
      \u0101: "a",
      \u0103: "a",
      \u0105: "a",
      \u0106: "C",
      \u0108: "C",
      \u010A: "C",
      \u010C: "C",
      \u0107: "c",
      \u0109: "c",
      \u010B: "c",
      \u010D: "c",
      \u010E: "D",
      \u0110: "D",
      \u010F: "d",
      \u0111: "d",
      \u0112: "E",
      \u0114: "E",
      \u0116: "E",
      \u0118: "E",
      \u011A: "E",
      \u0113: "e",
      \u0115: "e",
      \u0117: "e",
      \u0119: "e",
      \u011B: "e",
      \u011C: "G",
      \u011E: "G",
      \u0120: "G",
      \u0122: "G",
      \u011D: "g",
      \u011F: "g",
      \u0121: "g",
      \u0123: "g",
      \u0124: "H",
      \u0126: "H",
      \u0125: "h",
      \u0127: "h",
      \u0128: "I",
      \u012A: "I",
      \u012C: "I",
      \u012E: "I",
      \u0130: "I",
      \u0129: "i",
      \u012B: "i",
      \u012D: "i",
      \u012F: "i",
      \u0131: "i",
      \u0134: "J",
      \u0135: "j",
      \u0136: "K",
      \u0137: "k",
      \u0138: "k",
      \u0139: "L",
      \u013B: "L",
      \u013D: "L",
      \u013F: "L",
      \u0141: "L",
      \u013A: "l",
      \u013C: "l",
      \u013E: "l",
      \u0140: "l",
      \u0142: "l",
      \u0143: "N",
      \u0145: "N",
      \u0147: "N",
      \u014A: "N",
      \u0144: "n",
      \u0146: "n",
      \u0148: "n",
      \u014B: "n",
      \u014C: "O",
      \u014E: "O",
      \u0150: "O",
      \u014D: "o",
      \u014F: "o",
      \u0151: "o",
      \u0154: "R",
      \u0156: "R",
      \u0158: "R",
      \u0155: "r",
      \u0157: "r",
      \u0159: "r",
      \u015A: "S",
      \u015C: "S",
      \u015E: "S",
      \u0160: "S",
      \u015B: "s",
      \u015D: "s",
      \u015F: "s",
      \u0161: "s",
      \u0162: "T",
      \u0164: "T",
      \u0166: "T",
      \u0163: "t",
      \u0165: "t",
      \u0167: "t",
      \u0168: "U",
      \u016A: "U",
      \u016C: "U",
      \u016E: "U",
      \u0170: "U",
      \u0172: "U",
      \u0169: "u",
      \u016B: "u",
      \u016D: "u",
      \u016F: "u",
      \u0171: "u",
      \u0173: "u",
      \u0174: "W",
      \u0175: "w",
      \u0176: "Y",
      \u0177: "y",
      \u0178: "Y",
      \u0179: "Z",
      \u017B: "Z",
      \u017D: "Z",
      \u017A: "z",
      \u017C: "z",
      \u017E: "z",
      \u0132: "IJ",
      \u0133: "ij",
      \u0152: "Oe",
      \u0153: "oe",
      \u0149: "'n",
      \u017F: "ss"
    }, freeGlobal = typeof global == "object" && global && global.Object === Object && global, freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")();
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      for (initAccum && length && (accumulator = array[++index]); ++index < length; )
        accumulator = iteratee(accumulator, array[index], index, array);
      return accumulator;
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? void 0 : object[key];
      };
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var objectProto = Object.prototype, objectToString = objectProto.toString, Symbol2 = root.Symbol, symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string")
        return value;
      if (isSymbol(value))
        return symbolToString ? symbolToString.call(value) : "";
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
      };
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function deburr(string) {
      return string = toString(string), string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    var kebabCase2 = createCompounder(function(result, word, index) {
      return result + (index ? "-" : "") + word.toLowerCase();
    });
    function words(string, pattern, guard) {
      return string = toString(string), pattern = guard ? void 0 : pattern, pattern === void 0 ? hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string) : string.match(pattern) || [];
    }
    module2.exports = kebabCase2;
  }
});

// <stdin>
var stdin_exports = {};
__export(stdin_exports, {
  assets: () => assets_manifest_default,
  assetsBuildDirectory: () => assetsBuildDirectory,
  entry: () => entry,
  future: () => future,
  publicPath: () => publicPath,
  routes: () => routes
});
module.exports = __toCommonJS(stdin_exports);

// app/entry.server.tsx
var entry_server_exports = {};
__export(entry_server_exports, {
  default: () => handleRequest
});
var import_node_stream = require("node:stream"), import_node = __toESM(require_dist2()), import_react = __toESM(require_dist3());

// node_modules/isbot/index.mjs
function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
  return _classApplyDescriptorGet(receiver, descriptor);
}
function _classPrivateFieldSet(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
  return _classApplyDescriptorSet(receiver, descriptor, value), value;
}
function _classExtractFieldDescriptor(receiver, privateMap, action3) {
  if (!privateMap.has(receiver))
    throw new TypeError("attempted to " + action3 + " private field on non-instance");
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet(receiver, descriptor) {
  return descriptor.get ? descriptor.get.call(receiver) : descriptor.value;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
  if (descriptor.set)
    descriptor.set.call(receiver, value);
  else {
    if (!descriptor.writable)
      throw new TypeError("attempted to set read only private field");
    descriptor.value = value;
  }
}
function _classPrivateMethodGet(receiver, privateSet, fn) {
  if (!privateSet.has(receiver))
    throw new TypeError("attempted to get private field on non-instance");
  return fn;
}
function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj))
    throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classPrivateFieldInitSpec(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap), privateMap.set(obj, value);
}
function _classPrivateMethodInitSpec(obj, privateSet) {
  _checkPrivateRedeclaration(obj, privateSet), privateSet.add(obj);
}
var list = [
  " daum[ /]",
  " deusu/",
  "(?:^| )site",
  "@[a-z]",
  "\\(at\\)[a-z]",
  "\\(github\\.com/",
  "\\[at\\][a-z]",
  "^12345",
  "^<",
  "^[\\w \\.\\-\\(\\)]+(/v?\\d+(\\.\\d+)?(\\.\\d{1,10})?)?$",
  "^[^ ]{50,}$",
  "^active",
  "^ad muncher",
  "^anglesharp/",
  "^anonymous",
  "^avsdevicesdk/",
  "^axios/",
  "^bidtellect/",
  "^biglotron",
  "^btwebclient/",
  "^castro",
  "^clamav[ /]",
  "^client/",
  "^cobweb/",
  "^coccoc",
  "^custom",
  "^ddg[_-]android",
  "^discourse",
  "^dispatch/\\d",
  "^downcast/",
  "^duckduckgo",
  "^facebook",
  "^fdm[ /]\\d",
  "^getright/",
  "^gozilla/",
  "^hatena",
  "^hobbit",
  "^hotzonu",
  "^hwcdn/",
  "^jeode/",
  "^jetty/",
  "^jigsaw",
  "^linkdex",
  "^lwp[-: ]",
  "^metauri",
  "^microsoft bits",
  "^movabletype",
  "^mozilla/\\d\\.\\d \\(compatible;?\\)$",
  "^mozilla/\\d\\.\\d \\w*$",
  "^navermailapp",
  "^netsurf",
  "^offline explorer",
  "^php",
  "^postman",
  "^postrank",
  "^python",
  "^read",
  "^reed",
  "^restsharp/",
  "^snapchat",
  "^space bison",
  "^svn",
  "^swcd ",
  "^taringa",
  "^test certificate info",
  "^thumbor/",
  "^tumblr/",
  "^user-agent:mozilla",
  "^valid",
  "^venus/fedoraplanet",
  "^w3c",
  "^webbandit/",
  "^webcopier",
  "^wget",
  "^whatsapp",
  "^xenu link sleuth",
  "^yahoo",
  "^yandex",
  "^zdm/\\d",
  "^zoom marketplace/",
  "^{{.*}}$",
  "adbeat\\.com",
  "appinsights",
  "archive",
  "ask jeeves/teoma",
  "bit\\.ly/",
  "bluecoat drtr",
  "bot",
  "browsex",
  "burpcollaborator",
  "capture",
  "catch",
  "check",
  "chrome-lighthouse",
  "chromeframe",
  "cloud",
  "crawl",
  "cryptoapi",
  "dareboost",
  "datanyze",
  "dataprovider",
  "dejaclick",
  "dmbrowser",
  "download",
  "evc-batch/",
  "feed",
  "firephp",
  "freesafeip",
  "ghost",
  "gomezagent",
  "google",
  "headlesschrome/",
  "http",
  "httrack",
  "hubspot marketing grader",
  "hydra",
  "ibisbrowser",
  "images",
  "iplabel",
  "ips-agent",
  "java",
  "library",
  "mail\\.ru/",
  "manager",
  "monitor",
  "morningscore/",
  "neustar wpm",
  "news",
  "nutch",
  "offbyone",
  "optimize",
  "pageburst",
  "pagespeed",
  "perl",
  "phantom",
  "pingdom",
  "powermarks",
  "preview",
  "proxy",
  "ptst[ /]\\d",
  "reader",
  "rexx;",
  "rigor",
  "rss",
  "scan",
  "scrape",
  "search",
  "serp ?reputation ?management",
  "server",
  "sogou",
  "sparkler/",
  "speedcurve",
  "spider",
  "statuscake",
  "stumbleupon\\.com",
  "supercleaner",
  "synapse",
  "synthetic",
  "taginspector/",
  "torrent",
  "tracemyfile",
  "transcoder",
  "trendsmapresolver",
  "twingly recon",
  "url",
  "virtuoso",
  "wappalyzer",
  "webglance",
  "webkit2png",
  "websitemetadataretriever",
  "whatcms/",
  "wordpress",
  "zgrab"
];
function amend(list2) {
  try {
    new RegExp("(?<! cu)bot").test("dangerbot");
  } catch {
    return list2;
  }
  return [
    // Addresses: Cubot device
    ["bot", "(?<! cu)bot"],
    // Addresses: Android webview
    ["google", "(?<! (?:channel/|google/))google(?!(app|/google| pixel))"],
    // Addresses: libhttp browser
    ["http", "(?<!(?:lib))http"],
    // Addresses: java based browsers
    ["java", "java(?!;)"],
    // Addresses: Yandex Search App
    ["search", "(?<! ya(?:yandex)?)search"]
  ].forEach((_ref) => {
    let [search, replace] = _ref, index = list2.lastIndexOf(search);
    ~index && list2.splice(index, 1, replace);
  }), list2;
}
amend(list);
var flags = "i", _list = /* @__PURE__ */ new WeakMap(), _pattern = /* @__PURE__ */ new WeakMap(), _update = /* @__PURE__ */ new WeakSet(), _index = /* @__PURE__ */ new WeakSet(), Isbot = class {
  constructor(patterns) {
    return _classPrivateMethodInitSpec(this, _index), _classPrivateMethodInitSpec(this, _update), _classPrivateFieldInitSpec(this, _list, {
      writable: !0,
      value: void 0
    }), _classPrivateFieldInitSpec(this, _pattern, {
      writable: !0,
      value: void 0
    }), _classPrivateFieldSet(this, _list, patterns || list.slice()), _classPrivateMethodGet(this, _update, _update2).call(this), Object.defineProperties((ua) => this.test(ua), Object.entries(Object.getOwnPropertyDescriptors(Isbot.prototype)).reduce((accumulator, _ref) => {
      let [prop, descriptor] = _ref;
      return typeof descriptor.value == "function" && Object.assign(accumulator, {
        [prop]: {
          value: this[prop].bind(this)
        }
      }), typeof descriptor.get == "function" && Object.assign(accumulator, {
        [prop]: {
          get: () => this[prop]
        }
      }), accumulator;
    }, {}));
  }
  /**
   * Get a clone of the pattern
   * @type RegExp
   */
  get pattern() {
    return new RegExp(_classPrivateFieldGet(this, _pattern));
  }
  /**
   * Match given string against out pattern
   * @param  {string} ua User Agent string
   * @returns {boolean}
   */
  test(ua) {
    return Boolean(ua) && _classPrivateFieldGet(this, _pattern).test(ua);
  }
  /**
   * Get the match for strings' known crawler pattern
   * @param  {string} ua User Agent string
   * @returns {string|null}
   */
  find() {
    let match = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "").match(_classPrivateFieldGet(this, _pattern));
    return match && match[0];
  }
  /**
   * Get the patterns that match user agent string if any
   * @param  {string} ua User Agent string
   * @returns {string[]}
   */
  matches() {
    let ua = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return _classPrivateFieldGet(this, _list).filter((entry2) => new RegExp(entry2, flags).test(ua));
  }
  /**
   * Clear all patterns that match user agent
   * @param  {string} ua User Agent string
   * @returns {void}
   */
  clear() {
    let ua = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    this.exclude(this.matches(ua));
  }
  /**
   * Extent patterns for known crawlers
   * @param  {string[]} filters
   * @returns {void}
   */
  extend() {
    let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    [].push.apply(_classPrivateFieldGet(this, _list), filters.filter((rule) => _classPrivateMethodGet(this, _index, _index2).call(this, rule) === -1).map((filter) => filter.toLowerCase())), _classPrivateMethodGet(this, _update, _update2).call(this);
  }
  /**
   * Exclude patterns from bot pattern rule
   * @param  {string[]} filters
   * @returns {void}
   */
  exclude() {
    let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], {
      length
    } = filters;
    for (; length--; ) {
      let index = _classPrivateMethodGet(this, _index, _index2).call(this, filters[length]);
      index > -1 && _classPrivateFieldGet(this, _list).splice(index, 1);
    }
    _classPrivateMethodGet(this, _update, _update2).call(this);
  }
  /**
   * Create a new Isbot instance using given list or self's list
   * @param  {string[]} [list]
   * @returns {Isbot}
   */
  spawn(list2) {
    return new Isbot(list2 || _classPrivateFieldGet(this, _list));
  }
};
function _update2() {
  _classPrivateFieldSet(this, _pattern, new RegExp(_classPrivateFieldGet(this, _list).join("|"), flags));
}
function _index2(rule) {
  return _classPrivateFieldGet(this, _list).indexOf(rule.toLowerCase());
}
var isbot = new Isbot();

// app/entry.server.tsx
var import_server = __toESM(require_server_node()), import_jsx_dev_runtime = __toESM(require_jsx_dev_runtime()), ABORT_DELAY = 5e3;
function handleRequest(request, responseStatusCode, responseHeaders, remixContext) {
  return isbot(request.headers.get("user-agent")) ? handleBotRequest(
    request,
    responseStatusCode,
    responseHeaders,
    remixContext
  ) : handleBrowserRequest(
    request,
    responseStatusCode,
    responseHeaders,
    remixContext
  );
}
function handleBotRequest(request, responseStatusCode, responseHeaders, remixContext) {
  return new Promise((resolve, reject) => {
    let { pipe, abort } = (0, import_server.renderToPipeableStream)(
      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(
        import_react.RemixServer,
        {
          context: remixContext,
          url: request.url,
          abortDelay: ABORT_DELAY
        },
        void 0,
        !1,
        {
          fileName: "app/entry.server.tsx",
          lineNumber: 46,
          columnNumber: 7
        },
        this
      ),
      {
        onAllReady() {
          let body = new import_node_stream.PassThrough();
          responseHeaders.set("Content-Type", "text/html"), resolve(
            new import_node.Response(body, {
              headers: responseHeaders,
              status: responseStatusCode
            })
          ), pipe(body);
        },
        onShellError(error) {
          reject(error);
        },
        onError(error) {
          responseStatusCode = 500, console.error(error);
        }
      }
    );
    setTimeout(abort, ABORT_DELAY);
  });
}
function handleBrowserRequest(request, responseStatusCode, responseHeaders, remixContext) {
  return new Promise((resolve, reject) => {
    let { pipe, abort } = (0, import_server.renderToPipeableStream)(
      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(
        import_react.RemixServer,
        {
          context: remixContext,
          url: request.url,
          abortDelay: ABORT_DELAY
        },
        void 0,
        !1,
        {
          fileName: "app/entry.server.tsx",
          lineNumber: 88,
          columnNumber: 7
        },
        this
      ),
      {
        onShellReady() {
          let body = new import_node_stream.PassThrough();
          responseHeaders.set("Content-Type", "text/html"), resolve(
            new import_node.Response(body, {
              headers: responseHeaders,
              status: responseStatusCode
            })
          ), pipe(body);
        },
        onShellError(error) {
          reject(error);
        },
        onError(error) {
          console.error(error), responseStatusCode = 500;
        }
      }
    );
    setTimeout(abort, ABORT_DELAY);
  });
}

// app/root.tsx
var root_exports = {};
__export(root_exports, {
  ErrorBoundary: () => ErrorBoundary,
  default: () => App,
  links: () => links
});
var import_react2 = __toESM(require_dist3());

// app/styles/app.css
var app_default = "/build/_assets/app-NCZWV6BN.css";

// app/root.tsx
var import_jsx_dev_runtime2 = __toESM(require_jsx_dev_runtime()), links = () => [{ rel: "stylesheet", href: app_default }];
function ErrorBoundary() {
  let error = (0, import_react2.useRouteError)();
  return (0, import_react2.isRouteErrorResponse)(error) ? /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(import_jsx_dev_runtime2.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)("h1", { children: "Something went wrong!" }, void 0, !1, {
      fileName: "app/root.tsx",
      lineNumber: 21,
      columnNumber: 9
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)("p", { className: "text-[1px]", children: error.data }, void 0, !1, {
      fileName: "app/root.tsx",
      lineNumber: 22,
      columnNumber: 9
    }, this)
  ] }, void 0, !0, {
    fileName: "app/root.tsx",
    lineNumber: 20,
    columnNumber: 7
  }, this) : error instanceof Error ? /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(import_jsx_dev_runtime2.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)("h1", { children: "Something went wrong!" }, void 0, !1, {
      fileName: "app/root.tsx",
      lineNumber: 28,
      columnNumber: 9
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)("p", { className: "text-[1px]", children: error.message }, void 0, !1, {
      fileName: "app/root.tsx",
      lineNumber: 29,
      columnNumber: 9
    }, this)
  ] }, void 0, !0, {
    fileName: "app/root.tsx",
    lineNumber: 27,
    columnNumber: 7
  }, this) : /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(import_jsx_dev_runtime2.Fragment, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)("h1", { children: "Something went wrong!" }, void 0, !1, {
    fileName: "app/root.tsx",
    lineNumber: 35,
    columnNumber: 9
  }, this) }, void 0, !1, {
    fileName: "app/root.tsx",
    lineNumber: 34,
    columnNumber: 7
  }, this);
}
function App() {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)("html", { lang: "en", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)("head", { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)("meta", { charSet: "utf-8" }, void 0, !1, {
        fileName: "app/root.tsx",
        lineNumber: 45,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)("meta", { name: "viewport", content: "width=device-width,initial-scale=1" }, void 0, !1, {
        fileName: "app/root.tsx",
        lineNumber: 46,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(import_react2.Links, {}, void 0, !1, {
        fileName: "app/root.tsx",
        lineNumber: 47,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)("title", { children: "Store Page" }, void 0, !1, {
        fileName: "app/root.tsx",
        lineNumber: 48,
        columnNumber: 9
      }, this)
    ] }, void 0, !0, {
      fileName: "app/root.tsx",
      lineNumber: 44,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)("body", { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(import_react2.Outlet, {}, void 0, !1, {
        fileName: "app/root.tsx",
        lineNumber: 51,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(import_react2.Scripts, {}, void 0, !1, {
        fileName: "app/root.tsx",
        lineNumber: 52,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(import_react2.LiveReload, {}, void 0, !1, {
        fileName: "app/root.tsx",
        lineNumber: 53,
        columnNumber: 9
      }, this)
    ] }, void 0, !0, {
      fileName: "app/root.tsx",
      lineNumber: 50,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/root.tsx",
    lineNumber: 43,
    columnNumber: 5
  }, this);
}

// app/routes/products.$searchTerm.tsx
var products_searchTerm_exports = {};
__export(products_searchTerm_exports, {
  action: () => action,
  default: () => MainRoute,
  loader: () => loader
});
var import_node2 = __toESM(require_dist2());

// app/components/appbar.tsx
var import_react3 = __toESM(require_dist3()), import_react4 = __toESM(require_react());

// app/icons/bdt-icon-logo-oldstack.tsx
var import_jsx_dev_runtime3 = __toESM(require_jsx_dev_runtime());
function BdtIconAppLogoOldstack(attrs) {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(
    "svg",
    {
      width: "137",
      height: "49",
      viewBox: "0 0 137 49",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...attrs,
      children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M67.7799 42.684L132.817 48.2925L136.615 5.60852L71.578 0L48 19.4729L67.7799 42.684ZM132.539 9.18631L129.409 44.3523L125.918 44.0513L129.046 8.88627L132.539 9.18631ZM58.4302 18.5359C58.8776 19.0591 59.0954 19.7406 59.0343 20.4263C58.9733 21.1121 58.6385 21.7443 58.1057 22.1803C56.9901 23.098 55.3458 22.9562 54.4037 21.8612C53.9561 21.338 53.7381 20.6565 53.7991 19.9707C53.8601 19.2848 54.1948 18.6525 54.7276 18.2164C55.8433 17.2977 57.4887 17.4395 58.4307 18.5355L58.4302 18.5359Z",
            fill: "#F44945"
          },
          void 0,
          !1,
          {
            fileName: "app/icons/bdt-icon-logo-oldstack.tsx",
            lineNumber: 14,
            columnNumber: 7
          },
          this
        ),
        /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M99.9508 11.9648V8.28765C98.7007 7.66368 96.9659 7.30255 95.3831 7.30273C92.7643 7.30273 90.6631 8.51754 90.6631 11.0131C90.6631 13.7182 93.1948 14.3724 94.7814 14.7824C95.5055 14.9695 96.0328 15.1058 96.0328 15.3629C96.0328 15.5928 95.8986 15.757 95.0148 15.757C93.8474 15.757 92.2797 15.2976 90.779 14.3617V18.2525C92.0963 18.9744 93.6974 19.352 95.5149 19.352C98.3162 19.352 100.601 18.5472 100.601 15.4612C100.601 12.8401 98.2122 12.2338 96.6262 11.8313C95.8381 11.6313 95.2482 11.4816 95.2482 11.16C95.2482 10.9479 95.4316 10.8322 95.9486 10.8322C97.1991 10.8157 98.7334 11.2753 99.9508 11.9648ZM74.8846 7.58008C77.5685 7.58008 79.0538 8.46726 79.0538 10.4861C79.0538 11.6025 78.7034 12.4397 77.4362 12.948C78.9036 13.3922 79.5208 14.3762 79.5208 15.7387C79.5208 18.3486 77.386 19.0705 74.7511 19.0705H68.5977V7.58008H74.8846ZM74.1342 10.6661H73.0328V12.0449H74.1336C74.3914 12.0594 74.6364 11.9315 74.7718 11.7117C74.9055 11.4934 74.9055 11.2186 74.7718 11.0004C74.6364 10.7807 74.3916 10.6528 74.134 10.6672L74.1342 10.6661ZM74.3176 14.4747H73.033V15.9521H74.3172C74.589 15.9605 74.8441 15.8218 74.9849 15.5892C75.1236 15.3581 75.1236 15.0694 74.9849 14.8384C74.8443 14.6057 74.5892 14.4668 74.3174 14.4749L74.3176 14.4747ZM89.6279 7.58008V10.8634H84.8908V11.8485H88.9599V14.7706H84.8908V15.7557H89.7269V19.0713H80.4551V7.58008H89.6279ZM111.358 7.58045V11.3565H108.357V19.0716H103.921V11.3561H100.919V7.58008H111.359L111.358 7.58045ZM79.9545 26.8377C79.9545 23.4557 78.1194 21.0918 73.9176 21.0918H68.5977V32.5835H73.9176C78.1201 32.5835 79.9545 30.2196 79.9545 26.8377ZM73.033 24.7035H73.751C74.718 24.7035 75.3843 25.1797 75.3843 26.8377C75.3843 28.4956 74.7172 28.9719 73.7501 28.9719H73.033V24.7035ZM90.1613 21.0902V24.3735H85.4254V25.3586H89.4944V28.2808H85.4254V29.2657H90.2613V32.5818H80.9893V21.0898H90.1613V21.0902ZM94.8138 21.0918L90.6279 32.5833H95.1146L95.4983 31.2701H98.8982L99.2819 32.5833H103.769L99.5832 21.0918H94.8138ZM98.0488 28.3149H96.3312L96.8486 26.5421C97.0083 25.9771 97.1253 25.4009 97.1986 24.8184C97.272 25.4009 97.3891 25.9771 97.549 26.5421L98.0488 28.3149ZM108.806 21.0906V28.8057H113.542V32.5818H104.37V21.0898H108.806V21.0906ZM123.481 21.7976C122.231 21.1738 120.497 20.8125 118.912 20.8125L118.913 20.8129C116.294 20.8129 114.193 22.0277 114.193 24.523C114.193 27.2279 116.725 27.8821 118.312 28.2922C119.036 28.4793 119.563 28.6156 119.563 28.8729C119.563 29.1027 119.429 29.2669 118.545 29.2669C117.378 29.2669 115.811 28.8075 114.309 27.8716V31.7626C115.627 32.4843 117.228 32.8619 119.046 32.8619C121.847 32.8619 124.132 32.0573 124.132 28.9713C124.132 26.3499 121.743 25.7436 120.157 25.3412C119.369 25.1412 118.779 24.9916 118.779 24.6702C118.779 24.4579 118.962 24.3422 119.479 24.3422C120.73 24.3257 122.264 24.7855 123.481 25.4748V21.7976Z",
            fill: "white"
          },
          void 0,
          !1,
          {
            fileName: "app/icons/bdt-icon-logo-oldstack.tsx",
            lineNumber: 20,
            columnNumber: 7
          },
          this
        ),
        /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M101.79 35.498C104.029 35.498 105.166 36.8954 105.166 38.6834C105.166 40.4715 104.03 41.8686 101.79 41.8686C99.5495 41.8686 98.4209 40.4715 98.4209 38.6834C98.4209 36.8954 99.55 35.498 101.79 35.498ZM101.79 37.5812C101.216 37.5812 100.838 37.9545 100.838 38.6834C100.838 39.4124 101.217 39.7857 101.79 39.7857C102.372 39.7857 102.751 39.4122 102.751 38.6834C102.751 37.9547 102.372 37.5812 101.79 37.5812ZM98.3242 37.6435V35.6465H92.8057V37.6435H94.3922V41.7229H96.7372V37.6435H98.3242ZM90.7773 40.793C90.7773 41.5217 91.3069 41.869 91.9065 41.869C92.5147 41.869 93.0428 41.5219 93.0428 40.793C93.0428 40.064 92.5138 39.7168 91.9065 39.7168C91.3064 39.7168 90.7773 40.0642 90.7773 40.793ZM111.699 38.6843C111.699 36.8965 110.729 35.6465 108.508 35.6465H105.695V41.7222H108.508C110.729 41.7222 111.699 40.4722 111.699 38.6843ZM108.04 37.556H108.419L108.419 37.5545C108.931 37.5545 109.283 37.8053 109.283 38.6836C109.283 39.5619 108.931 39.8127 108.419 39.8127H108.04V37.556ZM111.488 41.7222L113.701 35.6465H116.223L118.436 41.7222H116.065L115.861 41.0277H114.063L113.859 41.7222H111.488ZM114.504 39.4655H115.412L115.147 38.5279C115.063 38.2293 115.001 37.9246 114.962 37.6167C114.923 37.9246 114.862 38.2293 114.777 38.5279L114.504 39.4655ZM119.442 39.6476V41.7222H121.77V39.6476L124.079 35.6465H121.434L120.606 37.7816L119.786 35.6465H117.141L119.442 39.6476Z",
            fill: "#FBE000"
          },
          void 0,
          !1,
          {
            fileName: "app/icons/bdt-icon-logo-oldstack.tsx",
            lineNumber: 26,
            columnNumber: 7
          },
          this
        ),
        /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)("path", { d: "M57.2308 19.3845H0V21.2307H57.2308V19.3845Z", fill: "white" }, void 0, !1, {
          fileName: "app/icons/bdt-icon-logo-oldstack.tsx",
          lineNumber: 32,
          columnNumber: 7
        }, this)
      ]
    },
    void 0,
    !0,
    {
      fileName: "app/icons/bdt-icon-logo-oldstack.tsx",
      lineNumber: 6,
      columnNumber: 5
    },
    this
  );
}

// app/utils/app-bar-menu-items.ts
var app_bar_menu_items_default = [
  {
    title: "Electronics",
    href: "/electronics"
  },
  {
    title: "Appliances",
    href: "/appliances"
  },
  {
    title: "Automotive",
    href: "/automotive"
  },
  {
    title: "Software",
    href: "/software"
  },
  {
    title: "Home & Kitchen",
    href: "/home-kitchen"
  }
];

// app/components/appbar.tsx
var import_jsx_dev_runtime4 = __toESM(require_jsx_dev_runtime()), Appbar = () => /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("header", { className: "contents", children: /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("nav", { className: "border-gray-200 bg-[#333333] sticky top-0 z-50", children: [
  /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("div", { className: "flex items-center justify-between mx-auto ", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(BdtIconAppLogoOldstack, {}, void 0, !1, {
      fileName: "app/components/appbar.tsx",
      lineNumber: 11,
      columnNumber: 11
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(
      import_react3.Form,
      {
        className: "flex justify-center mx-auto tablet:hidden min-w-[50%]",
        method: "post",
        action: "/products",
        reloadDocument: !0,
        children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(
            "input",
            {
              type: "text",
              "aria-label": "Search-input",
              name: "search-query",
              className: "w-full p-1 outline-none placeholder:text-sm pl-3 text-[#7b7b7b]",
              placeholder: "Search deals",
              defaultValue: "",
              required: !0
            },
            void 0,
            !1,
            {
              fileName: "app/components/appbar.tsx",
              lineNumber: 18,
              columnNumber: 13
            },
            this
          ),
          /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(
            "button",
            {
              className: "bg-red-500 uppercase text-white not-italic font-normal text-sm px-5",
              "aria-label": "Search-button",
              type: "submit",
              children: "Search"
            },
            void 0,
            !1,
            {
              fileName: "app/components/appbar.tsx",
              lineNumber: 27,
              columnNumber: 13
            },
            this
          )
        ]
      },
      void 0,
      !0,
      {
        fileName: "app/components/appbar.tsx",
        lineNumber: 12,
        columnNumber: 11
      },
      this
    ),
    /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(
      "button",
      {
        className: "hidden tablet:flex flex-col justify-between w-6 h-4 cursor-pointer bg-transparent mr-3",
        "aria-label": "open-mobile-menu",
        children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("span", { className: "block w-full h-0.5 bg-white" }, void 0, !1, {
            fileName: "app/components/appbar.tsx",
            lineNumber: 40,
            columnNumber: 13
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("span", { className: "block w-full h-0.5 bg-white" }, void 0, !1, {
            fileName: "app/components/appbar.tsx",
            lineNumber: 41,
            columnNumber: 13
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("span", { className: "block w-full h-0.5 bg-white" }, void 0, !1, {
            fileName: "app/components/appbar.tsx",
            lineNumber: 42,
            columnNumber: 13
          }, this)
        ]
      },
      void 0,
      !0,
      {
        fileName: "app/components/appbar.tsx",
        lineNumber: 36,
        columnNumber: 11
      },
      this
    )
  ] }, void 0, !0, {
    fileName: "app/components/appbar.tsx",
    lineNumber: 10,
    columnNumber: 9
  }, this),
  /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("div", { className: "flex flex-row w-full justify-between px-20 py-2 tablet:hidden sticky top-12 z-50 bg-white drop-shadow-md", children: [
    app_bar_menu_items_default.map(({ title, href }, i2) => /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(import_react4.Fragment, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(import_react3.Link, { to: `/products${href}`, className: "font-light text-sm", "aria-label": "categories", children: title }, void 0, !1, {
      fileName: "app/components/appbar.tsx",
      lineNumber: 48,
      columnNumber: 15
    }, this) }, `${title}-${i2}`, !1, {
      fileName: "app/components/appbar.tsx",
      lineNumber: 47,
      columnNumber: 13
    }, this)),
    /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("a", { href: "/categories", className: "font-light text-sm", "aria-label": "categories", children: "See All" }, void 0, !1, {
      fileName: "app/components/appbar.tsx",
      lineNumber: 53,
      columnNumber: 11
    }, this)
  ] }, void 0, !0, {
    fileName: "app/components/appbar.tsx",
    lineNumber: 45,
    columnNumber: 9
  }, this)
] }, void 0, !0, {
  fileName: "app/components/appbar.tsx",
  lineNumber: 9,
  columnNumber: 7
}, this) }, void 0, !1, {
  fileName: "app/components/appbar.tsx",
  lineNumber: 8,
  columnNumber: 5
}, this), appbar_default = Appbar;

// app/components/content.tsx
var import_react7 = __toESM(require_react()), import_react8 = __toESM(require_dist3());

// app/utils/products-filter.ts
var filtersMapType = {
  byBrand: (products, filterValues) => filterValues.length ? products.filter((p) => filterValues.includes(p.brandName || "")) : products,
  byFixedPrice: (products, filterValues) => filterValues.length ? products.filter((p) => !p.auction && filterValues.includes("fixed")) : products,
  byDiscounted: (products, filterValues) => filterValues.length ? products.filter((p) => p.discount && filterValues.includes("discounted")) : products,
  byStore: (products, filterValues) => filterValues.length ? products.filter((p) => filterValues.includes(p.shop)) : products,
  byCondition: (products, filterValues) => filterValues.length ? products.filter((p) => filterValues.includes(p.condition)) : products,
  byShipping: (products, filterValues) => filterValues.length ? products.filter((p) => filterValues.includes("shipping") && p.freeShipping) : products
}, getProductsByFilters = (products, filters) => {
  if (!products.length)
    return [];
  if (!filters)
    return products;
  let filtersKeys = Object.keys(filters), iter = (filteredProducts, filterBy) => {
    if (filterBy.length === 0)
      return filteredProducts;
    let [currentFilterKey, ...restFilterKeys] = filterBy, updatedList = filtersMapType[currentFilterKey](
      filteredProducts,
      filters[currentFilterKey]
    );
    return iter(updatedList, restFilterKeys);
  };
  return iter(products, filtersKeys);
}, getBrandFilterValues = (products) => [...new Set(products.map((p) => p.brandName).filter((p) => p))], getConditionFilterValues = (products) => [...new Set(products.map((p) => p.condition).filter((p) => p))], getStoreFilterValues = (products) => [...new Set(products.map((p) => p.shop).filter((p) => p))];

// app/utils/currency-formatter.ts
var currency_formatter_default = new Intl.NumberFormat("en", { style: "currency", currency: "USD" });

// app/icons/bdt-icon-free-shipping.tsx
var import_jsx_dev_runtime5 = __toESM(require_jsx_dev_runtime());
function BdtIconShipping({ fill, ...attrs }) {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime5.jsxDEV)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", ...attrs, children: /* @__PURE__ */ (0, import_jsx_dev_runtime5.jsxDEV)("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1", children: /* @__PURE__ */ (0, import_jsx_dev_runtime5.jsxDEV)(
    "path",
    {
      fill,
      fillRule: "nonzero",
      d: "M15.975 6a1 1 0 011 1l-.002.068-.064.925h1.324a2 2 0 011.991 2.19l-.467 4.905a1 1 0 01-.995.906l-1.174-.001c.05.157.076.325.076.5 0 .83-.592 1.5-1.323 1.5-.73 0-1.323-.67-1.323-1.5 0-.17.025-.336.072-.489H8.77c.047.153.072.318.072.49 0 .828-.592 1.5-1.323 1.5-.73 0-1.323-.672-1.323-1.5 0-.172.025-.337.072-.49H5a1 1 0 01-1-1l.003-.078.195-1.552a.5.5 0 01.996.035l-.003.09L5 15.005l2.367-.001a1.181 1.181 0 01.306 0h7.756l.027-.348L15.975 7H6.939a.5.5 0 01-.09-.992L6.94 6h9.036zm.91 2.993l-.428 5.675-.022.324 2.327.002.095-1.008h-.014a.5.5 0 01.09-.992l.019-.001.095-1h-1.114a.5.5 0 010-1h1.209l.087-.905.004-.094A1 1 0 0018.35 9l-.117-.006-1.348-.001zm-6.952 1a.5.5 0 110 1h-5a.5.5 0 110-1h5zm0-2a.5.5 0 010 1h-3a.5.5 0 110-1h3z"
    },
    void 0,
    !1,
    {
      fileName: "app/icons/bdt-icon-free-shipping.tsx",
      lineNumber: 8,
      columnNumber: 9
    },
    this
  ) }, void 0, !1, {
    fileName: "app/icons/bdt-icon-free-shipping.tsx",
    lineNumber: 7,
    columnNumber: 7
  }, this) }, void 0, !1, {
    fileName: "app/icons/bdt-icon-free-shipping.tsx",
    lineNumber: 6,
    columnNumber: 5
  }, this);
}

// app/components/desktop-filter.tsx
var import_react5 = __toESM(require_dist3()), import_react6 = __toESM(require_react());

// app/components/filter-row.tsx
var import_jsx_dev_runtime6 = __toESM(require_jsx_dev_runtime()), FilterRow = ({ title, filterBy, isChecked, value, onSubmit }) => /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)("fieldset", { className: "flex flex-row justify-between items-center", children: [
  /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)("label", { className: "text-sm font-normal capitalize text-[#7b7b7b] w-full", children: title }, void 0, !1, {
    fileName: "app/components/filter-row.tsx",
    lineNumber: 14,
    columnNumber: 7
  }, this),
  /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(
    "input",
    {
      name: filterBy,
      id: value,
      className: "text-white rounded-sm cursor-pointer ml-auto w-3 h-3 focus:ring-1 focus:ring-blue-300",
      value,
      type: "checkbox",
      checked: isChecked,
      onChange: onSubmit,
      "aria-label": `${title}-${value}`
    },
    void 0,
    !1,
    {
      fileName: "app/components/filter-row.tsx",
      lineNumber: 15,
      columnNumber: 7
    },
    this
  )
] }, void 0, !0, {
  fileName: "app/components/filter-row.tsx",
  lineNumber: 13,
  columnNumber: 5
}, this), filter_row_default = FilterRow;

// app/components/desktop-filter.tsx
var import_jsx_dev_runtime7 = __toESM(require_jsx_dev_runtime()), DesktopFilter = () => {
  var _a4, _b, _c;
  let { products } = (0, import_react5.useLoaderData)(), submit = (0, import_react5.useSubmit)(), toggle = (0, import_react5.useFetcher)(), data = (0, import_react5.useActionData)(), brandNames = getBrandFilterValues(products), storeNames = getStoreFilterValues(products), conditions = getConditionFilterValues(products), isFixedPriceChecked = data != null && data.filters ? (_a4 = data == null ? void 0 : data.filters) == null ? void 0 : _a4.byFixedPrice.includes("fixed") : !1, isDiscountChecked = data != null && data.filters ? (_b = data == null ? void 0 : data.filters) == null ? void 0 : _b.byDiscounted.includes("discounted") : !1, handleOnChange = (e2) => {
    e2.preventDefault(), submit(e2.target.form);
  };
  return /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
    "div",
    {
      className: "tablet:hidden sticky min-w-[245px] drop-shadow-lg h-[100] bg-white px-5 py-8",
      "aria-label": "filters",
      children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(toggle.Form, { method: "post", children: /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("div", { className: "flex flex-row justify-between ", children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("h1", { className: "text-[15px]", children: "Filter by" }, void 0, !1, {
            fileName: "app/components/desktop-filter.tsx",
            lineNumber: 37,
            columnNumber: 11
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
            "button",
            {
              className: "underline font-light text-[15px] text-[#7b7b7b]",
              onClick: handleOnChange,
              "aria-label": "clear-all",
              children: "Clear all"
            },
            void 0,
            !1,
            {
              fileName: "app/components/desktop-filter.tsx",
              lineNumber: 38,
              columnNumber: 11
            },
            this
          )
        ] }, void 0, !0, {
          fileName: "app/components/desktop-filter.tsx",
          lineNumber: 36,
          columnNumber: 9
        }, this) }, void 0, !1, {
          fileName: "app/components/desktop-filter.tsx",
          lineNumber: 35,
          columnNumber: 7
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(import_react5.Form, { method: "post", className: "flex flex-col gap-10 mt-10", children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("div", { className: "flex flex-col gap-5", children: [
            /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("h1", { className: "text-[#7b7b7b] text-[15px]", children: "Pricing" }, void 0, !1, {
              fileName: "app/components/desktop-filter.tsx",
              lineNumber: 50,
              columnNumber: 11
            }, this),
            /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
              filter_row_default,
              {
                title: "Fixed",
                value: "fixed",
                isChecked: isFixedPriceChecked,
                filterBy: "byFixedPrice",
                onSubmit: handleOnChange
              },
              void 0,
              !1,
              {
                fileName: "app/components/desktop-filter.tsx",
                lineNumber: 52,
                columnNumber: 11
              },
              this
            ),
            /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
              filter_row_default,
              {
                title: "Discounted Products",
                value: "discounted",
                isChecked: isDiscountChecked,
                filterBy: "byDiscounted",
                onSubmit: handleOnChange
              },
              void 0,
              !1,
              {
                fileName: "app/components/desktop-filter.tsx",
                lineNumber: 59,
                columnNumber: 11
              },
              this
            )
          ] }, void 0, !0, {
            fileName: "app/components/desktop-filter.tsx",
            lineNumber: 49,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("div", { className: "flex flex-col gap-5", children: [
            /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("h1", { className: "text-[#7b7b7b] text-[15px]", children: "Store" }, void 0, !1, {
              fileName: "app/components/desktop-filter.tsx",
              lineNumber: 68,
              columnNumber: 11
            }, this),
            storeNames.map((store, i2) => {
              var _a5;
              return /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(import_react6.default.Fragment, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
                filter_row_default,
                {
                  title: store,
                  value: store,
                  isChecked: data != null && data.filters ? (_a5 = data == null ? void 0 : data.filters) == null ? void 0 : _a5.byStore.includes(store) : !1,
                  filterBy: "byStore",
                  onSubmit: handleOnChange
                },
                void 0,
                !1,
                {
                  fileName: "app/components/desktop-filter.tsx",
                  lineNumber: 72,
                  columnNumber: 17
                },
                this
              ) }, `${store}-${i2}`, !1, {
                fileName: "app/components/desktop-filter.tsx",
                lineNumber: 71,
                columnNumber: 15
              }, this);
            })
          ] }, void 0, !0, {
            fileName: "app/components/desktop-filter.tsx",
            lineNumber: 67,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("div", { className: "flex flex-col gap-5", children: [
            /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("h1", { className: "text-[#7b7b7b] text-[15px]", children: "Condition" }, void 0, !1, {
              fileName: "app/components/desktop-filter.tsx",
              lineNumber: 84,
              columnNumber: 11
            }, this),
            conditions.map((condition, i2) => {
              var _a5;
              return /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(import_react6.default.Fragment, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
                filter_row_default,
                {
                  title: condition,
                  value: condition,
                  isChecked: data != null && data.filters ? (_a5 = data == null ? void 0 : data.filters) == null ? void 0 : _a5.byCondition.includes(condition) : !1,
                  filterBy: "byCondition",
                  onSubmit: handleOnChange
                },
                void 0,
                !1,
                {
                  fileName: "app/components/desktop-filter.tsx",
                  lineNumber: 88,
                  columnNumber: 17
                },
                this
              ) }, `${condition}-${i2}`, !1, {
                fileName: "app/components/desktop-filter.tsx",
                lineNumber: 87,
                columnNumber: 15
              }, this);
            })
          ] }, void 0, !0, {
            fileName: "app/components/desktop-filter.tsx",
            lineNumber: 83,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("div", { className: "flex flex-col gap-5", children: [
            /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("h1", { className: "text-[#7b7b7b] text-[15px]", children: "Brand" }, void 0, !1, {
              fileName: "app/components/desktop-filter.tsx",
              lineNumber: 100,
              columnNumber: 11
            }, this),
            brandNames.map((brand, i2) => {
              var _a5;
              return /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(import_react6.default.Fragment, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
                filter_row_default,
                {
                  title: brand,
                  value: brand,
                  isChecked: data != null && data.filters ? (_a5 = data == null ? void 0 : data.filters) == null ? void 0 : _a5.byBrand.includes(brand) : !1,
                  filterBy: "byBrand",
                  onSubmit: handleOnChange
                },
                void 0,
                !1,
                {
                  fileName: "app/components/desktop-filter.tsx",
                  lineNumber: 104,
                  columnNumber: 17
                },
                this
              ) }, `${brand}-${i2}`, !1, {
                fileName: "app/components/desktop-filter.tsx",
                lineNumber: 103,
                columnNumber: 15
              }, this);
            })
          ] }, void 0, !0, {
            fileName: "app/components/desktop-filter.tsx",
            lineNumber: 99,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("div", { className: "flex flex-col gap-5", children: [
            /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("h1", { className: "text-[#7b7b7b] text-[15px]", children: "Other" }, void 0, !1, {
              fileName: "app/components/desktop-filter.tsx",
              lineNumber: 116,
              columnNumber: 11
            }, this),
            /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
              filter_row_default,
              {
                title: "Free Shipping",
                value: "shipping",
                isChecked: data != null && data.filters ? (_c = data == null ? void 0 : data.filters) == null ? void 0 : _c.byShipping.includes("shipping") : !1,
                filterBy: "byShipping",
                onSubmit: handleOnChange
              },
              void 0,
              !1,
              {
                fileName: "app/components/desktop-filter.tsx",
                lineNumber: 117,
                columnNumber: 11
              },
              this
            )
          ] }, void 0, !0, {
            fileName: "app/components/desktop-filter.tsx",
            lineNumber: 115,
            columnNumber: 9
          }, this)
        ] }, void 0, !0, {
          fileName: "app/components/desktop-filter.tsx",
          lineNumber: 48,
          columnNumber: 7
        }, this)
      ]
    },
    void 0,
    !0,
    {
      fileName: "app/components/desktop-filter.tsx",
      lineNumber: 31,
      columnNumber: 5
    },
    this
  );
}, desktop_filter_default = DesktopFilter;

// app/components/content.tsx
var import_jsx_dev_runtime8 = __toESM(require_jsx_dev_runtime()), Content = () => {
  let { products, metadata } = (0, import_react8.useLoaderData)(), data = (0, import_react8.useActionData)(), filteredProducts = getProductsByFilters(products.slice(0, 35), data == null ? void 0 : data.filters);
  return /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("div", { className: "flex flex-row", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(desktop_filter_default, {}, void 0, !1, {
      fileName: "app/components/content.tsx",
      lineNumber: 16,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("div", { className: "w-full h-full px-6", children: /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("div", { className: "flex flex-col justify-center mt-4 mb-4", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("div", { className: "overflow-visible", children: /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("div", { className: "flex flex-col gap-4 mt-5", children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("div", { className: "flex flex-row text-[13px] leading-normal text-gray-400 ml-[-4px]", children: metadata.breadcrumbs.map((crump, i2) => /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(
          "a",
          {
            className: 'after:content-["/"] last:after:content-[""] capitalize',
            href: crump.path,
            children: [
              "\xA0\xA0",
              `${crump.title}`,
              "\xA0\xA0"
            ]
          },
          i2,
          !0,
          {
            fileName: "app/components/content.tsx",
            lineNumber: 23,
            columnNumber: 19
          },
          this
        )) }, void 0, !1, {
          fileName: "app/components/content.tsx",
          lineNumber: 21,
          columnNumber: 15
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("div", { className: "flex flex-row", children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("div", { className: "flex flex-row gap-5 sm:gap-3 sm:flex-col pr-9 mobile:pr-0", children: [
            /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("p", { className: "text-2xl capitalize", children: [
              "Best ",
              metadata.query,
              " deals in the united states"
            ] }, void 0, !0, {
              fileName: "app/components/content.tsx",
              lineNumber: 34,
              columnNumber: 19
            }, this),
            /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("span", { className: "flex leading-none text-base font-light text-[#686868] items-center", children: [
              filteredProducts.length,
              " deals found"
            ] }, void 0, !0, {
              fileName: "app/components/content.tsx",
              lineNumber: 37,
              columnNumber: 19
            }, this)
          ] }, void 0, !0, {
            fileName: "app/components/content.tsx",
            lineNumber: 33,
            columnNumber: 17
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("div", { className: "ml-auto" }, void 0, !1, {
            fileName: "app/components/content.tsx",
            lineNumber: 41,
            columnNumber: 17
          }, this)
        ] }, void 0, !0, {
          fileName: "app/components/content.tsx",
          lineNumber: 32,
          columnNumber: 15
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("div", { className: "border-b-[1px] sm:hidden" }, void 0, !1, {
          fileName: "app/components/content.tsx",
          lineNumber: 43,
          columnNumber: 15
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("span", { className: "text-[13px] font-light mobile:hidden", children: metadata == null ? void 0 : metadata.queryInfoTop }, void 0, !1, {
          fileName: "app/components/content.tsx",
          lineNumber: 44,
          columnNumber: 15
        }, this)
      ] }, void 0, !0, {
        fileName: "app/components/content.tsx",
        lineNumber: 20,
        columnNumber: 13
      }, this) }, void 0, !1, {
        fileName: "app/components/content.tsx",
        lineNumber: 19,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("div", { className: "grid mobile:grid-cols-2 tablet:grid-cols-3 desktop:grid-cols-3 xl-desktop:grid-cols-4 gap-5 mt-9", children: filteredProducts.map((p, i2) => /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(import_react7.Fragment, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(
        "a",
        {
          "aria-label": "product-card",
          href: p.redirectLinkTo,
          rel: "noreferrer",
          target: "_blank",
          className: " flex overflow-hidden relative flex-col justify-between rounded-sm cursor-pointer drop-shadow-md bg-white",
          children: [
            /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("div", { className: "pb-8", children: p.merchantLogo && /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(
              "img",
              {
                className: "h-5 absolute right-3 top-3 mobile:hidden",
                src: p.merchantLogo,
                alt: p.title
              },
              void 0,
              !1,
              {
                fileName: "app/components/content.tsx",
                lineNumber: 59,
                columnNumber: 23
              },
              this
            ) }, void 0, !1, {
              fileName: "app/components/content.tsx",
              lineNumber: 57,
              columnNumber: 19
            }, this),
            p.discount && /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("div", { className: "absolute top-16 left-[-12px] flex rotate-[-45deg] items-center justify-center w-32 h-8 origin-left whitespace-no-wrap bg-red-500 text-white", children: [
              Math.ceil(p.discount),
              "% OFF"
            ] }, void 0, !0, {
              fileName: "app/components/content.tsx",
              lineNumber: 67,
              columnNumber: 21
            }, this),
            /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("div", { className: "p-3 flex justify-center items-center h-32 w-32 mx-auto", children: /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(
              "img",
              {
                className: "mx-auto object-scale-down h-32 w-32",
                src: p.image,
                alt: p.title
              },
              void 0,
              !1,
              {
                fileName: "app/components/content.tsx",
                lineNumber: 72,
                columnNumber: 21
              },
              this
            ) }, void 0, !1, {
              fileName: "app/components/content.tsx",
              lineNumber: 71,
              columnNumber: 19
            }, this),
            /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("div", { className: "h-32 p-3", children: [
              /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("div", { className: "text-center block overflow-hidden whitespace-no-wrap w-full text-ellipsis ...", children: /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("span", { className: "line-clamp-1", children: p.title }, void 0, !1, {
                fileName: "app/components/content.tsx",
                lineNumber: 80,
                columnNumber: 23
              }, this) }, void 0, !1, {
                fileName: "app/components/content.tsx",
                lineNumber: 79,
                columnNumber: 21
              }, this),
              /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("div", { className: "text-center capitalize mb-2", children: /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("span", { children: p.condition }, void 0, !1, {
                fileName: "app/components/content.tsx",
                lineNumber: 83,
                columnNumber: 23
              }, this) }, void 0, !1, {
                fileName: "app/components/content.tsx",
                lineNumber: 82,
                columnNumber: 21
              }, this),
              /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("div", { className: "border-b-[1px] mx-[-30px]" }, void 0, !1, {
                fileName: "app/components/content.tsx",
                lineNumber: 85,
                columnNumber: 21
              }, this),
              /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("div", { className: "line-through text-center text-red-500 mt-6", children: p.oldPrice && /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("span", { children: currency_formatter_default.format(p.oldPrice) }, void 0, !1, {
                fileName: "app/components/content.tsx",
                lineNumber: 88,
                columnNumber: 38
              }, this) }, void 0, !1, {
                fileName: "app/components/content.tsx",
                lineNumber: 87,
                columnNumber: 21
              }, this)
            ] }, void 0, !0, {
              fileName: "app/components/content.tsx",
              lineNumber: 78,
              columnNumber: 19
            }, this),
            /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("div", { className: "flex flex-row justify-center tablet:hidden", children: [
              /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(BdtIconShipping, { fill: "#595959" }, void 0, !1, {
                fileName: "app/components/content.tsx",
                lineNumber: 92,
                columnNumber: 21
              }, this),
              /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("span", { className: "text-[#595959] text-[15px] font-normal uppercase", children: "Free shipping" }, void 0, !1, {
                fileName: "app/components/content.tsx",
                lineNumber: 93,
                columnNumber: 21
              }, this)
            ] }, void 0, !0, {
              fileName: "app/components/content.tsx",
              lineNumber: 91,
              columnNumber: 19
            }, this),
            /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("div", { className: "mobile:flex flex-row justify-center hidden", children: p.merchantLogo && /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("img", { className: "h-5", src: p.merchantLogo, alt: p.title }, void 0, !1, {
              fileName: "app/components/content.tsx",
              lineNumber: 98,
              columnNumber: 40
            }, this) }, void 0, !1, {
              fileName: "app/components/content.tsx",
              lineNumber: 97,
              columnNumber: 19
            }, this),
            /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("div", { children: /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("div", { className: "p-3", children: /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(
              "button",
              {
                className: " p-0 bg-[#61c200] hover:bg-[#52a102] uppercase text-white font-normal sm:text-sm py-2 px-4 w-full",
                "aria-label": "product-cta",
                children: "View Deal"
              },
              void 0,
              !1,
              {
                fileName: "app/components/content.tsx",
                lineNumber: 102,
                columnNumber: 23
              },
              this
            ) }, void 0, !1, {
              fileName: "app/components/content.tsx",
              lineNumber: 101,
              columnNumber: 21
            }, this) }, void 0, !1, {
              fileName: "app/components/content.tsx",
              lineNumber: 100,
              columnNumber: 19
            }, this)
          ]
        },
        void 0,
        !0,
        {
          fileName: "app/components/content.tsx",
          lineNumber: 50,
          columnNumber: 17
        },
        this
      ) }, `${p.title}-${i2}`, !1, {
        fileName: "app/components/content.tsx",
        lineNumber: 49,
        columnNumber: 15
      }, this)) }, void 0, !1, {
        fileName: "app/components/content.tsx",
        lineNumber: 47,
        columnNumber: 11
      }, this)
    ] }, void 0, !0, {
      fileName: "app/components/content.tsx",
      lineNumber: 18,
      columnNumber: 9
    }, this) }, void 0, !1, {
      fileName: "app/components/content.tsx",
      lineNumber: 17,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/components/content.tsx",
    lineNumber: 15,
    columnNumber: 5
  }, this);
}, content_default = Content;

// app/components/footer.tsx
var import_react9 = __toESM(require_react());

// app/icons/bdt-icon-logo-footer.tsx
var import_jsx_dev_runtime9 = __toESM(require_jsx_dev_runtime());
function BdtIconAppLogoFooter(attrs) {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)("svg", { xmlns: "http://www.w3.org/2000/svg", width: "40", height: "24", viewBox: "0 0 40 24", ...attrs, children: /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1", children: /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)("g", { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)("g", { fill: "#FFF", children: /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)("path", { d: "M19.292 0c1.14 0 2.39.258 3.29.703v2.623c-.876-.492-1.982-.82-2.882-.808-.373 0-.505.083-.505.234 0 .691 3.856.27 3.856 3.069 0 2.202-1.646 2.776-3.664 2.776-1.309 0-2.462-.27-3.41-.784V5.037c1.08.667 2.21.995 3.05.995.637 0 .733-.117.733-.281 0-.586-3.867-.293-3.867-3.104 0-1.78 1.513-2.647 3.4-2.647zM4.528.199c1.933 0 3.003.633 3.003 2.073 0 .797-.252 1.394-1.165 1.757 1.057.317 1.502 1.019 1.502 1.991 0 1.862-1.538 2.377-3.436 2.377H0V.2h4.528zm10.62 0v2.343h-3.412v.703h2.93v2.084h-2.93v.703h3.483v2.366H8.54V.199h6.607zm15.651 0v2.694h-2.162v5.505h-3.195V2.893H23.28V.199h7.52zM4.12 5.119h-.924v1.053h.925a.544.544 0 00.48-.259c.1-.164.1-.37 0-.535a.544.544 0 00-.48-.26zM3.989 2.4h-.793v.984h.792c.186.01.363-.081.46-.238a.482.482 0 000-.508.508.508 0 00-.46-.237V2.4zM36.24 9.966c1.141 0 2.39.258 3.291.703v2.624c-.876-.492-1.981-.82-2.882-.808-.373 0-.505.082-.505.234 0 .69 3.856.269 3.856 3.068 0 2.202-1.646 2.776-3.664 2.776-1.309 0-2.462-.269-3.411-.784v-2.776c1.081.668 2.21.995 3.05.995.638 0 .734-.117.734-.28 0-.586-3.868-.294-3.868-3.104 0-1.717 1.408-2.585 3.2-2.644l.199-.004zm-32.408.2c3.026 0 4.348 1.686 4.348 4.099 0 2.413-1.321 4.1-4.348 4.1H0v-8.2h3.832zm11.7-.001v2.343H12.12v.703h2.931v2.085h-2.93v.702h3.482v2.366H8.925v-8.199h6.606zm6.786 0l3.014 8.2h-3.231l-.277-.938h-2.449l-.276.937h-3.232l3.015-8.199h3.436zm6.643 0v5.505h3.411v2.694h-6.606v-8.2h3.195zm-25.25 2.577h-.516v3.046h.516c.697 0 1.177-.34 1.177-1.523 0-1.183-.48-1.523-1.176-1.523zm16.89.082a8.28 8.28 0 01-.253 1.23l-.373 1.265h1.237l-.36-1.265a8.28 8.28 0 01-.252-1.23z" }, void 0, !1, {
      fileName: "app/icons/bdt-icon-logo-footer.tsx",
      lineNumber: 10,
      columnNumber: 13
    }, this) }, void 0, !1, {
      fileName: "app/icons/bdt-icon-logo-footer.tsx",
      lineNumber: 9,
      columnNumber: 11
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(
      "path",
      {
        fill: "#FFC31E",
        d: "M16.789 22.464c.437 0 .818.248.818.768s-.38.768-.818.768c-.432 0-.814-.248-.814-.768s.381-.768.814-.768zm7.118-3.01c1.613 0 2.432.998 2.432 2.273 0 1.276-.818 2.273-2.432 2.273-1.613 0-2.426-.997-2.426-2.273 0-1.275.813-2.272 2.426-2.272zm-2.496.106v1.425h-1.143v2.91H18.58v-2.91h-1.142V19.56h3.974zm7.335 0c1.6 0 2.299.892 2.299 2.167 0 1.276-.699 2.168-2.299 2.168h-2.025V19.56h2.025zm5.557 0l1.594 4.335h-1.708l-.146-.496h-1.296l-.146.496h-1.708l1.594-4.335h1.816zm2.566 0l.59 1.523.597-1.523h1.906l-1.664 2.855v1.48H36.62v-1.48l-1.657-2.855h1.905zm-8.186 1.361v.001h-.273v1.61h.273c.368 0 .622-.178.622-.805s-.254-.806-.622-.806zm-4.776.02c-.413 0-.685.266-.685.786s.273.787.685.787c.42 0 .692-.267.692-.787s-.273-.786-.692-.786zm9.488.025c-.028.22-.072.437-.133.65l-.197.669h.654l-.19-.67a4.375 4.375 0 01-.134-.65z"
      },
      void 0,
      !1,
      {
        fileName: "app/icons/bdt-icon-logo-footer.tsx",
        lineNumber: 12,
        columnNumber: 11
      },
      this
    )
  ] }, void 0, !0, {
    fileName: "app/icons/bdt-icon-logo-footer.tsx",
    lineNumber: 8,
    columnNumber: 9
  }, this) }, void 0, !1, {
    fileName: "app/icons/bdt-icon-logo-footer.tsx",
    lineNumber: 7,
    columnNumber: 7
  }, this) }, void 0, !1, {
    fileName: "app/icons/bdt-icon-logo-footer.tsx",
    lineNumber: 6,
    columnNumber: 5
  }, this);
}

// app/utils/footer-navigation.ts
var footer_navigation_default = [
  {
    title: "General",
    menuItems: [
      {
        title: "Home",
        href: "/"
      },
      {
        title: "Privacy",
        href: "/privacy"
      },
      {
        title: "Terms & Conditions",
        href: "/terms"
      },
      { title: "Contact Us", href: "/contact-us" }
    ]
  },
  {
    title: "Popular searches",
    menuItems: [
      {
        title: "Oculus Quest 2",
        href: "/oculus-quest-2"
      },
      {
        title: "Airpod Pro",
        href: "/airpod-pro"
      },
      {
        title: "Ember Wave",
        href: "/ember-wave"
      },
      {
        title: "Dyson Airwrap Complete",
        href: "/dyson-airwrap-complete"
      },
      {
        title: "Uniden R7",
        href: "/uniden-r-7"
      },
      {
        title: "Nintendo Switch",
        href: "/nintendo-switch"
      },
      {
        title: "Laptop",
        href: "/laptop"
      }
    ]
  },
  {
    title: "Categories",
    menuItems: [
      {
        title: "Electronics",
        href: "/electronics"
      },
      {
        title: "Appliances",
        href: "/appliances"
      },
      {
        title: "Automotive",
        href: "/automotive"
      },
      {
        title: "Software",
        href: "/software"
      },
      {
        title: "Home & Kitchen",
        href: "/home-kitchen"
      }
    ]
  },
  {
    title: "International sites",
    menuItems: [
      {
        title: "France",
        href: "//fr.bestdeals.today"
      },
      {
        title: "Australia",
        href: "//au.bestdeals.today"
      },
      {
        title: "Spain",
        href: "//es.bestdeals.today"
      },
      {
        title: "Japan",
        href: "//jp.bestdeals.today"
      },
      {
        title: "Italy",
        href: "//it.bestdeals.today"
      },
      {
        title: "Germany",
        href: "//de.bestdeals.today"
      },
      {
        title: "Canada",
        href: "//ca.bestdeals.today"
      },
      {
        title: "Singapore",
        href: "//sg.bestdeals.today"
      },
      {
        title: "United Kingdom",
        href: "//uk.bestdeals.today"
      },
      {
        title: "Mexico",
        href: "//mx.bestdeals.today"
      },
      {
        title: "India",
        href: "//in.bestdeals.today"
      }
    ]
  }
];

// app/components/footer.tsx
var import_jsx_dev_runtime10 = __toESM(require_jsx_dev_runtime()), Footer = () => /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)("footer", { className: "px-[24px] bg-[#333333]", children: /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)("div", { className: "max-w-[1400px] py-[40px] mx-auto text-white", children: [
  /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)("div", { className: "tablet:text-center tablet:items-center tablet:flex-col tablet:justify-center flex items-start justify-between text-left", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)("a", { href: "/", className: "mt-5 tablet:mb-10", children: /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(BdtIconAppLogoFooter, { width: 104, height: 62 }, void 0, !1, {
      fileName: "app/components/footer.tsx",
      lineNumber: 11,
      columnNumber: 13
    }, this) }, void 0, !1, {
      fileName: "app/components/footer.tsx",
      lineNumber: 10,
      columnNumber: 11
    }, this),
    footer_navigation_default.map((item, i2) => /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)("div", { className: "p-5", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)("h4", { className: "mb-4 text-white font-bold uppercase", children: item.title }, void 0, !1, {
        fileName: "app/components/footer.tsx",
        lineNumber: 15,
        columnNumber: 15
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)("ul", { children: [
        item.menuItems.map((menuItem, index) => /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(import_react9.default.Fragment, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)("a", { href: menuItem.href, className: "block text-white font-light my-2 text-sm", children: menuItem.title }, void 0, !1, {
          fileName: "app/components/footer.tsx",
          lineNumber: 19,
          columnNumber: 21
        }, this) }, `${menuItem}-${index}`, !1, {
          fileName: "app/components/footer.tsx",
          lineNumber: 18,
          columnNumber: 19
        }, this)),
        item.title === "Categories" && /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(import_react9.default.Fragment, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)("a", { href: "/categories", children: "See All" }, void 0, !1, {
          fileName: "app/components/footer.tsx",
          lineNumber: 26,
          columnNumber: 21
        }, this) }, item.menuItems.length, !1, {
          fileName: "app/components/footer.tsx",
          lineNumber: 25,
          columnNumber: 19
        }, this)
      ] }, void 0, !0, {
        fileName: "app/components/footer.tsx",
        lineNumber: 16,
        columnNumber: 15
      }, this)
    ] }, `${item}-${i2}`, !0, {
      fileName: "app/components/footer.tsx",
      lineNumber: 14,
      columnNumber: 13
    }, this))
  ] }, void 0, !0, {
    fileName: "app/components/footer.tsx",
    lineNumber: 9,
    columnNumber: 9
  }, this),
  /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)("div", { className: "mt-6 pt-6 border-t-[0.01em] border-solid border-gray-400 tablet:items-center text-center text-[12px]", children: /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)("div", { className: "flex tablet:flex-col-reverse flex-row justify-between", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)("div", { className: "", children: "Amazon, Amazon Prime, the Amazon logo and Amazon Prime logo are trademarks of Amazon.com, Inc. or its affiliates" }, void 0, !1, {
      fileName: "app/components/footer.tsx",
      lineNumber: 35,
      columnNumber: 13
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)("div", { className: "justify-between mb-2", children: [
      "Bestdeals.today\xA0\xA9 ",
      (/* @__PURE__ */ new Date()).getFullYear(),
      " All Rights Reserved"
    ] }, void 0, !0, {
      fileName: "app/components/footer.tsx",
      lineNumber: 39,
      columnNumber: 13
    }, this)
  ] }, void 0, !0, {
    fileName: "app/components/footer.tsx",
    lineNumber: 34,
    columnNumber: 11
  }, this) }, void 0, !1, {
    fileName: "app/components/footer.tsx",
    lineNumber: 33,
    columnNumber: 9
  }, this)
] }, void 0, !0, {
  fileName: "app/components/footer.tsx",
  lineNumber: 8,
  columnNumber: 7
}, this) }, void 0, !1, {
  fileName: "app/components/footer.tsx",
  lineNumber: 7,
  columnNumber: 5
}, this), footer_default = Footer;

// node_modules/camelcase-keys/index.js
var import_map_obj = __toESM(require_map_obj(), 1);

// node_modules/camelcase/index.js
var UPPERCASE = /[\p{Lu}]/u, LOWERCASE = /[\p{Ll}]/u, LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu, IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u, SEPARATORS = /[_.\- ]+/, LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source), SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu"), NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu"), preserveCamelCase = (string, toLowerCase, toUpperCase, preserveConsecutiveUppercase2) => {
  let isLastCharLower = !1, isLastCharUpper = !1, isLastLastCharUpper = !1, isLastLastCharPreserved = !1;
  for (let index = 0; index < string.length; index++) {
    let character = string[index];
    isLastLastCharPreserved = index > 2 ? string[index - 3] === "-" : !0, isLastCharLower && UPPERCASE.test(character) ? (string = string.slice(0, index) + "-" + string.slice(index), isLastCharLower = !1, isLastLastCharUpper = isLastCharUpper, isLastCharUpper = !0, index++) : isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character) && (!isLastLastCharPreserved || preserveConsecutiveUppercase2) ? (string = string.slice(0, index - 1) + "-" + string.slice(index - 1), isLastLastCharUpper = isLastCharUpper, isLastCharUpper = !1, isLastCharLower = !0) : (isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character, isLastLastCharUpper = isLastCharUpper, isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character);
  }
  return string;
}, preserveConsecutiveUppercase = (input, toLowerCase) => (LEADING_CAPITAL.lastIndex = 0, input.replace(LEADING_CAPITAL, (m1) => toLowerCase(m1))), postProcess = (input, toUpperCase) => (SEPARATORS_AND_IDENTIFIER.lastIndex = 0, NUMBERS_AND_IDENTIFIER.lastIndex = 0, input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier)).replace(NUMBERS_AND_IDENTIFIER, (m2) => toUpperCase(m2)));
function camelCase(input, options) {
  if (!(typeof input == "string" || Array.isArray(input)))
    throw new TypeError("Expected the input to be `string | string[]`");
  if (options = {
    pascalCase: !1,
    preserveConsecutiveUppercase: !1,
    ...options
  }, Array.isArray(input) ? input = input.map((x2) => x2.trim()).filter((x2) => x2.length).join("-") : input = input.trim(), input.length === 0)
    return "";
  let toLowerCase = options.locale === !1 ? (string) => string.toLowerCase() : (string) => string.toLocaleLowerCase(options.locale), toUpperCase = options.locale === !1 ? (string) => string.toUpperCase() : (string) => string.toLocaleUpperCase(options.locale);
  return input.length === 1 ? SEPARATORS.test(input) ? "" : options.pascalCase ? toUpperCase(input) : toLowerCase(input) : (input !== toLowerCase(input) && (input = preserveCamelCase(input, toLowerCase, toUpperCase, options.preserveConsecutiveUppercase)), input = input.replace(LEADING_SEPARATORS, ""), input = options.preserveConsecutiveUppercase ? preserveConsecutiveUppercase(input, toLowerCase) : toLowerCase(input), options.pascalCase && (input = toUpperCase(input.charAt(0)) + input.slice(1)), postProcess(input, toUpperCase));
}

// node_modules/quick-lru/index.js
var QuickLRU = class extends Map {
  constructor(options = {}) {
    if (super(), !(options.maxSize && options.maxSize > 0))
      throw new TypeError("`maxSize` must be a number greater than 0");
    if (typeof options.maxAge == "number" && options.maxAge === 0)
      throw new TypeError("`maxAge` must be a number greater than 0");
    this.maxSize = options.maxSize, this.maxAge = options.maxAge || Number.POSITIVE_INFINITY, this.onEviction = options.onEviction, this.cache = /* @__PURE__ */ new Map(), this.oldCache = /* @__PURE__ */ new Map(), this._size = 0;
  }
  // TODO: Use private class methods when targeting Node.js 16.
  _emitEvictions(cache2) {
    if (typeof this.onEviction == "function")
      for (let [key, item] of cache2)
        this.onEviction(key, item.value);
  }
  _deleteIfExpired(key, item) {
    return typeof item.expiry == "number" && item.expiry <= Date.now() ? (typeof this.onEviction == "function" && this.onEviction(key, item.value), this.delete(key)) : !1;
  }
  _getOrDeleteIfExpired(key, item) {
    if (this._deleteIfExpired(key, item) === !1)
      return item.value;
  }
  _getItemValue(key, item) {
    return item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;
  }
  _peek(key, cache2) {
    let item = cache2.get(key);
    return this._getItemValue(key, item);
  }
  _set(key, value) {
    this.cache.set(key, value), this._size++, this._size >= this.maxSize && (this._size = 0, this._emitEvictions(this.oldCache), this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map());
  }
  _moveToRecent(key, item) {
    this.oldCache.delete(key), this._set(key, item);
  }
  *_entriesAscending() {
    for (let item of this.oldCache) {
      let [key, value] = item;
      this.cache.has(key) || this._deleteIfExpired(key, value) === !1 && (yield item);
    }
    for (let item of this.cache) {
      let [key, value] = item;
      this._deleteIfExpired(key, value) === !1 && (yield item);
    }
  }
  get(key) {
    if (this.cache.has(key)) {
      let item = this.cache.get(key);
      return this._getItemValue(key, item);
    }
    if (this.oldCache.has(key)) {
      let item = this.oldCache.get(key);
      if (this._deleteIfExpired(key, item) === !1)
        return this._moveToRecent(key, item), item.value;
    }
  }
  set(key, value, { maxAge = this.maxAge } = {}) {
    let expiry = typeof maxAge == "number" && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : void 0;
    this.cache.has(key) ? this.cache.set(key, {
      value,
      expiry
    }) : this._set(key, { value, expiry });
  }
  has(key) {
    return this.cache.has(key) ? !this._deleteIfExpired(key, this.cache.get(key)) : this.oldCache.has(key) ? !this._deleteIfExpired(key, this.oldCache.get(key)) : !1;
  }
  peek(key) {
    if (this.cache.has(key))
      return this._peek(key, this.cache);
    if (this.oldCache.has(key))
      return this._peek(key, this.oldCache);
  }
  delete(key) {
    let deleted = this.cache.delete(key);
    return deleted && this._size--, this.oldCache.delete(key) || deleted;
  }
  clear() {
    this.cache.clear(), this.oldCache.clear(), this._size = 0;
  }
  resize(newSize) {
    if (!(newSize && newSize > 0))
      throw new TypeError("`maxSize` must be a number greater than 0");
    let items = [...this._entriesAscending()], removeCount = items.length - newSize;
    removeCount < 0 ? (this.cache = new Map(items), this.oldCache = /* @__PURE__ */ new Map(), this._size = items.length) : (removeCount > 0 && this._emitEvictions(items.slice(0, removeCount)), this.oldCache = new Map(items.slice(removeCount)), this.cache = /* @__PURE__ */ new Map(), this._size = 0), this.maxSize = newSize;
  }
  *keys() {
    for (let [key] of this)
      yield key;
  }
  *values() {
    for (let [, value] of this)
      yield value;
  }
  *[Symbol.iterator]() {
    for (let item of this.cache) {
      let [key, value] = item;
      this._deleteIfExpired(key, value) === !1 && (yield [key, value.value]);
    }
    for (let item of this.oldCache) {
      let [key, value] = item;
      this.cache.has(key) || this._deleteIfExpired(key, value) === !1 && (yield [key, value.value]);
    }
  }
  *entriesDescending() {
    let items = [...this.cache];
    for (let i2 = items.length - 1; i2 >= 0; --i2) {
      let item = items[i2], [key, value] = item;
      this._deleteIfExpired(key, value) === !1 && (yield [key, value.value]);
    }
    items = [...this.oldCache];
    for (let i2 = items.length - 1; i2 >= 0; --i2) {
      let item = items[i2], [key, value] = item;
      this.cache.has(key) || this._deleteIfExpired(key, value) === !1 && (yield [key, value.value]);
    }
  }
  *entriesAscending() {
    for (let [key, value] of this._entriesAscending())
      yield [key, value.value];
  }
  get size() {
    if (!this._size)
      return this.oldCache.size;
    let oldCacheSize = 0;
    for (let key of this.oldCache.keys())
      this.cache.has(key) || oldCacheSize++;
    return Math.min(this._size + oldCacheSize, this.maxSize);
  }
  entries() {
    return this.entriesAscending();
  }
  forEach(callbackFunction, thisArgument = this) {
    for (let [key, value] of this.entriesAscending())
      callbackFunction.call(thisArgument, value, key, this);
  }
  get [Symbol.toStringTag]() {
    return JSON.stringify([...this.entriesAscending()]);
  }
};

// node_modules/camelcase-keys/index.js
var has = (array, key) => array.some((element) => typeof element == "string" ? element === key : (element.lastIndex = 0, element.test(key))), cache = new QuickLRU({ maxSize: 1e5 }), isObject = (value) => typeof value == "object" && value !== null && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date), camelCaseConvert = (input, options) => {
  if (!isObject(input))
    return input;
  options = {
    deep: !1,
    pascalCase: !1,
    ...options
  };
  let { exclude, pascalCase, stopPaths, deep } = options, stopPathsSet = new Set(stopPaths), makeMapper = (parentPath) => (key, value) => {
    if (deep && isObject(value)) {
      let path = parentPath === void 0 ? key : `${parentPath}.${key}`;
      stopPathsSet.has(path) || (value = (0, import_map_obj.default)(value, makeMapper(path)));
    }
    if (!(exclude && has(exclude, key))) {
      let cacheKey = pascalCase ? `${key}_` : key;
      if (cache.has(cacheKey))
        key = cache.get(cacheKey);
      else {
        let returnValue = camelCase(key, { pascalCase, locale: !1 });
        key.length < 100 && cache.set(cacheKey, returnValue), key = returnValue;
      }
    }
    return [key, value];
  };
  return (0, import_map_obj.default)(input, makeMapper(void 0));
};
function camelcaseKeys(input, options) {
  return Array.isArray(input) ? Object.keys(input).map((key) => camelCaseConvert(input[key], options)) : camelCaseConvert(input, options);
}

// node_modules/@roundforest/http-commons/src/http-commons.js
var import_lodash = __toESM(require_lodash(), 1);

// node_modules/@roundforest/functional-commons/src/functional-commons.js
function memo(syncCreationFunction) {
  let cacheMap = /* @__PURE__ */ new Map();
  return (...args) => {
    let key = JSON.stringify(args), cachedValue = cacheMap.get(key);
    if (cachedValue)
      return cachedValue;
    let newValue = syncCreationFunction(...args);
    if (typeof /** @type {any} */
    newValue.then == "function")
      throw new Error("your function returned a promise. Maybe you want to use cacheFunctionAsync?");
    return cacheMap.set(key, newValue), newValue;
  };
}
function makeError(error, properties) {
  return typeof error == "string" && (error = new Error(error)), properties ? Object.assign(error, properties) : error;
}

// node_modules/@roundforest/promise-commons/src/promise-commons.js
function delay(ms) {
  return new Promise((res) => setTimeout(res, ms));
}
var resolveSymbol = Symbol("resolve-promise"), rejectSymbol = Symbol("reject-promise");

// node_modules/@roundforest/http-commons/src/http-commons.js
function makeClient(fetcher2, requestIdGetterSymbol2) {
  async function throwErrorFromBadStatus2(response) {
    var _a4, _b;
    let body = await response.text().catch(() => "failed to get body of error");
    throw makeError(`Response ${response.status} returned from ${response.url}, body: ${body}`, {
      code: "ERR_X_STATUS_CODE_NOT_OK",
      status: response.status,
      statusText: response.statusText,
      // @ts-expect-error
      headers: ((_b = (_a4 = response == null ? void 0 : response.headers) == null ? void 0 : _a4.raw) == null ? void 0 : _b.call(_a4)) ?? response.headers,
      body
    });
  }
  async function fetchAsJson2(url, init, jsonReviver) {
    let response = await fetcher2(url, (0, import_lodash.default)({ headers: { Accept: "application/json" } }, init));
    return response.ok || await throwErrorFromBadStatus2(response), jsonReviver ? await JSON.parse(await response.text(), jsonReviver) : await response.json();
  }
  async function fetchAsText2(url, init) {
    let response = await fetcher2(url, init);
    return response.ok || await throwErrorFromBadStatus2(response), await response.text();
  }
  async function fetchAsTextWithJsonBody2(url, json2, init) {
    let response = await fetcher2(
      url,
      // @ts-expect-error
      (0, import_lodash.default)(
        { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(json2) },
        init || {}
      )
    );
    return response.ok || await throwErrorFromBadStatus2(response), await response.text();
  }
  async function fetchAsBuffer2(url, init) {
    let response = await /** @type {nodeFetch}*/
    fetcher2(url, init);
    return response.ok || await throwErrorFromBadStatus2(response), await response.buffer();
  }
  async function fetchAsBufferWithJsonBody2(url, json2, init) {
    let response = await /** @type {nodeFetch}*/
    fetcher2(
      url,
      (0, import_lodash.default)(
        { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(json2) },
        init || {}
      )
    );
    return response.ok || await throwErrorFromBadStatus2(response), await response.buffer();
  }
  async function fetchAsJsonWithJsonBody2(url, json2, init, jsonReviver) {
    let response = await fetcher2(
      url,
      // @ts-expect-error
      (0, import_lodash.default)(
        {
          method: "POST",
          headers: { "Content-Type": "application/json", Accept: "application/json" },
          body: JSON.stringify(json2)
        },
        init || {}
      )
    );
    return response.ok || await throwErrorFromBadStatus2(response), jsonReviver ? JSON.parse(await response.text(), jsonReviver) : await response.json();
  }
  async function retryFetch2(f3, { retries = 2, sleepTime = 100, backoff = 1.1, idempotent = !0 } = {}) {
    for (let retry = 0; retry <= retries; retry++) {
      if (retry === retries)
        return await f3(retry);
      try {
        return await f3(retry);
      } catch (err) {
        if (!(CONNECTION_ERROR_CODES.has(err.code) || CONNECTION_ERROR_CODES.has(err.type))) {
          if (err.code === "ERR_X_STATUS_CODE_NOT_OK") {
            if (err.status >= 300 && err.status < 500)
              throw err;
          } else if (!idempotent)
            throw err;
        }
        await delay(sleepTime * backoff ** retry);
      }
    }
  }
  function setGlobalRequestIdGetter2(requestIdGetter) {
    if (globalThis[requestIdGetterSymbol2] != null)
      throw new Error("you are not allowed to change global request id getter");
    globalThis[requestIdGetterSymbol2] = requestIdGetter;
  }
  let CONNECTION_ERROR_CODES = /* @__PURE__ */ new Set([
    "ENOTFOUND",
    "ECONNREFUSED",
    "ETIMEDOUT",
    "EHOSTUNREACH",
    "ECONNRESET",
    "request-timeout"
  ]);
  return {
    throwErrorFromBadStatus: throwErrorFromBadStatus2,
    fetchAsJson: fetchAsJson2,
    fetchAsText: fetchAsText2,
    fetchAsTextWithJsonBody: fetchAsTextWithJsonBody2,
    fetchAsBuffer: fetchAsBuffer2,
    fetchAsBufferWithJsonBody: fetchAsBufferWithJsonBody2,
    fetchAsJsonWithJsonBody: fetchAsJsonWithJsonBody2,
    setGlobalRequestIdGetter: setGlobalRequestIdGetter2,
    retryFetch: retryFetch2,
    fetch: fetcher2
  };
}

// node_modules/node-fetch/src/index.js
var import_node_http2 = __toESM(require("node:http"), 1), import_node_https = __toESM(require("node:https"), 1), import_node_zlib = __toESM(require("node:zlib"), 1), import_node_stream3 = __toESM(require("node:stream"), 1), import_node_buffer2 = require("node:buffer");

// node_modules/node-fetch/node_modules/data-uri-to-buffer/dist/index.js
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri))
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  uri = uri.replace(/\r?\n/g, "");
  let firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4)
    throw new TypeError("malformed data: URI");
  let meta = uri.substring(5, firstComma).split(";"), charset = "", base64 = !1, type = meta[0] || "text/plain", typeFull = type;
  for (let i2 = 1; i2 < meta.length; i2++)
    meta[i2] === "base64" ? base64 = !0 : meta[i2] && (typeFull += `;${meta[i2]}`, meta[i2].indexOf("charset=") === 0 && (charset = meta[i2].substring(8)));
  !meta[0] && !charset.length && (typeFull += ";charset=US-ASCII", charset = "US-ASCII");
  let encoding = base64 ? "base64" : "ascii", data = unescape(uri.substring(firstComma + 1)), buffer = Buffer.from(data, encoding);
  return buffer.type = type, buffer.typeFull = typeFull, buffer.charset = charset, buffer;
}
var dist_default = dataUriToBuffer;

// node_modules/node-fetch/src/body.js
var import_node_stream2 = __toESM(require("node:stream"), 1), import_node_util = require("node:util"), import_node_buffer = require("node:buffer");
init_fetch_blob();
init_esm_min();

// node_modules/node-fetch/src/errors/base.js
var FetchBaseError = class extends Error {
  constructor(message, type) {
    super(message), Error.captureStackTrace(this, this.constructor), this.type = type;
  }
  get name() {
    return this.constructor.name;
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
};

// node_modules/node-fetch/src/errors/fetch-error.js
var FetchError = class extends FetchBaseError {
  /**
   * @param  {string} message -      Error message for human
   * @param  {string} [type] -        Error type for machine
   * @param  {SystemError} [systemError] - For Node.js system error
   */
  constructor(message, type, systemError) {
    super(message, type), systemError && (this.code = this.errno = systemError.code, this.erroredSysCall = systemError.syscall);
  }
};

// node_modules/node-fetch/src/utils/is.js
var NAME = Symbol.toStringTag, isURLSearchParameters = (object) => typeof object == "object" && typeof object.append == "function" && typeof object.delete == "function" && typeof object.get == "function" && typeof object.getAll == "function" && typeof object.has == "function" && typeof object.set == "function" && typeof object.sort == "function" && object[NAME] === "URLSearchParams", isBlob = (object) => object && typeof object == "object" && typeof object.arrayBuffer == "function" && typeof object.type == "string" && typeof object.stream == "function" && typeof object.constructor == "function" && /^(Blob|File)$/.test(object[NAME]), isAbortSignal = (object) => typeof object == "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget"), isDomainOrSubdomain = (destination, original) => {
  let orig = new URL(original).hostname, dest = new URL(destination).hostname;
  return orig === dest || orig.endsWith(`.${dest}`);
}, isSameProtocol = (destination, original) => {
  let orig = new URL(original).protocol, dest = new URL(destination).protocol;
  return orig === dest;
};

// node_modules/node-fetch/src/body.js
var pipeline = (0, import_node_util.promisify)(import_node_stream2.default.pipeline), INTERNALS = Symbol("Body internals"), Body = class {
  constructor(body, {
    size = 0
  } = {}) {
    let boundary = null;
    body === null ? body = null : isURLSearchParameters(body) ? body = import_node_buffer.Buffer.from(body.toString()) : isBlob(body) || import_node_buffer.Buffer.isBuffer(body) || (import_node_util.types.isAnyArrayBuffer(body) ? body = import_node_buffer.Buffer.from(body) : ArrayBuffer.isView(body) ? body = import_node_buffer.Buffer.from(body.buffer, body.byteOffset, body.byteLength) : body instanceof import_node_stream2.default || (body instanceof FormData2 ? (body = formDataToBlob(body), boundary = body.type.split("=")[1]) : body = import_node_buffer.Buffer.from(String(body))));
    let stream = body;
    import_node_buffer.Buffer.isBuffer(body) ? stream = import_node_stream2.default.Readable.from(body) : isBlob(body) && (stream = import_node_stream2.default.Readable.from(body.stream())), this[INTERNALS] = {
      body,
      stream,
      boundary,
      disturbed: !1,
      error: null
    }, this.size = size, body instanceof import_node_stream2.default && body.on("error", (error_) => {
      let error = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
      this[INTERNALS].error = error;
    });
  }
  get body() {
    return this[INTERNALS].stream;
  }
  get bodyUsed() {
    return this[INTERNALS].disturbed;
  }
  /**
   * Decode response as ArrayBuffer
   *
   * @return  Promise
   */
  async arrayBuffer() {
    let { buffer, byteOffset, byteLength } = await consumeBody(this);
    return buffer.slice(byteOffset, byteOffset + byteLength);
  }
  async formData() {
    let ct = this.headers.get("content-type");
    if (ct.startsWith("application/x-www-form-urlencoded")) {
      let formData = new FormData2(), parameters = new URLSearchParams(await this.text());
      for (let [name, value] of parameters)
        formData.append(name, value);
      return formData;
    }
    let { toFormData: toFormData2 } = await Promise.resolve().then(() => (init_multipart_parser(), multipart_parser_exports));
    return toFormData2(this.body, ct);
  }
  /**
   * Return raw response as Blob
   *
   * @return Promise
   */
  async blob() {
    let ct = this.headers && this.headers.get("content-type") || this[INTERNALS].body && this[INTERNALS].body.type || "", buf = await this.arrayBuffer();
    return new fetch_blob_default([buf], {
      type: ct
    });
  }
  /**
   * Decode response as json
   *
   * @return  Promise
   */
  async json() {
    let text = await this.text();
    return JSON.parse(text);
  }
  /**
   * Decode response as text
   *
   * @return  Promise
   */
  async text() {
    let buffer = await consumeBody(this);
    return new TextDecoder().decode(buffer);
  }
  /**
   * Decode response as buffer (non-spec api)
   *
   * @return  Promise
   */
  buffer() {
    return consumeBody(this);
  }
};
Body.prototype.buffer = (0, import_node_util.deprecate)(Body.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer");
Object.defineProperties(Body.prototype, {
  body: { enumerable: !0 },
  bodyUsed: { enumerable: !0 },
  arrayBuffer: { enumerable: !0 },
  blob: { enumerable: !0 },
  json: { enumerable: !0 },
  text: { enumerable: !0 },
  data: { get: (0, import_node_util.deprecate)(
    () => {
    },
    "data doesn't exist, use json(), text(), arrayBuffer(), or body instead",
    "https://github.com/node-fetch/node-fetch/issues/1000 (response)"
  ) }
});
async function consumeBody(data) {
  if (data[INTERNALS].disturbed)
    throw new TypeError(`body used already for: ${data.url}`);
  if (data[INTERNALS].disturbed = !0, data[INTERNALS].error)
    throw data[INTERNALS].error;
  let { body } = data;
  if (body === null)
    return import_node_buffer.Buffer.alloc(0);
  if (!(body instanceof import_node_stream2.default))
    return import_node_buffer.Buffer.alloc(0);
  let accum = [], accumBytes = 0;
  try {
    for await (let chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        let error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        throw body.destroy(error), error;
      }
      accumBytes += chunk.length, accum.push(chunk);
    }
  } catch (error) {
    throw error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, "system", error);
  }
  if (body.readableEnded === !0 || body._readableState.ended === !0)
    try {
      return accum.every((c) => typeof c == "string") ? import_node_buffer.Buffer.from(accum.join("")) : import_node_buffer.Buffer.concat(accum, accumBytes);
    } catch (error) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, "system", error);
    }
  else
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
}
var clone = (instance, highWaterMark) => {
  let p1, p2, { body } = instance[INTERNALS];
  if (instance.bodyUsed)
    throw new Error("cannot clone body after it is used");
  return body instanceof import_node_stream2.default && typeof body.getBoundary != "function" && (p1 = new import_node_stream2.PassThrough({ highWaterMark }), p2 = new import_node_stream2.PassThrough({ highWaterMark }), body.pipe(p1), body.pipe(p2), instance[INTERNALS].stream = p1, body = p2), body;
}, getNonSpecFormDataBoundary = (0, import_node_util.deprecate)(
  (body) => body.getBoundary(),
  "form-data doesn't follow the spec and requires special treatment. Use alternative package",
  "https://github.com/node-fetch/node-fetch/issues/1167"
), extractContentType = (body, request) => body === null ? null : typeof body == "string" ? "text/plain;charset=UTF-8" : isURLSearchParameters(body) ? "application/x-www-form-urlencoded;charset=UTF-8" : isBlob(body) ? body.type || null : import_node_buffer.Buffer.isBuffer(body) || import_node_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body) ? null : body instanceof FormData2 ? `multipart/form-data; boundary=${request[INTERNALS].boundary}` : body && typeof body.getBoundary == "function" ? `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}` : body instanceof import_node_stream2.default ? null : "text/plain;charset=UTF-8", getTotalBytes = (request) => {
  let { body } = request[INTERNALS];
  return body === null ? 0 : isBlob(body) ? body.size : import_node_buffer.Buffer.isBuffer(body) ? body.length : body && typeof body.getLengthSync == "function" && body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
}, writeToStream = async (dest, { body }) => {
  body === null ? dest.end() : await pipeline(body, dest);
};

// node_modules/node-fetch/src/headers.js
var import_node_util2 = require("node:util"), import_node_http = __toESM(require("node:http"), 1), validateHeaderName = typeof import_node_http.default.validateHeaderName == "function" ? import_node_http.default.validateHeaderName : (name) => {
  if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
    let error = new TypeError(`Header name must be a valid HTTP token [${name}]`);
    throw Object.defineProperty(error, "code", { value: "ERR_INVALID_HTTP_TOKEN" }), error;
  }
}, validateHeaderValue = typeof import_node_http.default.validateHeaderValue == "function" ? import_node_http.default.validateHeaderValue : (name, value) => {
  if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
    let error = new TypeError(`Invalid character in header content ["${name}"]`);
    throw Object.defineProperty(error, "code", { value: "ERR_INVALID_CHAR" }), error;
  }
}, Headers2 = class extends URLSearchParams {
  /**
   * Headers class
   *
   * @constructor
   * @param {HeadersInit} [init] - Response headers
   */
  constructor(init) {
    let result = [];
    if (init instanceof Headers2) {
      let raw = init.raw();
      for (let [name, values] of Object.entries(raw))
        result.push(...values.map((value) => [name, value]));
    } else if (init != null)
      if (typeof init == "object" && !import_node_util2.types.isBoxedPrimitive(init)) {
        let method = init[Symbol.iterator];
        if (method == null)
          result.push(...Object.entries(init));
        else {
          if (typeof method != "function")
            throw new TypeError("Header pairs must be iterable");
          result = [...init].map((pair) => {
            if (typeof pair != "object" || import_node_util2.types.isBoxedPrimitive(pair))
              throw new TypeError("Each header pair must be an iterable object");
            return [...pair];
          }).map((pair) => {
            if (pair.length !== 2)
              throw new TypeError("Each header pair must be a name/value tuple");
            return [...pair];
          });
        }
      } else
        throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
    return result = result.length > 0 ? result.map(([name, value]) => (validateHeaderName(name), validateHeaderValue(name, String(value)), [String(name).toLowerCase(), String(value)])) : void 0, super(result), new Proxy(this, {
      get(target, p, receiver) {
        switch (p) {
          case "append":
          case "set":
            return (name, value) => (validateHeaderName(name), validateHeaderValue(name, String(value)), URLSearchParams.prototype[p].call(
              target,
              String(name).toLowerCase(),
              String(value)
            ));
          case "delete":
          case "has":
          case "getAll":
            return (name) => (validateHeaderName(name), URLSearchParams.prototype[p].call(
              target,
              String(name).toLowerCase()
            ));
          case "keys":
            return () => (target.sort(), new Set(URLSearchParams.prototype.keys.call(target)).keys());
          default:
            return Reflect.get(target, p, receiver);
        }
      }
    });
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  toString() {
    return Object.prototype.toString.call(this);
  }
  get(name) {
    let values = this.getAll(name);
    if (values.length === 0)
      return null;
    let value = values.join(", ");
    return /^content-encoding$/i.test(name) && (value = value.toLowerCase()), value;
  }
  forEach(callback, thisArg = void 0) {
    for (let name of this.keys())
      Reflect.apply(callback, thisArg, [this.get(name), name, this]);
  }
  *values() {
    for (let name of this.keys())
      yield this.get(name);
  }
  /**
   * @type {() => IterableIterator<[string, string]>}
   */
  *entries() {
    for (let name of this.keys())
      yield [name, this.get(name)];
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Node-fetch non-spec method
   * returning all headers and their values as array
   * @returns {Record<string, string[]>}
   */
  raw() {
    return [...this.keys()].reduce((result, key) => (result[key] = this.getAll(key), result), {});
  }
  /**
   * For better console.log(headers) and also to convert Headers into Node.js Request compatible format
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return [...this.keys()].reduce((result, key) => {
      let values = this.getAll(key);
      return key === "host" ? result[key] = values[0] : result[key] = values.length > 1 ? values : values[0], result;
    }, {});
  }
};
Object.defineProperties(
  Headers2.prototype,
  ["get", "entries", "forEach", "values"].reduce((result, property) => (result[property] = { enumerable: !0 }, result), {})
);
function fromRawHeaders(headers = []) {
  return new Headers2(
    headers.reduce((result, value, index, array) => (index % 2 === 0 && result.push(array.slice(index, index + 2)), result), []).filter(([name, value]) => {
      try {
        return validateHeaderName(name), validateHeaderValue(name, String(value)), !0;
      } catch {
        return !1;
      }
    })
  );
}

// node_modules/node-fetch/src/utils/is-redirect.js
var redirectStatus = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]), isRedirect = (code) => redirectStatus.has(code);

// node_modules/node-fetch/src/response.js
var INTERNALS2 = Symbol("Response internals"), Response3 = class extends Body {
  constructor(body = null, options = {}) {
    super(body, options);
    let status = options.status != null ? options.status : 200, headers = new Headers2(options.headers);
    if (body !== null && !headers.has("Content-Type")) {
      let contentType = extractContentType(body, this);
      contentType && headers.append("Content-Type", contentType);
    }
    this[INTERNALS2] = {
      type: "default",
      url: options.url,
      status,
      statusText: options.statusText || "",
      headers,
      counter: options.counter,
      highWaterMark: options.highWaterMark
    };
  }
  get type() {
    return this[INTERNALS2].type;
  }
  get url() {
    return this[INTERNALS2].url || "";
  }
  get status() {
    return this[INTERNALS2].status;
  }
  /**
   * Convenience property representing if the request ended normally
   */
  get ok() {
    return this[INTERNALS2].status >= 200 && this[INTERNALS2].status < 300;
  }
  get redirected() {
    return this[INTERNALS2].counter > 0;
  }
  get statusText() {
    return this[INTERNALS2].statusText;
  }
  get headers() {
    return this[INTERNALS2].headers;
  }
  get highWaterMark() {
    return this[INTERNALS2].highWaterMark;
  }
  /**
   * Clone this response
   *
   * @return  Response
   */
  clone() {
    return new Response3(clone(this, this.highWaterMark), {
      type: this.type,
      url: this.url,
      status: this.status,
      statusText: this.statusText,
      headers: this.headers,
      ok: this.ok,
      redirected: this.redirected,
      size: this.size,
      highWaterMark: this.highWaterMark
    });
  }
  /**
   * @param {string} url    The URL that the new response is to originate from.
   * @param {number} status An optional status code for the response (e.g., 302.)
   * @returns {Response}    A Response object.
   */
  static redirect(url, status = 302) {
    if (!isRedirect(status))
      throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
    return new Response3(null, {
      headers: {
        location: new URL(url).toString()
      },
      status
    });
  }
  static error() {
    let response = new Response3(null, { status: 0, statusText: "" });
    return response[INTERNALS2].type = "error", response;
  }
  static json(data = void 0, init = {}) {
    let body = JSON.stringify(data);
    if (body === void 0)
      throw new TypeError("data is not JSON serializable");
    let headers = new Headers2(init && init.headers);
    return headers.has("content-type") || headers.set("content-type", "application/json"), new Response3(body, {
      ...init,
      headers
    });
  }
  get [Symbol.toStringTag]() {
    return "Response";
  }
};
Object.defineProperties(Response3.prototype, {
  type: { enumerable: !0 },
  url: { enumerable: !0 },
  status: { enumerable: !0 },
  ok: { enumerable: !0 },
  redirected: { enumerable: !0 },
  statusText: { enumerable: !0 },
  headers: { enumerable: !0 },
  clone: { enumerable: !0 }
});

// node_modules/node-fetch/src/request.js
var import_node_url = require("node:url"), import_node_util3 = require("node:util");

// node_modules/node-fetch/src/utils/get-search.js
var getSearch = (parsedURL) => {
  if (parsedURL.search)
    return parsedURL.search;
  let lastOffset = parsedURL.href.length - 1, hash = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
  return parsedURL.href[lastOffset - hash.length] === "?" ? "?" : "";
};

// node_modules/node-fetch/src/utils/referrer.js
var import_node_net = require("node:net");
function stripURLForUseAsAReferrer(url, originOnly = !1) {
  return url == null || (url = new URL(url), /^(about|blob|data):$/.test(url.protocol)) ? "no-referrer" : (url.username = "", url.password = "", url.hash = "", originOnly && (url.pathname = "", url.search = ""), url);
}
var ReferrerPolicy = /* @__PURE__ */ new Set([
  "",
  "no-referrer",
  "no-referrer-when-downgrade",
  "same-origin",
  "origin",
  "strict-origin",
  "origin-when-cross-origin",
  "strict-origin-when-cross-origin",
  "unsafe-url"
]), DEFAULT_REFERRER_POLICY = "strict-origin-when-cross-origin";
function validateReferrerPolicy(referrerPolicy) {
  if (!ReferrerPolicy.has(referrerPolicy))
    throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
  return referrerPolicy;
}
function isOriginPotentiallyTrustworthy(url) {
  if (/^(http|ws)s:$/.test(url.protocol))
    return !0;
  let hostIp = url.host.replace(/(^\[)|(]$)/g, ""), hostIPVersion = (0, import_node_net.isIP)(hostIp);
  return hostIPVersion === 4 && /^127\./.test(hostIp) || hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp) ? !0 : url.host === "localhost" || url.host.endsWith(".localhost") ? !1 : url.protocol === "file:";
}
function isUrlPotentiallyTrustworthy(url) {
  return /^about:(blank|srcdoc)$/.test(url) || url.protocol === "data:" || /^(blob|filesystem):$/.test(url.protocol) ? !0 : isOriginPotentiallyTrustworthy(url);
}
function determineRequestsReferrer(request, { referrerURLCallback, referrerOriginCallback } = {}) {
  if (request.referrer === "no-referrer" || request.referrerPolicy === "")
    return null;
  let policy = request.referrerPolicy;
  if (request.referrer === "about:client")
    return "no-referrer";
  let referrerSource = request.referrer, referrerURL = stripURLForUseAsAReferrer(referrerSource), referrerOrigin = stripURLForUseAsAReferrer(referrerSource, !0);
  referrerURL.toString().length > 4096 && (referrerURL = referrerOrigin), referrerURLCallback && (referrerURL = referrerURLCallback(referrerURL)), referrerOriginCallback && (referrerOrigin = referrerOriginCallback(referrerOrigin));
  let currentURL = new URL(request.url);
  switch (policy) {
    case "no-referrer":
      return "no-referrer";
    case "origin":
      return referrerOrigin;
    case "unsafe-url":
      return referrerURL;
    case "strict-origin":
      return isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL) ? "no-referrer" : referrerOrigin.toString();
    case "strict-origin-when-cross-origin":
      return referrerURL.origin === currentURL.origin ? referrerURL : isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL) ? "no-referrer" : referrerOrigin;
    case "same-origin":
      return referrerURL.origin === currentURL.origin ? referrerURL : "no-referrer";
    case "origin-when-cross-origin":
      return referrerURL.origin === currentURL.origin ? referrerURL : referrerOrigin;
    case "no-referrer-when-downgrade":
      return isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL) ? "no-referrer" : referrerURL;
    default:
      throw new TypeError(`Invalid referrerPolicy: ${policy}`);
  }
}
function parseReferrerPolicyFromHeader(headers) {
  let policyTokens = (headers.get("referrer-policy") || "").split(/[,\s]+/), policy = "";
  for (let token of policyTokens)
    token && ReferrerPolicy.has(token) && (policy = token);
  return policy;
}

// node_modules/node-fetch/src/request.js
var INTERNALS3 = Symbol("Request internals"), isRequest = (object) => typeof object == "object" && typeof object[INTERNALS3] == "object", doBadDataWarn = (0, import_node_util3.deprecate)(
  () => {
  },
  ".data is not a valid RequestInit property, use .body instead",
  "https://github.com/node-fetch/node-fetch/issues/1000 (request)"
), Request2 = class extends Body {
  constructor(input, init = {}) {
    let parsedURL;
    if (isRequest(input) ? parsedURL = new URL(input.url) : (parsedURL = new URL(input), input = {}), parsedURL.username !== "" || parsedURL.password !== "")
      throw new TypeError(`${parsedURL} is an url with embedded credentials.`);
    let method = init.method || input.method || "GET";
    if (/^(delete|get|head|options|post|put)$/i.test(method) && (method = method.toUpperCase()), !isRequest(init) && "data" in init && doBadDataWarn(), (init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD"))
      throw new TypeError("Request with GET/HEAD method cannot have body");
    let inputBody = init.body ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
    super(inputBody, {
      size: init.size || input.size || 0
    });
    let headers = new Headers2(init.headers || input.headers || {});
    if (inputBody !== null && !headers.has("Content-Type")) {
      let contentType = extractContentType(inputBody, this);
      contentType && headers.set("Content-Type", contentType);
    }
    let signal = isRequest(input) ? input.signal : null;
    if ("signal" in init && (signal = init.signal), signal != null && !isAbortSignal(signal))
      throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
    let referrer = init.referrer == null ? input.referrer : init.referrer;
    if (referrer === "")
      referrer = "no-referrer";
    else if (referrer) {
      let parsedReferrer = new URL(referrer);
      referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? "client" : parsedReferrer;
    } else
      referrer = void 0;
    this[INTERNALS3] = {
      method,
      redirect: init.redirect || input.redirect || "follow",
      headers,
      parsedURL,
      signal,
      referrer
    }, this.follow = init.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init.follow, this.compress = init.compress === void 0 ? input.compress === void 0 ? !0 : input.compress : init.compress, this.counter = init.counter || input.counter || 0, this.agent = init.agent || input.agent, this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384, this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || !1, this.referrerPolicy = init.referrerPolicy || input.referrerPolicy || "";
  }
  /** @returns {string} */
  get method() {
    return this[INTERNALS3].method;
  }
  /** @returns {string} */
  get url() {
    return (0, import_node_url.format)(this[INTERNALS3].parsedURL);
  }
  /** @returns {Headers} */
  get headers() {
    return this[INTERNALS3].headers;
  }
  get redirect() {
    return this[INTERNALS3].redirect;
  }
  /** @returns {AbortSignal} */
  get signal() {
    return this[INTERNALS3].signal;
  }
  // https://fetch.spec.whatwg.org/#dom-request-referrer
  get referrer() {
    if (this[INTERNALS3].referrer === "no-referrer")
      return "";
    if (this[INTERNALS3].referrer === "client")
      return "about:client";
    if (this[INTERNALS3].referrer)
      return this[INTERNALS3].referrer.toString();
  }
  get referrerPolicy() {
    return this[INTERNALS3].referrerPolicy;
  }
  set referrerPolicy(referrerPolicy) {
    this[INTERNALS3].referrerPolicy = validateReferrerPolicy(referrerPolicy);
  }
  /**
   * Clone this request
   *
   * @return  Request
   */
  clone() {
    return new Request2(this);
  }
  get [Symbol.toStringTag]() {
    return "Request";
  }
};
Object.defineProperties(Request2.prototype, {
  method: { enumerable: !0 },
  url: { enumerable: !0 },
  headers: { enumerable: !0 },
  redirect: { enumerable: !0 },
  clone: { enumerable: !0 },
  signal: { enumerable: !0 },
  referrer: { enumerable: !0 },
  referrerPolicy: { enumerable: !0 }
});
var getNodeRequestOptions = (request) => {
  let { parsedURL } = request[INTERNALS3], headers = new Headers2(request[INTERNALS3].headers);
  headers.has("Accept") || headers.set("Accept", "*/*");
  let contentLengthValue = null;
  if (request.body === null && /^(post|put)$/i.test(request.method) && (contentLengthValue = "0"), request.body !== null) {
    let totalBytes = getTotalBytes(request);
    typeof totalBytes == "number" && !Number.isNaN(totalBytes) && (contentLengthValue = String(totalBytes));
  }
  contentLengthValue && headers.set("Content-Length", contentLengthValue), request.referrerPolicy === "" && (request.referrerPolicy = DEFAULT_REFERRER_POLICY), request.referrer && request.referrer !== "no-referrer" ? request[INTERNALS3].referrer = determineRequestsReferrer(request) : request[INTERNALS3].referrer = "no-referrer", request[INTERNALS3].referrer instanceof URL && headers.set("Referer", request.referrer), headers.has("User-Agent") || headers.set("User-Agent", "node-fetch"), request.compress && !headers.has("Accept-Encoding") && headers.set("Accept-Encoding", "gzip, deflate, br");
  let { agent } = request;
  typeof agent == "function" && (agent = agent(parsedURL)), !headers.has("Connection") && !agent && headers.set("Connection", "close");
  let search = getSearch(parsedURL), options = {
    // Overwrite search to retain trailing ? (issue #776)
    path: parsedURL.pathname + search,
    // The following options are not expressed in the URL
    method: request.method,
    headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
    insecureHTTPParser: request.insecureHTTPParser,
    agent
  };
  return {
    /** @type {URL} */
    parsedURL,
    options
  };
};

// node_modules/node-fetch/src/errors/abort-error.js
var AbortError = class extends FetchBaseError {
  constructor(message, type = "aborted") {
    super(message, type);
  }
};

// node_modules/node-fetch/src/index.js
init_esm_min();
init_from();
var supportedSchemas = /* @__PURE__ */ new Set(["data:", "http:", "https:"]);
async function fetch2(url, options_) {
  return new Promise((resolve, reject) => {
    let request = new Request2(url, options_), { parsedURL, options } = getNodeRequestOptions(request);
    if (!supportedSchemas.has(parsedURL.protocol))
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`);
    if (parsedURL.protocol === "data:") {
      let data = dist_default(request.url), response2 = new Response3(data, { headers: { "Content-Type": data.typeFull } });
      resolve(response2);
      return;
    }
    let send = (parsedURL.protocol === "https:" ? import_node_https.default : import_node_http2.default).request, { signal } = request, response = null, abort = () => {
      let error = new AbortError("The operation was aborted.");
      reject(error), request.body && request.body instanceof import_node_stream3.default.Readable && request.body.destroy(error), !(!response || !response.body) && response.body.emit("error", error);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    let abortAndFinalize = () => {
      abort(), finalize();
    }, request_ = send(parsedURL.toString(), options);
    signal && signal.addEventListener("abort", abortAndFinalize);
    let finalize = () => {
      request_.abort(), signal && signal.removeEventListener("abort", abortAndFinalize);
    };
    request_.on("error", (error) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${error.message}`, "system", error)), finalize();
    }), fixResponseChunkedTransferBadEnding(request_, (error) => {
      response && response.body && response.body.destroy(error);
    }), process.version < "v14" && request_.on("socket", (s2) => {
      let endedWithEventsCount;
      s2.prependListener("end", () => {
        endedWithEventsCount = s2._eventsCount;
      }), s2.prependListener("close", (hadError) => {
        if (response && endedWithEventsCount < s2._eventsCount && !hadError) {
          let error = new Error("Premature close");
          error.code = "ERR_STREAM_PREMATURE_CLOSE", response.body.emit("error", error);
        }
      });
    }), request_.on("response", (response_) => {
      request_.setTimeout(0);
      let headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        let location = headers.get("Location"), locationURL = null;
        try {
          locationURL = location === null ? null : new URL(location, request.url);
        } catch {
          if (request.redirect !== "manual") {
            reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect")), finalize();
            return;
          }
        }
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect")), finalize();
            return;
          case "manual":
            break;
          case "follow": {
            if (locationURL === null)
              break;
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect")), finalize();
              return;
            }
            let requestOptions = {
              headers: new Headers2(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: clone(request),
              signal: request.signal,
              size: request.size,
              referrer: request.referrer,
              referrerPolicy: request.referrerPolicy
            };
            if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL))
              for (let name of ["authorization", "www-authenticate", "cookie", "cookie2"])
                requestOptions.headers.delete(name);
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_node_stream3.default.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect")), finalize();
              return;
            }
            (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") && (requestOptions.method = "GET", requestOptions.body = void 0, requestOptions.headers.delete("content-length"));
            let responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);
            responseReferrerPolicy && (requestOptions.referrerPolicy = responseReferrerPolicy), resolve(fetch2(new Request2(locationURL, requestOptions))), finalize();
            return;
          }
          default:
            return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
        }
      }
      signal && response_.once("end", () => {
        signal.removeEventListener("abort", abortAndFinalize);
      });
      let body = (0, import_node_stream3.pipeline)(response_, new import_node_stream3.PassThrough(), (error) => {
        error && reject(error);
      });
      process.version < "v12.10" && response_.on("aborted", abortAndFinalize);
      let responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      }, codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response3(body, responseOptions), resolve(response);
        return;
      }
      let zlibOptions = {
        flush: import_node_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_node_zlib.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_node_stream3.pipeline)(body, import_node_zlib.default.createGunzip(zlibOptions), (error) => {
          error && reject(error);
        }), response = new Response3(body, responseOptions), resolve(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        let raw = (0, import_node_stream3.pipeline)(response_, new import_node_stream3.PassThrough(), (error) => {
          error && reject(error);
        });
        raw.once("data", (chunk) => {
          (chunk[0] & 15) === 8 ? body = (0, import_node_stream3.pipeline)(body, import_node_zlib.default.createInflate(), (error) => {
            error && reject(error);
          }) : body = (0, import_node_stream3.pipeline)(body, import_node_zlib.default.createInflateRaw(), (error) => {
            error && reject(error);
          }), response = new Response3(body, responseOptions), resolve(response);
        }), raw.once("end", () => {
          response || (response = new Response3(body, responseOptions), resolve(response));
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_node_stream3.pipeline)(body, import_node_zlib.default.createBrotliDecompress(), (error) => {
          error && reject(error);
        }), response = new Response3(body, responseOptions), resolve(response);
        return;
      }
      response = new Response3(body, responseOptions), resolve(response);
    }), writeToStream(request_, request).catch(reject);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  let LAST_CHUNK = import_node_buffer2.Buffer.from(`0\r
\r
`), isChunkedTransfer = !1, properLastChunkReceived = !1, previousChunk;
  request.on("response", (response) => {
    let { headers } = response;
    isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
  }), request.on("socket", (socket) => {
    let onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        let error = new Error("Premature close");
        error.code = "ERR_STREAM_PREMATURE_CLOSE", errorCallback(error);
      }
    }, onData = (buf) => {
      properLastChunkReceived = import_node_buffer2.Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0, !properLastChunkReceived && previousChunk && (properLastChunkReceived = import_node_buffer2.Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && import_node_buffer2.Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0), previousChunk = buf;
    };
    socket.prependListener("close", onSocketClose), socket.on("data", onData), request.on("close", () => {
      socket.removeListener("close", onSocketClose), socket.removeListener("data", onData);
    });
  });
}

// node_modules/@roundforest/http-commons/src/node.index.js
var import_https = require("https"), import_http = require("http"), requestIdGetterSymbol = Symbol("request-id-getter"), defaultAgent = memo(
  /**@param {string} protocol*/
  (protocol) => protocol === "http:" ? new import_http.Agent(SOCKET_OPTIONS) : new import_https.Agent(SOCKET_OPTIONS)
), HTTP_FETCH_SOCKET_TIMEOUT = parseInt(
  process.env.HTTP_FETCH_SOCKET_TIMEOUT || `${5 * 60 * 1e3}`,
  10
), SOCKET_OPTIONS = { keepAlive: !0, timeout: HTTP_FETCH_SOCKET_TIMEOUT };
async function fetcher(url, init) {
  var _a4;
  let requestId = (init == null ? void 0 : init.requestId) ?? ((_a4 = globalThis[requestIdGetterSymbol]) == null ? void 0 : _a4.call(globalThis));
  return await fetch2(url.toString(), {
    //@ts-expect-error
    agent: defaultAgent((url == null ? void 0 : url.protocol) ?? new URL(url).protocol),
    ...requestId != null ? {
      ...init,
      headers: {
        "x-request-id": requestId,
        ...init == null ? void 0 : init.headers
      }
    } : init
  });
}
var client = makeClient(fetcher, requestIdGetterSymbol), {
  throwErrorFromBadStatus,
  fetchAsJson,
  fetchAsText,
  fetchAsTextWithJsonBody,
  fetchAsBuffer,
  fetchAsBufferWithJsonBody,
  fetchAsJsonWithJsonBody,
  setGlobalRequestIdGetter,
  retryFetch,
  fetch: fetch3
} = client;

// node_modules/@roundforest/url-commons/src/url-commons.js
function addQueryParamsToUrl(url, queryParams, options) {
  typeof url == "string" && (url = new URL(url));
  for (let [queryParam, value] of Object.entries(queryParams))
    value != null && (Array.isArray(value) ? value.forEach((valueItem) => {
      let queryParamKey = (options == null ? void 0 : options.style) === "RoR" ? `${queryParam}[]` : queryParam;
      return (
        /** @type {URL} */
        url.searchParams.append(queryParamKey, valueItem)
      );
    }) : url.searchParams.set(queryParam, value));
  return url;
}
function buildUrl(url, baseUrl, queryParams, options) {
  baseUrl != null && typeof baseUrl == "string" && (baseUrl = new URL(baseUrl));
  let finalUrl = new URL(url, baseUrl);
  return queryParams ? addQueryParamsToUrl(finalUrl, queryParams, options) : finalUrl;
}

// node_modules/@roundforest/text-transforms-commons/src/unslug.js
var splitByTokensRules = {
  "all-in-number": /[a-z0-9]+-in-\d+/,
  // ex: all-in-1, 5-in-1
  "letter-word": /^[a-z]-[a-z]+/,
  // ex: E-reader, k-cup
  "non-word": /^non-[a-z]+/,
  // ex: non-smart, non-slip
  "number-number": /\d+-\d+/,
  // ex: 5-1 converted,
  "number-letters": /\d+-[a-zA-Z]+/,
  // 4-way switch
  "split-dashes": /[^\s:-]+/
}, SPLIT_BY_TOKENS = new RegExp(
  `(${Object.values(splitByTokensRules).map((x2) => x2.source).join("|")}|.)`,
  "g"
);

// node_modules/@roundforest/text-transforms-commons/src/slug-to-text.js
var import_lodash2 = __toESM(require_lodash2(), 1), import_lodash3 = __toESM(require_lodash3(), 1);
function slugToText(slug, { capitalize: shouldCapitalize = !0, urlDecode } = {}) {
  let result = urlDecode ? decodeURIComponent(slug).replaceAll(`
`, " ") : slug;
  return result.startsWith("/") && (result = result.slice(1)), result = result.replace(/_|-|%20/g, " "), shouldCapitalize && (result = (0, import_lodash2.default)(result)), result;
}

// node_modules/@roundforest/bdt-locale-commons/src/bdt-locale-commons.js
function mapHostHeaderToLocaleParams(hostHeader) {
  let defaultResult = { locale: "en", language: "en-US", currencyCode: "USD" };
  if (!hostHeader)
    return defaultResult;
  let locale = hostHeader.split(".")[0];
  switch (locale.endsWith("2") && (locale = locale.slice(0, -1)), locale) {
    case "au":
      return { locale, language: "en-AU", currencyCode: "AUD" };
    case "ca":
      return { locale, language: "en-CA", currencyCode: "CAD" };
    case "de":
      return { locale, language: "de-DE", currencyCode: "EUR" };
    case "es":
      return { locale, language: "es-ES", currencyCode: "EUR" };
    case "fr":
      return { locale, language: "fr-FR", currencyCode: "EUR" };
    case "in":
      return { locale, language: "en-IN", currencyCode: "INR" };
    case "it":
      return { locale, language: "it-IT", currencyCode: "EUR" };
    case "nl":
      return { locale, language: "nl-NL", currencyCode: "EUR" };
    case "sg":
      return { locale: "sg", language: "en-SG", currencyCode: "SGD" };
    case "uk":
      return { locale: "uk", language: "en-GB", currencyCode: "GBP" };
    case "jp":
      return { locale, language: "ja-JA", currencyCode: "JPY" };
    case "tt":
      return { locale: "uk", language: "en-GB", currencyCode: "GBP" };
    default:
      return defaultResult;
  }
}

// node_modules/@roundforest/bdt-client/lib/commons/random-number.js
var randomNumber = () => Math.round(Math.random() * 1e16);

// node_modules/@roundforest/bdt-client/lib/modify-base-url-based-on-host-header.js
function modifyBaseUrlBasedOnHostHeader(baseUrl, hostHeader) {
  let {
    locale
  } = mapHostHeaderToLocaleParams(hostHeader), localedBaseUrl = new URL(baseUrl), hostnameSegments = localedBaseUrl.hostname.split(".");
  if (hostnameSegments[1] !== "bestdeals")
    return baseUrl;
  let normalizedLocale = locale === "en" ? "www" : locale;
  return localedBaseUrl.hostname = [normalizedLocale, ...hostnameSegments.slice(1)].join("."), localedBaseUrl.href;
}

// node_modules/@roundforest/bdt-client/lib/bdt-client.js
function extractTrafficFromCookieValue(rawTrafficString) {
  if (!rawTrafficString)
    return;
  let trafficString = decodeURIComponent(rawTrafficString);
  try {
    return JSON.parse(trafficString);
  } catch {
    return {
      raw: trafficString
    };
  }
}
function makeClient2(baseUrl) {
  return {
    submitContactForm,
    registerEmail,
    getProductsAndMetadata,
    getPageTypeData,
    getManualDeals,
    trackRequest,
    getAllCategories,
    TEST_clear: () => {
    }
  };
  async function submitContactForm(data) {
    return await fetchAsJsonWithJsonBody(buildUrl("./contact", baseUrl), data, {
      redirect: "error"
    });
  }
  async function registerEmail(data) {
    let dataForApi = {
      email: data.email,
      app_id: data.appId,
      user_id: data.userId,
      subscription_location: data.subscriptionLocation
    };
    return await fetchAsJsonWithJsonBody(buildUrl("./collect_email", baseUrl), {
      subscription: dataForApi
    });
  }
  async function getProductsAndMetadata(search, userAgent, {
    pageQueryParameters
  } = {
    pageQueryParameters: void 0
  }) {
    let headers = userAgent ? {
      "user-agent": userAgent
    } : void 0, apiUrl = buildUrl("./products", baseUrl, {
      search,
      ...pageQueryParameters || {}
    }), {
      metadata,
      products
    } = await fetchAsJson(apiUrl, {
      headers
    }), normalizedProducts = camelcaseKeys(products);
    return {
      metadata: camelcaseKeys(metadata),
      products: normalizedProducts.map((product) => {
        let randomClickId = randomNumber();
        return {
          ...product,
          redirectLinkTo: product.redirectLinkTo.replace("rf_client_click_id=000000000", `rf_client_click_id=${randomClickId}`),
          clickId: randomClickId
        };
      }),
      TEST_apiUrl: apiUrl.href
    };
  }
  async function getPageTypeData(commonBdtParameters, search) {
    let localedBaseUrl = modifyBaseUrlBasedOnHostHeader(baseUrl, commonBdtParameters.hostHeader), slugAsText = slugToText(search, {
      capitalize: !1
    }), {
      page_type,
      popular_categories,
      subcategories,
      banner
    } = await fetchAsJson(buildUrl("./page_type", localedBaseUrl, {
      search: slugAsText
    }), {
      headers: generateCommonHeaders(commonBdtParameters, baseUrl.toString())
    }), popularCategories = normalizePageTypeCategories(popular_categories || []), normalizedSubcategories = normalizePageTypeCategories(subcategories || []);
    return {
      banner,
      pageType: page_type,
      popularCategories,
      subcategories: normalizedSubcategories
    };
  }
  async function getManualDeals({
    location,
    positions,
    l1Taxonomy
  }) {
    let response = await fetchAsJson(buildUrl("./manual_deals", baseUrl, {
      location,
      positions,
      l1Taxonomy: l1Taxonomy ?? void 0
    }, {
      style: "RoR"
    }));
    return {
      topDeals: getManualDealsByPositionOrUndefined(positions, "Top Deals", response),
      topOffers: getManualDealsByPositionOrUndefined(positions, "Top Offers", response),
      popups: getManualDealsByPositionOrUndefined(positions, "Popups", response),
      banners: getManualDealsByPositionOrUndefined(positions, "Banners", response),
      coupons: getManualDealsByPositionOrUndefined(positions, "Coupons", response),
      offers: getManualDealsByPositionOrUndefined(positions, "Offers", response)
    };
  }
  async function trackRequest(commonBdtParameters, cookieSetter) {
    let {
      locale
    } = mapHostHeaderToLocaleParams(commonBdtParameters.hostHeader), trackRequestResponse = await fetch3(buildUrl("./track_request", baseUrl, {
      locale
    }), {
      headers: {
        "Content-Type": "application/json",
        ...generateCommonHeaders(commonBdtParameters, baseUrl.toString())
      },
      method: "POST",
      body: JSON.stringify({
        ab_tests: commonBdtParameters.abTests
      })
    });
    trackRequestResponse.ok || await throwErrorFromBadStatus(trackRequestResponse);
    let trackRequestCookies = trackRequestResponse.headers.raw()["set-cookie"], {
      bdtSession,
      traffic
    } = extractTrackingValuesFromCookies(trackRequestCookies);
    return cookieSetter && (traffic && cookieSetter("traffic", decodeURIComponent(traffic)), bdtSession && cookieSetter("_noam-stucco_session", decodeURIComponent(bdtSession))), {
      traffic: extractTrafficFromCookieValue(traffic),
      trackRequestCookies
    };
  }
  function getAllCategories(commonBdtParameters) {
    let {
      locale
    } = mapHostHeaderToLocaleParams(commonBdtParameters.hostHeader);
    return fetchAsJson(buildUrl("./categories", baseUrl, {
      locale
    }), {
      headers: generateCommonHeaders(commonBdtParameters, baseUrl.toString())
    });
  }
}
function normalizePageTypeCategories(categories) {
  return categories.map(({
    title,
    url,
    img,
    image
  }) => ({
    title,
    url,
    image: image || img
  }));
}
function normalizeManualDeal(manualDeal) {
  let manualDealItems = manualDeal == null ? void 0 : manualDeal.items.map((deal) => ({
    ...deal,
    clickId: randomNumber()
  }));
  return {
    duration: (manualDeal == null ? void 0 : manualDeal.duration) || 0,
    items: camelcaseKeys(manualDealItems || [])
  };
}
function getManualDealsByPositionOrUndefined(positions, positionKey, response) {
  return positions.includes(positionKey) ? normalizeManualDeal(response[positionKey]) : void 0;
}
function generateCommonHeaders({
  userAgent,
  userId,
  sessionId,
  pageId,
  requestPath,
  bdtSession,
  traffic
}, baseUrl) {
  return {
    ...userAgent ? {
      "user-agent": userAgent
    } : {},
    ...requestPath ? {
      referer: new URL(requestPath, baseUrl).href
    } : {},
    cookie: [userId ? `user_id=${userId}` : void 0, sessionId ? `page_group_id=${sessionId}` : void 0, pageId ? `page_load_id=${pageId}` : void 0, bdtSession ? `_noam-stucco_session=${bdtSession}` : void 0, traffic ? `traffic=${traffic}` : void 0].filter((x2) => !!x2).join("; ")
  };
}
function extractTrackingValuesFromCookies(cookies) {
  let trafficCookieString = cookies.find((cookieString) => cookieString.includes("traffic")), bdtSessionCookieString = cookies.find((cookieString) => cookieString.includes("_noam-stucco_session"));
  return {
    traffic: trafficCookieString ? extractValueFromCookieString(trafficCookieString) : void 0,
    bdtSession: bdtSessionCookieString ? extractValueFromCookieString(bdtSessionCookieString) : void 0
  };
}
function extractValueFromCookieString(cookieString) {
  return cookieString.split(";")[0].split("=")[1];
}

// node_modules/@roundforest/bdt-client/lib/fixtures/products-and-metadata.db.js
var mockData = {
  products: [{
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B07ZLRGJ94",
    title: "Video Games: The Movie V",
    truncatedTitle: "Video Games: The Movie",
    publicItemId: "B07ZLRGJ94",
    source: "amazon",
    categoryId: "2649512011",
    merchantId: null,
    total_new: 1,
    total_used: 0,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: null,
    condition: "new",
    price: 3.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTDEWDhwK_-U64YhfH4F6kO4pgpoWdv3WSypzeN4vtwPU.jpg",
    image: "https://m.media-amazon.com/images/I/61C5IggSY6L._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNjFDNUlnZ1NZNkwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.png",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDdaTFJHSjk0P1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=379172815-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B07ZLRGJ94-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=TW92aWVzICYgVFYgfCBNb3ZpZXM=&rf_from_api=true",
    position: 0,
    productCode: "amazon-us-B07ZLRGJ94-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_323951062782",
    title: "Super Smash Bros. Ultimate - Nintendo Switch (long german word tiiiiiiiiiiooooooooooOOOOOOOOOOXXXXXMMMMMMMMMiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiitl)",
    truncatedTitle: "Super Smash Bros. Ultimate - Nintendo Switch",
    publicItemId: "323951062782",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-18T00:40:36.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 42.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qV6u4CEUXZ3NWqfcmSJ8a3f_JW_9QKCF5pio3N55EvnOc-6wCVoY6XBgerGqMahhnr.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/-LIAAOSw3tddqQoG/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTAwMFgxMDAw/z/-LIAAOSw3tddqQoG/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy8tTElBQU9TdzN0ZGRxUW9HL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzMyMzk1MTA2Mjc4Mj9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=585204701-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-323951062782-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 1,
    productCode: "ebay-us-323951062782-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "nfl shop_new_15930515418",
    title: "Madden NFL 21 Xbox One Video Game",
    truncatedTitle: "Madden NFL 21 Xbox One Video Game",
    publicItemId: "15930515418",
    source: "bizrate.com",
    categoryId: "15010100",
    merchantId: 134939,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "nfl shop",
    expiring: null,
    auction: !1,
    brandName: "cokem",
    condition: "new",
    price: 59.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OHtFjQNBJd07nqH1lZMlQ-3Hn_wZnvjpNtoU-BloU6u1wbwhNMlit22tmOOVjZjQxu-iFyplXFfigCKTawPFrZy-HknCfOPLcpLMOo5YPzYJILT0xoZ7ysv55V-8eG9OK_aicW8IsIl6Hx9Lz5XfZxcv3s6Z2_5ZUadRB3-6tGaFcaQ3Nt2ONQqc6HAvegEJTG5EzHX2AqdQ2PdouVsNlb43UmDGQeAo8I1XEnANYqDG4ATZCiXcqPJAmmYa9jXw8y5lA5jisbJLPGwkT_xOsR0.jpeg",
    image: "https://d8.cnnx.io/image/obj/15930515418;sq=160;p=0;t=ooPwmM0WTWKfBARaVBY6aLR-KO_2YGOplhsmTkaQZE_U6xArW8SWSo630ymYVndlorncelIwZFk4gv0v61LeOOCLDF8JDsjY2mywNxF8Lrd7isRR9TlcrZUVzPCj1Uf_jdNQ4OwCxfJ-TmMEjsd2TdM=",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9kOC5jbm54LmlvL2ltYWdlL29iai8xNTkzMDUxNTQxODtzcT0xNjA7cD0wO3Q9b29Qd21NMFdUV0tmQkFSYVZCWTZhTFItS09fMllHT3BsaHNtVGthUVpFX1U2eEFyVzhTV1NvNjMweW1ZVm5kbG9ybmNlbEl3WkZrNGd2MHY2MUxlT09DTERGOEpEc2pZMm15d054RjhMcmQ3aXNSUjlUbGNyWlVWelBDajFVZl9qZE5RNE93Q3hmSi1UbU1FanNkMlRkTT0=",
    merchantLogo: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OGvyFA7sMtl4X-Sr3Ka1xUHi88nU-5n6yvV6bUlBxDMGXtS8TAV75yHD7vpq8nUKmw.gif",
    merchantLogoUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OGvyFA7sMtl4X-Sr3Ka1xUHi88nU-5n6yvV6bUlBxDMGXtS8TAV75yHD7vpq8nUKmw.gif",
    svgMerchantLogo: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OGvyFA7sMtl4X-Sr3Ka1xUHi88nU-5n6yvV6bUlBxDMGXtS8TAV75yHD7vpq8nUKmw.gif",
    originalMerchantLogo: "https://s9.cnnx.io/merchant/little/134939.gif",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly9yZC5iaXpyYXRlLmNvbS9yZD90PWh0dHBzJTNBJTJGJTJGd3d3Lm5mbHNob3AuY29tJTJGbWFkZGVuX25mbF8yMV94Ym94X29uZV92aWRlb19nYW1lJTJGdC00NzE1MTM4OCUyQm8tODA1MCUyQmQtOTA2MTQzODI4JTJCZi00MDcyMjg0JTJCei05LTIyMjY5MDQxMTMlM0Z1dG1fbWVkaXVtJTNEY3NlJTI2X3MlM0RhazE5NDRuZmwtc2hvcHppbGxhJTI2c2t1JTNEMTQyNzM5MDQmbWlkPTEzNDkzOSZjYXRfaWQ9MTUwMTAxMDAmYXRvbT0xMDAwMDM0NTMmcHJvZF9pZD0mb2lkPTE1OTMwNTE1NDE4JnBvcz0xJmJfaWQ9MTgmYmlkX3R5cGU9MTAmYmFtdD00OGNkOTIwMmRiMTk1ZTliJmNvYnJhbmQ9MSZwcHI9MjU5ZmFkZGFjMWVkZDFlMCZhZl9zaWQ9NzImbXBpZD0xNDI3MzkwNCZrZXl3b3JkPXZpZGVvJTIwZ2FtZXMmYT04YmRiNzg5MDQ2OTEyYWMzOTY2YWQyY2IzNDgwYWFkYyZkdj0xNGU3ODdjMDU4YzQ5NDE5M2ZiYzRlN2NjZWZkZjE1OWFjNzhkMzNiOWRmYzlkZTkmcmY9YWYxJmFmX2Fzc2V0dHlwZV9pZD0xMCZhZl9jcmVhdGl2ZV9pZD0yOTc1JmFmX2lkPTYwODEwNSZhZl9wbGFjZW1lbnRfaWQ9MiZwbGFjZW1lbnRJZD0x&click_id=415526353-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=bizrate.com&rf_product_code=bizrate.com-us-15930515418-new&rf_account=bizrate_us&rf_position=0&rf_merchant_name=NFL Shop&rf_merchant_id=134939&rf_c=&rf_from_api=true",
    position: 2,
    productCode: "bizrate.com-us-15930515418-new",
    account: "bizrate_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !0
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B096WZFCHR",
    title: "Marvel\u2019s Guardians of the Galaxy - PlayStation 5",
    truncatedTitle: "Marvel\u2019s Guardians of the Galaxy - PlayStation 5",
    publicItemId: "B096WZFCHR",
    source: "amazon",
    categoryId: "20972797011",
    merchantId: null,
    total_new: 23,
    total_used: 3,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: "Square Enix",
    condition: "new",
    price: 59.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTt4acKuHTT_UIyQCVb6Aa1DxqmA9X8wv6575Su9os9N0.jpg",
    image: "https://m.media-amazon.com/images/I/51fbu9jCezL._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNTFmYnU5akNlekwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/amazon-logo-543924fcbf756b453bf9414716467e3ef1e615637f49b7ba0b75461a839bb6ed.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/amazon-logo-b105fcd1d1470059ab7cea0edf9309ebc7d878039365215b947426e4f60e139d.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDk2V1pGQ0hSP1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=059477658-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B096WZFCHR-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=VmlkZW8gR2FtZXMgfCBQbGF5U3RhdGlvbiA1IHwgR2FtZXM=&rf_from_api=true",
    position: 3,
    productCode: "amazon-us-B096WZFCHR-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_used_B096WZFCHR",
    title: "Marvel\u2019s Guardians of the Galaxy - PlayStation 5",
    truncatedTitle: "Marvel\u2019s Guardians of the Galaxy - PlayStation 5",
    publicItemId: "B096WZFCHR",
    source: "amazon",
    categoryId: "20972797011",
    merchantId: null,
    total_new: 23,
    total_used: 3,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: "Square Enix",
    condition: "used",
    price: 52.79,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTt4acKuHTT_UIyQCVb6Aa1DxqmA9X8wv6575Su9os9N0.jpg",
    image: "https://m.media-amazon.com/images/I/51fbu9jCezL._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNTFmYnU5akNlekwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/amazon-logo-543924fcbf756b453bf9414716467e3ef1e615637f49b7ba0b75461a839bb6ed.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/amazon-logo-b105fcd1d1470059ab7cea0edf9309ebc7d878039365215b947426e4f60e139d.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDk2V1pGQ0hSP1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=705698613-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B096WZFCHR-used&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=VmlkZW8gR2FtZXMgfCBQbGF5U3RhdGlvbiA1IHwgR2FtZXM=&rf_from_api=true",
    position: 4,
    productCode: "amazon-us-B096WZFCHR-used",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_373082166982",
    title: "NINTENDO WII GAME LOT YOU PICK CHOOSE BUY 2 GET 1 50% OFF ALL GAMES PLAY TESTED!",
    truncatedTitle: "NINTENDO WII GAME LOT YOU PICK CHOOSE BUY 2 GET 1 50% OFF ALL GAMES PLAY...",
    publicItemId: "373082166982",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-13T02:03:41.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 1.97,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qV47OjNh9L7K9-958FXr7G8vqbYhqk_gnSVSbJmTFWI4_gHGjhH91IJi7v9dZ1pTup.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/DMQAAOSwvKBeww1Y/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTA1M1gxNTEx/z/DMQAAOSwvKBeww1Y/$_12.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9ETVFBQU9Td3ZLQmV3dzFZL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzM3MzA4MjE2Njk4Mj9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=203484469-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-373082166982-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 5,
    productCode: "ebay-us-373082166982-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "focus camera_new_17540256060",
    title: "Sony Watch Dogs 2 Video Game for Playstation 4",
    truncatedTitle: "Sony Watch Dogs 2 Video Game for Playstation 4",
    publicItemId: "17540256060",
    source: "bizrate.com",
    categoryId: "15010100",
    merchantId: 94705,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "focus camera",
    expiring: null,
    auction: !1,
    brandName: "Sony",
    condition: "new",
    price: 79.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLoqq0P-bB3rUQBimQQs1Q_Eh4qa9tfMCnTa2z5rNcHqYcje8_h0wOln80GAIKsK65q-wTm1p8Y16ar82K-7XsWp5q0-KKuJ9pgTiY3pu6GI33u41X_BVspgPfBZ36zKqO-Y4SVEicJk8meQtx2UqDCK4LA4U0PNdXj-XSNK37J7Xl_ZHScTMKhxbcU4Jrr2H1B2ywPEocCF4SntkFjrnY_WiS1As_C_4vdBt1LOs_5m.jpeg",
    image: "https://d10.cnnx.io/image/obj/17540256060;sq=160;p=0;t=ooPwmM0WTWKaBQ8NCV4zeSNCmBIMGjoDHVr-0SePLLAozh94mpq9wByav-1lFXIwmDh7OLoeSAMiNKcXepMrOe3ogHmVCrT2pMCnHFtS-w==",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9kMTAuY25ueC5pby9pbWFnZS9vYmovMTc1NDAyNTYwNjA7c3E9MTYwO3A9MDt0PW9vUHdtTTBXVFdLYUJROE5DVjR6ZVNOQ21CSU1Ham9ESFZyLTBTZVBMTEFvemg5NG1wcTl3Qnlhdi0xbEZYSXdtRGg3T0xvZVNBTWlOS2NYZXBNck9lM29nSG1WQ3JUMnBNQ25IRnRTLXc9PQ==",
    merchantLogo: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OMWRTpUpTFkVct9O84hCvu0646SEhhdweo6Sy2lTcM70MR7f4qlLKHYEoRoimJQ67g.gif",
    merchantLogoUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OMWRTpUpTFkVct9O84hCvu0646SEhhdweo6Sy2lTcM70MR7f4qlLKHYEoRoimJQ67g.gif",
    svgMerchantLogo: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OMWRTpUpTFkVct9O84hCvu0646SEhhdweo6Sy2lTcM70MR7f4qlLKHYEoRoimJQ67g.gif",
    originalMerchantLogo: "https://s10.cnnx.io/merchant/little/94705.gif",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly9yZC5iaXpyYXRlLmNvbS9yZD90PWh0dHBzJTNBJTJGJTJGd3d3LmZvY3VzY2FtZXJhLmNvbSUyRndhdGNoLWRvZ3MtMi1mb3ItcGxheXN0YXRpb24tNC5odG1sJTNGdXRtX3NvdXJjZSUzRGNvbm5leGl0eSUyNmNueGNsaWQlM0RTWl9SRURJUkVDVF9JRCUyNnN6cmVkaXJlY3RpZCUzRFNaX1JFRElSRUNUX0lEJm1pZD05NDcwNSZjYXRfaWQ9MTUwMTAxMDAmYXRvbT0xMDAwMDM0NTMmcHJvZF9pZD0mb2lkPTE3NTQwMjU2MDYwJnBvcz0xJmJfaWQ9MTgmYmlkX3R5cGU9OCZiYW10PTQ4Y2Q5MjAyZGIxOTVlOWImY29icmFuZD0xJnBwcj1jMDBmMmRlOTljZjM1ZTIyJmFmX3NpZD03MiZtcGlkPTAyMjg4JmJyYW5kSWQ9MzkwJmtleXdvcmQ9dmlkZW8lMjBnYW1lcyZhPTY3ODc3YjQyNzBiNzE2MzMyMWE1Y2I3NDZhOTNhM2NiJmR2PWE5MzliZDA2NjE5MWUwNWEyZjYwYzdmMTRmNzY5NmM1NmFiNTM3ZmFhYTgxOWZmNyZyZj1hZjEmYWZfYXNzZXR0eXBlX2lkPTEwJmFmX2NyZWF0aXZlX2lkPTI5NzUmYWZfaWQ9NjA4MTA1JmFmX3BsYWNlbWVudF9pZD0yJnBsYWNlbWVudElkPTE=&click_id=853383909-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=bizrate.com&rf_product_code=bizrate.com-us-17540256060-new&rf_account=bizrate_us&rf_position=0&rf_merchant_name=Focus Camera&rf_merchant_id=94705&rf_c=&rf_from_api=true",
    position: 6,
    productCode: "bizrate.com-us-17540256060-new",
    account: "bizrate_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B00EJQUZVK",
    title: "The Ultimate History of Video Games: From Pong to Pokemon: The Story Behind the Craze that Touched Our Lives and Changed the World",
    truncatedTitle: "The Ultimate History of Video Games: From Pong to Pokemon: The Story...",
    publicItemId: "B00EJQUZVK",
    source: "amazon",
    categoryId: "87",
    merchantId: null,
    total_new: 1,
    total_used: 0,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: null,
    condition: "new",
    price: 29.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGT5CO3IdK8mnB5mL9YOksxr5dLr-nGpox-Wa3VyF1rysM.jpg",
    image: "https://m.media-amazon.com/images/I/61GCaxr3r3L._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNjFHQ2F4cjNyM0wuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/amazon-logo-543924fcbf756b453bf9414716467e3ef1e615637f49b7ba0b75461a839bb6ed.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/amazon-logo-b105fcd1d1470059ab7cea0edf9309ebc7d878039365215b947426e4f60e139d.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDBFSlFVWlZLP1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=377060277-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B00EJQUZVK-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=Qm9va3MgfCBDb21wdXRlcnMgJiBUZWNobm9sb2d5IHwgR2FtZXMgJiBTdHJhdGVneSBHdWlkZXM=&rf_from_api=true",
    position: 7,
    productCode: "amazon-us-B00EJQUZVK-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_used_B098KVCFM8",
    title: "FIFA 22 - PlayStation 4",
    truncatedTitle: "FIFA 22 - PlayStation 4",
    publicItemId: "B098KVCFM8",
    source: "amazon",
    categoryId: "6427831011",
    merchantId: null,
    total_new: 21,
    total_used: 1,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: "Electronic Arts",
    condition: "used",
    price: 36.79,
    oldPrice: 59.99,
    discount: 38,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTNM8vDrJd9nReYzsNPk2SIpXHcJXkOkdbCBsjqIb8xS8.jpg",
    image: "https://m.media-amazon.com/images/I/41-I2ULMO1L._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNDEtSTJVTE1PMUwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/amazon-logo-543924fcbf756b453bf9414716467e3ef1e615637f49b7ba0b75461a839bb6ed.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/amazon-logo-b105fcd1d1470059ab7cea0edf9309ebc7d878039365215b947426e4f60e139d.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDk4S1ZDRk04P1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=830256134-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B098KVCFM8-used&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=VmlkZW8gR2FtZXMgfCBQbGF5U3RhdGlvbiA0IHwgR2FtZXM=&rf_from_api=true",
    position: 8,
    productCode: "amazon-us-B098KVCFM8-used",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_193657316256",
    title: "Mario Kart 8 Deluxe - Nintendo Switch",
    truncatedTitle: "Mario Kart 8 Deluxe - Nintendo Switch",
    publicItemId: "193657316256",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-10T23:28:47.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 36.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qV4vrXDb6U_t3FIurxTR0kVjpWcR_rNExQ1b4hEONrISEVs_4I_6uem6W7I8OE80yv.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/msgAAOSwfBFblpsK/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTAwMFgxMDAw/z/msgAAOSwfBFblpsK/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9tc2dBQU9Td2ZCRmJscHNLL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzE5MzY1NzMxNjI1Nj9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=565843717-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-193657316256-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 9,
    productCode: "ebay-us-193657316256-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B098KVCFM8",
    title: "FIFA 22 - PlayStation 4",
    truncatedTitle: "FIFA 22 - PlayStation 4",
    publicItemId: "B098KVCFM8",
    source: "amazon",
    categoryId: "6427831011",
    merchantId: null,
    total_new: 21,
    total_used: 1,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: "Electronic Arts",
    condition: "new",
    price: 39.99,
    oldPrice: 59.99,
    discount: 33,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTNM8vDrJd9nReYzsNPk2SIpXHcJXkOkdbCBsjqIb8xS8.jpg",
    image: "https://m.media-amazon.com/images/I/41-I2ULMO1L._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNDEtSTJVTE1PMUwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/amazon-logo-543924fcbf756b453bf9414716467e3ef1e615637f49b7ba0b75461a839bb6ed.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/amazon-logo-b105fcd1d1470059ab7cea0edf9309ebc7d878039365215b947426e4f60e139d.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDk4S1ZDRk04P1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=459159361-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B098KVCFM8-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=VmlkZW8gR2FtZXMgfCBQbGF5U3RhdGlvbiA0IHwgR2FtZXM=&rf_from_api=true",
    position: 10,
    productCode: "amazon-us-B098KVCFM8-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B07RGFF98S",
    title: "Nintendo Switch 32GB Console Video Games w/ 32GB Memory Card | Neon Red/Neon Blue Joy-Con | 1080p Resolution | 802.11ac WiFi | HDMI | Surround Sound | IR Motion Camera",
    truncatedTitle: "Nintendo Switch 32GB Console Video Games w/ 32GB Memory Card | Neon Red...",
    publicItemId: "B07RGFF98S",
    source: "amazon",
    categoryId: "16329781011",
    merchantId: null,
    total_new: 53,
    total_used: 2,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: "Nintendo",
    condition: "new",
    price: 395,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTYnCAagXefZKMGa7Ay8JgLrFDB_Cqpm-8erhWTNKwd84.jpg",
    image: "https://m.media-amazon.com/images/I/417kf2GJBuL._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNDE3a2YyR0pCdUwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/amazon-logo-543924fcbf756b453bf9414716467e3ef1e615637f49b7ba0b75461a839bb6ed.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/amazon-logo-b105fcd1d1470059ab7cea0edf9309ebc7d878039365215b947426e4f60e139d.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDdSR0ZGOThTP1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=007488442-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B07RGFF98S-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=VmlkZW8gR2FtZXMgfCBOaW50ZW5kbyBTd2l0Y2ggfCBBY2Nlc3NvcmllcyB8IENvbnRyb2xsZXJz&rf_from_api=true",
    position: 11,
    productCode: "amazon-us-B07RGFF98S-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_324436850948",
    title: "Luigi's Mansion 3 - Nintendo Switch",
    truncatedTitle: "Luigi's Mansion 3 - Nintendo Switch",
    publicItemId: "324436850948",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-30T19:35:41.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 52.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVEhmTNZOlKagipmfnzsumZqLV3GxWpOiG_n8m7FGyH6pCLIdBRQxQGPhp1hTeszqZ.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/1JwAAOSwihtd6YnT/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTAwMFgxMDAw/z/1JwAAOSwihtd6YnT/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy8xSndBQU9Td2lodGQ2WW5UL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzMyNDQzNjg1MDk0OD9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=139027653-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-324436850948-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 12,
    productCode: "ebay-us-324436850948-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_used_B07RGFF98S",
    title: "Nintendo Switch 32GB Console Video Games w/ 32GB Memory Card | Neon Red/Neon Blue Joy-Con | 1080p Resolution | 802.11ac WiFi | HDMI | Surround Sound | IR Motion Camera",
    truncatedTitle: "Nintendo Switch 32GB Console Video Games w/ 32GB Memory Card | Neon Red...",
    publicItemId: "B07RGFF98S",
    source: "amazon",
    categoryId: "16329781011",
    merchantId: null,
    total_new: 53,
    total_used: 2,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: "Nintendo",
    condition: "used",
    price: 365,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTYnCAagXefZKMGa7Ay8JgLrFDB_Cqpm-8erhWTNKwd84.jpg",
    image: "https://m.media-amazon.com/images/I/417kf2GJBuL._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNDE3a2YyR0pCdUwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/amazon-logo-543924fcbf756b453bf9414716467e3ef1e615637f49b7ba0b75461a839bb6ed.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/amazon-logo-b105fcd1d1470059ab7cea0edf9309ebc7d878039365215b947426e4f60e139d.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDdSR0ZGOThTP1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=294158344-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B07RGFF98S-used&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=VmlkZW8gR2FtZXMgfCBOaW50ZW5kbyBTd2l0Y2ggfCBBY2Nlc3NvcmllcyB8IENvbnRyb2xsZXJz&rf_from_api=true",
    position: 13,
    productCode: "amazon-us-B07RGFF98S-used",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B08Y6HCHP8",
    title: "Pok\xE9mon Brilliant Diamond - Nintendo Switch",
    truncatedTitle: "Pok\xE9mon Brilliant Diamond - Nintendo Switch",
    publicItemId: "B08Y6HCHP8",
    source: "amazon",
    categoryId: "16227133011",
    merchantId: null,
    total_new: 1,
    total_used: 0,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: "Nintendo",
    condition: "new",
    price: 59.88,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTmYhkjnJiHtwvf9T6RTozR21nNILumlfexgEkcV1UsnM.jpg",
    image: "https://m.media-amazon.com/images/I/51lgw9CRKbL._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNTFsZ3c5Q1JLYkwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/amazon-logo-543924fcbf756b453bf9414716467e3ef1e615637f49b7ba0b75461a839bb6ed.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/amazon-logo-b105fcd1d1470059ab7cea0edf9309ebc7d878039365215b947426e4f60e139d.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDhZNkhDSFA4P1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=555526169-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B08Y6HCHP8-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=VmlkZW8gR2FtZXMgfCBOaW50ZW5kbyBTd2l0Y2ggfCBHYW1lcw==&rf_from_api=true",
    position: 14,
    productCode: "amazon-us-B08Y6HCHP8-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_203102862760",
    title: "Super Mario Odyssey Standard Edition - Nintendo Switch",
    truncatedTitle: "Super Mario Odyssey Standard Edition - Nintendo Switch",
    publicItemId: "203102862760",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-11T00:16:35.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 38.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVgEeEpBRJHjoGcN8F7lskrbfNdbBCXUk3zpjMGUL_6sAiEKquaPTJ1Fon0VtQtUYv.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/N14AAOSw7FJblrC7/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTAwMFgxMDAw/z/N14AAOSw7FJblrC7/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9OMTRBQU9TdzdGSmJsckM3L3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzIwMzEwMjg2Mjc2MD9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=455887876-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-203102862760-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 15,
    productCode: "ebay-us-203102862760-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B01N5A8HEC",
    title: "Troll Face Quest Video Games",
    truncatedTitle: "Troll Face Quest Video Games",
    publicItemId: "B01N5A8HEC",
    source: "amazon",
    categoryId: "9408533011",
    merchantId: null,
    total_new: 1,
    total_used: 0,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: "SPIL GAMES",
    condition: "new",
    price: 0,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTdzy6pRQjIsMP3JkQ3iH1v-_gaW74JqHNclvsMQAOtdg.png",
    image: "https://m.media-amazon.com/images/I/719Kay7BjQL._SL500_.png",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNzE5S2F5N0JqUUwuX1NMNTAwXy5wbmc=",
    merchantLogo: "https://www.bestdeals.today/assets/amazon-logo-543924fcbf756b453bf9414716467e3ef1e615637f49b7ba0b75461a839bb6ed.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/amazon-logo-b105fcd1d1470059ab7cea0edf9309ebc7d878039365215b947426e4f60e139d.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDFONUE4SEVDP1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=810354787-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B01N5A8HEC-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=QXBwcyAmIEdhbWVzIHwgR2FtZXMgfCBCcmFpbiAmIFB1enpsZQ==&rf_from_api=true",
    position: 16,
    productCode: "amazon-us-B01N5A8HEC-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_284512457426",
    title: "Mario Party Superstars - Nintendo Switch",
    truncatedTitle: "Mario Party Superstars - Nintendo Switch",
    publicItemId: "284512457426",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-01T19:39:18.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 52.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVASUXdbIJDx6_mNDxrts5sv57UH7yiqBeOfPhjtxnzgtdzXYK6NggytOs2209juxZ.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/z~UAAOSwBMhhgEIC/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTUwMFg5MjY=/z/z~UAAOSwBMhhgEIC/$_12.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy96flVBQU9Td0JNaGhnRUlDL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzI4NDUxMjQ1NzQyNj9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=879440820-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-284512457426-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 17,
    productCode: "ebay-us-284512457426-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_202639034313",
    title: "Super Mario Bros. 3 - Nintendo NES Game Authentic",
    truncatedTitle: "Super Mario Bros. 3 - Nintendo NES Game Authentic",
    publicItemId: "202639034313",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-29T13:00:44.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 16.49,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 2.95,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVhk_Tt7CwT1FPIVLLg30qhdLLhIIPmcGOqucYT4RpUBXAot5fxzYcy9TG7Gv9ZEJu.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/fPQAAOSw~xVgbyMC/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTYwMFgxNDY3/z/fPQAAOSw~xVgbyMC/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9mUFFBQU9Td354VmdieU1DL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzIwMjYzOTAzNDMxMz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=648381428-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-202639034313-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 18,
    productCode: "ebay-us-202639034313-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_193657439637",
    title: "Animal Crossing: New Horizons - Nintendo Switch",
    truncatedTitle: "Animal Crossing: New Horizons - Nintendo Switch",
    publicItemId: "193657439637",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-11T02:04:50.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 50.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVq8HxkRVSWc1p3URiKCQr9z1FVJ5ENOYgudGrOQPzDS-cLb3IC4p8uevFGcY0GZUa.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/-vQAAOSwbPBeyKh1/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTAwMFg2MTg=/z/-vQAAOSwbPBeyKh1/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy8tdlFBQU9Td2JQQmV5S2gxL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzE5MzY1NzQzOTYzNz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=570090975-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-193657439637-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 19,
    productCode: "ebay-us-193657439637-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_164093307854",
    title: "Halo games (Microsoft Xbox 360) Tested",
    truncatedTitle: "Halo games (Microsoft Xbox 360) Tested",
    publicItemId: "164093307854",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-23T02:39:05.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 13.47,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 4.25,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVOUZ8zZObRXTnxKJhE321lFj0s8LVQfMNXMYz45hyNywEVsBtXmDyfnozy9hW32T8.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/AKMAAOSw4qNeUeAx/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9BS01BQU9TdzRxTmVVZUF4L3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzE2NDA5MzMwNzg1ND9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=795109873-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-164093307854-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 20,
    productCode: "ebay-us-164093307854-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_284469027330",
    title: "Metroid Dread - Nintendo Switch",
    truncatedTitle: "Metroid Dread - Nintendo Switch",
    publicItemId: "284469027330",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-28T21:41:24.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 54.95,
    oldPrice: 59.99,
    discount: 8,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVKQgpJ1VgVwCgbkCEgdKYJ_tiaFjPXEeui7dTu__Xraho-lmQbSCMyi9Wlgm0Zge_.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/4~wAAOSwphhhexu8/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy80fndBQU9Td3BoaGhleHU4L3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzI4NDQ2OTAyNzMzMD9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=165358476-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-284469027330-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 21,
    productCode: "ebay-us-284469027330-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_373241969167",
    title: "NINTENDO WII GAME LOT YOU PICK CHOOSE BUY 2 GET 1 50% OFF GAMES PLAY TESTED LOT2",
    truncatedTitle: "NINTENDO WII GAME LOT YOU PICK CHOOSE BUY 2 GET 1 50% OFF GAMES PLAY...",
    publicItemId: "373241969167",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-29T01:24:35.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 26.77,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVN4mojV2yIImjI5jke2DFJPHE6QWU2kVGqYalAkSOphFaaGFKaK9x-QShDRoeXy-y.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/EE0AAOSwFZhfjK5~/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9FRTBBQU9Td0ZaaGZqSzV+L3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzM3MzI0MTk2OTE2Nz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=269954237-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-373241969167-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 22,
    productCode: "ebay-us-373241969167-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_203293128997",
    title: "Super Mario 3D World + Bowsers Fury - Nintendo Switch, Nintendo Switch Lite",
    truncatedTitle: "Super Mario 3D World + Bowsers Fury - Nintendo Switch, Nintendo Switch Lite",
    publicItemId: "203293128997",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-01T18:10:29.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 51.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVAqOLmhaS-Tr2yMbYLTr1OOPyT1iNhtG9Bs2SWt5vE0KEeUS05Sddw8xHANjHOo08.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/5h0AAOSwf-5gPS4X/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTAwMFg2MTg=/z/5h0AAOSwf-5gPS4X/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy81aDBBQU9Td2YtNWdQUzRYL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzIwMzI5MzEyODk5Nz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=414297857-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-203293128997-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 23,
    productCode: "ebay-us-203293128997-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_392926103491",
    title: "Random Steam Game Key",
    truncatedTitle: "Random Steam Game Key",
    publicItemId: "392926103491",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-30T20:02:33.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 0.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVJjnSPRKunti0A_KPFpxEbmnFmubYehZ1g9s8qpypl8TJN2q9ZHHkc0tik0BPRrvb.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/OoYAAOSwjWRe~RS-/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9Pb1lBQU9Td2pXUmV+UlMtL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzM5MjkyNjEwMzQ5MT9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=008828760-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-392926103491-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 24,
    productCode: "ebay-us-392926103491-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_234277415927",
    title: "The Legend of Zelda: Skyward Sword HD - Nintendo Switch - In Stock Ready To Ship",
    truncatedTitle: "The Legend of Zelda: Skyward Sword HD - Nintendo Switch - In Stock Ready...",
    publicItemId: "234277415927",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-08T22:58:33.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 41,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVST6fUuul2H5FfAS3o5noyp7McriLmjyEsvgx4CCeHQbpw70Gp6DetEEgGyeI1eK3.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/lsgAAOSwWt9g1ahx/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9sc2dBQU9Td1d0OWcxYWh4L3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzIzNDI3NzQxNTkyNz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=011639376-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-234277415927-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 25,
    productCode: "ebay-us-234277415927-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_353260498302",
    title: "America/NA Genshin Impact Diluc Hu Tao Eula Zhongli Xiao Baal Ayaka Kazuha Venti",
    truncatedTitle: "America/NA Genshin Impact Diluc Hu Tao Eula Zhongli Xiao Baal Ayaka...",
    publicItemId: "353260498302",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-02T17:32:07.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 1.49,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qV2kB9LFSMw5cHH4_hGYBwo62B2ZfjimNj3watX6JlFQg4DY6xUv3pRvrV3OWMVoDL.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/IOkAAOSw40lhef3j/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9JT2tBQU9TdzQwbGhlZjNqL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzM1MzI2MDQ5ODMwMj9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=665197178-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-353260498302-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 26,
    productCode: "ebay-us-353260498302-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_403262883483",
    title: "GAMESTOP Shiny Zacian and Zamazenta BOTH (2) CODES - Pok\xE9mon Sword & Shield",
    truncatedTitle: "GAMESTOP Shiny Zacian and Zamazenta BOTH (2) CODES - Pok\xE9mon Sword & Shield",
    publicItemId: "403262883483",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-28T23:00:33.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 3.4,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVomIKzmHHtGUnzGX536nsRcGKlaOhwnxOglQMI4h4GlQ651t409MUXF8-k2yaW5rg.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/uaIAAOSw1x5hhbba/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy91YUlBQU9TdzF4NWhoYmJhL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzQwMzI2Mjg4MzQ4Mz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=045761077-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-403262883483-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 27,
    productCode: "ebay-us-403262883483-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_372840325578",
    title: "Nintendo Wii Games! You Choose from Large Selection! $7.95 Each! Buy 2 Get 1 50%",
    truncatedTitle: "Nintendo Wii Games! You Choose from Large Selection! $7.95 Each! Buy...",
    publicItemId: "372840325578",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-13T20:16:50.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 7.95,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 3.95,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVeBY6b1K4jqgtNTprB8Ps-PyTvrIn-aQ0bCI7eF9ByXtBmdgsEnCz1ruJJKK9lEUv.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/ENUAAOSwjY5de-qK/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTIwMFgxNjAw/z/ENUAAOSwjY5de-qK/$_12.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9FTlVBQU9Td2pZNWRlLXFLL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzM3Mjg0MDMyNTU3OD9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=402940196-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-372840325578-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 28,
    productCode: "ebay-us-372840325578-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_333855526527",
    title: "1X Random Steam Key [REGION FREE]",
    truncatedTitle: "1X Random Steam Key [REGION FREE]",
    publicItemId: "333855526527",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-12T18:54:45.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 0.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVm2-f-wnCYkWDNTUQx2eaCVRQLgjhAccN3RdnzewmFGS52xp_0SL3HlhYVAIyCL5x.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/OI8AAOSwAfVf~e75/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/NTAwWDUwMA==/z/OI8AAOSwAfVf~e75/$_12.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9PSThBQU9Td0FmVmZ+ZTc1L3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzMzMzg1NTUyNjUyNz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=049898507-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-333855526527-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 29,
    productCode: "ebay-us-333855526527-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_373342188901",
    title: "NINTENDO WII GAME LOT YOU PICK CHOOSE BUY 2 GET 1 50% OFF GAMES PLAY TESTED LOT3",
    truncatedTitle: "NINTENDO WII GAME LOT YOU PICK CHOOSE BUY 2 GET 1 50% OFF GAMES PLAY...",
    publicItemId: "373342188901",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-16T03:25:04.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 18.77,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qV7cp6OS-O6ofEFwEPqjjgnOZEPidy811huO0eG4_eatGRSgnjjayPUF1G29H8mLWD.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/UwQAAOSwgPtfsa2t/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9Vd1FBQU9Td2dQdGZzYTJ0L3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzM3MzM0MjE4ODkwMT9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=168956157-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-373342188901-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 30,
    productCode: "ebay-us-373342188901-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_192873974855",
    title: "Super Mario Bros. 2 - Nintendo NES Game Authentic",
    truncatedTitle: "Super Mario Bros. 2 - Nintendo NES Game Authentic",
    publicItemId: "192873974855",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-29T13:21:05.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 19.79,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 2.95,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVr7l_uMdVmDgN_7cqCvaj528zM57PntBUB7S6Gj_OfbZkFioQ9M0gl1sa3msVZR69.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/1zIAAOSwIxNf9eKI/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTYwMFgxNDI2/z/1zIAAOSwIxNf9eKI/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy8xeklBQU9Td0l4TmY5ZUtJL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzE5Mjg3Mzk3NDg1NT9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=036002691-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-192873974855-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 31,
    productCode: "ebay-us-192873974855-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_165170704956",
    title: "Nintendo Switch Games NEW SEALED Fun You Pick & Choose Video Games Lot Kids",
    truncatedTitle: "Nintendo Switch Games NEW SEALED Fun You Pick & Choose Video Games Lot Kids",
    publicItemId: "165170704956",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-06T21:22:46.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 44.91,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVmwBXM1381NCsFv2I2si-2_JPfHzInQHtAoe-Q_jL0CDym42gjJcUcpDNYtH1kaYb.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/Z6kAAOSwo0lhhvhB/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9aNmtBQU9Td28wbGhodmhCL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzE2NTE3MDcwNDk1Nj9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=528910424-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-165170704956-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 32,
    productCode: "ebay-us-165170704956-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_124994322339",
    title: "Animal Crossing Treasure Island | Version 2.0 | Unlimited Trips - free friends",
    truncatedTitle: "Animal Crossing Treasure Island | Version 2.0 | Unlimited Trips - free...",
    publicItemId: "124994322339",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-08T17:48:23.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 10,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVL_Pc0z8nrOR6fLoAw3wACP0I4EBsaY5Ji4n_rC5NG8i93ult734mT1txShfA9RVE.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/o5MAAOSwJ9BhiWGp/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9vNU1BQU9Td0o5QmhpV0dwL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzEyNDk5NDMyMjMzOT9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=100853898-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-124994322339-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 33,
    productCode: "ebay-us-124994322339-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_185115334649",
    title: "Minecraft (Nintendo Switch) Includes Super Mario Mash-Up + Case and Cartridge",
    truncatedTitle: "Minecraft (Nintendo Switch) Includes Super Mario Mash-Up + Case and...",
    publicItemId: "185115334649",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-18T21:10:28.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 29.98,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVF8kh642mfnsLp67Kl6wkWvwDzhVOrBNfR4M8ypBCCeo2oV8O1abLlkK56s51Mu55.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/Sj4AAOSwY~FhbeJS/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTUwMFgxNTAw/z/Sj4AAOSwY~FhbeJS/$_12.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9TajRBQU9Td1l+RmhiZUpTL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzE4NTExNTMzNDY0OT9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=074277027-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-185115334649-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 34,
    productCode: "ebay-us-185115334649-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_193844437919",
    title: "Nintendo Switch Games to Choose From (Or Blank Case)",
    truncatedTitle: "Nintendo Switch Games to Choose From (Or Blank Case)",
    publicItemId: "193844437919",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-10T21:34:58.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 44.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 3.45,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVpVQU_T-Gl0WAoat1TRIF3wKahQQJBsMXlMBJVfBVz4luiyQEYoOEfLWolCkJZrx7.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/qZcAAOSwy0Nf-2uH/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9xWmNBQU9Td3kwTmYtMnVIL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzE5Mzg0NDQzNzkxOT9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=115777774-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-193844437919-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 35,
    productCode: "ebay-us-193844437919-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_133923636655",
    title: "Shiny Zacian & Zamazenta GAMESTOP EVENT BOTH [2] CODES! Pokemon Sword and Shield",
    truncatedTitle: "Shiny Zacian & Zamazenta GAMESTOP EVENT BOTH [2] CODES! Pokemon Sword...",
    publicItemId: "133923636655",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-03T19:44:11.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 3.4,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVUfU3gF3PZz0vEeJFoQCUPFttGEB6nvYTFTRGL_m8PlAhQvYidYvf8ropYUQm0b2T.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/UbIAAOSwRGBhiA-F/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/NTI0WDU5Mw==/z/UbIAAOSwRGBhiA-F/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9VYklBQU9Td1JHQmhpQS1GL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzEzMzkyMzYzNjY1NT9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=309992456-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-133923636655-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 36,
    productCode: "ebay-us-133923636655-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_194376553053",
    title: "NINTENDO SWITCH GAMES LOT | BRAND NEW FACTORY SEALED | PICK & CHOOSE YOUR TITLE",
    truncatedTitle: "NINTENDO SWITCH GAMES LOT | BRAND NEW FACTORY SEALED | PICK & CHOOSE...",
    publicItemId: "194376553053",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-19T20:04:28.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 15.95,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVzgKhTOif-l2UJ4cPwM6Kz07b7TcbmgpJcsH5hKaknBDnhIbRLz6YmWl7a3AkMoGv.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/7KoAAOSwHeZhR4ac/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/OTQyWDE2MDA=/z/7KoAAOSwHeZhR4ac/$_12.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy83S29BQU9Td0hlWmhSNGFjL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzE5NDM3NjU1MzA1Mz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=200558594-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-194376553053-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 37,
    productCode: "ebay-us-194376553053-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_174967042821",
    title: "The Legend of Zelda: Phantom Hourglass (DS, 2007), Tested,US Version Hot Gift",
    truncatedTitle: "The Legend of Zelda: Phantom Hourglass (DS, 2007), Tested,US Version Hot...",
    publicItemId: "174967042821",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-06T14:41:35.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 14.55,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVMeFRjKnB0dXDu5aL-uSwC8xj4brDx83innuxMqepUxzjLQ8CSmBKfxKZlJKGTTBc.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/DhMAAOSwlophXbWF/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTYwMFgxNjAw/z/DhMAAOSwlophXbWF/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9EaE1BQU9Td2xvcGhYYldGL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzE3NDk2NzA0MjgyMT9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=251956442-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-174967042821-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 38,
    productCode: "ebay-us-174967042821-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_165171623112",
    title: "Nintendo Switch Games Complete Fun You Pick & Choose Video Games Lot Kids",
    truncatedTitle: "Nintendo Switch Games Complete Fun You Pick & Choose Video Games Lot Kids",
    publicItemId: "165171623112",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-07T15:38:08.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 10.91,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qV8sVUJ1-d_lgzgXBrZ09ltNXMB2pCQywZgDKlXnNxWSMoGOFXfaeBTscKCkpSXpQS.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/UAsAAOSwe95hh~Ca/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTIwMFgxNjAw/z/UAsAAOSwe95hh~Ca/$_12.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9VQXNBQU9Td2U5NWhofkNhL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzE2NTE3MTYyMzExMj9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=607746749-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-165171623112-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 39,
    productCode: "ebay-us-165171623112-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_353756562210",
    title: "Call of Duty: Vanguard (PS4 / PlayStation 4) BRAND NEW ",
    truncatedTitle: "Call of Duty: Vanguard (PS4 / PlayStation 4) BRAND NEW ",
    publicItemId: "353756562210",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-04T14:46:21.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 63.95,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVTiOEyvTEYEN-8MKc-BygcLY1JRxgZh6_Pw3AjY1mXfPOIEJqVxPvB1D5CsgTzqXR.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/HcwAAOSwbbNhhASy/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTYwMFgxMjAw/z/HcwAAOSwbbNhhASy/$_12.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9IY3dBQU9Td2JiTmhoQVN5L3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzM1Mzc1NjU2MjIxMD9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=410362581-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-353756562210-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 40,
    productCode: "ebay-us-353756562210-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_274806861917",
    title: "Buy 2 Get 3rd 50% Off!! Nintendo Wii Game Lot Pick & Choose!",
    truncatedTitle: "Buy 2 Get 3rd 50% Off!! Nintendo Wii Game Lot Pick & Choose!",
    publicItemId: "274806861917",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-22T17:31:51.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 7.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVaSTpalXuyK-dzSyN6X9_o4H9wPFAHpPeli2tHTUCNz6QPpONQfxkkPwIC1zdStn1.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/cHoAAOSwsRRgIcfp/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTYwMFgxMjAw/z/cHoAAOSwsRRgIcfp/$_12.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9jSG9BQU9Td3NSUmdJY2ZwL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzI3NDgwNjg2MTkxNz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=468501593-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-274806861917-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 41,
    productCode: "ebay-us-274806861917-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_194391097035",
    title: "Super 64 Retro Video Game 340 In 1 Cartridge - N64 Consoles ED64 Plus 16GB Card",
    truncatedTitle: "Super 64 Retro Video Game 340 In 1 Cartridge - N64 Consoles ED64 Plus...",
    publicItemId: "194391097035",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-25T17:28:54.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 64.95,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVUJEq12Dq99nOs9Km2oNr-_lTvQ_SWMgxKAwz7ebqBmUFmXSrADmrtNTUZZGmSrzl.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/JwwAAOSwBPhhT1Ay/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTYwMFgxMjAw/z/JwwAAOSwBPhhT1Ay/$_12.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9Kd3dBQU9Td0JQaGhUMUF5L3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzE5NDM5MTA5NzAzNT9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=661573027-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-194391097035-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 42,
    productCode: "ebay-us-194391097035-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_283884785065",
    title: "Minecraft - Nintendo Switch Includes Super Mario Mash-Up",
    truncatedTitle: "Minecraft - Nintendo Switch Includes Super Mario Mash-Up",
    publicItemId: "283884785065",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-20T16:06:22.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 31.95,
    oldPrice: 59.99,
    discount: 46,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qV4A7gf9GFBnNaLBkmwQyZexRA-fsR3Wb2vR3hRdYDqpo48G9m5JSAhNS7K94jHPW4.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/HBAAAOSwhjxhcI24/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9IQkFBQU9Td2hqeGhjSTI0L3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzI4Mzg4NDc4NTA2NT9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=557777212-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-283884785065-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 43,
    productCode: "ebay-us-283884785065-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_363203340563",
    title: "XBOX 360 Games - Xbox 360 Lot! Great Selection!! Low Prices & Shipping!!! ",
    truncatedTitle: "XBOX 360 Games - Xbox 360 Lot! Great Selection!! Low Prices & Shipping!!! ",
    publicItemId: "363203340563",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-01T16:37:55.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 34,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 3.5,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVqMz2AcjX81DmjUgMoOO-QHFDJb6JxBbaNwjz7533905Fqe7x2t74jrfOmdXE0Ots.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/gd4AAOSwFwlgX4BL/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9nZDRBQU9Td0Z3bGdYNEJML3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzM2MzIwMzM0MDU2Mz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=068227146-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-363203340563-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 44,
    productCode: "ebay-us-363203340563-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_203658230553",
    title: "Nintendo GameCube Black Label Games You Pick & Choose Video Game Lot - B",
    truncatedTitle: "Nintendo GameCube Black Label Games You Pick & Choose Video Game Lot - B",
    publicItemId: "203658230553",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-19T23:08:02.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 3.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 4.75,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVAVI4aXsE0dOQjlVw6e8Ta5FTAS7FG1-EEvi-aHSru_6Z1UGV5e89_qo-K7UpkoDk.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/OMkAAOSw~p1hb0EU/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTQ0M1gxNjAw/z/OMkAAOSw~p1hb0EU/$_12.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9PTWtBQU9Td35wMWhiMEVVL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzIwMzY1ODIzMDU1Mz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=843024559-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-203658230553-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 45,
    productCode: "ebay-us-203658230553-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_185140934923",
    title: "Mario Kart 64 Video Game Cartridge Console For Nintendo N64 Mario party 1 2 3",
    truncatedTitle: "Mario Kart 64 Video Game Cartridge Console For Nintendo N64 Mario party...",
    publicItemId: "185140934923",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-02T10:13:57.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 23.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVODhDyoqAZCbp-Yqwj4MEPkdSsYjspiptB4oMFaFjV31e6H966FcUp-Wc4CesT9Kk.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/HzwAAOSw2XRhgQ-C/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTAwMFgxMDAw/z/HzwAAOSw2XRhgQ-C/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9IendBQU9TdzJYUmhnUS1DL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzE4NTE0MDkzNDkyMz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=394123732-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-185140934923-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 46,
    productCode: "ebay-us-185140934923-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_373656621871",
    title: "Wii Play Wii Game",
    truncatedTitle: "Wii Play Wii Game",
    publicItemId: "373656621871",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-21T21:20:37.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 4.47,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 2.95,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVKPqd3lbyXzGzaRUJpRV3tuzuSNThFPlJhI1twiRJutXdg8SnOQnprAHunc2Q4Awb.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/0NAAAOSwqvVg-Iv~/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/ODk4WDY0MA==/z/0NAAAOSwqvVg-Iv~/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy8wTkFBQU9Td3F2VmctSXZ+L3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzM3MzY1NjYyMTg3MT9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=158928547-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-373656621871-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 47,
    productCode: "ebay-us-373656621871-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_403286467967",
    title: "Treasure Island for Animal Crossing New Horizon V 2.0 (1Hrs Unlimited Trips) \uFFFC",
    truncatedTitle: "Treasure Island for Animal Crossing New Horizon V 2.0 (1Hrs Unlimited...",
    publicItemId: "403286467967",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-09T18:26:43.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 30,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVKGOplqOnnA-XHUMW48XIc70P6uTL02jCDtsDkv8-Vqc5n9THbgvTP2oG_Z3OuxSG.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/lmkAAOSwPzthigOe/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTI4MFgxMjgw/z/lmkAAOSwPzthigOe/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9sbWtBQU9Td1B6dGhpZ09lL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzQwMzI4NjQ2Nzk2Nz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=614198923-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-403286467967-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 48,
    productCode: "ebay-us-403286467967-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_373497929502",
    title: "NINTENDO WII DISNEY SING IT GAME MICROPHONE BUY2 GET1 50% OFF BUILD YOUR BUNDLE ",
    truncatedTitle: "NINTENDO WII DISNEY SING IT GAME MICROPHONE BUY2 GET1 50% OFF BUILD YOUR...",
    publicItemId: "373497929502",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-11-14T16:45:45.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 3.98,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVOaXVQkB4T8VaYGWt-g0vkNGm0rpDRXocojSGRg6FYM4UxiEWBLRVW4kcwKfiLp43.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/WEMAAOSwaRFgTUw6/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTAyNVgxMDcz/z/WEMAAOSwaRFgTUw6/$_12.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9XRU1BQU9Td2FSRmdUVXc2L3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzM3MzQ5NzkyOTUwMj9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=831188278-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-373497929502-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 49,
    productCode: "ebay-us-373497929502-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_255220857763",
    title: "Pokemon Shining Pearl - Nintendo Switch",
    truncatedTitle: "Pokemon Shining Pearl - Nintendo Switch",
    publicItemId: "255220857763",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-10T06:11:06.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 59.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVHb5Ca9ppER67TA67Tr9lL83hvSc321JHHb04wA2r7ESm-IB3SxIdPMIY4sxfb45l.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/W~sAAOSwQvdhi2HU/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTYwMFg3NDA=/z/W~sAAOSwQvdhi2HU/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9XfnNBQU9Td1F2ZGhpMkhVL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzI1NTIyMDg1Nzc2Mz9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=300983841-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-255220857763-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 50,
    productCode: "ebay-us-255220857763-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_234275739364",
    title: "Lots of Xbox 360 games!!",
    truncatedTitle: "Lots of Xbox 360 games!!",
    publicItemId: "234275739364",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-07T22:02:14.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 6.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 1,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVNMLJwC_jWfHJqk4NlrjemhmRpOlr0aYdfgfJyZIm5YSM6bOSeyPxZ-wxunkrvvkm.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/4bcAAOSwlLdhiDmh/s-l140.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy80YmNBQU9Td2xMZGhpRG1oL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzIzNDI3NTczOTM2ND9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=660911291-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-234275739364-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 51,
    productCode: "ebay-us-234275739364-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_used_264357193616",
    title: "God of War PS4 [Factory Refurbished]",
    truncatedTitle: "God of War PS4 [Factory Refurbished]",
    publicItemId: "264357193616",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-10T18:51:06.000Z",
    auction: !1,
    brandName: null,
    condition: "used",
    price: 11.51,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qVpbAUa9puxGfyagBWy0xUQ5QozttC15nfxhywsoYzcqfgkhzo9ziJuh9bYsI8KrKL.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/5G0AAOSwM5Rc~qaf/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTUwMFgxNTAw/z/5G0AAOSwM5Rc~qaf/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy81RzBBQU9Td001UmN+cWFmL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzI2NDM1NzE5MzYxNj9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=368606623-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-264357193616-used&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 52,
    productCode: "ebay-us-264357193616-used",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "ebay_new_194189865184",
    title: "Metal Gear Solid HD Collection - PS3 - Brand New | Factory Sealed",
    truncatedTitle: "Metal Gear Solid HD Collection - PS3 - Brand New | Factory Sealed",
    publicItemId: "194189865184",
    source: "ebay",
    categoryId: "139973",
    merchantId: null,
    total_new: null,
    total_used: null,
    total_refurbished: null,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "ebay",
    expiring: "2021-12-06T20:02:38.000Z",
    auction: !1,
    brandName: null,
    condition: "new",
    price: 24.99,
    oldPrice: null,
    discount: null,
    freeShipping: !0,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OIGiSGemLtVWX4bzjIvWy17olGodWoXz3ccEIrmb9-qV8ZADqjwF5dGqykZPAusCQE0ij31FSxyjKlnHVgBlRbeuHSdMocODXveL86UVuryJ.jpg",
    image: "https://i.ebayimg.com/thumbs/images/g/arYAAOSw1iZgwRIC/s-l140.jpg",
    bigImage: "https://i.ebayimg.com/00/s/MTYwMFgxMjgw/z/arYAAOSw1iZgwRIC/$_3.JPG",
    imageOrigin: "aHR0cHM6Ly9pLmViYXlpbWcuY29tL3RodW1icy9pbWFnZXMvZy9hcllBQU9TdzFpWmd3UklDL3MtbDE0MC5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/ebay-logo-b979a7542e2f36b2c8c34e7eab42d592945253c2c4fe02231985bea7d3a829a8.jpg",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/shops/ebay-logo-cc8cec3059b342fd760c02db0405f8b17b60bf68f5456554f05d8a2d00b0a260.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtLzE5NDE4OTg2NTE4ND9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9NzExLTUzMjAwLTE5MjU1LTAmY2FtcGlkPTAwMDAwJnRvb2xpZD0xMDA0OSZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=014615487-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=ebay&rf_product_code=ebay-us-194189865184-new&rf_account=ebay_us&rf_position=0&rf_merchant_name=ebay&rf_merchant_id=&rf_c=&rf_from_api=true",
    position: 53,
    productCode: "ebay-us-194189865184-new",
    account: "ebay_us",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B07ZLRGJ94",
    title: "1Video Games: The Movie V",
    truncatedTitle: "1Video Games: The Movie",
    publicItemId: "B07ZLRGJ94",
    source: "amazon",
    categoryId: "2649512011",
    merchantId: null,
    total_new: 1,
    total_used: 0,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: null,
    condition: "new",
    price: 3.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTDEWDhwK_-U64YhfH4F6kO4pgpoWdv3WSypzeN4vtwPU.jpg",
    image: "https://m.media-amazon.com/images/I/61C5IggSY6L._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNjFDNUlnZ1NZNkwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.png",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDdaTFJHSjk0P1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=379172815-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B07ZLRGJ94-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=TW92aWVzICYgVFYgfCBNb3ZpZXM=&rf_from_api=true",
    position: 54,
    productCode: "amazon-us-B07ZLRGJ94-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B07ZLRGJ94",
    title: "2Video Games: The Movie V",
    truncatedTitle: "2Video Games: The Movie",
    publicItemId: "B07ZLRGJ94",
    source: "amazon",
    categoryId: "2649512011",
    merchantId: null,
    total_new: 1,
    total_used: 0,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: null,
    condition: "new",
    price: 3.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTDEWDhwK_-U64YhfH4F6kO4pgpoWdv3WSypzeN4vtwPU.jpg",
    image: "https://m.media-amazon.com/images/I/61C5IggSY6L._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNjFDNUlnZ1NZNkwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.png",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDdaTFJHSjk0P1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=379172815-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B07ZLRGJ94-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=TW92aWVzICYgVFYgfCBNb3ZpZXM=&rf_from_api=true",
    position: 55,
    productCode: "amazon-us-B07ZLRGJ94-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B07ZLRGJ94",
    title: "3Video Games: The Movie V",
    truncatedTitle: "3Video Games: The Movie",
    publicItemId: "B07ZLRGJ94",
    source: "amazon",
    categoryId: "2649512011",
    merchantId: null,
    total_new: 1,
    total_used: 0,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: null,
    condition: "new",
    price: 3.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTDEWDhwK_-U64YhfH4F6kO4pgpoWdv3WSypzeN4vtwPU.jpg",
    image: "https://m.media-amazon.com/images/I/61C5IggSY6L._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNjFDNUlnZ1NZNkwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.png",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDdaTFJHSjk0P1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=379172815-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B07ZLRGJ94-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=TW92aWVzICYgVFYgfCBNb3ZpZXM=&rf_from_api=true",
    position: 56,
    productCode: "amazon-us-B07ZLRGJ94-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B07ZLRGJ94",
    title: "4Video Games: The Movie V",
    truncatedTitle: "4Video Games: The Movie",
    publicItemId: "B07ZLRGJ94",
    source: "amazon",
    categoryId: "2649512011",
    merchantId: null,
    total_new: 1,
    total_used: 0,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: null,
    condition: "new",
    price: 3.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTDEWDhwK_-U64YhfH4F6kO4pgpoWdv3WSypzeN4vtwPU.jpg",
    image: "https://m.media-amazon.com/images/I/61C5IggSY6L._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNjFDNUlnZ1NZNkwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.png",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDdaTFJHSjk0P1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=379172815-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B07ZLRGJ94-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=TW92aWVzICYgVFYgfCBNb3ZpZXM=&rf_from_api=true",
    position: 57,
    productCode: "amazon-us-B07ZLRGJ94-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B07ZLRGJ94",
    title: "5Video Games: The Movie V",
    truncatedTitle: "5Video Games: The Movie",
    publicItemId: "B07ZLRGJ94",
    source: "amazon",
    categoryId: "2649512011",
    merchantId: null,
    total_new: 1,
    total_used: 0,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: null,
    condition: "new",
    price: 3.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTDEWDhwK_-U64YhfH4F6kO4pgpoWdv3WSypzeN4vtwPU.jpg",
    image: "https://m.media-amazon.com/images/I/61C5IggSY6L._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNjFDNUlnZ1NZNkwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.png",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDdaTFJHSjk0P1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=379172815-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B07ZLRGJ94-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=TW92aWVzICYgVFYgfCBNb3ZpZXM=&rf_from_api=true",
    position: 58,
    productCode: "amazon-us-B07ZLRGJ94-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B07ZLRGJ94",
    title: "6Video Games: The Movie V",
    truncatedTitle: "6Video Games: The Movie",
    publicItemId: "B07ZLRGJ94",
    source: "amazon",
    categoryId: "2649512011",
    merchantId: null,
    total_new: 1,
    total_used: 0,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: null,
    condition: "new",
    price: 3.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTDEWDhwK_-U64YhfH4F6kO4pgpoWdv3WSypzeN4vtwPU.jpg",
    image: "https://m.media-amazon.com/images/I/61C5IggSY6L._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNjFDNUlnZ1NZNkwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.png",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDdaTFJHSjk0P1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=379172815-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B07ZLRGJ94-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=TW92aWVzICYgVFYgfCBNb3ZpZXM=&rf_from_api=true",
    position: 59,
    productCode: "amazon-us-B07ZLRGJ94-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B07ZLRGJ94",
    title: "7Video Games: The Movie V",
    truncatedTitle: "7Video Games: The Movie",
    publicItemId: "B07ZLRGJ94",
    source: "amazon",
    categoryId: "2649512011",
    merchantId: null,
    total_new: 1,
    total_used: 0,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: null,
    condition: "new",
    price: 3.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTDEWDhwK_-U64YhfH4F6kO4pgpoWdv3WSypzeN4vtwPU.jpg",
    image: "https://m.media-amazon.com/images/I/61C5IggSY6L._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNjFDNUlnZ1NZNkwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.png",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDdaTFJHSjk0P1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=379172815-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B07ZLRGJ94-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=TW92aWVzICYgVFYgfCBNb3ZpZXM=&rf_from_api=true",
    position: 60,
    productCode: "amazon-us-B07ZLRGJ94-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }, {
    id: null,
    salesRank: null,
    alternativeId: "amazon_new_B07ZLRGJ94",
    title: "8Video Games: The Movie V",
    truncatedTitle: "8Video Games: The Movie",
    publicItemId: "B07ZLRGJ94",
    source: "amazon",
    categoryId: "2649512011",
    merchantId: null,
    total_new: 1,
    total_used: 0,
    total_refurbished: 0,
    min_hours_availability: null,
    max_hours_availability: null,
    shop: "amazon",
    expiring: null,
    auction: !1,
    brandName: null,
    condition: "new",
    price: 3.99,
    oldPrice: null,
    discount: null,
    freeShipping: !1,
    shippingPrice: 0,
    imageUrl: "//images-ssl.bestdeals.today/NjU3YTg2ZjdmNGZkM2U5OLGpT5Qixf5ZDIJcV-p2WcnqvYy8Q0bU1jJKcSep1OGTDEWDhwK_-U64YhfH4F6kO4pgpoWdv3WSypzeN4vtwPU.jpg",
    image: "https://m.media-amazon.com/images/I/61C5IggSY6L._SL500_.jpg",
    bigImage: null,
    imageOrigin: "aHR0cHM6Ly9tLm1lZGlhLWFtYXpvbi5jb20vaW1hZ2VzL0kvNjFDNUlnZ1NZNkwuX1NMNTAwXy5qcGc=",
    merchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.png",
    merchantLogoUrl: "",
    svgMerchantLogo: "https://www.bestdeals.today/assets/non-existant-merchant-logo.svg",
    originalMerchantLogo: "",
    redirectLinkTo: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDdaTFJHSjk0P1N1YnNjcmlwdGlvbklkPUFLSUFKQTU0Sk1FU1g3M0lHUFhRJmFzY3N1YnRhZz0wMDAwMDAwMDAmbGlua0NvZGU9b3NpJnBzYz0xJnRhZz1kXzJiX2FfZC0yMCZ0aD0x&click_id=379172815-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=17919056460849&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9wcm9kdWN0cz9zZWFyY2g9dmlkZW8lMjBnYW1lcw==&rf_item_id=&rf_source=amazon&rf_product_code=amazon-us-B07ZLRGJ94-new&rf_account=amazon_us_2&rf_position=0&rf_merchant_name=amazon&rf_merchant_id=&rf_c=TW92aWVzICYgVFYgfCBNb3ZpZXM=&rf_from_api=true",
    position: 61,
    productCode: "amazon-us-B07ZLRGJ94-new",
    account: "amazon_us_2",
    couponCode: null,
    dwsType: null,
    isSponsored: !1
  }],
  metadata: {
    id: 512103979,
    query: "video games",
    queryInfoTop: "Deals are available from 4 stores  and 3 brands. An additional discount is available for 4 items. Last updated on November 11, 2021.",
    queryInfoBottom: ["54 deals were found for Video Games. Deals are available from 4 stores  and 3 brands. An additional discount is available for 4 items. Last updated on November 11, 2021.", "Scanning all available deals for Video Games shows that the average price across all deals is $41.98. The lowest price is $0.00 from amazon while the highest price is $395.00 from amazon.", "The average discount we found across all deals is 31.79%, the largest discount is 46.74% for the product Minecraft - Nintendo Switch Includes Super Mario Mash-Up from ebay.", "New products prices vary between $0.00 and $395.00.", "Free shipping is offered across 3 stores - amazon, ebay, Focus Camera.", null],
    related: ["video games ps4", "video games nintendo switch", "video games for kids 8-12", "video games for kids ages 4-8", "video games xbox one"],
    locale: "us",
    description: null,
    for_adult: null,
    adult_ratio: 0,
    pageSize: 60,
    breadcrumbs: [{
      title: "Video Games",
      path: "video-games"
    }, {
      title: "Nintendo Switch",
      path: "nintendo-switch"
    }],
    noindex: !1,
    amazon_search_url: "https://www.amazon.com/s?SubscriptionId=AKIAJA54JMESX73IGPXQ&ascsubtag=000000000&k=video+games&tag=d_2b_a_d-20",
    ebay_search_url: "https://www.ebay.com/sch/i.html?_nkw=video+games&ff3=2&toolid=10041&pub=5575086808&campid=00000&customid=000000000"
  }
};

// node_modules/@roundforest/bdt-client/lib/fixtures/page-type.db.js
var electronicsMock = {
  page_type: "l1",
  popular_categories: [{
    title: "Office Products",
    img: "https://www.bestdeals.today/assets/l1_categories/office-products-49ee17832aeb456a7deacdf0b1dc7400fdddb13b220638a0d5029dd19da97d33.png",
    url: "/office-products"
  }, {
    title: "Toys & Games",
    img: "https://www.bestdeals.today/assets/l1_categories/toys-games-eba67209d7f4fa3f0250afc2a52f09af671e9594eafdca4d47afc83a97a50e4b.png",
    url: "/toys-games"
  }, {
    title: "Beauty & Personal Care",
    img: "https://www.bestdeals.today/assets/l1_categories/beauty-personal-care-6122ac70e7dd12d6d9ce824d461ba8c38b5ff84c9b9ac879793e78e57206d132.png",
    url: "/beauty-personal-care"
  }, {
    title: "Home & Kitchen",
    img: "https://www.bestdeals.today/assets/l1_categories/home-kitchen-7c22d712e0dcaabcc532ac749c18937b72c59d3347866d5ef20f73b1f97171e1.png",
    url: "/home-kitchen"
  }, {
    title: "Apps & Games",
    img: "https://www.bestdeals.today/assets/l1_categories/apps-games-b07b41ae0fffff73cd57ade76d1c5f765283f598f740c69efaa516d975440e2b.png",
    url: "/apps-games"
  }, {
    title: "Appliances",
    img: "https://www.bestdeals.today/assets/l1_categories/appliances-8b61eb1387dd18137c55ea76e00ed90e1889383534f24734f19f2accad2173a5.png",
    url: "/appliances"
  }],
  subcategories: [{
    title: "Computers & Accessories",
    img: "https://i.ebayimg.com/thumbs/imgs/g/nz0AAOSwne5fCMxH/s-l225.jpg",
    url: "/computers-accessories"
  }, {
    title: "Electronics Features",
    img: "https://i.ebayimg.com/thumbs/imgs/g/UgYAAOSwrptfzcW0/s-l225.jpg",
    url: "/electronics-features"
  }, {
    title: "Portable Audio & Video",
    img: "https://i.ebayimg.com/thumbs/imgs/g/yFcAAOSwreVh2LWv/s-l225.jpg",
    url: "/portable-audio-video"
  }, {
    title: "Headphones",
    img: "https://i.ebayimg.com/thumbs/imgs/g/xvoAAOSwK41gsUDW/s-l225.jpg",
    url: "/headphones"
  }, {
    title: "Home Audio",
    img: "https://i.ebayimg.com/thumbs/imgs/g/cYEAAOSwntNh1U9w/s-l225.jpg",
    url: "/home-audio"
  }, {
    title: "GPS, Finders & Accessories",
    img: "https://i.ebayimg.com/thumbs/imgs/g/-BwAAOSw-ldh08kt/s-l225.jpg",
    url: "/gps-finders-accessories"
  }, {
    title: "Camera & Photo",
    img: "https://i.ebayimg.com/thumbs/imgs/g/ymkAAOSwbk9geiAC/s-l225.jpg",
    url: "/camera-photo"
  }, {
    title: "Television & Video",
    img: "https://i.ebayimg.com/thumbs/imgs/g/hMQAAOSwelthZ2Bz/s-l225.jpg",
    url: "/television-video"
  }, {
    title: "Computers Features",
    img: "https://i.ebayimg.com/thumbs/imgs/g/56gAAOSw9yZhcl8O/s-l225.jpg",
    url: "/computers-features"
  }, {
    title: "Accessories & Supplies",
    img: "https://i.ebayimg.com/thumbs/imgs/g/g~gAAOSwh0Ve97Lf/s-l225.jpg",
    url: "/accessories-supplies"
  }, {
    title: "Camera & Photo Features",
    img: "https://i.ebayimg.com/thumbs/imgs/g/W80AAOSwDtRh00Ae/s-l225.jpg",
    url: "/camera-photo-features"
  }, {
    title: "Wearable Technology",
    img: "https://i.ebayimg.com/thumbs/imgs/g/7D8AAOSwcDZheJTg/s-l225.jpg",
    url: "/wearable-technology"
  }, {
    title: "Car & Vehicle Electronics",
    img: "https://i.ebayimg.com/thumbs/imgs/g/EnoAAOSw3Gthyc8y/s-l225.jpg",
    url: "/car-vehicle-electronics"
  }, {
    title: "eBook Readers & Accessories",
    img: "https://i.ebayimg.com/thumbs/imgs/g/KLcAAOSwdFlhcaJh/s-l225.jpg",
    url: "/ebook-readers-accessories"
  }, {
    title: "Electronics Warranties",
    img: "https://i.ebayimg.com/thumbs/imgs/g/IYEAAOSwt4xaWQTm/s-l225.jpg",
    url: "/electronics-warranties"
  }, {
    title: "Security & Surveillance",
    img: "https://i.ebayimg.com/thumbs/imgs/g/-ZMAAOSwTLNhCYjA/s-l225.jpg",
    url: "/security-surveillance"
  }, {
    title: "Video Projectors",
    img: "https://i.ebayimg.com/thumbs/imgs/g/AssAAOSwnmtgb3xs/s-l225.jpg",
    url: "/video-projectors"
  }, {
    title: "Video Game Consoles & Accessories",
    img: "https://i.ebayimg.com/thumbs/imgs/g/25sAAOSwm2peCkI6/s-l225.jpg",
    url: "/video-game-consoles-accessories"
  }],
  banner: "https://www.bestdeals.today/assets/l1_categories/banners/electronics-6a478f245650d6dcac6874389c84b21c4d3144d0c5c3460b27cbb79a4675ee17.png"
};
function getPageTypeDataMock(searchTerm) {
  switch (searchTerm) {
    case "electronics":
      return electronicsMock;
    case "computers accessories":
      return {
        page_type: "l2",
        popular_categories: [{
          title: "Office Products",
          img: "https://www.bestdeals.today/assets/l1_categories/office-products-49ee17832aeb456a7deacdf0b1dc7400fdddb13b220638a0d5029dd19da97d33.png",
          url: "/office-products"
        }, {
          title: "Toys & Games",
          img: "https://www.bestdeals.today/assets/l1_categories/toys-games-eba67209d7f4fa3f0250afc2a52f09af671e9594eafdca4d47afc83a97a50e4b.png",
          url: "/toys-games"
        }, {
          title: "Beauty & Personal Care",
          img: "https://www.bestdeals.today/assets/l1_categories/beauty-personal-care-6122ac70e7dd12d6d9ce824d461ba8c38b5ff84c9b9ac879793e78e57206d132.png",
          url: "/beauty-personal-care"
        }, {
          title: "Home & Kitchen",
          img: "https://www.bestdeals.today/assets/l1_categories/home-kitchen-7c22d712e0dcaabcc532ac749c18937b72c59d3347866d5ef20f73b1f97171e1.png",
          url: "/home-kitchen"
        }, {
          title: "Apps & Games",
          img: "https://www.bestdeals.today/assets/l1_categories/apps-games-b07b41ae0fffff73cd57ade76d1c5f765283f598f740c69efaa516d975440e2b.png",
          url: "/apps-games"
        }, {
          title: "Appliances",
          img: "https://www.bestdeals.today/assets/l1_categories/appliances-8b61eb1387dd18137c55ea76e00ed90e1889383534f24734f19f2accad2173a5.png",
          url: "/appliances"
        }],
        subcategories: [{
          title: "Electronics Features",
          img: "https://i.ebayimg.com/thumbs/imgs/g/UgYAAOSwrptfzcW0/s-l225.jpg",
          url: "/electronics-features"
        }, {
          title: "Portable Audio & Video",
          img: "https://i.ebayimg.com/thumbs/imgs/g/yFcAAOSwreVh2LWv/s-l225.jpg",
          url: "/portable-audio-video"
        }, {
          title: "Headphones",
          img: "https://i.ebayimg.com/thumbs/imgs/g/xvoAAOSwK41gsUDW/s-l225.jpg",
          url: "/headphones"
        }, {
          title: "Home Audio",
          img: "https://i.ebayimg.com/thumbs/imgs/g/cYEAAOSwntNh1U9w/s-l225.jpg",
          url: "/home-audio"
        }],
        banner: "https://www.bestdeals.today/assets/l1_categories/banners/electronics-6a478f245650d6dcac6874389c84b21c4d3144d0c5c3460b27cbb79a4675ee17.png"
      };
    case "video games":
      return {
        page_type: "store",
        popular_categories: null,
        subcategories: null,
        banner: null
      };
    default:
      return electronicsMock;
  }
}

// node_modules/@roundforest/bdt-client/lib/fixtures/manual-deals.db.js
function getManualDealsMock(_positions) {
  return {
    "Top Deals": {
      items: [{
        id: 1275,
        shop_image: "https://static.bestdeals.today/bdt-prod/shops/amazon-logo.svg",
        shop_name: "amazon",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtSW5zdGFudCBQb3QgVm9ydGV4IFBsdXMtLTEwLVF1YXJ0IEFpciBGcnllciwgUm90aXNzZXJpZSBhbmQgQ29udmVjdGlvbiBPdmVuLUluc3RhbnQgVm9ydGV4IFBsdXMtaW1hZ2UtMjAyMi0wMS0xMCAxMDoxOToxNCBVVEM=.jpg",
        badge_type: "Price Drop",
        title: "Instant Pot Vortex Plus Convection Oven",
        description: "A 10-quart air fryer, rotisserie, and convection oven, capable of frying, broiling, baking, roasting, dehydrating foods, and more!",
        price: 99.95,
        end_time: "2022-01-18T14:00:00.000Z",
        old_price: 139.99,
        discount: 28,
        url: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9JbnN0YW50LVZvcnRleC1QbHVzLVJvdGlzc2VyaWUtMTAvZHAvQjA3Vk0yOFhUUj9TdWJzY3JpcHRpb25JZD1BS0lBSU5JSTNYQkI0WVdOUzVMUSZhc2NzdWJ0YWc9MDAwMDAwMDAwJnRhZz1iZHRfbmV3aG9tZXBhZ2UtMjA=&click_id=067011097-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=1275&rf_source=amazon&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=amazon&rf_manual_deal=true",
        simple_source: "amazon",
        short_title: "Instant Pot Vortex Plus Convection Oven"
      }, {
        id: 1276,
        shop_image: "https://static.bestdeals.today/bdt-prod/shops/V2FsbWFydC11cw==.gif",
        shop_name: "Walmart",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtQ2hpbW5leUZyZWUgUG93ZXJoZWF0IEluZnJhcmVkIFF1YXJ0eiBFbGVjdHJpYyBTdG92ZSBIZWF0ZXItQ2hpbW5leUhlYXQgaGVhdGVyLWltYWdlLTIwMjItMDEtMTAgMTE6NDI6MzYgVVRD.jpeg",
        badge_type: "Best Value",
        title: "ChimneyFree Powerheat Infrared Quartz Electric Stove Heater",
        description: "Warms up to 1000 sq. ft., while providing an aesthetically-pleasing fireplace-look. Eco-friendly, maintaining the room's natural humidity!",
        price: 69,
        end_time: "2022-01-18T11:24:00.000Z",
        old_price: 82,
        discount: 15,
        url: "/redirect?url=aHR0cHM6Ly9nb3RvLndhbG1hcnQuY29tL2MvMzUzNDgzLzU2NjcxOS85MzgzP3N1YklkMT1bMV0mc3ViSWQyPVsyXSZzdWJJZDM9WzNdJnNoYXJlZGlkPVs0XSZ2ZWg9YWZmJnNvdXJjZWlkPWltcF8wMDAwMTExMTIyMjIzMzMzNDQmdT1odHRwcyUzQSUyRiUyRnd3dy53YWxtYXJ0LmNvbSUyRmlwJTJGQ2hpbW5leUZyZWUtUG93ZXJoZWF0LUluZnJhcmVkLVF1YXJ0ei1FbGVjdHJpYy1TdG92ZS1IZWF0ZXIlMkY4MDc4MjUyNTU=&click_id=032503448-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=1276&rf_source=walmart.com_deeplink&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=Walmart&rf_manual_deal=true",
        simple_source: "walmart.com",
        short_title: "ChimneyFree Powerheat Infrared Quartz..."
      }, {
        id: 1277,
        shop_image: "https://static.bestdeals.today/bdt-prod/shops/V2FsbWFydC11cw==.gif",
        shop_name: "Walmart",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtVENMIDU1IiA0SyBVSEQgUm9rdSBTbWFydCBUVi1UQ0wgNTUiIFRWLWltYWdlLTIwMjItMDEtMTAgMTI6Mzk6NTQgVVRD.jpeg",
        badge_type: "On Fire",
        title: 'TCL 55" 4K UHD Roku Smart TV',
        description: "Provides high-dynamic-range technology to enjoy thousands of channels of TV shows, movies, sporting events with breathtaking resolution! Can be coupled with a cable box, Blu-ray player, gaming console, and more!",
        price: 319,
        end_time: "2022-01-18T12:02:00.000Z",
        old_price: 599.99,
        discount: 46,
        url: "/redirect?url=aHR0cHM6Ly9nb3RvLndhbG1hcnQuY29tL2MvMzUzNDgzLzU2NjcxOS85MzgzP3N1YklkMT1bMV0mc3ViSWQyPVsyXSZzdWJJZDM9WzNdJnNoYXJlZGlkPVs0XSZ2ZWg9YWZmJnNvdXJjZWlkPWltcF8wMDAwMTExMTIyMjIzMzMzNDQmdT1odHRwcyUzQSUyRiUyRnd3dy53YWxtYXJ0LmNvbSUyRmlwJTJGVENMLTU1LUNsYXNzLTQtU2VyaWVzLTRLLVVIRC1IRFItUm9rdS1TbWFydC1UVi01NVM0MzElMkYyNzY5NjQ5MDM=&click_id=138329241-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=1277&rf_source=walmart.com_deeplink&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=Walmart&rf_manual_deal=true",
        simple_source: "walmart.com",
        short_title: 'TCL 55" 4K UHD Roku Smart TV'
      }, {
        id: 1278,
        shop_image: "https://static.bestdeals.today/bdt-prod/shops/amazon-logo.svg",
        shop_name: "amazon",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtTm9yZGljVHJhY2sgVCBTZXJpZXMgVHJlYWRtaWxscy1Ob3JkaWMgVHJhY2sgVCBTZXJpZXMtaW1hZ2UtMjAyMi0wMS0xMCAxMzo1NDo0NyBVVEM=.jpg",
        badge_type: "Price Drop",
        title: "NordicTrack T Series Treadmills",
        description: "Allows for speed, interval, and endurance training. Folds up easily and compactly after use! Comes with a 30-day iFit membership to training sessions!",
        price: 549,
        end_time: "2022-01-18T13:43:00.000Z",
        old_price: 649,
        discount: 15,
        url: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDE5M1YzREo2L3JlZj12YV9saXZlX2Nhcm91c2VsP1N1YnNjcmlwdGlvbklkPUFLSUFJTklJM1hCQjRZV05TNUxRJmFzY3N1YnRhZz0wMDAwMDAwMDAmdGFnPWJkdF9uZXdob21lcGFnZS0yMA==&click_id=010207160-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=1278&rf_source=amazon&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=amazon&rf_manual_deal=true",
        simple_source: "amazon",
        short_title: "NordicTrack T Series Treadmills"
      }, {
        id: 1279,
        shop_image: "https://static.bestdeals.today/bdt-prod/shops/V2F5ZmFpci11cw==.gif",
        shop_name: "Wayfair",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtRGF6aWVsIE1pY3JvZmliZXIgQ29tZm9ydGVyIFNldC1EYXppZWwrTWljcm9maWJlcitQb2x5ZXN0ZXIrTW9kZXJuKyYrQ29udGVtcG9yYXJ5K0NvbWZvcnRlcitTZXQtaW1hZ2UtMjAyMi0wMS0xMCAxNDo0NjoxMCBVVEM=.jpg",
        badge_type: "On Fire",
        title: "Daziel Microfiber Comforter Set",
        description: "This set includes a comforter and two pillow shams. Available in twin, Queen, and King sizes, and 4 soft-toned colors!",
        price: 55.83,
        end_time: "2022-01-18T14:12:00.000Z",
        old_price: 109.99,
        discount: 49,
        url: "/redirect?url=aHR0cHM6Ly93d3cud2F5ZmFpci5jb20vYmVkLWJhdGgvcGRwL2dlb3JnZS1vbGl2ZXItZGF6aWVsLWNvbWZvcnRlci1zZXQtdzAwNTQ4MzYyMC5odG1sJmN1c3RvbWlkPTAwMDAwMDAwMA==&click_id=718787213-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=1279&rf_source=bizrate.com_deeplink&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=Wayfair&rf_manual_deal=true",
        simple_source: "bizrate.com",
        short_title: "Daziel Microfiber Comforter Set"
      }, {
        id: 1238,
        shop_image: "https://static.bestdeals.today/bdt-prod/shops/amazon-logo.svg",
        shop_name: "amazon",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtQ29yZWR5IFJvYm90IFZhY3V1bSBDbGVhbmVyLTcxT2hWQWlwZzFMLWltYWdlLTIwMjAtMDUtMTAgMTM6MDA6NDkgVVRD._AC_SL1200_",
        badge_type: "Best Value",
        title: "Coredy Robot Vacuum Cleaner",
        description: "3-in-1 Sweep Vacuum Mop Robotic Vacuum Cleaner: R500+ is a 7.2cm super thin robot vacuum cleaner, eliminate dirt from under beds, sofa and hard to reach areas with zero effort. Include 3-point cleaning system and dual edge-brushes, works on hard floors and carpets to clean the dust and pet hair.",
        price: 136,
        end_time: "2025-07-31T12:53:00.000Z",
        old_price: 189.99,
        discount: 28,
        url: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9Db3JlZHktUm9ib3QtVmFjdXVtLUNsZWFuZXItQWxsLU5ldy9kcC9CMDdMMllCOE5XL3JlZj1nYnBzX2ltZ19tLTlfNDc1ZV81NmNkODliMD9TdWJzY3JpcHRpb25JZD1BS0lBSU5JSTNYQkI0WVdOUzVMUSZhc2NzdWJ0YWc9MDAwMDAwMDAwJnBmX3JkX2k9MTU1Mjk2MDkwMTEmcGZfcmRfbT1BVFZQREtJS1gwREVSJnBmX3JkX3A9NWQ4NmRlZjItZWMxMC00MzY0LTkwMDgtOGZiY2NmMzA0NzVlJnBmX3JkX3I9Sk1DTkRSRTRRQVQ2NzRWOEhCQzkmcGZfcmRfcz1tZXJjaGFuZGlzZWQtc2VhcmNoLTkmcGZfcmRfdD0xMDEmc21pZD1BMTVXNVdQOFU3MDRPNCZzcExhPVpXNWpjbmx3ZEdWa1VYVmhiR2xtYVdWeVBVRXlPRUpQUmpSTk0xVkpTazBtWlc1amNubHdkR1ZrU1dROVFUQTNNREE1T1RNeVV6azRVRk5GUkZVeFMwSkxKbVZ1WTNKNWNIUmxaRUZrU1dROVFUQTVPRFV3TWpNeU5WbzRXRWxaUmxGUVZFNVdKbmRwWkdkbGRFNWhiV1U5YzNCZloySmZiV0ZwYmw5emRYQndiR1VtWVdOMGFXOXVQV05zYVdOclVtVmthWEpsWTNRbVpHOU9iM1JNYjJkRGJHbGphejEwY25WbCZ0YWc9YmR0X25ld2hvbWVwYWdlLTIw&click_id=203650719-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=1238&rf_source=amazon&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=amazon&rf_manual_deal=true",
        simple_source: "amazon",
        short_title: "Coredy Robot Vacuum Cleaner"
      }, {
        id: 1227,
        shop_image: "https://static.bestdeals.today/bdt-prod/shops/V2FsbWFydC11cw==.gif",
        shop_name: "Walmart",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtTGF1cmEgR2VsbGVyIEdpbGRlZCBIb25leSBNYWtldXAgU2V0LUxhdXJhIEdlbGxlciBtYWtldXBfbW9kaWZpZWQtaW1hZ2UtMjAyMC0wNC0yNCAwNzo1MDo0MyBVVEM=.jpg",
        badge_type: "Price Drop",
        title: "Laura Geller Gilded Honey Makeup Set",
        description: "Includes highlighter, lip gloss, and body spray!",
        price: 27.99,
        end_time: "2025-07-31T15:00:00.000Z",
        old_price: 35,
        discount: 20,
        url: "/redirect?url=aHR0cHM6Ly9nb3RvLndhbG1hcnQuY29tL2MvMzUzNDgzLzU2NjcxOS85MzgzP3N1YklkMT1bMV0mc3ViSWQyPVsyXSZzdWJJZDM9WzNdJnNoYXJlZGlkPVs0XSZ2ZWg9YWZmJnNvdXJjZWlkPWltcF8wMDAwMTExMTIyMjIzMzMzNDQmdT1odHRwcyUzQSUyRiUyRnd3dy53YWxtYXJ0LmNvbSUyRmlwJTJGODAtVmFsdWUtTGF1cmEtR2VsbGVyLUdpbGRlZC1Ib25leS1CZXN0LVNlbGxlcnMtTWFrZXVwLUdpZnQtU2V0LUhpZ2hsaWdodGVyLU1ha2V1cC1MaXAtR2xvc3MtQm9keS1TcHJheSUyRjMxNDA4MDgxNg==&click_id=095479972-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=1227&rf_source=walmart.com_deeplink&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=Walmart&rf_manual_deal=true",
        simple_source: "walmart.com",
        short_title: "Laura Geller Gilded Honey Makeup Set"
      }, {
        id: 1242,
        shop_image: "https://static.bestdeals.today/bdt-prod/shops/amazon-logo.svg",
        shop_name: "amazon",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtZ2FyZGVuaW5nIHRvb2xzLWRvd25sb2FkICgxKS1pbWFnZS0yMDIwLTA2LTE4IDA4OjMwOjA0IFVUQw==.jpeg",
        badge_type: "Best Value",
        title: "FANHAO Garden Tool Set, 5 Piece Aluminum Heavy Duty Gardening Tool Set",
        description: "Top Quality No rusting Aluminum. FANHAO Garden tools set contains 5 pieces high quality Gardening tools. Perfect for all your garden needs.",
        price: 32.9,
        end_time: "2025-07-31T08:22:00.000Z",
        old_price: 45,
        discount: 26,
        url: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9kcC9CMDgyTkxRQ0hXP1N1YnNjcmlwdGlvbklkPUFLSUFJTklJM1hCQjRZV05TNUxRJmFzY3N1YnRhZz0wMDAwMDAwMDAmdGFnPWJkdF9uZXdob21lcGFnZS0yMA==&click_id=790127937-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=1242&rf_source=amazon&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=amazon&rf_manual_deal=true",
        simple_source: "amazon",
        short_title: "FANHAO Garden Tool Set, 5 Piece Alumi..."
      }, {
        id: 1223,
        shop_image: "https://static.bestdeals.today/bdt-prod/shops/ebay-logo.svg",
        shop_name: "ebay",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtQ2xhc3NpYyBGaWdhcm8gTGluayBCcmFjZWxldC1GaWdhcm8gYnJhY2VsZXRfbW9kaWZpZWQtaW1hZ2UtMjAyMC0wNC0yMyAxNTozMDoyOCBVVEM=.jpg",
        badge_type: "On Fire",
        title: "Classic Figaro Link Bracelet",
        description: 'An 8.5" bronze bracelet, plated with 18K gold!',
        price: 10,
        end_time: "2025-07-31T15:00:00.000Z",
        old_price: 109,
        discount: 90,
        url: "/redirect?url=aHR0cHM6Ly93d3cuZWJheS5jb20vaXRtL0l0YWxpYW4tTWFkZS1DbGFzc2ljLUZpZ2Fyby1MaW5rLUJyYWNlbGV0LWluLTE4Sy1Hb2xkLVBsYXRlZC1Ccm9uemUtOC01LzI2NDU0NjI5Mjk4NT9ta2V2dD0xJm1rY2lkPTEmbWtyaWQ9JmNhbXBpZD0wMDAwMCZ0b29saWQ9MTAwNDkmY3VzdG9taWQ9MDAwMDAwMDAw&click_id=087151595-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=1223&rf_source=ebay_deeplink&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=ebay&rf_manual_deal=true",
        simple_source: "ebay",
        short_title: "Classic Figaro Link Bracelet"
      }],
      duration: 11199422681063819e-8
    },
    Offers: {
      items: [{
        id: 1269,
        badge_type: "On Fire",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtU2F2ZSB1cCB0byA1MCUgb24gTWFkZGVuIE5GTCAyMiBDb21wdXRlciBHYW1lcyEtZm9vdGJhbGwtaW1hZ2UtMjAyMS0xMi0yOCAxMzo1MjozMyBVVEM=.jpg",
        additional_image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtU2F2ZSB1cCB0byA1MCUgb24gTWFkZGVuIE5GTCAyMiBDb21wdXRlciBHYW1lcyEtQW1hem9uX2xvZ29fUE5HMy1hZGRpdGlvbmFsX2ltYWdlLTIwMjEtMTItMjggMTM6NTI6MzMgVVRD.png",
        title: "Save up to 50% on Madden NFL 22 Computer Games!",
        shop_name: "amazon",
        end_time: "2022-01-28T12:10:00.000Z",
        url: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9zdG9yZXMvcGFnZS9wcmV2aWV3P1N1YnNjcmlwdGlvbklkPUFLSUFJTklJM1hCQjRZV05TNUxRJmFzY3N1YnRhZz0wMDAwMDAwMDAmYXNpbnM9QjA5Nk5CMUpTOSUyQ0IwOTZOQ1o5RzIlMkNCMDk2TkdMVzc4JTJDQjA5Nk5CMzExSCUyQ0IwOThLVkNGTTglMkNCMDk4S1ZTRjlSJTJDQjA5OEtTMTJOTCUyQ0IwOThLVllXUUQlMkNCMDk4S1ZIWjNQJTJDQjA5RDIzNzg1UCUyQ0IwOUQxV0hRWUYlMkNCMDlEMVozVE5EJTJDQjA5RDIyUTRaSiUyQ0IwOTI1SEg5WVQlMkNCMDkyTkc2ODVNJTJDQjA5MjVIRDdRNSUyQ0IwOE1YVERHTjYlMkNCMDhNWFZOWldQJTJDQjA4UTQzQktIRyUyQ0IwOFEzVjJUWFYlMkNCMDhUNDg4MjU5JTJDQjA4NjlHSzJNSyUyQyZpc1ByZXZpZXc9MSZpc1NscD0xJnJlZj1kbHhfZGVhbHNfZ2RfZGNsX2ltZ184Xzk1MTI1ODIwX2R0X3NsMTVfZDgmdGFnPWJkdF9uZXdob21lcGFnZS0yMA==&click_id=639853195-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=1269&rf_source=amazon&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=amazon&rf_manual_deal=true",
        simple_source: "amazon",
        short_title: "Save up to 50% on Madden NFL 22 Compu..."
      }, {
        id: 72,
        badge_type: "Crowd\u2019s Favorite",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtQW1hem9uIENvdXBvbnMtYW1hem9uLWNvdXBvbi1pbWFnZS0yMDE5LTExLTI2IDE1OjE0OjM5IFVUQw==.jpg",
        additional_image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtQW1hem9uIENvdXBvbnMtQ2FwdHVyZS1hZGRpdGlvbmFsX2ltYWdlLTIwMjAtMDItMTcgMDk6MjY6NTkgVVRD.PNG",
        title: "Save up to 50% off with AMAZON coupons!",
        shop_name: "amazon",
        end_time: "2025-07-31T15:00:00.000Z",
        url: "/redirect?url=aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9jb3Vwb25zP1N1YnNjcmlwdGlvbklkPUFLSUFJTklJM1hCQjRZV05TNUxRJmFzY3N1YnRhZz0wMDAwMDAwMDAmdGFnPWJkdF9uZXdob21lcGFnZS0yMA==&click_id=049885590-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=72&rf_source=amazon&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=amazon&rf_manual_deal=true",
        simple_source: "amazon",
        short_title: "Save up to 50% off with AMAZON coupons!"
      }, {
        id: 990,
        badge_type: "On Fire",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtU2F2ZSBhcyBtdWNoIGFzIDUwJSBvbiBZb2dhIEVxdWlwbWVudCBTZXRzIS1waG90by1vZi13b21hbi1kb2luZy15b2dhLTIyOTQzNTNfbW9kaWZpZWQtaW1hZ2UtMjAyMC0wMy0yNSAxNDozOTo1OSBVVEM=.jpg",
        additional_image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtU2F2ZSBhcyBtdWNoIGFzIDUwJSBvbiBZb2dhIEVxdWlwbWVudCBTZXRzIS13YWxtYXJ0LWFkZGl0aW9uYWxfaW1hZ2UtMjAyMC0wMy0yNSAxNDozOTo1OSBVVEM=.png",
        title: "Save as much as 50% on Yoga Equipment Sets!",
        shop_name: "Walmart",
        end_time: "2025-07-31T15:00:00.000Z",
        url: "/redirect?url=aHR0cHM6Ly9nb3RvLndhbG1hcnQuY29tL2MvMzUzNDgzLzU2NjcxOS85MzgzP3N1YklkMT1bMV0mc3ViSWQyPVsyXSZzdWJJZDM9WzNdJnNoYXJlZGlkPVs0XSZ2ZWg9YWZmJnNvdXJjZWlkPWltcF8wMDAwMTExMTIyMjIzMzMzNDQmdT1odHRwcyUzQSUyRiUyRnd3dy53YWxtYXJ0LmNvbSUyRmJyb3dzZSUyRnNwb3J0cy1vdXRkb29ycyUyRnlvZ2Eta2l0cyUyRjQxMjVfNDEzNF8xMDc4Mzg0XzEwNzgzODg=&click_id=343968322-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=990&rf_source=walmart.com_deeplink&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=Walmart&rf_manual_deal=true",
        simple_source: "walmart.com",
        short_title: "Save as much as 50% on Yoga Equipment..."
      }, {
        id: 814,
        badge_type: "On Fire",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtU2F2ZSBhcyBtdWNoIGFzIDYwJSBvbiBNZW4ncyAmIFdvbWVuJ3MgRnJhZ3JhbmNlcyEtcGVyZnVtZXMtaW1hZ2UtMjAyMC0wMy0wMSAxMDowNjo0MiBVVEM=.jpg",
        additional_image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtU2F2ZSBhcyBtdWNoIGFzIDYwJSBvbiBNZW4ncyAmIFdvbWVuJ3MgRnJhZ3JhbmNlcyEtd2FsbWFydC1hZGRpdGlvbmFsX2ltYWdlLTIwMjAtMDMtMDEgMTA6MDY6NDMgVVRD.png",
        title: "Save as much as 60% on Men's & Women's Fragrances!",
        shop_name: "Walmart",
        end_time: "2025-07-31T15:00:00.000Z",
        url: "/redirect?url=aHR0cHM6Ly9nb3RvLndhbG1hcnQuY29tL2MvMzUzNDgzLzU2NjcxOS85MzgzP3N1YklkMT1bMV0mc3ViSWQyPVsyXSZzdWJJZDM9WzNdJnNoYXJlZGlkPVs0XSZ2ZWg9YWZmJnNvdXJjZWlkPWltcF8wMDAwMTExMTIyMjIzMzMzNDQmdT1odHRwcyUzQSUyRiUyRnd3dy53YWxtYXJ0LmNvbSUyRmJyb3dzZSUyRmJlYXV0eS1kZWFscyUyRjAlM0ZfYmVfc2hlbGZfaWQlM0Q3NTk4OTkzJTI2Y2F0X2lkJTNEMCUyNmZhY2V0JTNEc2hlbGZfaWQlMjUzQTc1OTg5OTMlMjU3QyUyNTdDc3BlY2lhbF9vZmZlcnMlMjUzQVJlZHVjZWQlMkJQcmljZSUyNTdDJTI1N0NjYXRlZ29yeSUyNTNBV29tZW4lMjUyN3MlMkJGcmFncmFuY2U=&click_id=474338470-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=814&rf_source=walmart.com_deeplink&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=Walmart&rf_manual_deal=true",
        simple_source: "walmart.com",
        short_title: "Save as much as 60% on Men's & Women'..."
      }, {
        id: 1220,
        badge_type: "Best Value",
        image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtU2F2ZSBvdmVyIDMwJSBvbiBTZWxlY3QgU3R5bGlzaCBWYXNlcyEtYXNzb3J0ZWQtZ29sZC1wbGF0ZWQtdGFibGUtZmlndXJpbmVzLTEwOTk4MTZfbW9kaWZpZWQtaW1hZ2UtMjAyMC0wNC0yMyAxMDo1MjoyOCBVVEM=.jpg",
        additional_image: "https://static.bestdeals.today/bdt-prod/manual-deals/MTYtU2F2ZSBvdmVyIDMwJSBvbiBTZWxlY3QgU3R5bGlzaCBWYXNlcyEtd2F5ZmFpci1hZGRpdGlvbmFsX2ltYWdlLTIwMjAtMDQtMjMgMTA6NTI6MjggVVRD.png",
        title: "Save over 30% on Select Stylish Vases!",
        shop_name: "Wayfair",
        end_time: "2025-07-31T15:00:00.000Z",
        url: "/redirect?url=aHR0cHM6Ly93d3cud2F5ZmFpci5jb20vZGVjb3ItcGlsbG93cy9zYjAvdmFzZXMtdXJucy1qYXJzLWJvdHRsZXMtYzIxNTQ1OS5odG1sPyZjdXN0b21pZD0wMDAwMDAwMDA=&click_id=767511375-16-626232018.1636531292&ga_uuid=UA-58304533-1&user_id=74829508505280&page_load_id=84883901774533&rffrf=aHR0cHM6Ly93d3cuYmVzdGRlYWxzLnRvZGF5L2FwaS92MS9tYW51YWxfZGVhbHM/bG9jYXRpb249SG9tZSBQYWdlJnBvc2l0aW9uc1tdPVRvcCBEZWFscyZwb3NpdGlvbnNbXT1PZmZlcnMmcG9zaXRpb25zW109Q291cG9ucw==&rf_item_id=1220&rf_source=bizrate.com_deeplink&rf_product_code=Manual Deal&rf_position=0&rf_merchant_name=Wayfair&rf_manual_deal=true",
        simple_source: "bizrate.com",
        short_title: "Save over 30% on Select Stylish Vases!"
      }],
      duration: 11199422680070628e-8
    },
    Coupons: {
      items: [],
      duration: 0
    },
    "Top Offers": void 0,
    Banners: void 0,
    Popups: void 0
  };
}

// node_modules/@roundforest/bdt-client/lib/fixtures/categories.db.js
var categoriesMock = [{
  title: "Appliances",
  img: "https://www.bestdeals.today/assets/l1_categories/appliances-8b61eb1387dd18137c55ea76e00ed90e1889383534f24734f19f2accad2173a5.png",
  url: "/appliances"
}, {
  title: "Apps & Games",
  img: "https://www.bestdeals.today/assets/l1_categories/apps-games-b07b41ae0fffff73cd57ade76d1c5f765283f598f740c69efaa516d975440e2b.png",
  url: "/apps-games"
}, {
  title: "Arts, Crafts & Sewing",
  img: "https://www.bestdeals.today/assets/l1_categories/arts-crafts-sewing-5f2b12fb6280be455889ae5dd23b42b3a9560ac67a117ac1fee37e3f5b3f0deb.png",
  url: "/arts-crafts-sewing"
}, {
  title: "Automotive",
  img: "https://www.bestdeals.today/assets/l1_categories/automotive-4fc39061d6ae5b538b467863d78625f8a54b2e21972f917160df3bd3169985e7.png",
  url: "/automotive"
}, {
  title: "Baby Products",
  img: "https://www.bestdeals.today/assets/l1_categories/baby-products-08a9f23ca2dabfef60d6789329afd4fb736c9e884a54964fd88b0eb4dc40643e.png",
  url: "/baby-products"
}, {
  title: "Beauty & Personal Care",
  img: "https://www.bestdeals.today/assets/l1_categories/beauty-personal-care-6122ac70e7dd12d6d9ce824d461ba8c38b5ff84c9b9ac879793e78e57206d132.png",
  url: "/beauty-personal-care"
}, {
  title: "Books",
  img: "https://www.bestdeals.today/assets/l1_categories/books-e207ee51e888c8630056d4bd4a0dca121d25532c57b8ba6be80d698b660fcd0c.png",
  url: "/books"
}, {
  title: "Cell Phones & Accessories",
  img: "https://www.bestdeals.today/assets/l1_categories/cell-phones-accessories-ddfcd768db5ac1ed7ae248038dc3bdd2e84124eeb30c999a0f0f851955e509e7.png",
  url: "/cell-phones-accessories"
}, {
  title: "Clothing, Shoes & Jewelry",
  img: "https://www.bestdeals.today/assets/l1_categories/clothing-shoes-jewelry-0e2de1e90fd3154892904e14c3b0a88070133402989a33c3286055c826965aae.png",
  url: "/clothing-shoes-jewelry"
}, {
  title: "Collectibles & Fine Art",
  img: "https://www.bestdeals.today/assets/l1_categories/collectibles-fine-art-f5dd4854f1f972478c503d4e2e333ce8a044154f1f97eb5de56e4ed64d06974e.png",
  url: "/collectibles-fine-art"
}, {
  title: "Credit & Payment Cards",
  img: "https://www.bestdeals.today/assets/l1_categories/credit-payment-cards-55e61483e7a156658643cf42a3cb31ccfa0126eb10ef9a91183254316c945df6.png",
  url: "/credit-payment-cards"
}, {
  title: "Digital Music",
  img: "https://www.bestdeals.today/assets/l1_categories/digital-music-650269a233703a8a6b194477051ee084c15857ed05e205d267548172c0219872.png",
  url: "/digital-music"
}, {
  title: "Electronics",
  img: "https://www.bestdeals.today/assets/l1_categories/electronics-d363b9cb9e1d1dbb2674f35e6c44c4cf0a4f2adb20ef1f3ab349a1242f54edc9.png",
  url: "/electronics"
}, {
  title: "Grocery & Gourmet Food",
  img: "https://www.bestdeals.today/assets/l1_categories/grocery-gourmet-food-818ed2016cb287a3eddaf2592121893e28abcc0e7c623d578ca650b978788077.png",
  url: "/grocery-gourmet-food"
}, {
  title: "Handmade Products",
  img: "https://www.bestdeals.today/assets/l1_categories/handmade-products-012672785036b3b86dcc26c280ab2369b0920c04fd330e2ed36c6b01af7bb96c.png",
  url: "/handmade-products"
}, {
  title: "Health & Household",
  img: "https://www.bestdeals.today/assets/l1_categories/health-household-8737e8abb90095f9ac250a9a42c742b65e246054592f4aa74a52d1450238ff7a.png",
  url: "/health-household"
}, {
  title: "Home & Business Services",
  img: "https://www.bestdeals.today/assets/l1_categories/home-business-services-7d9a9d1ee7fd30b8a7c472da9604e5c4a7607ad5bb36021c5cb2b36834451a1b.png",
  url: "/home-business-services"
}, {
  title: "Home & Kitchen",
  img: "https://www.bestdeals.today/assets/l1_categories/home-kitchen-7c22d712e0dcaabcc532ac749c18937b72c59d3347866d5ef20f73b1f97171e1.png",
  url: "/home-kitchen"
}, {
  title: "Industrial & Scientific",
  img: "https://www.bestdeals.today/assets/l1_categories/industrial-scientific-37e77555184fe4fbeceff1fe4b0c54e4e96f342ed7e726cf10fd0b41f3d58e25.png",
  url: "/industrial-scientific"
}, {
  title: "Kindle Store",
  img: "https://www.bestdeals.today/assets/l1_categories/kindle-store-fa2df0a8187201981c4ca070d4ec8dab9110d666fbd1c52b0c6dc2ae5782ed64.png",
  url: "/kindle-store"
}, {
  title: "Magazine Subscriptions",
  img: "https://www.bestdeals.today/assets/l1_categories/magazine-subscriptions-49a1a9dedeaae6dcdcf3f6b7ff00ecb24adebe365c7b9b809ffdfd7c2226c1f3.png",
  url: "/magazine-subscriptions"
}, {
  title: "Movies & TV",
  img: "https://www.bestdeals.today/assets/l1_categories/movies-tv-d7c8874777dc97b06d4ac8a6ba6b96fa4da18a8571304d036a73364fe3bd5892.png",
  url: "/movies-tv"
}, {
  title: "Musical Instruments",
  img: "https://www.bestdeals.today/assets/l1_categories/musical-instruments-a57b1ec3486deab759264b310dd915a14f7725976ba1f79fe4dec011fe184973.png",
  url: "/musical-instruments"
}, {
  title: "Office Products",
  img: "https://www.bestdeals.today/assets/l1_categories/office-products-49ee17832aeb456a7deacdf0b1dc7400fdddb13b220638a0d5029dd19da97d33.png",
  url: "/office-products"
}, {
  title: "Patio, Lawn & Garden",
  img: "https://www.bestdeals.today/assets/l1_categories/patio-lawn-garden-de58edfb9f60c69d7db49ed3aadceb29f7639c6ec1e8c22e08a2a9bafe8210dd.png",
  url: "/patio-lawn-garden"
}, {
  title: "Pet Supplies",
  img: "https://www.bestdeals.today/assets/l1_categories/pet-supplies-0ae03d57ef271fabad998e6d61f91e1f001ba5755fb7241a2a630b0fff82a84a.png",
  url: "/pet-supplies"
}, {
  title: "Software",
  img: "https://www.bestdeals.today/assets/l1_categories/software-8d7fcd634f77e91f96c9c6475b1dd11a1de6d12c778bf163fbcd1376a0e68114.png",
  url: "/software"
}, {
  title: "Sports & Outdoors",
  img: "https://www.bestdeals.today/assets/l1_categories/sports-outdoors-87c0221207330d538b6f124e01f76bec0b0c892d9c2186241433633e62ad737c.png",
  url: "/sports-outdoors"
}, {
  title: "Tools & Home Improvement",
  img: "https://www.bestdeals.today/assets/l1_categories/tools-home-improvement-ff06ccd99b5264dc0e2a60a3f88e992e08eb4345a2f696242e88e2149bf384e2.png",
  url: "/tools-home-improvement"
}, {
  title: "Toys & Games",
  img: "https://www.bestdeals.today/assets/l1_categories/toys-games-eba67209d7f4fa3f0250afc2a52f09af671e9594eafdca4d47afc83a97a50e4b.png",
  url: "/toys-games"
}, {
  title: "Video Games",
  img: "https://www.bestdeals.today/assets/l1_categories/video-games-abc11d3c2205d64878de970642b431f7080a9bd929acc66d3b94df3974f0a650.png",
  url: "/video-games"
}];

// node_modules/@roundforest/bdt-client/lib/bdt-client-fake.js
function makeClient3() {
  return {
    getProductsAndMetadata,
    submitContactForm,
    getPageTypeData,
    getManualDeals,
    trackRequest,
    registerEmail,
    getAllCategories,
    TEST_clear: () => {
    }
  };
  async function submitContactForm() {
  }
  async function registerEmail(data) {
    let dataForApi = {
      email: data.email,
      app_id: data.appId,
      user_id: data.userId,
      subscription_location: data.subscriptionLocation
    };
    if (dataForApi.email === "test@test.com")
      return {
        type: "0"
      };
    if (dataForApi.email === "test1@test.com")
      return {
        type: "1"
      };
    if (dataForApi.email === "test2@test.com")
      return {
        type: "2"
      };
    throw Error;
  }
  async function getProductsAndMetadata() {
    let {
      products,
      metadata
    } = mockData, normalizedProducts = camelcaseKeys(products), normalizedMetadata = camelcaseKeys(metadata);
    return {
      products: normalizedProducts.map((product) => ({
        ...product,
        clickId: 123456
      })),
      metadata: normalizedMetadata
    };
  }
  async function getPageTypeData(_commonBdtParameters, searchTerm) {
    let slugAsText = slugToText(searchTerm, {
      capitalize: !1
    }), {
      page_type,
      popular_categories,
      subcategories,
      banner
    } = await getPageTypeDataMock(slugAsText), popularCategories = normalizePageTypeCategories(popular_categories || []), normalizedSubcategories = normalizePageTypeCategories(subcategories || []);
    return {
      banner,
      pageType: page_type,
      popularCategories,
      subcategories: normalizedSubcategories
    };
  }
  async function getManualDeals({
    positions
  }) {
    let response = getManualDealsMock(positions);
    return {
      topDeals: getManualDealsByPositionOrUndefined(positions, "Top Deals", response),
      topOffers: getManualDealsByPositionOrUndefined(positions, "Top Offers", response),
      popups: getManualDealsByPositionOrUndefined(positions, "Popups", response),
      banners: getManualDealsByPositionOrUndefined(positions, "Banners", response),
      coupons: getManualDealsByPositionOrUndefined(positions, "Coupons", response),
      offers: getManualDealsByPositionOrUndefined(positions, "Offers", response)
    };
  }
  async function trackRequest(_commonBdtParameters) {
    return {
      traffic: {
        type: "direct"
      },
      trackRequestCookies: {}
    };
  }
  async function getAllCategories() {
    return categoriesMock;
  }
}

// server/clients.ts
var client2 = makeClient2("https://www.bestdeals.today/bdt-store-page/api/"), fakeClient = makeClient3();
var getFakeData = async (searchTerm) => {
  try {
    return await fakeClient.getProductsAndMetadata(searchTerm);
  } catch (e2) {
    throw e2;
  }
};

// app/routes/products.$searchTerm.tsx
var import_jsx_dev_runtime11 = __toESM(require_jsx_dev_runtime()), loader = async ({ params }) => {
  let { searchTerm } = params, data = await getFakeData(searchTerm || "");
  return (0, import_node2.json)(data);
};
async function action({ request }) {
  let formData = await request.formData(), byFixedPrice = formData.getAll("byFixedPrice"), byDiscounted = formData.getAll("byDiscounted"), byStore = formData.getAll("byStore"), byCondition = formData.getAll("byCondition"), byBrand = formData.getAll("byBrand"), byShipping = formData.getAll("byShipping");
  return (0, import_node2.json)({ filters: { byBrand, byFixedPrice, byDiscounted, byStore, byCondition, byShipping } });
}
function MainRoute() {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)("main", { className: "flex flex-col", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(appbar_default, {}, void 0, !1, {
      fileName: "app/routes/products.$searchTerm.tsx",
      lineNumber: 34,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(content_default, {}, void 0, !1, {
      fileName: "app/routes/products.$searchTerm.tsx",
      lineNumber: 35,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(footer_default, {}, void 0, !1, {
      fileName: "app/routes/products.$searchTerm.tsx",
      lineNumber: 36,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/routes/products.$searchTerm.tsx",
    lineNumber: 33,
    columnNumber: 5
  }, this);
}

// app/routes/products.tsx
var products_exports = {};
__export(products_exports, {
  action: () => action2,
  default: () => Products
});
var import_node3 = __toESM(require_dist2()), import_react10 = __toESM(require_dist3()), import_jsx_dev_runtime12 = __toESM(require_jsx_dev_runtime());
async function action2({ request }) {
  let query = (await request.formData()).get("search-query");
  return (0, import_node3.redirect)(`/products/${query}`);
}
function Products() {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(import_react10.Outlet, {}, void 0, !1, {
    fileName: "app/routes/products.tsx",
    lineNumber: 12,
    columnNumber: 10
  }, this);
}

// app/routes/healthz.tsx
var healthz_exports = {};
__export(healthz_exports, {
  default: () => Products2
});
var import_jsx_dev_runtime13 = __toESM(require_jsx_dev_runtime());
function Products2() {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)("div", { children: "Healthz" }, void 0, !1, {
    fileName: "app/routes/healthz.tsx",
    lineNumber: 2,
    columnNumber: 10
  }, this);
}

// app/routes/_index.tsx
var index_exports = {};
__export(index_exports, {
  default: () => index_default
});
var import_jsx_dev_runtime14 = __toESM(require_jsx_dev_runtime()), Main = () => /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)("div", { children: /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)(
  "input",
  {
    type: "range",
    className: "pointer-events-none [&::-webkit-slider-thumb]:pointer-events-auto"
  },
  void 0,
  !1,
  {
    fileName: "app/routes/_index.tsx",
    lineNumber: 6,
    columnNumber: 7
  },
  this
) }, void 0, !1, {
  fileName: "app/routes/_index.tsx",
  lineNumber: 5,
  columnNumber: 5
}, this), index_default = Main;

// server-assets-manifest:@remix-run/dev/assets-manifest
var assets_manifest_default = { entry: { module: "/build/entry.client-I2CH6JD6.js", imports: ["/build/_shared/chunk-QL3LT76M.js", "/build/_shared/chunk-NLQNPAAV.js"] }, routes: { root: { id: "root", parentId: void 0, path: "", index: void 0, caseSensitive: void 0, module: "/build/root-CWGJBYBO.js", imports: void 0, hasAction: !1, hasLoader: !1, hasCatchBoundary: !1, hasErrorBoundary: !0 }, "routes/_index": { id: "routes/_index", parentId: "root", path: void 0, index: !0, caseSensitive: void 0, module: "/build/routes/_index-4TUJHQ6G.js", imports: void 0, hasAction: !1, hasLoader: !1, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/healthz": { id: "routes/healthz", parentId: "root", path: "healthz", index: void 0, caseSensitive: void 0, module: "/build/routes/healthz-ALZMRHNV.js", imports: void 0, hasAction: !1, hasLoader: !1, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/products": { id: "routes/products", parentId: "root", path: "products", index: void 0, caseSensitive: void 0, module: "/build/routes/products-ASU5WADJ.js", imports: void 0, hasAction: !0, hasLoader: !1, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/products.$searchTerm": { id: "routes/products.$searchTerm", parentId: "routes/products", path: ":searchTerm", index: void 0, caseSensitive: void 0, module: "/build/routes/products.$searchTerm-BBATDRKA.js", imports: void 0, hasAction: !0, hasLoader: !0, hasCatchBoundary: !1, hasErrorBoundary: !1 } }, cssBundleHref: void 0, version: "c6a22c0f", hmr: void 0, url: "/build/manifest-C6A22C0F.js" };

// server-entry-module:@remix-run/dev/server-build
var assetsBuildDirectory = "public/build", future = { unstable_dev: !1, unstable_postcss: !1, unstable_tailwind: !1, v2_errorBoundary: !0, v2_headers: !1, v2_meta: !0, v2_normalizeFormMethod: !0, v2_routeConvention: !0 }, publicPath = "/build/", entry = { module: entry_server_exports }, routes = {
  root: {
    id: "root",
    parentId: void 0,
    path: "",
    index: void 0,
    caseSensitive: void 0,
    module: root_exports
  },
  "routes/products.$searchTerm": {
    id: "routes/products.$searchTerm",
    parentId: "routes/products",
    path: ":searchTerm",
    index: void 0,
    caseSensitive: void 0,
    module: products_searchTerm_exports
  },
  "routes/products": {
    id: "routes/products",
    parentId: "root",
    path: "products",
    index: void 0,
    caseSensitive: void 0,
    module: products_exports
  },
  "routes/healthz": {
    id: "routes/healthz",
    parentId: "root",
    path: "healthz",
    index: void 0,
    caseSensitive: void 0,
    module: healthz_exports
  },
  "routes/_index": {
    id: "routes/_index",
    parentId: "root",
    path: void 0,
    index: !0,
    caseSensitive: void 0,
    module: index_exports
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  assets,
  assetsBuildDirectory,
  entry,
  future,
  publicPath,
  routes
});
/*! Bundled license information:

@remix-run/node/dist/fetch.js:
  (**
   * @remix-run/node v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/base64.js:
  (**
   * @remix-run/node v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/globals.js:
  (**
   * @remix-run/node v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

@remix-run/server-runtime/dist/warnings.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/cookies.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/formData.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/router/dist/router.cjs.js:
  (**
   * @remix-run/router v1.6.3
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/mode.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/errors.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/responses.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/entry.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/headers.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/invariant.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/routeMatching.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/data.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/routes.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/markup.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/serverHandoff.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/server.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/sessions.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/sessions/cookieStorage.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/sessions/memoryStorage.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/upload/errors.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/upload/memoryUploadHandler.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/dev.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/index.js:
  (**
   * @remix-run/server-runtime v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/crypto.js:
  (**
   * @remix-run/node v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/implementations.js:
  (**
   * @remix-run/node v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/sessions/fileStorage.js:
  (**
   * @remix-run/node v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/stream.js:
  (**
   * @remix-run/node v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/upload/fileUploadHandler.js:
  (**
   * @remix-run/node v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/index.js:
  (**
   * @remix-run/node v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-router/dist/umd/react-router.development.js:
  (**
   * React Router v6.12.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router/dist/main.js:
  (**
   * React Router v6.12.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router-dom/dist/umd/react-router-dom.development.js:
  (**
   * React Router DOM v6.12.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router-dom/dist/main.js:
  (**
   * React Router DOM v6.12.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/_virtual/_rollupPluginBabelHelpers.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/errorBoundaries.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/invariant.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/routeModules.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/links.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/markup.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/transition.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/warnings.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/components.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/errors.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/data.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/routes.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/browser.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/scroll-restoration.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/server.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/index.js:
  (**
   * @remix-run/react v1.17.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-dom/cjs/react-dom-server-legacy.node.development.js:
  (**
   * @license React
   * react-dom-server-legacy.node.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-server.node.development.js:
  (**
   * @license React
   * react-dom-server.node.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-dev-runtime.development.js:
  (**
   * @license React
   * react-jsx-dev-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

fetch-blob/index.js:
  (*! fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

formdata-polyfill/esm.min.js:
  (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

node-domexception/index.js:
  (*! node-domexception. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)
*/
//# sourceMappingURL=index.js.map
